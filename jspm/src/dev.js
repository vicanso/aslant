"bundle";
System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/array.js", ["./any", "./cast", "./errors", "hoek"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Any = $__require('./any');
  var Cast = $__require('./cast');
  var Errors = $__require('./errors');
  var Hoek = $__require('hoek');
  var internals = {};
  internals.Array = function() {
    Any.call(this);
    this._type = 'array';
    this._inner.inclusions = [];
    this._inner.exclusions = [];
    this._flags.sparse = false;
  };
  Hoek.inherits(internals.Array, Any);
  internals.Array.prototype._base = function(value, state, options) {
    var result = {value: value};
    if (typeof value === 'string' && options.convert) {
      try {
        var converted = JSON.parse(value);
        if (Array.isArray(converted)) {
          result.value = converted;
        }
      } catch (e) {}
    }
    var isArray = Array.isArray(result.value);
    var wasArray = isArray;
    if (options.convert && this._flags.single && !isArray) {
      result.value = [result.value];
      isArray = true;
    }
    if (!isArray) {
      result.errors = Errors.create('array.base', null, state, options);
      return result;
    }
    if (this._inner.inclusions.length || this._inner.exclusions.length || !this._flags.sparse) {
      if (wasArray) {
        result.value = result.value.slice(0);
      }
      result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);
      if (result.errors && wasArray && options.convert && this._flags.single) {
        var previousErrors = result.errors;
        result.value = [result.value];
        result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);
        if (result.errors) {
          result.errors = previousErrors;
          result.value = result.value[0];
        }
      }
    }
    return result;
  };
  internals.checkItems = function(items, wasArray, state, options) {
    var errors = [];
    var errored;
    for (var v = 0,
        vl = items.length; v < vl; ++v) {
      errored = false;
      var item = items[v];
      var isValid = false;
      var localState = {
        key: v,
        path: (state.path ? state.path + '.' : '') + v,
        parent: items,
        reference: state.reference
      };
      if (!this._flags.sparse && item === undefined) {
        errors.push(Errors.create('array.sparse', null, {
          key: state.key,
          path: localState.path
        }, options));
        if (options.abortEarly) {
          return errors;
        }
        continue;
      }
      for (var i = 0,
          il = this._inner.exclusions.length; i < il; ++i) {
        var res = this._inner.exclusions[i]._validate(item, localState, {});
        if (!res.errors) {
          errors.push(Errors.create(wasArray ? 'array.excludes' : 'array.excludesSingle', {pos: v}, {
            key: state.key,
            path: localState.path
          }, options));
          errored = true;
          if (options.abortEarly) {
            return errors;
          }
          break;
        }
      }
      if (errored) {
        continue;
      }
      for (i = 0, il = this._inner.inclusions.length; i < il; ++i) {
        var res = this._inner.inclusions[i]._validate(item, localState, options);
        if (!res.errors) {
          items[v] = res.value;
          isValid = true;
          break;
        }
        if (il === 1) {
          errors.push(Errors.create(wasArray ? 'array.includesOne' : 'array.includesOneSingle', {
            pos: v,
            reason: res.errors
          }, {
            key: state.key,
            path: localState.path
          }, options));
          errored = true;
          if (options.abortEarly) {
            return errors;
          }
          break;
        }
      }
      if (errored) {
        continue;
      }
      if (this._inner.inclusions.length && !isValid) {
        errors.push(Errors.create(wasArray ? 'array.includes' : 'array.includesSingle', {pos: v}, {
          key: state.key,
          path: localState.path
        }, options));
        if (options.abortEarly) {
          return errors;
        }
      }
    }
    return errors.length ? errors : null;
  };
  internals.Array.prototype.describe = function() {
    var description = Any.prototype.describe.call(this);
    if (this._inner.inclusions.length) {
      description.includes = [];
      for (var i = 0,
          il = this._inner.inclusions.length; i < il; ++i) {
        description.includes.push(this._inner.inclusions[i].describe());
      }
    }
    if (this._inner.exclusions.length) {
      description.excludes = [];
      for (var i = 0,
          il = this._inner.exclusions.length; i < il; ++i) {
        description.excludes.push(this._inner.exclusions[i].describe());
      }
    }
    return description;
  };
  internals.Array.prototype.includes = function() {
    var inclusions = Hoek.flatten(Array.prototype.slice.call(arguments)).map(function(type) {
      return Cast.schema(type);
    });
    var obj = this.clone();
    obj._inner.inclusions = obj._inner.inclusions.concat(inclusions);
    return obj;
  };
  internals.Array.prototype.excludes = function() {
    var exclusions = Hoek.flatten(Array.prototype.slice.call(arguments)).map(function(type) {
      return Cast.schema(type);
    });
    var obj = this.clone();
    obj._inner.exclusions = obj._inner.exclusions.concat(exclusions);
    return obj;
  };
  internals.Array.prototype.min = function(limit) {
    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    return this._test('min', limit, function(value, state, options) {
      if (value.length >= limit) {
        return null;
      }
      return Errors.create('array.min', {limit: limit}, state, options);
    });
  };
  internals.Array.prototype.max = function(limit) {
    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    return this._test('max', limit, function(value, state, options) {
      if (value.length <= limit) {
        return null;
      }
      return Errors.create('array.max', {limit: limit}, state, options);
    });
  };
  internals.Array.prototype.length = function(limit) {
    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    return this._test('length', limit, function(value, state, options) {
      if (value.length === limit) {
        return null;
      }
      return Errors.create('array.length', {limit: limit}, state, options);
    });
  };
  internals.Array.prototype.unique = function() {
    return this._test('unique', undefined, function(value, state, options) {
      var found = {
        string: {},
        number: {},
        undefined: {},
        boolean: {},
        object: [],
        function: []
      };
      for (var i = 0,
          il = value.length; i < il; ++i) {
        var item = value[i];
        var type = typeof item;
        var records = found[type];
        if (records) {
          if (Array.isArray(records)) {
            for (var r = 0,
                rl = records.length; r < rl; ++r) {
              if (Hoek.deepEqual(records[r], item)) {
                return Errors.create('array.unique', {pos: i}, state, options);
              }
            }
            records.push(item);
          } else {
            if (records[item]) {
              return Errors.create('array.unique', {pos: i}, state, options);
            }
            records[item] = true;
          }
        }
      }
    });
  };
  internals.Array.prototype.sparse = function(enabled) {
    var obj = this.clone();
    obj._flags.sparse = enabled === undefined ? true : !!enabled;
    return obj;
  };
  internals.Array.prototype.single = function(enabled) {
    var obj = this.clone();
    obj._flags.single = enabled === undefined ? true : !!enabled;
    return obj;
  };
  module.exports = new internals.Array();
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/binary.js", ["./any", "./errors", "hoek"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Any = $__require('./any');
  var Errors = $__require('./errors');
  var Hoek = $__require('hoek');
  var internals = {};
  internals.Binary = function() {
    Any.call(this);
    this._type = 'binary';
  };
  Hoek.inherits(internals.Binary, Any);
  internals.Binary.prototype._base = function(value, state, options) {
    var result = {value: value};
    if (typeof value === 'string' && options.convert) {
      try {
        var converted = new Buffer(value, this._flags.encoding);
        result.value = converted;
      } catch (e) {}
    }
    result.errors = Buffer.isBuffer(result.value) ? null : Errors.create('binary.base', null, state, options);
    return result;
  };
  internals.Binary.prototype.encoding = function(encoding) {
    Hoek.assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);
    var obj = this.clone();
    obj._flags.encoding = encoding;
    return obj;
  };
  internals.Binary.prototype.min = function(limit) {
    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    return this._test('min', limit, function(value, state, options) {
      if (value.length >= limit) {
        return null;
      }
      return Errors.create('binary.min', {limit: limit}, state, options);
    });
  };
  internals.Binary.prototype.max = function(limit) {
    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    return this._test('max', limit, function(value, state, options) {
      if (value.length <= limit) {
        return null;
      }
      return Errors.create('binary.max', {limit: limit}, state, options);
    });
  };
  internals.Binary.prototype.length = function(limit) {
    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    return this._test('length', limit, function(value, state, options) {
      if (value.length === limit) {
        return null;
      }
      return Errors.create('binary.length', {limit: limit}, state, options);
    });
  };
  module.exports = new internals.Binary();
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/function.js", ["./any", "./errors", "hoek"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Any = $__require('./any');
  var Errors = $__require('./errors');
  var Hoek = $__require('hoek');
  var internals = {};
  internals.Function = function() {
    Any.call(this);
    this._type = 'func';
  };
  Hoek.inherits(internals.Function, Any);
  internals.Function.prototype._base = function(value, state, options) {
    return {
      value: value,
      errors: (typeof value === 'function') ? null : Errors.create('function.base', null, state, options)
    };
  };
  module.exports = new internals.Function();
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/number.js", ["./any", "./errors", "hoek"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Any = $__require('./any');
  var Errors = $__require('./errors');
  var Hoek = $__require('hoek');
  var internals = {};
  internals.Number = function() {
    Any.call(this);
    this._type = 'number';
    this._invalids.add(Infinity);
    this._invalids.add(-Infinity);
  };
  Hoek.inherits(internals.Number, Any);
  internals.Number.prototype._base = function(value, state, options) {
    var result = {
      errors: null,
      value: value
    };
    if (typeof value === 'string' && options.convert) {
      var number = parseFloat(value);
      result.value = (isNaN(number) || !isFinite(value)) ? NaN : number;
    }
    var isNumber = typeof result.value === 'number' && !isNaN(result.value);
    if (options.convert && 'precision' in this._flags && isNumber) {
      var precision = Math.pow(10, this._flags.precision);
      result.value = Math.round(result.value * precision) / precision;
    }
    result.errors = isNumber ? null : Errors.create('number.base', null, state, options);
    return result;
  };
  internals.Number.prototype.min = function(limit) {
    Hoek.assert(Hoek.isInteger(limit), 'limit must be an integer');
    return this._test('min', limit, function(value, state, options) {
      if (value >= limit) {
        return null;
      }
      return Errors.create('number.min', {limit: limit}, state, options);
    });
  };
  internals.Number.prototype.max = function(limit) {
    Hoek.assert(Hoek.isInteger(limit), 'limit must be an integer');
    return this._test('max', limit, function(value, state, options) {
      if (value <= limit) {
        return null;
      }
      return Errors.create('number.max', {limit: limit}, state, options);
    });
  };
  internals.Number.prototype.greater = function(limit) {
    Hoek.assert(Hoek.isInteger(limit), 'limit must be an integer');
    return this._test('greater', limit, function(value, state, options) {
      if (value > limit) {
        return null;
      }
      return Errors.create('number.greater', {limit: limit}, state, options);
    });
  };
  internals.Number.prototype.less = function(limit) {
    Hoek.assert(Hoek.isInteger(limit), 'limit must be an integer');
    return this._test('less', limit, function(value, state, options) {
      if (value < limit) {
        return null;
      }
      return Errors.create('number.less', {limit: limit}, state, options);
    });
  };
  internals.Number.prototype.integer = function() {
    return this._test('integer', undefined, function(value, state, options) {
      return Hoek.isInteger(value) ? null : Errors.create('number.integer', null, state, options);
    });
  };
  internals.Number.prototype.negative = function() {
    return this._test('negative', undefined, function(value, state, options) {
      if (value < 0) {
        return null;
      }
      return Errors.create('number.negative', null, state, options);
    });
  };
  internals.Number.prototype.positive = function() {
    return this._test('positive', undefined, function(value, state, options) {
      if (value > 0) {
        return null;
      }
      return Errors.create('number.positive', null, state, options);
    });
  };
  internals.precisionRx = /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/;
  internals.Number.prototype.precision = function(limit) {
    Hoek.assert(Hoek.isInteger(limit), 'limit must be an integer');
    Hoek.assert(!('precision' in this._flags), 'precision already set');
    var obj = this._test('precision', limit, function(value, state, options) {
      var places = value.toString().match(internals.precisionRx);
      var decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
      if (decimals <= limit) {
        return null;
      }
      return Errors.create('number.precision', {limit: limit}, state, options);
    });
    obj._flags.precision = limit;
    return obj;
  };
  module.exports = new internals.Number();
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/boolean.js", ["./any", "./errors", "hoek"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Any = $__require('./any');
  var Errors = $__require('./errors');
  var Hoek = $__require('hoek');
  var internals = {};
  internals.Boolean = function() {
    Any.call(this);
    this._type = 'boolean';
  };
  Hoek.inherits(internals.Boolean, Any);
  internals.Boolean.prototype._base = function(value, state, options) {
    var result = {value: value};
    if (typeof value === 'string' && options.convert) {
      var lower = value.toLowerCase();
      result.value = (lower === 'true' || lower === 'yes' || lower === 'on' ? true : (lower === 'false' || lower === 'no' || lower === 'off' ? false : value));
    }
    result.errors = (typeof result.value === 'boolean') ? null : Errors.create('boolean.base', null, state, options);
    return result;
  };
  module.exports = new internals.Boolean();
  return module.exports;
});

System.registerDynamic("github:capaj/topo-browser@1.1.0/lib/index.js", ["hoek"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Hoek = $__require('hoek');
  var internals = {};
  exports = module.exports = internals.Topo = function() {
    this._items = [];
    this.nodes = [];
  };
  internals.Topo.prototype.add = function(nodes, options) {
    var self = this;
    options = options || {};
    var before = [].concat(options.before || []);
    var after = [].concat(options.after || []);
    var group = options.group || '?';
    Hoek.assert(before.indexOf(group) === -1, 'Item cannot come before itself:', group);
    Hoek.assert(before.indexOf('?') === -1, 'Item cannot come before unassociated items');
    Hoek.assert(after.indexOf(group) === -1, 'Item cannot come after itself:', group);
    Hoek.assert(after.indexOf('?') === -1, 'Item cannot come after unassociated items');
    ([].concat(nodes)).forEach(function(node, i) {
      var item = {
        seq: self._items.length,
        before: before,
        after: after,
        group: group,
        node: node
      };
      self._items.push(item);
    });
    var error = this._sort();
    Hoek.assert(!error, 'item', (group !== '?' ? 'added into group ' + group : ''), 'created a dependencies error');
    return this.nodes;
  };
  internals.Topo.prototype._sort = function() {
    var groups = {};
    var graph = {};
    var graphAfters = {};
    for (var i = 0,
        il = this._items.length; i < il; ++i) {
      var item = this._items[i];
      var seq = item.seq;
      var group = item.group;
      groups[group] = groups[group] || [];
      groups[group].push(seq);
      graph[seq] = [item.before];
      var after = item.after;
      for (var j = 0,
          jl = after.length; j < jl; ++j) {
        graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);
      }
    }
    var graphNodes = Object.keys(graph);
    for (i = 0, il = graphNodes.length; i < il; ++i) {
      var node = graphNodes[i];
      var expandedGroups = [];
      var graphNodeItems = Object.keys(graph[node]);
      for (j = 0, jl = graphNodeItems.length; j < jl; ++j) {
        var group = graph[node][graphNodeItems[j]];
        groups[group] = groups[group] || [];
        groups[group].forEach(function(d) {
          expandedGroups.push(d);
        });
      }
      graph[node] = expandedGroups;
    }
    var afterNodes = Object.keys(graphAfters);
    for (i = 0, il = afterNodes.length; i < il; ++i) {
      var group = afterNodes[i];
      if (groups[group]) {
        for (j = 0, jl = groups[group].length; j < jl; ++j) {
          var node = groups[group][j];
          graph[node] = graph[node].concat(graphAfters[group]);
        }
      }
    }
    var ancestors = {};
    graphNodes = Object.keys(graph);
    for (i = 0, il = graphNodes.length; i < il; ++i) {
      var node = graphNodes[i];
      var children = graph[node];
      for (j = 0, jl = children.length; j < jl; ++j) {
        ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);
      }
    }
    var visited = {};
    var sorted = [];
    for (i = 0, il = this._items.length; i < il; ++i) {
      var next = i;
      if (ancestors[i]) {
        next = null;
        for (j = 0, jl = this._items.length; j < jl; ++j) {
          if (visited[j] === true) {
            continue;
          }
          if (!ancestors[j]) {
            ancestors[j] = [];
          }
          var shouldSeeCount = ancestors[j].length;
          var seenCount = 0;
          for (var l = 0,
              ll = shouldSeeCount; l < ll; ++l) {
            if (sorted.indexOf(ancestors[j][l]) >= 0) {
              ++seenCount;
            }
          }
          if (seenCount === shouldSeeCount) {
            next = j;
            break;
          }
        }
      }
      if (next !== null) {
        next = next.toString();
        visited[next] = true;
        sorted.push(next);
      }
    }
    if (sorted.length !== this._items.length) {
      return new Error('Invalid dependencies');
    }
    var seqIndex = {};
    this._items.forEach(function(item) {
      seqIndex[item.seq] = item;
    });
    var sortedNodes = [];
    this._items = sorted.map(function(value) {
      var item = seqIndex[value];
      sortedNodes.push(item.node);
      return item;
    });
    this.nodes = sortedNodes;
  };
  return module.exports;
});

System.registerDynamic("github:capaj/topo-browser@1.1.0.json", [], false, function() {
  return {
    "main": "index"
  };
});

System.registerDynamic("github:capaj/topo-browser@1.1.0/index.js", ["./lib/index"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./lib/index');
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/object.js", ["hoek", "topo", "./any", "./cast", "./errors"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Hoek = $__require('hoek');
  var Topo = $__require('topo');
  var Any = $__require('./any');
  var Cast = $__require('./cast');
  var Errors = $__require('./errors');
  var internals = {};
  internals.Object = function() {
    Any.call(this);
    this._type = 'object';
    this._inner.children = null;
    this._inner.renames = [];
    this._inner.dependencies = [];
    this._inner.patterns = [];
  };
  Hoek.inherits(internals.Object, Any);
  internals.Object.prototype._base = function(value, state, options) {
    var target = value;
    var errors = [];
    var finish = function() {
      return {
        value: target,
        errors: errors.length ? errors : null
      };
    };
    if (typeof value === 'string' && options.convert) {
      try {
        value = JSON.parse(value);
      } catch (err) {}
    }
    if (!value || typeof value !== 'object' || Array.isArray(value)) {
      errors.push(Errors.create('object.base', null, state, options));
      return finish();
    }
    if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && !this._inner.patterns.length) {
      target = value;
      return finish();
    }
    if (target === value) {
      target = Object.create(Object.getPrototypeOf(value));
      var valueKeys = Object.keys(value);
      for (var t = 0,
          tl = valueKeys.length; t < tl; ++t) {
        target[valueKeys[t]] = value[valueKeys[t]];
      }
    } else {
      target = value;
    }
    var renamed = {};
    for (var r = 0,
        rl = this._inner.renames.length; r < rl; ++r) {
      var item = this._inner.renames[r];
      if (target[item.from] === undefined) {
        continue;
      }
      if (!item.options.multiple && renamed[item.to]) {
        errors.push(Errors.create('object.rename.multiple', {
          from: item.from,
          to: item.to
        }, state, options));
        if (options.abortEarly) {
          return finish();
        }
      }
      if (target.hasOwnProperty(item.to) && !item.options.override && !renamed[item.to]) {
        errors.push(Errors.create('object.rename.override', {
          from: item.from,
          to: item.to
        }, state, options));
        if (options.abortEarly) {
          return finish();
        }
      }
      target[item.to] = target[item.from];
      renamed[item.to] = true;
      if (!item.options.alias) {
        delete target[item.from];
      }
    }
    for (var d = 0,
        dl = this._inner.dependencies.length; d < dl; ++d) {
      var dep = this._inner.dependencies[d];
      var err = internals[dep.type](dep.key !== null && value[dep.key], dep.peers, target, {
        key: dep.key,
        path: (state.path ? state.path + '.' : '') + dep.key
      }, options);
      if (err) {
        errors.push(err);
        if (options.abortEarly) {
          return finish();
        }
      }
    }
    if (!this._inner.children && !this._inner.patterns.length) {
      return finish();
    }
    var unprocessed = Hoek.mapToObject(Object.keys(target));
    var key;
    if (this._inner.children) {
      for (var i = 0,
          il = this._inner.children.length; i < il; ++i) {
        var child = this._inner.children[i];
        var key = child.key;
        var item = target[key];
        delete unprocessed[key];
        var localState = {
          key: key,
          path: (state.path ? state.path + '.' : '') + key,
          parent: target,
          reference: state.reference
        };
        var result = child.schema._validate(item, localState, options);
        if (result.errors) {
          errors = errors.concat(result.errors);
          if (options.abortEarly) {
            return finish();
          }
        }
        if (result.value !== undefined) {
          target[key] = result.value;
        }
      }
    }
    var unprocessedKeys = Object.keys(unprocessed);
    if (unprocessedKeys.length && this._inner.patterns.length) {
      for (i = 0, il = unprocessedKeys.length; i < il; ++i) {
        var key = unprocessedKeys[i];
        for (var p = 0,
            pl = this._inner.patterns.length; p < pl; ++p) {
          var pattern = this._inner.patterns[p];
          if (pattern.regex.test(key)) {
            delete unprocessed[key];
            var item = target[key];
            var localState = {
              key: key,
              path: (state.path ? state.path + '.' : '') + key,
              parent: target,
              reference: state.reference
            };
            var result = pattern.rule._validate(item, localState, options);
            if (result.errors) {
              errors = errors.concat(result.errors);
              if (options.abortEarly) {
                return finish();
              }
            }
            if (result.value !== undefined) {
              target[key] = result.value;
            }
          }
        }
      }
      unprocessedKeys = Object.keys(unprocessed);
    }
    if (unprocessedKeys.length) {
      if (options.stripUnknown || options.skipFunctions) {
        var hasFunctions = false;
        for (var k = 0,
            kl = unprocessedKeys.length; k < kl; ++k) {
          key = unprocessedKeys[k];
          if (options.stripUnknown) {
            delete target[key];
          } else if (typeof target[key] === 'function') {
            delete unprocessed[key];
            hasFunctions = true;
          }
        }
        if (options.stripUnknown) {
          return finish();
        }
        if (hasFunctions) {
          unprocessedKeys = Object.keys(unprocessed);
        }
      }
      if (unprocessedKeys.length && (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {
        for (var e = 0,
            el = unprocessedKeys.length; e < el; ++e) {
          errors.push(Errors.create('object.allowUnknown', null, {
            key: unprocessedKeys[e],
            path: state.path
          }, options));
        }
      }
    }
    return finish();
  };
  internals.Object.prototype.keys = function(schema) {
    Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');
    Hoek.assert(!schema || !schema.isJoi, 'Object schema cannot be a joi schema');
    var obj = this.clone();
    if (!schema) {
      obj._inner.children = null;
      return obj;
    }
    var children = Object.keys(schema);
    if (!children.length) {
      obj._inner.children = [];
      return obj;
    }
    var topo = new Topo();
    if (obj._inner.children) {
      for (var i = 0,
          il = obj._inner.children.length; i < il; ++i) {
        var child = obj._inner.children[i];
        topo.add(child, {
          after: child._refs,
          group: child.key
        });
      }
    }
    for (var c = 0,
        cl = children.length; c < cl; ++c) {
      var key = children[c];
      var child = schema[key];
      var cast = Cast.schema(child);
      topo.add({
        key: key,
        schema: cast
      }, {
        after: cast._refs,
        group: key
      });
    }
    obj._inner.children = topo.nodes;
    return obj;
  };
  internals.Object.prototype.unknown = function(allow) {
    var obj = this.clone();
    obj._flags.allowUnknown = (allow !== false);
    return obj;
  };
  internals.Object.prototype.length = function(limit) {
    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    return this._test('length', limit, function(value, state, options) {
      if (Object.keys(value).length === limit) {
        return null;
      }
      return Errors.create('object.length', {limit: limit}, state, options);
    });
  };
  internals.Object.prototype.min = function(limit) {
    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    return this._test('min', limit, function(value, state, options) {
      if (Object.keys(value).length >= limit) {
        return null;
      }
      return Errors.create('object.min', {limit: limit}, state, options);
    });
  };
  internals.Object.prototype.max = function(limit) {
    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    return this._test('max', limit, function(value, state, options) {
      if (Object.keys(value).length <= limit) {
        return null;
      }
      return Errors.create('object.max', {limit: limit}, state, options);
    });
  };
  internals.Object.prototype.pattern = function(pattern, schema) {
    Hoek.assert(pattern instanceof RegExp, 'Invalid regular expression');
    Hoek.assert(schema !== undefined, 'Invalid rule');
    pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);
    var obj = this.clone();
    obj._inner.patterns.push({
      regex: pattern,
      rule: Cast.schema(schema)
    });
    return obj;
  };
  internals.Object.prototype.with = function(key, peers) {
    return this._dependency('with', key, peers);
  };
  internals.Object.prototype.without = function(key, peers) {
    return this._dependency('without', key, peers);
  };
  internals.Object.prototype.xor = function() {
    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency('xor', null, peers);
  };
  internals.Object.prototype.or = function() {
    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency('or', null, peers);
  };
  internals.Object.prototype.and = function() {
    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency('and', null, peers);
  };
  internals.Object.prototype.nand = function() {
    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency('nand', null, peers);
  };
  internals.Object.prototype.requiredKeys = function(children) {
    children = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this.applyFunctionToChildren(children, 'required');
  };
  internals.Object.prototype.optionalKeys = function(children) {
    children = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this.applyFunctionToChildren(children, 'optional');
  };
  internals.renameDefaults = {
    alias: false,
    multiple: false,
    override: false
  };
  internals.Object.prototype.rename = function(from, to, options) {
    Hoek.assert(typeof from === 'string', 'Rename missing the from argument');
    Hoek.assert(typeof to === 'string', 'Rename missing the to argument');
    Hoek.assert(to !== from, 'Cannot rename key to same name:', from);
    for (var i = 0,
        il = this._inner.renames.length; i < il; ++i) {
      Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');
    }
    var obj = this.clone();
    obj._inner.renames.push({
      from: from,
      to: to,
      options: Hoek.applyToDefaults(internals.renameDefaults, options || {})
    });
    return obj;
  };
  internals.groupChildren = function(children) {
    children.sort();
    var grouped = {};
    for (var c = 0,
        lc = children.length; c < lc; c++) {
      var child = children[c];
      Hoek.assert(typeof child === 'string', 'children must be strings');
      var group = child.split('.')[0];
      var childGroup = grouped[group] = (grouped[group] || []);
      childGroup.push(child.substring(group.length + 1));
    }
    return grouped;
  };
  internals.Object.prototype.applyFunctionToChildren = function(children, fn, args, root) {
    children = [].concat(children);
    Hoek.assert(children.length > 0, 'expected at least one children');
    var groupedChildren = internals.groupChildren(children);
    var obj;
    if ('' in groupedChildren) {
      obj = this[fn].apply(this, args);
      delete groupedChildren[''];
    } else {
      obj = this.clone();
    }
    if (obj._inner.children) {
      root = root ? (root + '.') : '';
      for (var i = 0,
          il = obj._inner.children.length; i < il; ++i) {
        var child = obj._inner.children[i];
        var group = groupedChildren[child.key];
        if (group) {
          obj._inner.children[i] = {
            key: child.key,
            _refs: child._refs,
            schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)
          };
          delete groupedChildren[child.key];
        }
      }
    }
    var remaining = Object.keys(groupedChildren);
    Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));
    return obj;
  };
  internals.Object.prototype._dependency = function(type, key, peers) {
    peers = [].concat(peers);
    for (var i = 0,
        li = peers.length; i < li; i++) {
      Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');
    }
    var obj = this.clone();
    obj._inner.dependencies.push({
      type: type,
      key: key,
      peers: peers
    });
    return obj;
  };
  internals.with = function(value, peers, parent, state, options) {
    if (value === undefined) {
      return null;
    }
    for (var i = 0,
        il = peers.length; i < il; ++i) {
      var peer = peers[i];
      if (!parent.hasOwnProperty(peer) || parent[peer] === undefined) {
        return Errors.create('object.with', {peer: peer}, state, options);
      }
    }
    return null;
  };
  internals.without = function(value, peers, parent, state, options) {
    if (value === undefined) {
      return null;
    }
    for (var i = 0,
        il = peers.length; i < il; ++i) {
      var peer = peers[i];
      if (parent.hasOwnProperty(peer) && parent[peer] !== undefined) {
        return Errors.create('object.without', {peer: peer}, state, options);
      }
    }
    return null;
  };
  internals.xor = function(value, peers, parent, state, options) {
    var present = [];
    for (var i = 0,
        il = peers.length; i < il; ++i) {
      var peer = peers[i];
      if (parent.hasOwnProperty(peer) && parent[peer] !== undefined) {
        present.push(peer);
      }
    }
    if (present.length === 1) {
      return null;
    }
    if (present.length === 0) {
      return Errors.create('object.missing', {peers: peers}, state, options);
    }
    return Errors.create('object.xor', {peers: peers}, state, options);
  };
  internals.or = function(value, peers, parent, state, options) {
    for (var i = 0,
        il = peers.length; i < il; ++i) {
      var peer = peers[i];
      if (parent.hasOwnProperty(peer) && parent[peer] !== undefined) {
        return null;
      }
    }
    return Errors.create('object.missing', {peers: peers}, state, options);
  };
  internals.and = function(value, peers, parent, state, options) {
    var missing = [];
    var present = [];
    var count = peers.length;
    for (var i = 0; i < count; ++i) {
      var peer = peers[i];
      if (!parent.hasOwnProperty(peer) || parent[peer] === undefined) {
        missing.push(peer);
      } else {
        present.push(peer);
      }
    }
    var aon = (missing.length === count || present.length === count);
    return !aon ? Errors.create('object.and', {
      present: present,
      missing: missing
    }, state, options) : null;
  };
  internals.nand = function(value, peers, parent, state, options) {
    var present = [];
    for (var i = 0,
        il = peers.length; i < il; ++i) {
      var peer = peers[i];
      if (parent.hasOwnProperty(peer) && parent[peer] !== undefined) {
        present.push(peer);
      }
    }
    var values = Hoek.clone(peers);
    var main = values.splice(0, 1);
    var allPresent = (present.length === peers.length);
    return allPresent ? Errors.create('object.nand', {
      main: main,
      peers: values
    }, state, options) : null;
  };
  internals.Object.prototype.describe = function(shallow) {
    var description = Any.prototype.describe.call(this);
    if (this._inner.children && !shallow) {
      description.children = {};
      for (var i = 0,
          il = this._inner.children.length; i < il; ++i) {
        var child = this._inner.children[i];
        description.children[child.key] = child.schema.describe();
      }
    }
    if (this._inner.dependencies.length) {
      description.dependencies = Hoek.clone(this._inner.dependencies);
    }
    if (this._inner.patterns.length) {
      description.patterns = [];
      for (var p = 0,
          pl = this._inner.patterns.length; p < pl; ++p) {
        var pattern = this._inner.patterns[p];
        description.patterns.push({
          regex: pattern.regex.toString(),
          rule: pattern.rule.describe()
        });
      }
    }
    return description;
  };
  internals.Object.prototype.assert = function(ref, schema, message) {
    ref = Cast.ref(ref);
    Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');
    message = message || 'pass the assertion test';
    var cast = Cast.schema(schema);
    return this._test('assert', {
      cast: cast,
      ref: ref
    }, function(value, state, options) {
      var result = cast._validate(ref(value), null, options, value);
      if (!result.errors) {
        return null;
      }
      return Errors.create('object.assert', {
        ref: ref.path.join('.'),
        message: message
      }, state, options);
    });
  };
  internals.Object.prototype.type = function(constructor, name) {
    Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');
    name = name || constructor.name;
    return this._test('type', name, function(value, state, options) {
      if (value instanceof constructor) {
        return null;
      }
      return Errors.create('object.type', {type: name}, state, options);
    });
  };
  module.exports = new internals.Object();
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/cast.js", ["hoek", "./ref", "./date", "./string", "./number", "./boolean", "./any", "./alternatives", "./object"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Hoek = $__require('hoek');
  var Ref = $__require('./ref');
  var internals = {
    any: null,
    date: $__require('./date'),
    string: $__require('./string'),
    number: $__require('./number'),
    boolean: $__require('./boolean'),
    alt: null,
    object: null
  };
  exports.schema = function(config) {
    internals.any = internals.any || new ($__require('./any'))();
    internals.alt = internals.alt || $__require('./alternatives');
    internals.object = internals.object || $__require('./object');
    if (config && typeof config === 'object') {
      if (config.isJoi) {
        return config;
      }
      if (Array.isArray(config)) {
        return internals.alt.try(config);
      }
      if (config instanceof RegExp) {
        return internals.string.regex(config);
      }
      if (config instanceof Date) {
        return internals.date.valid(config);
      }
      return internals.object.keys(config);
    }
    if (typeof config === 'string') {
      return internals.string.valid(config);
    }
    if (typeof config === 'number') {
      return internals.number.valid(config);
    }
    if (typeof config === 'boolean') {
      return internals.boolean.valid(config);
    }
    if (Ref.isRef(config)) {
      return internals.any.valid(config);
    }
    Hoek.assert(config === null, 'Invalid schema content:', config);
    return internals.any.valid(null);
  };
  exports.ref = function(id) {
    return Ref.isRef(id) ? id : Ref.create(id);
  };
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/alternatives.js", ["hoek", "./any", "./cast", "./ref", "./errors"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Hoek = $__require('hoek');
  var Any = $__require('./any');
  var Cast = $__require('./cast');
  var Ref = $__require('./ref');
  var Errors = $__require('./errors');
  var internals = {};
  internals.Alternatives = function() {
    Any.call(this);
    this._type = 'alternatives';
    this._invalids.remove(null);
    this._inner.matches = [];
  };
  Hoek.inherits(internals.Alternatives, Any);
  internals.Alternatives.prototype._base = function(value, state, options) {
    var errors = [];
    for (var i = 0,
        il = this._inner.matches.length; i < il; ++i) {
      var item = this._inner.matches[i];
      var schema = item.schema;
      if (!schema) {
        var failed = item.is._validate(item.ref(state.parent, options), null, options, state.parent).errors;
        schema = failed ? item.otherwise : item.then;
        if (!schema) {
          continue;
        }
      }
      var result = schema._validate(value, state, options);
      if (!result.errors) {
        return result;
      }
      errors = errors.concat(result.errors);
    }
    return {errors: errors.length ? errors : Errors.create('alternatives.base', null, state, options)};
  };
  internals.Alternatives.prototype.try = function() {
    var schemas = Hoek.flatten(Array.prototype.slice.call(arguments));
    Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');
    var obj = this.clone();
    for (var i = 0,
        il = schemas.length; i < il; ++i) {
      var cast = Cast.schema(schemas[i]);
      if (cast._refs.length) {
        obj._refs = obj._refs.concat(cast._refs);
      }
      obj._inner.matches.push({schema: cast});
    }
    return obj;
  };
  internals.Alternatives.prototype.when = function(ref, options) {
    Hoek.assert(Ref.isRef(ref) || typeof ref === 'string', 'Invalid reference:', ref);
    Hoek.assert(options, 'Missing options');
    Hoek.assert(typeof options === 'object', 'Invalid options');
    Hoek.assert(options.hasOwnProperty('is'), 'Missing "is" directive');
    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');
    var obj = this.clone();
    var item = {
      ref: Cast.ref(ref),
      is: Cast.schema(options.is),
      then: options.then !== undefined ? Cast.schema(options.then) : undefined,
      otherwise: options.otherwise !== undefined ? Cast.schema(options.otherwise) : undefined
    };
    Ref.push(obj._refs, item.ref);
    obj._refs = obj._refs.concat(item.is._refs);
    if (item.then && item.then._refs) {
      obj._refs = obj._refs.concat(item.then._refs);
    }
    if (item.otherwise && item.otherwise._refs) {
      obj._refs = obj._refs.concat(item.otherwise._refs);
    }
    obj._inner.matches.push(item);
    return obj;
  };
  internals.Alternatives.prototype.describe = function() {
    var description = Any.prototype.describe.call(this);
    var alternatives = [];
    for (var i = 0,
        il = this._inner.matches.length; i < il; ++i) {
      var item = this._inner.matches[i];
      if (item.schema) {
        alternatives.push(item.schema.describe());
      } else {
        var when = {
          ref: item.ref.toString(),
          is: item.is.describe()
        };
        if (item.then) {
          when.then = item.then.describe();
        }
        if (item.otherwise) {
          when.otherwise = item.otherwise.describe();
        }
        alternatives.push(when);
      }
    }
    description.alternatives = alternatives;
    return description;
  };
  module.exports = new internals.Alternatives();
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/any.js", ["hoek", "./ref", "./errors", "./cast", "./alternatives"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Hoek = $__require('hoek');
  var Ref = $__require('./ref');
  var Errors = $__require('./errors');
  var Alternatives = null;
  var Cast = null;
  var internals = {};
  internals.defaults = {
    abortEarly: true,
    convert: true,
    allowUnknown: false,
    skipFunctions: false,
    stripUnknown: false,
    language: {},
    presence: 'optional',
    raw: false
  };
  internals.checkOptions = function(options) {
    var optionType = {
      abortEarly: 'boolean',
      convert: 'boolean',
      allowUnknown: 'boolean',
      skipFunctions: 'boolean',
      stripUnknown: 'boolean',
      language: 'object',
      presence: ['string', 'required', 'optional', 'forbidden', 'ignore'],
      raw: 'boolean',
      context: 'object'
    };
    var keys = Object.keys(options);
    for (var k = 0,
        kl = keys.length; k < kl; ++k) {
      var key = keys[k];
      var opt = optionType[key];
      var type = opt;
      var values;
      if (Array.isArray(opt)) {
        type = opt[0];
        values = opt.slice(1);
      }
      Hoek.assert(type, 'unknown key ' + key);
      Hoek.assert(typeof options[key] === type, key + ' should be of type ' + type);
      if (values) {
        Hoek.assert(values.indexOf(options[key]) >= 0, key + ' should be one of ' + values.join(', '));
      }
    }
  };
  module.exports = internals.Any = function() {
    this.isJoi = true;
    this._type = 'any';
    this._settings = null;
    this._valids = new internals.Set();
    this._invalids = new internals.Set();
    this._tests = [];
    this._refs = [];
    this._flags = {};
    this._description = null;
    this._unit = null;
    this._notes = [];
    this._tags = [];
    this._examples = [];
    this._meta = [];
    this._inner = {};
  };
  internals.Any.prototype.isImmutable = true;
  internals.Any.prototype.clone = function() {
    var obj = Object.create(Object.getPrototypeOf(this));
    obj.isJoi = true;
    obj._type = this._type;
    obj._settings = internals.concatSettings(this._settings);
    obj._valids = Hoek.clone(this._valids);
    obj._invalids = Hoek.clone(this._invalids);
    obj._tests = this._tests.slice();
    obj._refs = this._refs.slice();
    obj._flags = Hoek.clone(this._flags);
    obj._description = this._description;
    obj._unit = this._unit;
    obj._notes = this._notes.slice();
    obj._tags = this._tags.slice();
    obj._examples = this._examples.slice();
    obj._meta = this._meta.slice();
    obj._inner = {};
    var inners = Object.keys(this._inner);
    for (var i = 0,
        il = inners.length; i < il; ++i) {
      var key = inners[i];
      obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;
    }
    return obj;
  };
  internals.Any.prototype.concat = function(schema) {
    Hoek.assert(schema && schema.isJoi, 'Invalid schema object');
    Hoek.assert(schema._type === 'any' || schema._type === this._type, 'Cannot merge with another type:', schema._type);
    var obj = this.clone();
    obj._settings = obj._settings ? internals.concatSettings(obj._settings, schema._settings) : schema._settings;
    obj._valids.merge(schema._valids, schema._invalids);
    obj._invalids.merge(schema._invalids, schema._valids);
    obj._tests = obj._tests.concat(schema._tests);
    obj._refs = obj._refs.concat(schema._refs);
    Hoek.merge(obj._flags, schema._flags);
    obj._description = schema._description || obj._description;
    obj._unit = schema._unit || obj._unit;
    obj._notes = obj._notes.concat(schema._notes);
    obj._tags = obj._tags.concat(schema._tags);
    obj._examples = obj._examples.concat(schema._examples);
    obj._meta = obj._meta.concat(schema._meta);
    var inners = Object.keys(schema._inner);
    var isObject = obj._type === 'object';
    for (var i = 0,
        il = inners.length; i < il; ++i) {
      var key = inners[i];
      var source = schema._inner[key];
      if (source) {
        var target = obj._inner[key];
        if (target) {
          if (isObject && key === 'children') {
            var keys = {};
            for (var k = 0,
                kl = target.length; k < kl; ++k) {
              keys[target[k].key] = k;
            }
            for (k = 0, kl = source.length; k < kl; ++k) {
              var sourceKey = source[k].key;
              if (keys[sourceKey] >= 0) {
                target[keys[sourceKey]] = {
                  key: sourceKey,
                  schema: target[keys[sourceKey]].schema.concat(source[k].schema)
                };
              } else {
                target.push(source[k]);
              }
            }
          } else {
            obj._inner[key] = obj._inner[key].concat(source);
          }
        } else {
          obj._inner[key] = source.slice();
        }
      }
    }
    return obj;
  };
  internals.Any.prototype._test = function(name, arg, func) {
    Hoek.assert(!this._flags.allowOnly, 'Cannot define rules when valid values specified');
    var obj = this.clone();
    obj._tests.push({
      func: func,
      name: name,
      arg: arg
    });
    return obj;
  };
  internals.Any.prototype.options = function(options) {
    Hoek.assert(!options.context, 'Cannot override context');
    internals.checkOptions(options);
    var obj = this.clone();
    obj._settings = internals.concatSettings(obj._settings, options);
    return obj;
  };
  internals.Any.prototype.strict = function() {
    var obj = this.clone();
    obj._settings = obj._settings || {};
    obj._settings.convert = false;
    return obj;
  };
  internals.Any.prototype.raw = function(isRaw) {
    var obj = this.clone();
    obj._settings = obj._settings || {};
    obj._settings.raw = isRaw === undefined ? true : isRaw;
    return obj;
  };
  internals.Any.prototype._allow = function() {
    var values = Hoek.flatten(Array.prototype.slice.call(arguments));
    for (var i = 0,
        il = values.length; i < il; ++i) {
      var value = values[i];
      this._invalids.remove(value);
      this._valids.add(value, this._refs);
    }
  };
  internals.Any.prototype.allow = function() {
    var obj = this.clone();
    obj._allow.apply(obj, arguments);
    return obj;
  };
  internals.Any.prototype.valid = internals.Any.prototype.equal = function() {
    Hoek.assert(!this._tests.length, 'Cannot set valid values when rules specified');
    var obj = this.allow.apply(this, arguments);
    obj._flags.allowOnly = true;
    return obj;
  };
  internals.Any.prototype.invalid = internals.Any.prototype.not = function(value) {
    var obj = this.clone();
    var values = Hoek.flatten(Array.prototype.slice.call(arguments));
    for (var i = 0,
        il = values.length; i < il; ++i) {
      var value = values[i];
      obj._valids.remove(value);
      obj._invalids.add(value, this._refs);
    }
    return obj;
  };
  internals.Any.prototype.required = internals.Any.prototype.exist = function() {
    var obj = this.clone();
    obj._flags.presence = 'required';
    return obj;
  };
  internals.Any.prototype.optional = function() {
    var obj = this.clone();
    obj._flags.presence = 'optional';
    return obj;
  };
  internals.Any.prototype.forbidden = function() {
    var obj = this.clone();
    obj._flags.presence = 'forbidden';
    return obj;
  };
  internals.Any.prototype.applyFunctionToChildren = function(children, fn, args, root) {
    children = [].concat(children);
    if (children.length !== 1 || children[0] !== '') {
      root = root ? (root + '.') : '';
      var extraChildren = (children[0] === '' ? children.slice(1) : children).map(function(child) {
        return root + child;
      });
      throw new Error('unknown key(s) ' + extraChildren.join(', '));
    }
    return this[fn].apply(this, args);
  };
  internals.Any.prototype.default = function(value) {
    var obj = this.clone();
    obj._flags.default = value;
    Ref.push(obj._refs, value);
    return obj;
  };
  internals.Any.prototype.when = function(ref, options) {
    Hoek.assert(options && typeof options === 'object', 'Invalid options');
    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');
    Cast = Cast || $__require('./cast');
    var then = options.then ? this.concat(Cast.schema(options.then)) : this;
    var otherwise = options.otherwise ? this.concat(Cast.schema(options.otherwise)) : this;
    Alternatives = Alternatives || $__require('./alternatives');
    var obj = Alternatives.when(ref, {
      is: options.is,
      then: then,
      otherwise: otherwise
    });
    obj._flags.presence = 'ignore';
    return obj;
  };
  internals.Any.prototype.description = function(desc) {
    Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');
    var obj = this.clone();
    obj._description = desc;
    return obj;
  };
  internals.Any.prototype.notes = function(notes) {
    Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');
    var obj = this.clone();
    obj._notes = obj._notes.concat(notes);
    return obj;
  };
  internals.Any.prototype.tags = function(tags) {
    Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');
    var obj = this.clone();
    obj._tags = obj._tags.concat(tags);
    return obj;
  };
  internals.Any.prototype.meta = function(meta) {
    Hoek.assert(meta !== undefined, 'Meta cannot be undefined');
    var obj = this.clone();
    obj._meta = obj._meta.concat(meta);
    return obj;
  };
  internals.Any.prototype.example = function(value) {
    Hoek.assert(arguments.length, 'Missing example');
    var result = this._validate(value, null, internals.defaults);
    Hoek.assert(!result.errors, 'Bad example:', result.errors && Errors.process(result.errors, value));
    var obj = this.clone();
    obj._examples = obj._examples.concat(value);
    return obj;
  };
  internals.Any.prototype.unit = function(name) {
    Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');
    var obj = this.clone();
    obj._unit = name;
    return obj;
  };
  internals.Any.prototype._validate = function(value, state, options, reference) {
    var self = this;
    var originalValue = value;
    state = state || {
      key: '',
      path: '',
      parent: null,
      reference: reference
    };
    if (this._settings) {
      options = internals.concatSettings(options, this._settings);
    }
    var errors = [];
    var finish = function() {
      return {
        value: (value !== undefined) ? (options.raw ? originalValue : value) : (Ref.isRef(self._flags.default) ? self._flags.default(state.parent, options) : self._flags.default),
        errors: errors.length ? errors : null
      };
    };
    var presence = this._flags.presence || options.presence;
    if (presence === 'optional') {
      if (value === undefined) {
        return finish();
      }
    } else if (presence === 'required' && value === undefined) {
      errors.push(Errors.create('any.required', null, state, options));
      return finish();
    } else if (presence === 'forbidden') {
      if (value === undefined) {
        return finish();
      }
      errors.push(Errors.create('any.unknown', null, state, options));
      return finish();
    }
    if (this._valids.has(value, state, options, this._flags.insensitive)) {
      return finish();
    }
    if (this._invalids.has(value, state, options, this._flags.insensitive)) {
      errors.push(Errors.create(value === '' ? 'any.empty' : 'any.invalid', null, state, options));
      if (options.abortEarly || value === undefined) {
        return finish();
      }
    }
    if (this._base) {
      var base = this._base.call(this, value, state, options);
      if (base.errors) {
        value = base.value;
        errors = errors.concat(base.errors);
        return finish();
      }
      if (base.value !== value) {
        value = base.value;
        if (this._valids.has(value, state, options, this._flags.insensitive)) {
          return finish();
        }
        if (this._invalids.has(value, state, options, this._flags.insensitive)) {
          errors.push(Errors.create('any.invalid', null, state, options));
          if (options.abortEarly) {
            return finish();
          }
        }
      }
    }
    if (this._flags.allowOnly) {
      errors.push(Errors.create('any.allowOnly', {valids: this._valids.toString(false)}, state, options));
      if (options.abortEarly) {
        return finish();
      }
    }
    for (var i = 0,
        il = this._tests.length; i < il; ++i) {
      var test = this._tests[i];
      var err = test.func.call(this, value, state, options);
      if (err) {
        errors.push(err);
        if (options.abortEarly) {
          return finish();
        }
      }
    }
    return finish();
  };
  internals.Any.prototype._validateWithOptions = function(value, options, callback) {
    if (options) {
      internals.checkOptions(options);
    }
    var settings = internals.concatSettings(internals.defaults, options);
    var result = this._validate(value, null, settings);
    var errors = Errors.process(result.errors, value);
    if (callback) {
      return callback(errors, result.value);
    }
    return {
      error: errors,
      value: result.value
    };
  };
  internals.Any.prototype.validate = function(value, callback) {
    var result = this._validate(value, null, internals.defaults);
    var errors = Errors.process(result.errors, value);
    if (callback) {
      return callback(errors, result.value);
    }
    return {
      error: errors,
      value: result.value
    };
  };
  internals.Any.prototype.describe = function() {
    var description = {type: this._type};
    if (Object.keys(this._flags).length) {
      description.flags = this._flags;
    }
    if (this._description) {
      description.description = this._description;
    }
    if (this._notes.length) {
      description.notes = this._notes;
    }
    if (this._tags.length) {
      description.tags = this._tags;
    }
    if (this._meta.length) {
      description.meta = this._meta;
    }
    if (this._examples.length) {
      description.examples = this._examples;
    }
    if (this._unit) {
      description.unit = this._unit;
    }
    var valids = this._valids.values();
    if (valids.length) {
      description.valids = valids;
    }
    var invalids = this._invalids.values();
    if (invalids.length) {
      description.invalids = invalids;
    }
    description.rules = [];
    for (var i = 0,
        il = this._tests.length; i < il; ++i) {
      var validator = this._tests[i];
      var item = {name: validator.name};
      if (validator.arg !== void 0) {
        item.arg = validator.arg;
      }
      description.rules.push(item);
    }
    if (!description.rules.length) {
      delete description.rules;
    }
    var label = Hoek.reach(this._settings, 'language.label');
    if (label) {
      description.label = label;
    }
    return description;
  };
  internals.Any.prototype.label = function(name) {
    Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');
    var obj = this.clone();
    var options = {language: {label: name}};
    obj._settings = internals.concatSettings(options, obj._settings);
    return obj;
  };
  internals.Set = function() {
    this._set = [];
  };
  internals.Set.prototype.add = function(value, refs) {
    Hoek.assert(value === null || value === undefined || value instanceof Date || Ref.isRef(value) || (typeof value !== 'function' && typeof value !== 'object'), 'Value cannot be an object or function');
    if (typeof value !== 'function' && this.has(value, null, null, false)) {
      return;
    }
    Ref.push(refs, value);
    this._set.push(value);
  };
  internals.Set.prototype.merge = function(add, remove) {
    for (var i = 0,
        il = add._set.length; i < il; ++i) {
      this.add(add._set[i]);
    }
    for (i = 0, il = remove._set.length; i < il; ++i) {
      this.remove(remove._set[i]);
    }
  };
  internals.Set.prototype.remove = function(value) {
    this._set = this._set.filter(function(item) {
      return value !== item;
    });
  };
  internals.Set.prototype.has = function(value, state, options, insensitive) {
    for (var i = 0,
        il = this._set.length; i < il; ++i) {
      var item = this._set[i];
      if (Ref.isRef(item)) {
        item = item(state.reference || state.parent, options);
      }
      if (typeof value !== typeof item) {
        continue;
      }
      if (value === item || (value instanceof Date && item instanceof Date && value.getTime() === item.getTime()) || (insensitive && typeof value === 'string' && value.toLowerCase() === item.toLowerCase())) {
        return true;
      }
    }
    return false;
  };
  internals.Set.prototype.values = function() {
    return this._set.slice();
  };
  internals.Set.prototype.toString = function(includeUndefined) {
    var list = '';
    for (var i = 0,
        il = this._set.length; i < il; ++i) {
      var item = this._set[i];
      if (item !== undefined || includeUndefined) {
        list += (list ? ', ' : '') + internals.stringify(item);
      }
    }
    return list;
  };
  internals.stringify = function(value) {
    if (value === undefined) {
      return 'undefined';
    }
    if (value === null) {
      return 'null';
    }
    if (typeof value === 'string') {
      return value;
    }
    return value.toString();
  };
  internals.concatSettings = function(target, source) {
    if (!target && !source) {
      return null;
    }
    var obj = {};
    if (target) {
      var tKeys = Object.keys(target);
      for (var i = 0,
          il = tKeys.length; i < il; ++i) {
        var key = tKeys[i];
        obj[key] = target[key];
      }
    }
    if (source) {
      var sKeys = Object.keys(source);
      for (var j = 0,
          jl = sKeys.length; j < jl; ++j) {
        var key = sKeys[j];
        if (key !== 'language' || !obj.hasOwnProperty(key)) {
          obj[key] = source[key];
        } else {
          obj[key] = Hoek.applyToDefaults(obj[key], source[key]);
        }
      }
    }
    return obj;
  };
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/ref.js", ["hoek"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Hoek = $__require('hoek');
  var internals = {};
  exports.create = function(key, options) {
    Hoek.assert(typeof key === 'string', 'Invalid reference key:', key);
    var settings = Hoek.clone(options);
    var ref = function(value, validationOptions) {
      return Hoek.reach(ref.isContext ? validationOptions.context : value, ref.key, settings);
    };
    ref.isContext = (key[0] === ((settings && settings.contextPrefix) || '$'));
    ref.key = (ref.isContext ? key.slice(1) : key);
    ref.path = ref.key.split((settings && settings.separator) || '.');
    ref.depth = ref.path.length;
    ref.root = ref.path[0];
    ref.isJoi = true;
    ref.toString = function() {
      return (ref.isContext ? 'context:' : 'ref:') + ref.key;
    };
    return ref;
  };
  exports.isRef = function(ref) {
    return typeof ref === 'function' && ref.isJoi;
  };
  exports.push = function(array, ref) {
    if (exports.isRef(ref) && !ref.isContext) {
      array.push(ref.root);
    }
  };
  return module.exports;
});

System.registerDynamic("npm:moment@2.13.0.json", [], false, function() {
  return {
    "main": "./moment.js",
    "map": {
      "moment": "./moment"
    }
  };
});

(function() {
var define = System.amdDefine;
;
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define("npm:moment@2.13.0/moment.js", [], factory) : global.moment = factory();
}(this, function() {
  'use strict';
  var hookCallback;
  function utils_hooks__hooks() {
    return hookCallback.apply(null, arguments);
  }
  function setHookCallback(callback) {
    hookCallback = callback;
  }
  function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
  }
  function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
  }
  function map(arr, fn) {
    var res = [],
        i;
    for (i = 0; i < arr.length; ++i) {
      res.push(fn(arr[i], i));
    }
    return res;
  }
  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }
  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }
    if (hasOwnProp(b, 'toString')) {
      a.toString = b.toString;
    }
    if (hasOwnProp(b, 'valueOf')) {
      a.valueOf = b.valueOf;
    }
    return a;
  }
  function create_utc__createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
  }
  function defaultParsingFlags() {
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false,
      parsedDateParts: [],
      meridiem: null
    };
  }
  function getParsingFlags(m) {
    if (m._pf == null) {
      m._pf = defaultParsingFlags();
    }
    return m._pf;
  }
  var some;
  if (Array.prototype.some) {
    some = Array.prototype.some;
  } else {
    some = function(fun) {
      var t = Object(this);
      var len = t.length >>> 0;
      for (var i = 0; i < len; i++) {
        if (i in t && fun.call(this, t[i], i, t)) {
          return true;
        }
      }
      return false;
    };
  }
  function valid__isValid(m) {
    if (m._isValid == null) {
      var flags = getParsingFlags(m);
      var parsedParts = some.call(flags.parsedDateParts, function(i) {
        return i != null;
      });
      m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || (flags.meridiem && parsedParts));
      if (m._strict) {
        m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
      }
    }
    return m._isValid;
  }
  function valid__createInvalid(flags) {
    var m = create_utc__createUTC(NaN);
    if (flags != null) {
      extend(getParsingFlags(m), flags);
    } else {
      getParsingFlags(m).userInvalidated = true;
    }
    return m;
  }
  function isUndefined(input) {
    return input === void 0;
  }
  var momentProperties = utils_hooks__hooks.momentProperties = [];
  function copyConfig(to, from) {
    var i,
        prop,
        val;
    if (!isUndefined(from._isAMomentObject)) {
      to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
      to._i = from._i;
    }
    if (!isUndefined(from._f)) {
      to._f = from._f;
    }
    if (!isUndefined(from._l)) {
      to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
      to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
      to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
      to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
      to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
      to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
      to._locale = from._locale;
    }
    if (momentProperties.length > 0) {
      for (i in momentProperties) {
        prop = momentProperties[i];
        val = from[prop];
        if (!isUndefined(val)) {
          to[prop] = val;
        }
      }
    }
    return to;
  }
  var updateInProgress = false;
  function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (updateInProgress === false) {
      updateInProgress = true;
      utils_hooks__hooks.updateOffset(this);
      updateInProgress = false;
    }
  }
  function isMoment(obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
  }
  function absFloor(number) {
    if (number < 0) {
      return Math.ceil(number);
    } else {
      return Math.floor(number);
    }
  }
  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;
    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      value = absFloor(coercedNumber);
    }
    return value;
  }
  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
      if ((dontConvert && array1[i] !== array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
        diffs++;
      }
    }
    return diffs + lengthDiff;
  }
  function warn(msg) {
    if (utils_hooks__hooks.suppressDeprecationWarnings === false && (typeof console !== 'undefined') && console.warn) {
      console.warn('Deprecation warning: ' + msg);
    }
  }
  function deprecate(msg, fn) {
    var firstTime = true;
    return extend(function() {
      if (utils_hooks__hooks.deprecationHandler != null) {
        utils_hooks__hooks.deprecationHandler(null, msg);
      }
      if (firstTime) {
        warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
        firstTime = false;
      }
      return fn.apply(this, arguments);
    }, fn);
  }
  var deprecations = {};
  function deprecateSimple(name, msg) {
    if (utils_hooks__hooks.deprecationHandler != null) {
      utils_hooks__hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
      warn(msg);
      deprecations[name] = true;
    }
  }
  utils_hooks__hooks.suppressDeprecationWarnings = false;
  utils_hooks__hooks.deprecationHandler = null;
  function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }
  function isObject(input) {
    return Object.prototype.toString.call(input) === '[object Object]';
  }
  function locale_set__set(config) {
    var prop,
        i;
    for (i in config) {
      prop = config[i];
      if (isFunction(prop)) {
        this[i] = prop;
      } else {
        this['_' + i] = prop;
      }
    }
    this._config = config;
    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
  }
  function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig),
        prop;
    for (prop in childConfig) {
      if (hasOwnProp(childConfig, prop)) {
        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
          res[prop] = {};
          extend(res[prop], parentConfig[prop]);
          extend(res[prop], childConfig[prop]);
        } else if (childConfig[prop] != null) {
          res[prop] = childConfig[prop];
        } else {
          delete res[prop];
        }
      }
    }
    return res;
  }
  function Locale(config) {
    if (config != null) {
      this.set(config);
    }
  }
  var keys;
  if (Object.keys) {
    keys = Object.keys;
  } else {
    keys = function(obj) {
      var i,
          res = [];
      for (i in obj) {
        if (hasOwnProp(obj, i)) {
          res.push(i);
        }
      }
      return res;
    };
  }
  var locales = {};
  var globalLocale;
  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
  }
  function chooseLocale(names) {
    var i = 0,
        j,
        next,
        locale,
        split;
    while (i < names.length) {
      split = normalizeLocale(names[i]).split('-');
      j = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split('-') : null;
      while (j > 0) {
        locale = loadLocale(split.slice(0, j).join('-'));
        if (locale) {
          return locale;
        }
        if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
          break;
        }
        j--;
      }
      i++;
    }
    return null;
  }
  function loadLocale(name) {
    var oldLocale = null;
    if (!locales[name] && (typeof module !== 'undefined') && module && module.exports) {
      try {
        oldLocale = globalLocale._abbr;
        require('./locale/' + name);
        locale_locales__getSetGlobalLocale(oldLocale);
      } catch (e) {}
    }
    return locales[name];
  }
  function locale_locales__getSetGlobalLocale(key, values) {
    var data;
    if (key) {
      if (isUndefined(values)) {
        data = locale_locales__getLocale(key);
      } else {
        data = defineLocale(key, values);
      }
      if (data) {
        globalLocale = data;
      }
    }
    return globalLocale._abbr;
  }
  function defineLocale(name, config) {
    if (config !== null) {
      config.abbr = name;
      if (locales[name] != null) {
        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale');
        config = mergeConfigs(locales[name]._config, config);
      } else if (config.parentLocale != null) {
        if (locales[config.parentLocale] != null) {
          config = mergeConfigs(locales[config.parentLocale]._config, config);
        } else {
          deprecateSimple('parentLocaleUndefined', 'specified parentLocale is not defined yet');
        }
      }
      locales[name] = new Locale(config);
      locale_locales__getSetGlobalLocale(name);
      return locales[name];
    } else {
      delete locales[name];
      return null;
    }
  }
  function updateLocale(name, config) {
    if (config != null) {
      var locale;
      if (locales[name] != null) {
        config = mergeConfigs(locales[name]._config, config);
      }
      locale = new Locale(config);
      locale.parentLocale = locales[name];
      locales[name] = locale;
      locale_locales__getSetGlobalLocale(name);
    } else {
      if (locales[name] != null) {
        if (locales[name].parentLocale != null) {
          locales[name] = locales[name].parentLocale;
        } else if (locales[name] != null) {
          delete locales[name];
        }
      }
    }
    return locales[name];
  }
  function locale_locales__getLocale(key) {
    var locale;
    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }
    if (!key) {
      return globalLocale;
    }
    if (!isArray(key)) {
      locale = loadLocale(key);
      if (locale) {
        return locale;
      }
      key = [key];
    }
    return chooseLocale(key);
  }
  function locale_locales__listLocales() {
    return keys(locales);
  }
  var aliases = {};
  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
  }
  function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
  }
  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;
    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);
        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }
    return normalizedInput;
  }
  function makeGetSet(unit, keepTime) {
    return function(value) {
      if (value != null) {
        get_set__set(this, unit, value);
        utils_hooks__hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get_set__get(this, unit);
      }
    };
  }
  function get_set__get(mom, unit) {
    return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
  }
  function get_set__set(mom, unit, value) {
    if (mom.isValid()) {
      mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
  }
  function getSet(units, value) {
    var unit;
    if (typeof units === 'object') {
      for (unit in units) {
        this.set(unit, units[unit]);
      }
    } else {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units](value);
      }
    }
    return this;
  }
  function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
  }
  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
  var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
  var formatFunctions = {};
  var formatTokenFunctions = {};
  function addFormatToken(token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
      func = function() {
        return this[callback]();
      };
    }
    if (token) {
      formatTokenFunctions[token] = func;
    }
    if (padded) {
      formatTokenFunctions[padded[0]] = function() {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }
    if (ordinal) {
      formatTokenFunctions[ordinal] = function() {
        return this.localeData().ordinal(func.apply(this, arguments), token);
      };
    }
  }
  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
  }
  function makeFormatFunction(format) {
    var array = format.match(formattingTokens),
        i,
        length;
    for (i = 0, length = array.length; i < length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }
    return function(mom) {
      var output = '',
          i;
      for (i = 0; i < length; i++) {
        output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
      }
      return output;
    };
  }
  function formatMoment(m, format) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }
    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
    return formatFunctions[format](m);
  }
  function expandFormat(format, locale) {
    var i = 5;
    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }
    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }
    return format;
  }
  var match1 = /\d/;
  var match2 = /\d\d/;
  var match3 = /\d{3}/;
  var match4 = /\d{4}/;
  var match6 = /[+-]?\d{6}/;
  var match1to2 = /\d\d?/;
  var match3to4 = /\d\d\d\d?/;
  var match5to6 = /\d\d\d\d\d\d?/;
  var match1to3 = /\d{1,3}/;
  var match1to4 = /\d{1,4}/;
  var match1to6 = /[+-]?\d{1,6}/;
  var matchUnsigned = /\d+/;
  var matchSigned = /[+-]?\d+/;
  var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
  var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
  var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
  var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var regexes = {};
  function addRegexToken(token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
      return (isStrict && strictRegex) ? strictRegex : regex;
    };
  }
  function getParseRegexForToken(token, config) {
    if (!hasOwnProp(regexes, token)) {
      return new RegExp(unescapeFormat(token));
    }
    return regexes[token](config._strict, config._locale);
  }
  function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
      return p1 || p2 || p3 || p4;
    }));
  }
  function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }
  var tokens = {};
  function addParseToken(token, callback) {
    var i,
        func = callback;
    if (typeof token === 'string') {
      token = [token];
    }
    if (typeof callback === 'number') {
      func = function(input, array) {
        array[callback] = toInt(input);
      };
    }
    for (i = 0; i < token.length; i++) {
      tokens[token[i]] = func;
    }
  }
  function addWeekParseToken(token, callback) {
    addParseToken(token, function(input, array, config, token) {
      config._w = config._w || {};
      callback(input, config._w, config, token);
    });
  }
  function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
      tokens[token](input, config._a, config, token);
    }
  }
  var YEAR = 0;
  var MONTH = 1;
  var DATE = 2;
  var HOUR = 3;
  var MINUTE = 4;
  var SECOND = 5;
  var MILLISECOND = 6;
  var WEEK = 7;
  var WEEKDAY = 8;
  var indexOf;
  if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
  } else {
    indexOf = function(o) {
      var i;
      for (i = 0; i < this.length; ++i) {
        if (this[i] === o) {
          return i;
        }
      }
      return -1;
    };
  }
  function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
  }
  addFormatToken('M', ['MM', 2], 'Mo', function() {
    return this.month() + 1;
  });
  addFormatToken('MMM', 0, 0, function(format) {
    return this.localeData().monthsShort(this, format);
  });
  addFormatToken('MMMM', 0, 0, function(format) {
    return this.localeData().months(this, format);
  });
  addUnitAlias('month', 'M');
  addRegexToken('M', match1to2);
  addRegexToken('MM', match1to2, match2);
  addRegexToken('MMM', function(isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
  });
  addRegexToken('MMMM', function(isStrict, locale) {
    return locale.monthsRegex(isStrict);
  });
  addParseToken(['M', 'MM'], function(input, array) {
    array[MONTH] = toInt(input) - 1;
  });
  addParseToken(['MMM', 'MMMM'], function(input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  });
  var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
  function localeMonths(m, format) {
    return isArray(this._months) ? this._months[m.month()] : this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
  }
  var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
  function localeMonthsShort(m, format) {
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
  }
  function units_month__handleStrictParse(monthName, format, strict) {
    var i,
        ii,
        mom,
        llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
      for (i = 0; i < 12; ++i) {
        mom = create_utc__createUTC([2000, i]);
        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeMonthsParse(monthName, format, strict) {
    var i,
        mom,
        regex;
    if (this._monthsParseExact) {
      return units_month__handleStrictParse.call(this, monthName, format, strict);
    }
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    }
    for (i = 0; i < 12; i++) {
      mom = create_utc__createUTC([2000, i]);
      if (strict && !this._longMonthsParse[i]) {
        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
      }
      if (!strict && !this._monthsParse[i]) {
        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
      }
      if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
        return i;
      } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
        return i;
      } else if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  }
  function setMonth(mom, value) {
    var dayOfMonth;
    if (!mom.isValid()) {
      return mom;
    }
    if (typeof value === 'string') {
      if (/^\d+$/.test(value)) {
        value = toInt(value);
      } else {
        value = mom.localeData().monthsParse(value);
        if (typeof value !== 'number') {
          return mom;
        }
      }
    }
    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
  }
  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      utils_hooks__hooks.updateOffset(this, true);
      return this;
    } else {
      return get_set__get(this, 'Month');
    }
  }
  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }
  var defaultMonthsShortRegex = matchWord;
  function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsShortStrictRegex;
      } else {
        return this._monthsShortRegex;
      }
    } else {
      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
    }
  }
  var defaultMonthsRegex = matchWord;
  function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsStrictRegex;
      } else {
        return this._monthsRegex;
      }
    } else {
      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
    }
  }
  function computeMonthsParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom;
    for (i = 0; i < 12; i++) {
      mom = create_utc__createUTC([2000, i]);
      shortPieces.push(this.monthsShort(mom, ''));
      longPieces.push(this.months(mom, ''));
      mixedPieces.push(this.months(mom, ''));
      mixedPieces.push(this.monthsShort(mom, ''));
    }
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }
    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
  }
  function checkOverflow(m) {
    var overflow;
    var a = m._a;
    if (a && getParsingFlags(m).overflow === -2) {
      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
        overflow = DATE;
      }
      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
        overflow = WEEK;
      }
      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
        overflow = WEEKDAY;
      }
      getParsingFlags(m).overflow = overflow;
    }
    return m;
  }
  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
  var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
  var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
  var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]];
  var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
  var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
  function configFromISO(config) {
    var i,
        l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime,
        dateFormat,
        timeFormat,
        tzFormat;
    if (match) {
      getParsingFlags(config).iso = true;
      for (i = 0, l = isoDates.length; i < l; i++) {
        if (isoDates[i][1].exec(match[1])) {
          dateFormat = isoDates[i][0];
          allowTime = isoDates[i][2] !== false;
          break;
        }
      }
      if (dateFormat == null) {
        config._isValid = false;
        return;
      }
      if (match[3]) {
        for (i = 0, l = isoTimes.length; i < l; i++) {
          if (isoTimes[i][1].exec(match[3])) {
            timeFormat = (match[2] || ' ') + isoTimes[i][0];
            break;
          }
        }
        if (timeFormat == null) {
          config._isValid = false;
          return;
        }
      }
      if (!allowTime && timeFormat != null) {
        config._isValid = false;
        return;
      }
      if (match[4]) {
        if (tzRegex.exec(match[4])) {
          tzFormat = 'Z';
        } else {
          config._isValid = false;
          return;
        }
      }
      config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
      configFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  }
  function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);
    if (matched !== null) {
      config._d = new Date(+matched[1]);
      return;
    }
    configFromISO(config);
    if (config._isValid === false) {
      delete config._isValid;
      utils_hooks__hooks.createFromInputFallback(config);
    }
  }
  utils_hooks__hooks.createFromInputFallback = deprecate('moment construction falls back to js Date. This is ' + 'discouraged and will be removed in upcoming major ' + 'release. Please refer to ' + 'https://github.com/moment/moment/issues/1407 for more info.', function(config) {
    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
  });
  function createDate(y, m, d, h, M, s, ms) {
    var date = new Date(y, m, d, h, M, s, ms);
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
    return date;
  }
  function createUTCDate(y) {
    var date = new Date(Date.UTC.apply(null, arguments));
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
    return date;
  }
  addFormatToken('Y', 0, 0, function() {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
  });
  addFormatToken(0, ['YY', 2], 0, function() {
    return this.year() % 100;
  });
  addFormatToken(0, ['YYYY', 4], 0, 'year');
  addFormatToken(0, ['YYYYY', 5], 0, 'year');
  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
  addUnitAlias('year', 'y');
  addRegexToken('Y', matchSigned);
  addRegexToken('YY', match1to2, match2);
  addRegexToken('YYYY', match1to4, match4);
  addRegexToken('YYYYY', match1to6, match6);
  addRegexToken('YYYYYY', match1to6, match6);
  addParseToken(['YYYYY', 'YYYYYY'], YEAR);
  addParseToken('YYYY', function(input, array) {
    array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken('YY', function(input, array) {
    array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
  });
  addParseToken('Y', function(input, array) {
    array[YEAR] = parseInt(input, 10);
  });
  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }
  function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
  }
  utils_hooks__hooks.parseTwoDigitYear = function(input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  };
  var getSetYear = makeGetSet('FullYear', true);
  function getIsLeapYear() {
    return isLeapYear(this.year());
  }
  function firstWeekOffset(year, dow, doy) {
    var fwd = 7 + dow - doy,
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
  }
  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear,
        resDayOfYear;
    if (dayOfYear <= 0) {
      resYear = year - 1;
      resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
      resYear = year + 1;
      resDayOfYear = dayOfYear - daysInYear(year);
    } else {
      resYear = year;
      resDayOfYear = dayOfYear;
    }
    return {
      year: resYear,
      dayOfYear: resDayOfYear
    };
  }
  function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek,
        resYear;
    if (week < 1) {
      resYear = mom.year() - 1;
      resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
      resWeek = week - weeksInYear(mom.year(), dow, doy);
      resYear = mom.year() + 1;
    } else {
      resYear = mom.year();
      resWeek = week;
    }
    return {
      week: resWeek,
      year: resYear
    };
  }
  function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  }
  function defaults(a, b, c) {
    if (a != null) {
      return a;
    }
    if (b != null) {
      return b;
    }
    return c;
  }
  function currentDateArray(config) {
    var nowValue = new Date(utils_hooks__hooks.now());
    if (config._useUTC) {
      return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  }
  function configFromArray(config) {
    var i,
        date,
        input = [],
        currentDate,
        yearToUse;
    if (config._d) {
      return;
    }
    currentDate = currentDateArray(config);
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    }
    if (config._dayOfYear) {
      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
      if (config._dayOfYear > daysInYear(yearToUse)) {
        getParsingFlags(config)._overflowDayOfYear = true;
      }
      date = createUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    }
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    }
    for (; i < 7; i++) {
      config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }
    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
      config._nextDay = true;
      config._a[HOUR] = 0;
    }
    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }
    if (config._nextDay) {
      config._a[HOUR] = 24;
    }
  }
  function dayOfYearFromWeekInfo(config) {
    var w,
        weekYear,
        week,
        weekday,
        dow,
        doy,
        temp,
        weekdayOverflow;
    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4;
      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
      week = defaults(w.W, 1);
      weekday = defaults(w.E, 1);
      if (weekday < 1 || weekday > 7) {
        weekdayOverflow = true;
      }
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
      week = defaults(w.w, 1);
      if (w.d != null) {
        weekday = w.d;
        if (weekday < 0 || weekday > 6) {
          weekdayOverflow = true;
        }
      } else if (w.e != null) {
        weekday = w.e + dow;
        if (w.e < 0 || w.e > 6) {
          weekdayOverflow = true;
        }
      } else {
        weekday = dow;
      }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
      getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
      getParsingFlags(config)._overflowWeekday = true;
    } else {
      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
      config._a[YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
  }
  utils_hooks__hooks.ISO_8601 = function() {};
  function configFromStringAndFormat(config) {
    if (config._f === utils_hooks__hooks.ISO_8601) {
      configFromISO(config);
      return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;
    var string = '' + config._i,
        i,
        parsedInput,
        tokens,
        token,
        skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;
    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));
        if (skipped.length > 0) {
          getParsingFlags(config).unusedInput.push(skipped);
        }
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      }
      if (formatTokenFunctions[token]) {
        if (parsedInput) {
          getParsingFlags(config).empty = false;
        } else {
          getParsingFlags(config).unusedTokens.push(token);
        }
        addTimeToArrayFromToken(token, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        getParsingFlags(config).unusedTokens.push(token);
      }
    }
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
      getParsingFlags(config).unusedInput.push(string);
    }
    if (getParsingFlags(config).bigHour === true && config._a[HOUR] <= 12 && config._a[HOUR] > 0) {
      getParsingFlags(config).bigHour = undefined;
    }
    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
    configFromArray(config);
    checkOverflow(config);
  }
  function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;
    if (meridiem == null) {
      return hour;
    }
    if (locale.meridiemHour != null) {
      return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
      isPm = locale.isPM(meridiem);
      if (isPm && hour < 12) {
        hour += 12;
      }
      if (!isPm && hour === 12) {
        hour = 0;
      }
      return hour;
    } else {
      return hour;
    }
  }
  function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,
        scoreToBeat,
        i,
        currentScore;
    if (config._f.length === 0) {
      getParsingFlags(config).invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }
    for (i = 0; i < config._f.length; i++) {
      currentScore = 0;
      tempConfig = copyConfig({}, config);
      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }
      tempConfig._f = config._f[i];
      configFromStringAndFormat(tempConfig);
      if (!valid__isValid(tempConfig)) {
        continue;
      }
      currentScore += getParsingFlags(tempConfig).charsLeftOver;
      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
      getParsingFlags(tempConfig).score = currentScore;
      if (scoreToBeat == null || currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
    extend(config, bestMoment || tempConfig);
  }
  function configFromObject(config) {
    if (config._d) {
      return;
    }
    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function(obj) {
      return obj && parseInt(obj, 10);
    });
    configFromArray(config);
  }
  function createFromConfig(config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
      res.add(1, 'd');
      res._nextDay = undefined;
    }
    return res;
  }
  function prepareConfig(config) {
    var input = config._i,
        format = config._f;
    config._locale = config._locale || locale_locales__getLocale(config._l);
    if (input === null || (format === undefined && input === '')) {
      return valid__createInvalid({nullInput: true});
    }
    if (typeof input === 'string') {
      config._i = input = config._locale.preparse(input);
    }
    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isArray(format)) {
      configFromStringAndArray(config);
    } else if (format) {
      configFromStringAndFormat(config);
    } else if (isDate(input)) {
      config._d = input;
    } else {
      configFromInput(config);
    }
    if (!valid__isValid(config)) {
      config._d = null;
    }
    return config;
  }
  function configFromInput(config) {
    var input = config._i;
    if (input === undefined) {
      config._d = new Date(utils_hooks__hooks.now());
    } else if (isDate(input)) {
      config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
      configFromString(config);
    } else if (isArray(input)) {
      config._a = map(input.slice(0), function(obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config);
    } else if (typeof(input) === 'object') {
      configFromObject(config);
    } else if (typeof(input) === 'number') {
      config._d = new Date(input);
    } else {
      utils_hooks__hooks.createFromInputFallback(config);
    }
  }
  function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var c = {};
    if (typeof(locale) === 'boolean') {
      strict = locale;
      locale = undefined;
    }
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;
    return createFromConfig(c);
  }
  function local__createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
  }
  var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548', function() {
    var other = local__createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return valid__createInvalid();
    }
  });
  var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548', function() {
    var other = local__createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return valid__createInvalid();
    }
  });
  function pickBy(fn, moments) {
    var res,
        i;
    if (moments.length === 1 && isArray(moments[0])) {
      moments = moments[0];
    }
    if (!moments.length) {
      return local__createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
      if (!moments[i].isValid() || moments[i][fn](res)) {
        res = moments[i];
      }
    }
    return res;
  }
  function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isBefore', args);
  }
  function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isAfter', args);
  }
  var now = function() {
    return Date.now ? Date.now() : +(new Date());
  };
  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;
    this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 1000 * 60 * 60;
    this._days = +days + weeks * 7;
    this._months = +months + quarters * 3 + years * 12;
    this._data = {};
    this._locale = locale_locales__getLocale();
    this._bubble();
  }
  function isDuration(obj) {
    return obj instanceof Duration;
  }
  function offset(token, separator) {
    addFormatToken(token, 0, 0, function() {
      var offset = this.utcOffset();
      var sign = '+';
      if (offset < 0) {
        offset = -offset;
        sign = '-';
      }
      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
  }
  offset('Z', ':');
  offset('ZZ', '');
  addRegexToken('Z', matchShortOffset);
  addRegexToken('ZZ', matchShortOffset);
  addParseToken(['Z', 'ZZ'], function(input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
  });
  var chunkOffset = /([\+\-]|\d\d)/gi;
  function offsetFromString(matcher, string) {
    var matches = ((string || '').match(matcher) || []);
    var chunk = matches[matches.length - 1] || [];
    var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);
    return parts[0] === '+' ? minutes : -minutes;
  }
  function cloneWithOffset(input, model) {
    var res,
        diff;
    if (model._isUTC) {
      res = model.clone();
      diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
      res._d.setTime(res._d.valueOf() + diff);
      utils_hooks__hooks.updateOffset(res, false);
      return res;
    } else {
      return local__createLocal(input).local();
    }
  }
  function getDateOffset(m) {
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
  }
  utils_hooks__hooks.updateOffset = function() {};
  function getSetOffset(input, keepLocalTime) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      if (typeof input === 'string') {
        input = offsetFromString(matchShortOffset, input);
      } else if (Math.abs(input) < 16) {
        input = input * 60;
      }
      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }
      this._offset = input;
      this._isUTC = true;
      if (localAdjust != null) {
        this.add(localAdjust, 'm');
      }
      if (offset !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          utils_hooks__hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }
      return this;
    } else {
      return this._isUTC ? offset : getDateOffset(this);
    }
  }
  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== 'string') {
        input = -input;
      }
      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }
  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }
  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;
      if (keepLocalTime) {
        this.subtract(getDateOffset(this), 'm');
      }
    }
    return this;
  }
  function setOffsetToParsedOffset() {
    if (this._tzm) {
      this.utcOffset(this._tzm);
    } else if (typeof this._i === 'string') {
      this.utcOffset(offsetFromString(matchOffset, this._i));
    }
    return this;
  }
  function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
      return false;
    }
    input = input ? local__createLocal(input).utcOffset() : 0;
    return (this.utcOffset() - input) % 60 === 0;
  }
  function isDaylightSavingTime() {
    return (this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset());
  }
  function isDaylightSavingTimeShifted() {
    if (!isUndefined(this._isDSTShifted)) {
      return this._isDSTShifted;
    }
    var c = {};
    copyConfig(c, this);
    c = prepareConfig(c);
    if (c._a) {
      var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }
    return this._isDSTShifted;
  }
  function isLocal() {
    return this.isValid() ? !this._isUTC : false;
  }
  function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
  }
  function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
  }
  var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;
  var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
  function create__createDuration(input, key) {
    var duration = input,
        match = null,
        sign,
        ret,
        diffRes;
    if (isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months
      };
    } else if (typeof input === 'number') {
      duration = {};
      if (key) {
        duration[key] = input;
      } else {
        duration.milliseconds = input;
      }
    } else if (!!(match = aspNetRegex.exec(input))) {
      sign = (match[1] === '-') ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign,
        h: toInt(match[HOUR]) * sign,
        m: toInt(match[MINUTE]) * sign,
        s: toInt(match[SECOND]) * sign,
        ms: toInt(match[MILLISECOND]) * sign
      };
    } else if (!!(match = isoRegex.exec(input))) {
      sign = (match[1] === '-') ? -1 : 1;
      duration = {
        y: parseIso(match[2], sign),
        M: parseIso(match[3], sign),
        w: parseIso(match[4], sign),
        d: parseIso(match[5], sign),
        h: parseIso(match[6], sign),
        m: parseIso(match[7], sign),
        s: parseIso(match[8], sign)
      };
    } else if (duration == null) {
      duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
      diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }
    ret = new Duration(duration);
    if (isDuration(input) && hasOwnProp(input, '_locale')) {
      ret._locale = input._locale;
    }
    return ret;
  }
  create__createDuration.fn = Duration.prototype;
  function parseIso(inp, sign) {
    var res = inp && parseFloat(inp.replace(',', '.'));
    return (isNaN(res) ? 0 : res) * sign;
  }
  function positiveMomentsDifference(base, other) {
    var res = {
      milliseconds: 0,
      months: 0
    };
    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
      --res.months;
    }
    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
    return res;
  }
  function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
      return {
        milliseconds: 0,
        months: 0
      };
    }
    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }
    return res;
  }
  function absRound(number) {
    if (number < 0) {
      return Math.round(-1 * number) * -1;
    } else {
      return Math.round(number);
    }
  }
  function createAdder(direction, name) {
    return function(val, period) {
      var dur,
          tmp;
      if (period !== null && !isNaN(+period)) {
        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
        tmp = val;
        val = period;
        period = tmp;
      }
      val = typeof val === 'string' ? +val : val;
      dur = create__createDuration(val, period);
      add_subtract__addSubtract(this, dur, direction);
      return this;
    };
  }
  function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);
    if (!mom.isValid()) {
      return;
    }
    updateOffset = updateOffset == null ? true : updateOffset;
    if (milliseconds) {
      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
      get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
    }
    if (months) {
      setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
      utils_hooks__hooks.updateOffset(mom, days || months);
    }
  }
  var add_subtract__add = createAdder(1, 'add');
  var add_subtract__subtract = createAdder(-1, 'subtract');
  function moment_calendar__calendar(time, formats) {
    var now = time || local__createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        diff = this.diff(sod, 'days', true),
        format = diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);
    return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
  }
  function clone() {
    return new Moment(this);
  }
  function isAfter(input, units) {
    var localInput = isMoment(input) ? input : local__createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
      return this.valueOf() > localInput.valueOf();
    } else {
      return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
  }
  function isBefore(input, units) {
    var localInput = isMoment(input) ? input : local__createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
      return this.valueOf() < localInput.valueOf();
    } else {
      return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
  }
  function isBetween(from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) && (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
  }
  function isSame(input, units) {
    var localInput = isMoment(input) ? input : local__createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
      return this.valueOf() === localInput.valueOf();
    } else {
      inputMs = localInput.valueOf();
      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
  }
  function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
  }
  function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
  }
  function diff(input, units, asFloat) {
    var that,
        zoneDelta,
        delta,
        output;
    if (!this.isValid()) {
      return NaN;
    }
    that = cloneWithOffset(input, this);
    if (!that.isValid()) {
      return NaN;
    }
    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
    units = normalizeUnits(units);
    if (units === 'year' || units === 'month' || units === 'quarter') {
      output = monthDiff(this, that);
      if (units === 'quarter') {
        output = output / 3;
      } else if (units === 'year') {
        output = output / 12;
      }
    } else {
      delta = this - that;
      output = units === 'second' ? delta / 1e3 : units === 'minute' ? delta / 6e4 : units === 'hour' ? delta / 36e5 : units === 'day' ? (delta - zoneDelta) / 864e5 : units === 'week' ? (delta - zoneDelta) / 6048e5 : delta;
    }
    return asFloat ? output : absFloor(output);
  }
  function monthDiff(a, b) {
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2,
        adjust;
    if (b - anchor < 0) {
      anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
      adjust = (b - anchor) / (anchor2 - anchor);
    }
    return -(wholeMonthDiff + adjust) || 0;
  }
  utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
  utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
  function toString() {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
  }
  function moment_format__toISOString() {
    var m = this.clone().utc();
    if (0 < m.year() && m.year() <= 9999) {
      if (isFunction(Date.prototype.toISOString)) {
        return this.toDate().toISOString();
      } else {
        return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
      }
    } else {
      return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
  }
  function format(inputString) {
    if (!inputString) {
      inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
  }
  function from(time, withoutSuffix) {
    if (this.isValid() && ((isMoment(time) && time.isValid()) || local__createLocal(time).isValid())) {
      return create__createDuration({
        to: this,
        from: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function fromNow(withoutSuffix) {
    return this.from(local__createLocal(), withoutSuffix);
  }
  function to(time, withoutSuffix) {
    if (this.isValid() && ((isMoment(time) && time.isValid()) || local__createLocal(time).isValid())) {
      return create__createDuration({
        from: this,
        to: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function toNow(withoutSuffix) {
    return this.to(local__createLocal(), withoutSuffix);
  }
  function locale(key) {
    var newLocaleData;
    if (key === undefined) {
      return this._locale._abbr;
    } else {
      newLocaleData = locale_locales__getLocale(key);
      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }
      return this;
    }
  }
  var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function(key) {
    if (key === undefined) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  });
  function localeData() {
    return this._locale;
  }
  function startOf(units) {
    units = normalizeUnits(units);
    switch (units) {
      case 'year':
        this.month(0);
      case 'quarter':
      case 'month':
        this.date(1);
      case 'week':
      case 'isoWeek':
      case 'day':
      case 'date':
        this.hours(0);
      case 'hour':
        this.minutes(0);
      case 'minute':
        this.seconds(0);
      case 'second':
        this.milliseconds(0);
    }
    if (units === 'week') {
      this.weekday(0);
    }
    if (units === 'isoWeek') {
      this.isoWeekday(1);
    }
    if (units === 'quarter') {
      this.month(Math.floor(this.month() / 3) * 3);
    }
    return this;
  }
  function endOf(units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
      return this;
    }
    if (units === 'date') {
      units = 'day';
    }
    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
  }
  function to_type__valueOf() {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
  }
  function unix() {
    return Math.floor(this.valueOf() / 1000);
  }
  function toDate() {
    return this._offset ? new Date(this.valueOf()) : this._d;
  }
  function toArray() {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
  }
  function toObject() {
    var m = this;
    return {
      years: m.year(),
      months: m.month(),
      date: m.date(),
      hours: m.hours(),
      minutes: m.minutes(),
      seconds: m.seconds(),
      milliseconds: m.milliseconds()
    };
  }
  function toJSON() {
    return this.isValid() ? this.toISOString() : null;
  }
  function moment_valid__isValid() {
    return valid__isValid(this);
  }
  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }
  function invalidAt() {
    return getParsingFlags(this).overflow;
  }
  function creationData() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    };
  }
  addFormatToken(0, ['gg', 2], 0, function() {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ['GG', 2], 0, function() {
    return this.isoWeekYear() % 100;
  });
  function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
  }
  addWeekYearFormatToken('gggg', 'weekYear');
  addWeekYearFormatToken('ggggg', 'weekYear');
  addWeekYearFormatToken('GGGG', 'isoWeekYear');
  addWeekYearFormatToken('GGGGG', 'isoWeekYear');
  addUnitAlias('weekYear', 'gg');
  addUnitAlias('isoWeekYear', 'GG');
  addRegexToken('G', matchSigned);
  addRegexToken('g', matchSigned);
  addRegexToken('GG', match1to2, match2);
  addRegexToken('gg', match1to2, match2);
  addRegexToken('GGGG', match1to4, match4);
  addRegexToken('gggg', match1to4, match4);
  addRegexToken('GGGGG', match1to6, match6);
  addRegexToken('ggggg', match1to6, match6);
  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function(input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
  });
  addWeekParseToken(['gg', 'GG'], function(input, week, config, token) {
    week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
  });
  function getSetWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
  }
  function getSetISOWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
  }
  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }
  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }
  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
      return weekOfYear(this, dow, doy).year;
    } else {
      weeksTarget = weeksInYear(input, dow, doy);
      if (week > weeksTarget) {
        week = weeksTarget;
      }
      return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
  }
  function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
  }
  addFormatToken('Q', 0, 'Qo', 'quarter');
  addUnitAlias('quarter', 'Q');
  addRegexToken('Q', match1);
  addParseToken('Q', function(input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  });
  function getSetQuarter(input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
  }
  addFormatToken('w', ['ww', 2], 'wo', 'week');
  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
  addUnitAlias('week', 'w');
  addUnitAlias('isoWeek', 'W');
  addRegexToken('w', match1to2);
  addRegexToken('ww', match1to2, match2);
  addRegexToken('W', match1to2);
  addRegexToken('WW', match1to2, match2);
  addWeekParseToken(['w', 'ww', 'W', 'WW'], function(input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
  });
  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }
  var defaultLocaleWeek = {
    dow: 0,
    doy: 6
  };
  function localeFirstDayOfWeek() {
    return this._week.dow;
  }
  function localeFirstDayOfYear() {
    return this._week.doy;
  }
  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
  }
  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
  }
  addFormatToken('D', ['DD', 2], 'Do', 'date');
  addUnitAlias('date', 'D');
  addRegexToken('D', match1to2);
  addRegexToken('DD', match1to2, match2);
  addRegexToken('Do', function(isStrict, locale) {
    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
  });
  addParseToken(['D', 'DD'], DATE);
  addParseToken('Do', function(input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
  });
  var getSetDayOfMonth = makeGetSet('Date', true);
  addFormatToken('d', 0, 'do', 'day');
  addFormatToken('dd', 0, 0, function(format) {
    return this.localeData().weekdaysMin(this, format);
  });
  addFormatToken('ddd', 0, 0, function(format) {
    return this.localeData().weekdaysShort(this, format);
  });
  addFormatToken('dddd', 0, 0, function(format) {
    return this.localeData().weekdays(this, format);
  });
  addFormatToken('e', 0, 0, 'weekday');
  addFormatToken('E', 0, 0, 'isoWeekday');
  addUnitAlias('day', 'd');
  addUnitAlias('weekday', 'e');
  addUnitAlias('isoWeekday', 'E');
  addRegexToken('d', match1to2);
  addRegexToken('e', match1to2);
  addRegexToken('E', match1to2);
  addRegexToken('dd', function(isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken('ddd', function(isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken('dddd', function(isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
  });
  addWeekParseToken(['dd', 'ddd', 'dddd'], function(input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken(['d', 'e', 'E'], function(input, week, config, token) {
    week[token] = toInt(input);
  });
  function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
      return input;
    }
    if (!isNaN(input)) {
      return parseInt(input, 10);
    }
    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
      return input;
    }
    return null;
  }
  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
  function localeWeekdays(m, format) {
    return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
  }
  var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
  function localeWeekdaysShort(m) {
    return this._weekdaysShort[m.day()];
  }
  var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
  function localeWeekdaysMin(m) {
    return this._weekdaysMin[m.day()];
  }
  function day_of_week__handleStrictParse(weekdayName, format, strict) {
    var i,
        ii,
        mom,
        llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._minWeekdaysParse = [];
      for (i = 0; i < 7; ++i) {
        mom = create_utc__createUTC([2000, 1]).day(i);
        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeWeekdaysParse(weekdayName, format, strict) {
    var i,
        mom,
        regex;
    if (this._weekdaysParseExact) {
      return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
    }
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._minWeekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._fullWeekdaysParse = [];
    }
    for (i = 0; i < 7; i++) {
      mom = create_utc__createUTC([2000, 1]).day(i);
      if (strict && !this._fullWeekdaysParse[i]) {
        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
      }
      if (!this._weekdaysParse[i]) {
        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
      }
      if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
        return i;
      }
    }
  }
  function getSetDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, 'd');
    } else {
      return day;
    }
  }
  function getSetLocaleDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
  }
  function getSetISODayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
  }
  var defaultWeekdaysRegex = matchWord;
  function weekdaysRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysStrictRegex;
      } else {
        return this._weekdaysRegex;
      }
    } else {
      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
    }
  }
  var defaultWeekdaysShortRegex = matchWord;
  function weekdaysShortRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysShortStrictRegex;
      } else {
        return this._weekdaysShortRegex;
      }
    } else {
      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
  }
  var defaultWeekdaysMinRegex = matchWord;
  function weekdaysMinRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysMinStrictRegex;
      } else {
        return this._weekdaysMinRegex;
      }
    } else {
      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
  }
  function computeWeekdaysParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var minPieces = [],
        shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom,
        minp,
        shortp,
        longp;
    for (i = 0; i < 7; i++) {
      mom = create_utc__createUTC([2000, 1]).day(i);
      minp = this.weekdaysMin(mom, '');
      shortp = this.weekdaysShort(mom, '');
      longp = this.weekdays(mom, '');
      minPieces.push(minp);
      shortPieces.push(shortp);
      longPieces.push(longp);
      mixedPieces.push(minp);
      mixedPieces.push(shortp);
      mixedPieces.push(longp);
    }
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }
    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;
    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
  }
  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
  addUnitAlias('dayOfYear', 'DDD');
  addRegexToken('DDD', match1to3);
  addRegexToken('DDDD', match3);
  addParseToken(['DDD', 'DDDD'], function(input, array, config) {
    config._dayOfYear = toInt(input);
  });
  function getSetDayOfYear(input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
  }
  function hFormat() {
    return this.hours() % 12 || 12;
  }
  function kFormat() {
    return this.hours() || 24;
  }
  addFormatToken('H', ['HH', 2], 0, 'hour');
  addFormatToken('h', ['hh', 2], 0, hFormat);
  addFormatToken('k', ['kk', 2], 0, kFormat);
  addFormatToken('hmm', 0, 0, function() {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });
  addFormatToken('hmmss', 0, 0, function() {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  addFormatToken('Hmm', 0, 0, function() {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
  });
  addFormatToken('Hmmss', 0, 0, function() {
    return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function() {
      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
  }
  meridiem('a', true);
  meridiem('A', false);
  addUnitAlias('hour', 'h');
  function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
  }
  addRegexToken('a', matchMeridiem);
  addRegexToken('A', matchMeridiem);
  addRegexToken('H', match1to2);
  addRegexToken('h', match1to2);
  addRegexToken('HH', match1to2, match2);
  addRegexToken('hh', match1to2, match2);
  addRegexToken('hmm', match3to4);
  addRegexToken('hmmss', match5to6);
  addRegexToken('Hmm', match3to4);
  addRegexToken('Hmmss', match5to6);
  addParseToken(['H', 'HH'], HOUR);
  addParseToken(['a', 'A'], function(input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken(['h', 'hh'], function(input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmm', function(input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmmss', function(input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('Hmm', function(input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken('Hmmss', function(input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
  });
  function localeIsPM(input) {
    return ((input + '').toLowerCase().charAt(0) === 'p');
  }
  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
  function localeMeridiem(hours, minutes, isLower) {
    if (hours > 11) {
      return isLower ? 'pm' : 'PM';
    } else {
      return isLower ? 'am' : 'AM';
    }
  }
  var getSetHour = makeGetSet('Hours', true);
  addFormatToken('m', ['mm', 2], 0, 'minute');
  addUnitAlias('minute', 'm');
  addRegexToken('m', match1to2);
  addRegexToken('mm', match1to2, match2);
  addParseToken(['m', 'mm'], MINUTE);
  var getSetMinute = makeGetSet('Minutes', false);
  addFormatToken('s', ['ss', 2], 0, 'second');
  addUnitAlias('second', 's');
  addRegexToken('s', match1to2);
  addRegexToken('ss', match1to2, match2);
  addParseToken(['s', 'ss'], SECOND);
  var getSetSecond = makeGetSet('Seconds', false);
  addFormatToken('S', 0, 0, function() {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ['SS', 2], 0, function() {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ['SSS', 3], 0, 'millisecond');
  addFormatToken(0, ['SSSS', 4], 0, function() {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ['SSSSS', 5], 0, function() {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ['SSSSSS', 6], 0, function() {
    return this.millisecond() * 1000;
  });
  addFormatToken(0, ['SSSSSSS', 7], 0, function() {
    return this.millisecond() * 10000;
  });
  addFormatToken(0, ['SSSSSSSS', 8], 0, function() {
    return this.millisecond() * 100000;
  });
  addFormatToken(0, ['SSSSSSSSS', 9], 0, function() {
    return this.millisecond() * 1000000;
  });
  addUnitAlias('millisecond', 'ms');
  addRegexToken('S', match1to3, match1);
  addRegexToken('SS', match1to3, match2);
  addRegexToken('SSS', match1to3, match3);
  var token;
  for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
  }
  function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
  }
  for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
  }
  var getSetMillisecond = makeGetSet('Milliseconds', false);
  addFormatToken('z', 0, 0, 'zoneAbbr');
  addFormatToken('zz', 0, 0, 'zoneName');
  function getZoneAbbr() {
    return this._isUTC ? 'UTC' : '';
  }
  function getZoneName() {
    return this._isUTC ? 'Coordinated Universal Time' : '';
  }
  var momentPrototype__proto = Moment.prototype;
  momentPrototype__proto.add = add_subtract__add;
  momentPrototype__proto.calendar = moment_calendar__calendar;
  momentPrototype__proto.clone = clone;
  momentPrototype__proto.diff = diff;
  momentPrototype__proto.endOf = endOf;
  momentPrototype__proto.format = format;
  momentPrototype__proto.from = from;
  momentPrototype__proto.fromNow = fromNow;
  momentPrototype__proto.to = to;
  momentPrototype__proto.toNow = toNow;
  momentPrototype__proto.get = getSet;
  momentPrototype__proto.invalidAt = invalidAt;
  momentPrototype__proto.isAfter = isAfter;
  momentPrototype__proto.isBefore = isBefore;
  momentPrototype__proto.isBetween = isBetween;
  momentPrototype__proto.isSame = isSame;
  momentPrototype__proto.isSameOrAfter = isSameOrAfter;
  momentPrototype__proto.isSameOrBefore = isSameOrBefore;
  momentPrototype__proto.isValid = moment_valid__isValid;
  momentPrototype__proto.lang = lang;
  momentPrototype__proto.locale = locale;
  momentPrototype__proto.localeData = localeData;
  momentPrototype__proto.max = prototypeMax;
  momentPrototype__proto.min = prototypeMin;
  momentPrototype__proto.parsingFlags = parsingFlags;
  momentPrototype__proto.set = getSet;
  momentPrototype__proto.startOf = startOf;
  momentPrototype__proto.subtract = add_subtract__subtract;
  momentPrototype__proto.toArray = toArray;
  momentPrototype__proto.toObject = toObject;
  momentPrototype__proto.toDate = toDate;
  momentPrototype__proto.toISOString = moment_format__toISOString;
  momentPrototype__proto.toJSON = toJSON;
  momentPrototype__proto.toString = toString;
  momentPrototype__proto.unix = unix;
  momentPrototype__proto.valueOf = to_type__valueOf;
  momentPrototype__proto.creationData = creationData;
  momentPrototype__proto.year = getSetYear;
  momentPrototype__proto.isLeapYear = getIsLeapYear;
  momentPrototype__proto.weekYear = getSetWeekYear;
  momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
  momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
  momentPrototype__proto.month = getSetMonth;
  momentPrototype__proto.daysInMonth = getDaysInMonth;
  momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
  momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
  momentPrototype__proto.weeksInYear = getWeeksInYear;
  momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
  momentPrototype__proto.date = getSetDayOfMonth;
  momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
  momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
  momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
  momentPrototype__proto.dayOfYear = getSetDayOfYear;
  momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
  momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
  momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
  momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
  momentPrototype__proto.utcOffset = getSetOffset;
  momentPrototype__proto.utc = setOffsetToUTC;
  momentPrototype__proto.local = setOffsetToLocal;
  momentPrototype__proto.parseZone = setOffsetToParsedOffset;
  momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
  momentPrototype__proto.isDST = isDaylightSavingTime;
  momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
  momentPrototype__proto.isLocal = isLocal;
  momentPrototype__proto.isUtcOffset = isUtcOffset;
  momentPrototype__proto.isUtc = isUtc;
  momentPrototype__proto.isUTC = isUtc;
  momentPrototype__proto.zoneAbbr = getZoneAbbr;
  momentPrototype__proto.zoneName = getZoneName;
  momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
  momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
  momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
  momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);
  var momentPrototype = momentPrototype__proto;
  function moment__createUnix(input) {
    return local__createLocal(input * 1000);
  }
  function moment__createInZone() {
    return local__createLocal.apply(null, arguments).parseZone();
  }
  var defaultCalendar = {
    sameDay: '[Today at] LT',
    nextDay: '[Tomorrow at] LT',
    nextWeek: 'dddd [at] LT',
    lastDay: '[Yesterday at] LT',
    lastWeek: '[Last] dddd [at] LT',
    sameElse: 'L'
  };
  function locale_calendar__calendar(key, mom, now) {
    var output = this._calendar[key];
    return isFunction(output) ? output.call(mom, now) : output;
  }
  var defaultLongDateFormat = {
    LTS: 'h:mm:ss A',
    LT: 'h:mm A',
    L: 'MM/DD/YYYY',
    LL: 'MMMM D, YYYY',
    LLL: 'MMMM D, YYYY h:mm A',
    LLLL: 'dddd, MMMM D, YYYY h:mm A'
  };
  function longDateFormat(key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];
    if (format || !formatUpper) {
      return format;
    }
    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
      return val.slice(1);
    });
    return this._longDateFormat[key];
  }
  var defaultInvalidDate = 'Invalid date';
  function invalidDate() {
    return this._invalidDate;
  }
  var defaultOrdinal = '%d';
  var defaultOrdinalParse = /\d{1,2}/;
  function ordinal(number) {
    return this._ordinal.replace('%d', number);
  }
  function preParsePostFormat(string) {
    return string;
  }
  var defaultRelativeTime = {
    future: 'in %s',
    past: '%s ago',
    s: 'a few seconds',
    m: 'a minute',
    mm: '%d minutes',
    h: 'an hour',
    hh: '%d hours',
    d: 'a day',
    dd: '%d days',
    M: 'a month',
    MM: '%d months',
    y: 'a year',
    yy: '%d years'
  };
  function relative__relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
  }
  function pastFuture(diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
  }
  var prototype__proto = Locale.prototype;
  prototype__proto._calendar = defaultCalendar;
  prototype__proto.calendar = locale_calendar__calendar;
  prototype__proto._longDateFormat = defaultLongDateFormat;
  prototype__proto.longDateFormat = longDateFormat;
  prototype__proto._invalidDate = defaultInvalidDate;
  prototype__proto.invalidDate = invalidDate;
  prototype__proto._ordinal = defaultOrdinal;
  prototype__proto.ordinal = ordinal;
  prototype__proto._ordinalParse = defaultOrdinalParse;
  prototype__proto.preparse = preParsePostFormat;
  prototype__proto.postformat = preParsePostFormat;
  prototype__proto._relativeTime = defaultRelativeTime;
  prototype__proto.relativeTime = relative__relativeTime;
  prototype__proto.pastFuture = pastFuture;
  prototype__proto.set = locale_set__set;
  prototype__proto.months = localeMonths;
  prototype__proto._months = defaultLocaleMonths;
  prototype__proto.monthsShort = localeMonthsShort;
  prototype__proto._monthsShort = defaultLocaleMonthsShort;
  prototype__proto.monthsParse = localeMonthsParse;
  prototype__proto._monthsRegex = defaultMonthsRegex;
  prototype__proto.monthsRegex = monthsRegex;
  prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
  prototype__proto.monthsShortRegex = monthsShortRegex;
  prototype__proto.week = localeWeek;
  prototype__proto._week = defaultLocaleWeek;
  prototype__proto.firstDayOfYear = localeFirstDayOfYear;
  prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
  prototype__proto.weekdays = localeWeekdays;
  prototype__proto._weekdays = defaultLocaleWeekdays;
  prototype__proto.weekdaysMin = localeWeekdaysMin;
  prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
  prototype__proto.weekdaysShort = localeWeekdaysShort;
  prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
  prototype__proto.weekdaysParse = localeWeekdaysParse;
  prototype__proto._weekdaysRegex = defaultWeekdaysRegex;
  prototype__proto.weekdaysRegex = weekdaysRegex;
  prototype__proto._weekdaysShortRegex = defaultWeekdaysShortRegex;
  prototype__proto.weekdaysShortRegex = weekdaysShortRegex;
  prototype__proto._weekdaysMinRegex = defaultWeekdaysMinRegex;
  prototype__proto.weekdaysMinRegex = weekdaysMinRegex;
  prototype__proto.isPM = localeIsPM;
  prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
  prototype__proto.meridiem = localeMeridiem;
  function lists__get(format, index, field, setter) {
    var locale = locale_locales__getLocale();
    var utc = create_utc__createUTC().set(setter, index);
    return locale[field](utc, format);
  }
  function listMonthsImpl(format, index, field) {
    if (typeof format === 'number') {
      index = format;
      format = undefined;
    }
    format = format || '';
    if (index != null) {
      return lists__get(format, index, field, 'month');
    }
    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
      out[i] = lists__get(format, i, field, 'month');
    }
    return out;
  }
  function listWeekdaysImpl(localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
      if (typeof format === 'number') {
        index = format;
        format = undefined;
      }
      format = format || '';
    } else {
      format = localeSorted;
      index = format;
      localeSorted = false;
      if (typeof format === 'number') {
        index = format;
        format = undefined;
      }
      format = format || '';
    }
    var locale = locale_locales__getLocale(),
        shift = localeSorted ? locale._week.dow : 0;
    if (index != null) {
      return lists__get(format, (index + shift) % 7, field, 'day');
    }
    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
      out[i] = lists__get(format, (i + shift) % 7, field, 'day');
    }
    return out;
  }
  function lists__listMonths(format, index) {
    return listMonthsImpl(format, index, 'months');
  }
  function lists__listMonthsShort(format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
  }
  function lists__listWeekdays(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
  }
  function lists__listWeekdaysShort(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
  }
  function lists__listWeekdaysMin(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
  }
  locale_locales__getSetGlobalLocale('en', {
    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function(number) {
      var b = number % 10,
          output = (toInt(number % 100 / 10) === 1) ? 'th' : (b === 1) ? 'st' : (b === 2) ? 'nd' : (b === 3) ? 'rd' : 'th';
      return number + output;
    }
  });
  utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
  utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
  var mathAbs = Math.abs;
  function duration_abs__abs() {
    var data = this._data;
    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);
    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);
    return this;
  }
  function duration_add_subtract__addSubtract(duration, input, value, direction) {
    var other = create__createDuration(input, value);
    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;
    return duration._bubble();
  }
  function duration_add_subtract__add(input, value) {
    return duration_add_subtract__addSubtract(this, input, value, 1);
  }
  function duration_add_subtract__subtract(input, value) {
    return duration_add_subtract__addSubtract(this, input, value, -1);
  }
  function absCeil(number) {
    if (number < 0) {
      return Math.floor(number);
    } else {
      return Math.ceil(number);
    }
  }
  function bubble() {
    var milliseconds = this._milliseconds;
    var days = this._days;
    var months = this._months;
    var data = this._data;
    var seconds,
        minutes,
        hours,
        years,
        monthsFromDays;
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) || (milliseconds <= 0 && days <= 0 && months <= 0))) {
      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
      days = 0;
      months = 0;
    }
    data.milliseconds = milliseconds % 1000;
    seconds = absFloor(milliseconds / 1000);
    data.seconds = seconds % 60;
    minutes = absFloor(seconds / 60);
    data.minutes = minutes % 60;
    hours = absFloor(minutes / 60);
    data.hours = hours % 24;
    days += absFloor(hours / 24);
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));
    years = absFloor(months / 12);
    months %= 12;
    data.days = days;
    data.months = months;
    data.years = years;
    return this;
  }
  function daysToMonths(days) {
    return days * 4800 / 146097;
  }
  function monthsToDays(months) {
    return months * 146097 / 4800;
  }
  function as(units) {
    var days;
    var months;
    var milliseconds = this._milliseconds;
    units = normalizeUnits(units);
    if (units === 'month' || units === 'year') {
      days = this._days + milliseconds / 864e5;
      months = this._months + daysToMonths(days);
      return units === 'month' ? months : months / 12;
    } else {
      days = this._days + Math.round(monthsToDays(this._months));
      switch (units) {
        case 'week':
          return days / 7 + milliseconds / 6048e5;
        case 'day':
          return days + milliseconds / 864e5;
        case 'hour':
          return days * 24 + milliseconds / 36e5;
        case 'minute':
          return days * 1440 + milliseconds / 6e4;
        case 'second':
          return days * 86400 + milliseconds / 1000;
        case 'millisecond':
          return Math.floor(days * 864e5) + milliseconds;
        default:
          throw new Error('Unknown unit ' + units);
      }
    }
  }
  function duration_as__valueOf() {
    return (this._milliseconds + this._days * 864e5 + (this._months % 12) * 2592e6 + toInt(this._months / 12) * 31536e6);
  }
  function makeAs(alias) {
    return function() {
      return this.as(alias);
    };
  }
  var asMilliseconds = makeAs('ms');
  var asSeconds = makeAs('s');
  var asMinutes = makeAs('m');
  var asHours = makeAs('h');
  var asDays = makeAs('d');
  var asWeeks = makeAs('w');
  var asMonths = makeAs('M');
  var asYears = makeAs('y');
  function duration_get__get(units) {
    units = normalizeUnits(units);
    return this[units + 's']();
  }
  function makeGetter(name) {
    return function() {
      return this._data[name];
    };
  }
  var milliseconds = makeGetter('milliseconds');
  var seconds = makeGetter('seconds');
  var minutes = makeGetter('minutes');
  var hours = makeGetter('hours');
  var days = makeGetter('days');
  var months = makeGetter('months');
  var years = makeGetter('years');
  function weeks() {
    return absFloor(this.days() / 7);
  }
  var round = Math.round;
  var thresholds = {
    s: 45,
    m: 45,
    h: 22,
    d: 26,
    M: 11
  };
  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }
  function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
    var duration = create__createDuration(posNegDuration).abs();
    var seconds = round(duration.as('s'));
    var minutes = round(duration.as('m'));
    var hours = round(duration.as('h'));
    var days = round(duration.as('d'));
    var months = round(duration.as('M'));
    var years = round(duration.as('y'));
    var a = seconds < thresholds.s && ['s', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
  }
  function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === undefined) {
      return false;
    }
    if (limit === undefined) {
      return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    return true;
  }
  function humanize(withSuffix) {
    var locale = this.localeData();
    var output = duration_humanize__relativeTime(this, !withSuffix, locale);
    if (withSuffix) {
      output = locale.pastFuture(+this, output);
    }
    return locale.postformat(output);
  }
  var iso_string__abs = Math.abs;
  function iso_string__toISOString() {
    var seconds = iso_string__abs(this._milliseconds) / 1000;
    var days = iso_string__abs(this._days);
    var months = iso_string__abs(this._months);
    var minutes,
        hours,
        years;
    minutes = absFloor(seconds / 60);
    hours = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;
    years = absFloor(months / 12);
    months %= 12;
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();
    if (!total) {
      return 'P0D';
    }
    return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + ((h || m || s) ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
  }
  var duration_prototype__proto = Duration.prototype;
  duration_prototype__proto.abs = duration_abs__abs;
  duration_prototype__proto.add = duration_add_subtract__add;
  duration_prototype__proto.subtract = duration_add_subtract__subtract;
  duration_prototype__proto.as = as;
  duration_prototype__proto.asMilliseconds = asMilliseconds;
  duration_prototype__proto.asSeconds = asSeconds;
  duration_prototype__proto.asMinutes = asMinutes;
  duration_prototype__proto.asHours = asHours;
  duration_prototype__proto.asDays = asDays;
  duration_prototype__proto.asWeeks = asWeeks;
  duration_prototype__proto.asMonths = asMonths;
  duration_prototype__proto.asYears = asYears;
  duration_prototype__proto.valueOf = duration_as__valueOf;
  duration_prototype__proto._bubble = bubble;
  duration_prototype__proto.get = duration_get__get;
  duration_prototype__proto.milliseconds = milliseconds;
  duration_prototype__proto.seconds = seconds;
  duration_prototype__proto.minutes = minutes;
  duration_prototype__proto.hours = hours;
  duration_prototype__proto.days = days;
  duration_prototype__proto.weeks = weeks;
  duration_prototype__proto.months = months;
  duration_prototype__proto.years = years;
  duration_prototype__proto.humanize = humanize;
  duration_prototype__proto.toISOString = iso_string__toISOString;
  duration_prototype__proto.toString = iso_string__toISOString;
  duration_prototype__proto.toJSON = iso_string__toISOString;
  duration_prototype__proto.locale = locale;
  duration_prototype__proto.localeData = localeData;
  duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
  duration_prototype__proto.lang = lang;
  addFormatToken('X', 0, 0, 'unix');
  addFormatToken('x', 0, 0, 'valueOf');
  addRegexToken('x', matchSigned);
  addRegexToken('X', matchTimestamp);
  addParseToken('X', function(input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
  });
  addParseToken('x', function(input, array, config) {
    config._d = new Date(toInt(input));
  });
  utils_hooks__hooks.version = '2.13.0';
  setHookCallback(local__createLocal);
  utils_hooks__hooks.fn = momentPrototype;
  utils_hooks__hooks.min = min;
  utils_hooks__hooks.max = max;
  utils_hooks__hooks.now = now;
  utils_hooks__hooks.utc = create_utc__createUTC;
  utils_hooks__hooks.unix = moment__createUnix;
  utils_hooks__hooks.months = lists__listMonths;
  utils_hooks__hooks.isDate = isDate;
  utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
  utils_hooks__hooks.invalid = valid__createInvalid;
  utils_hooks__hooks.duration = create__createDuration;
  utils_hooks__hooks.isMoment = isMoment;
  utils_hooks__hooks.weekdays = lists__listWeekdays;
  utils_hooks__hooks.parseZone = moment__createInZone;
  utils_hooks__hooks.localeData = locale_locales__getLocale;
  utils_hooks__hooks.isDuration = isDuration;
  utils_hooks__hooks.monthsShort = lists__listMonthsShort;
  utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
  utils_hooks__hooks.defineLocale = defineLocale;
  utils_hooks__hooks.updateLocale = updateLocale;
  utils_hooks__hooks.locales = locale_locales__listLocales;
  utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
  utils_hooks__hooks.normalizeUnits = normalizeUnits;
  utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
  utils_hooks__hooks.prototype = momentPrototype;
  var _moment = utils_hooks__hooks;
  return _moment;
}));

})();
System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/date.js", ["./any", "./errors", "./ref", "hoek", "moment"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Any = $__require('./any');
  var Errors = $__require('./errors');
  var Ref = $__require('./ref');
  var Hoek = $__require('hoek');
  var Moment = $__require('moment');
  var internals = {};
  internals.isoDate = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\d))$/;
  internals.invalidDate = new Date('');
  internals.isIsoDate = (function() {
    var isoString = internals.isoDate.toString();
    return function(date) {
      return date && (date.toString() === isoString);
    };
  })();
  internals.Date = function() {
    Any.call(this);
    this._type = 'date';
  };
  Hoek.inherits(internals.Date, Any);
  internals.Date.prototype._base = function(value, state, options) {
    var result = {value: (options.convert && internals.toDate(value, this._flags.format)) || value};
    if (result.value instanceof Date && !isNaN(result.value.getTime())) {
      result.errors = null;
    } else {
      result.errors = Errors.create(internals.isIsoDate(this._flags.format) ? 'date.isoDate' : 'date.base', null, state, options);
    }
    return result;
  };
  internals.toDate = function(value, format) {
    if (value instanceof Date) {
      return value;
    }
    if (typeof value === 'string' || Hoek.isInteger(value)) {
      if (typeof value === 'string' && /^[+-]?\d+$/.test(value)) {
        value = parseInt(value, 10);
      }
      var date;
      if (format) {
        if (internals.isIsoDate(format)) {
          date = format.test(value) ? new Date(value) : internals.invalidDate;
        } else {
          date = Moment(value, format, true);
          date = date.isValid() ? date.toDate() : internals.invalidDate;
        }
      } else {
        date = new Date(value);
      }
      if (!isNaN(date.getTime())) {
        return date;
      }
    }
    return null;
  };
  internals.compare = function(type, compare) {
    return function(date) {
      var isNow = date === 'now';
      var isRef = Ref.isRef(date);
      if (!isNow && !isRef) {
        date = internals.toDate(date);
      }
      Hoek.assert(date, 'Invalid date format');
      return this._test(type, date, function(value, state, options) {
        var compareTo;
        if (isNow) {
          compareTo = Date.now();
        } else if (isRef) {
          compareTo = internals.toDate(date(state.parent));
          if (!compareTo) {
            return Errors.create('date.ref', {ref: date.key}, state, options);
          }
          compareTo = compareTo.getTime();
        } else {
          compareTo = date.getTime();
        }
        if (compare(value.getTime(), compareTo)) {
          return null;
        }
        return Errors.create('date.' + type, {limit: new Date(compareTo)}, state, options);
      });
    };
  };
  internals.Date.prototype.min = internals.compare('min', function(value, date) {
    return value >= date;
  });
  internals.Date.prototype.max = internals.compare('max', function(value, date) {
    return value <= date;
  });
  internals.Date.prototype.format = function(format) {
    Hoek.assert(typeof format === 'string' || (Array.isArray(format) && format.every(function(f) {
      return typeof f === 'string';
    })), 'Invalid format.');
    var obj = this.clone();
    obj._flags.format = format;
    return obj;
  };
  internals.Date.prototype.iso = function() {
    var obj = this.clone();
    obj._flags.format = internals.isoDate;
    return obj;
  };
  internals.Date.prototype._isIsoDate = function(value) {
    return internals.isoDate.test(value);
  };
  module.exports = new internals.Date();
  return module.exports;
});

System.registerDynamic("github:capaj/hoek-browser@2.12.0/lib/escape.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var internals = {};
  exports.escapeJavaScript = function(input) {
    if (!input) {
      return '';
    }
    var escaped = '';
    for (var i = 0,
        il = input.length; i < il; ++i) {
      var charCode = input.charCodeAt(i);
      if (internals.isSafe(charCode)) {
        escaped += input[i];
      } else {
        escaped += internals.escapeJavaScriptChar(charCode);
      }
    }
    return escaped;
  };
  exports.escapeHtml = function(input) {
    if (!input) {
      return '';
    }
    var escaped = '';
    for (var i = 0,
        il = input.length; i < il; ++i) {
      var charCode = input.charCodeAt(i);
      if (internals.isSafe(charCode)) {
        escaped += input[i];
      } else {
        escaped += internals.escapeHtmlChar(charCode);
      }
    }
    return escaped;
  };
  internals.escapeJavaScriptChar = function(charCode) {
    if (charCode >= 256) {
      return '\\u' + internals.padLeft('' + charCode, 4);
    }
    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '\\x' + internals.padLeft(hexValue, 2);
  };
  internals.escapeHtmlChar = function(charCode) {
    var namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
      return namedEscape;
    }
    if (charCode >= 256) {
      return '&#' + charCode + ';';
    }
    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '&#x' + internals.padLeft(hexValue, 2) + ';';
  };
  internals.padLeft = function(str, len) {
    while (str.length < len) {
      str = '0' + str;
    }
    return str;
  };
  internals.isSafe = function(charCode) {
    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
  };
  internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
  };
  internals.safeCharCodes = (function() {
    var safe = {};
    for (var i = 32; i < 123; ++i) {
      if ((i >= 97) || (i >= 65 && i <= 90) || (i >= 48 && i <= 57) || i === 32 || i === 46 || i === 44 || i === 45 || i === 58 || i === 95) {
        safe[i] = null;
      }
    }
    return safe;
  }());
  return module.exports;
});

System.registerDynamic("github:capaj/hoek-browser@2.12.0/lib/index.js", ["./escape"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Escape = $__require('./escape');
  var internals = {};
  exports.clone = function(obj, seen) {
    if (typeof obj !== 'object' || obj === null) {
      return obj;
    }
    seen = seen || {
      orig: [],
      copy: []
    };
    var lookup = seen.orig.indexOf(obj);
    if (lookup !== -1) {
      return seen.copy[lookup];
    }
    var newObj;
    var cloneDeep = false;
    if (!Array.isArray(obj)) {
      if (obj instanceof Date) {
        newObj = new Date(obj.getTime());
      } else if (obj instanceof RegExp) {
        newObj = new RegExp(obj);
      } else {
        var proto = Object.getPrototypeOf(obj);
        if (!proto || proto.isImmutable) {
          newObj = obj;
        } else {
          newObj = Object.create(proto);
          cloneDeep = true;
        }
      }
    } else {
      newObj = [];
      cloneDeep = true;
    }
    seen.orig.push(obj);
    seen.copy.push(newObj);
    if (cloneDeep) {
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          var descriptor = Object.getOwnPropertyDescriptor(obj, i);
          if (descriptor.get || descriptor.set) {
            Object.defineProperty(newObj, i, descriptor);
          } else {
            newObj[i] = exports.clone(obj[i], seen);
          }
        }
      }
    }
    return newObj;
  };
  exports.merge = function(target, source, isNullOverride, isMergeArrays) {
    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');
    if (!source) {
      return target;
    }
    if (Array.isArray(source)) {
      exports.assert(Array.isArray(target), 'Cannot merge array onto an object');
      if (isMergeArrays === false) {
        target.length = 0;
      }
      for (var i = 0,
          il = source.length; i < il; ++i) {
        target.push(exports.clone(source[i]));
      }
      return target;
    }
    var keys = Object.keys(source);
    for (var k = 0,
        kl = keys.length; k < kl; ++k) {
      var key = keys[k];
      var value = source[key];
      if (value && typeof value === 'object') {
        if (!target[key] || typeof target[key] !== 'object' || (Array.isArray(target[key]) ^ Array.isArray(value)) || value instanceof Date || value instanceof RegExp) {
          target[key] = exports.clone(value);
        } else {
          exports.merge(target[key], value, isNullOverride, isMergeArrays);
        }
      } else {
        if (value !== null && value !== undefined) {
          target[key] = value;
        } else if (isNullOverride !== false) {
          target[key] = value;
        }
      }
    }
    return target;
  };
  exports.applyToDefaults = function(defaults, options) {
    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
    if (!options) {
      return null;
    }
    var copy = exports.clone(defaults);
    if (options === true) {
      return copy;
    }
    return exports.merge(copy, options, false, false);
  };
  exports.cloneWithShallow = function(source, keys) {
    if (!source || typeof source !== 'object') {
      return source;
    }
    var storage = internals.store(source, keys);
    var copy = exports.clone(source);
    internals.restore(copy, source, storage);
    return copy;
  };
  internals.store = function(source, keys) {
    var storage = {};
    for (var i = 0,
        il = keys.length; i < il; ++i) {
      var key = keys[i];
      var value = exports.reach(source, key);
      if (value !== undefined) {
        storage[key] = value;
        internals.reachSet(source, key, undefined);
      }
    }
    return storage;
  };
  internals.restore = function(copy, source, storage) {
    var keys = Object.keys(storage);
    for (var i = 0,
        il = keys.length; i < il; ++i) {
      var key = keys[i];
      internals.reachSet(copy, key, storage[key]);
      internals.reachSet(source, key, storage[key]);
    }
  };
  internals.reachSet = function(obj, key, value) {
    var path = key.split('.');
    var ref = obj;
    for (var i = 0,
        il = path.length; i < il; ++i) {
      var segment = path[i];
      if (i + 1 === il) {
        ref[segment] = value;
      }
      ref = ref[segment];
    }
  };
  exports.applyToDefaultsWithShallow = function(defaults, options, keys) {
    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
    exports.assert(keys && Array.isArray(keys), 'Invalid keys');
    if (!options) {
      return null;
    }
    var copy = exports.cloneWithShallow(defaults, keys);
    if (options === true) {
      return copy;
    }
    var storage = internals.store(options, keys);
    exports.merge(copy, options, false, false);
    internals.restore(copy, options, storage);
    return copy;
  };
  exports.deepEqual = function(obj, ref, seen) {
    var type = typeof obj;
    if (type !== typeof ref) {
      return false;
    }
    if (type !== 'object' || obj === null || ref === null) {
      if (obj === ref) {
        return obj !== 0 || 1 / obj === 1 / ref;
      }
      return obj !== obj && ref !== ref;
    }
    seen = seen || [];
    if (seen.indexOf(obj) !== -1) {
      return true;
    }
    seen.push(obj);
    if (Array.isArray(obj)) {
      if (!Array.isArray(ref)) {
        return false;
      }
      if (obj.length !== ref.length) {
        return false;
      }
      for (var i = 0,
          il = obj.length; i < il; ++i) {
        if (!exports.deepEqual(obj[i], ref[i])) {
          return false;
        }
      }
      return true;
    }
    if (obj instanceof Date) {
      return (ref instanceof Date && obj.getTime() === ref.getTime());
    }
    if (obj instanceof RegExp) {
      return (ref instanceof RegExp && obj.toString() === ref.toString());
    }
    if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
      return false;
    }
    var keys = Object.keys(obj);
    for (var k = 0,
        kl = keys.length; k < kl; ++k) {
      var key = keys[k];
      var descriptor = Object.getOwnPropertyDescriptor(obj, key);
      if (descriptor.get) {
        if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), seen)) {
          return false;
        }
      } else if (!exports.deepEqual(obj[key], ref[key], seen)) {
        return false;
      }
    }
    return true;
  };
  exports.unique = function(array, key) {
    var index = {};
    var result = [];
    for (var i = 0,
        il = array.length; i < il; ++i) {
      var id = (key ? array[i][key] : array[i]);
      if (index[id] !== true) {
        result.push(array[i]);
        index[id] = true;
      }
    }
    return result;
  };
  exports.mapToObject = function(array, key) {
    if (!array) {
      return null;
    }
    var obj = {};
    for (var i = 0,
        il = array.length; i < il; ++i) {
      if (key) {
        if (array[i][key]) {
          obj[array[i][key]] = true;
        }
      } else {
        obj[array[i]] = true;
      }
    }
    return obj;
  };
  exports.intersect = function(array1, array2, justFirst) {
    if (!array1 || !array2) {
      return [];
    }
    var common = [];
    var hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);
    var found = {};
    for (var i = 0,
        il = array2.length; i < il; ++i) {
      if (hash[array2[i]] && !found[array2[i]]) {
        if (justFirst) {
          return array2[i];
        }
        common.push(array2[i]);
        found[array2[i]] = true;
      }
    }
    return (justFirst ? null : common);
  };
  exports.contain = function(ref, values, options) {
    var valuePairs = null;
    if (typeof ref === 'object' && typeof values === 'object' && !Array.isArray(ref) && !Array.isArray(values)) {
      valuePairs = values;
      values = Object.keys(values);
    } else {
      values = [].concat(values);
    }
    options = options || {};
    exports.assert(arguments.length >= 2, 'Insufficient arguments');
    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');
    exports.assert(values.length, 'Values array cannot be empty');
    var compare = options.deep ? exports.deepEqual : function(a, b) {
      return a === b;
    };
    var misses = false;
    var matches = new Array(values.length);
    for (var i = 0,
        il = matches.length; i < il; ++i) {
      matches[i] = 0;
    }
    if (typeof ref === 'string') {
      var pattern = '(';
      for (i = 0, il = values.length; i < il; ++i) {
        var value = values[i];
        exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');
        pattern += (i ? '|' : '') + exports.escapeRegex(value);
      }
      var regex = new RegExp(pattern + ')', 'g');
      var leftovers = ref.replace(regex, function($0, $1) {
        var index = values.indexOf($1);
        ++matches[index];
        return '';
      });
      misses = !!leftovers;
    } else if (Array.isArray(ref)) {
      for (i = 0, il = ref.length; i < il; ++i) {
        for (var j = 0,
            jl = values.length,
            matched = false; j < jl && matched === false; ++j) {
          matched = compare(ref[i], values[j]) && j;
        }
        if (matched !== false) {
          ++matches[matched];
        } else {
          misses = true;
        }
      }
    } else {
      var keys = Object.keys(ref);
      for (i = 0, il = keys.length; i < il; ++i) {
        var key = keys[i];
        var pos = values.indexOf(key);
        if (pos !== -1) {
          if (valuePairs && !compare(ref[key], valuePairs[key])) {
            return false;
          }
          ++matches[pos];
        } else {
          misses = true;
        }
      }
    }
    var result = false;
    for (i = 0, il = matches.length; i < il; ++i) {
      result = result || !!matches[i];
      if ((options.once && matches[i] > 1) || (!options.part && !matches[i])) {
        return false;
      }
    }
    if (options.only && misses) {
      return false;
    }
    return result;
  };
  exports.flatten = function(array, target) {
    var result = target || [];
    for (var i = 0,
        il = array.length; i < il; ++i) {
      if (Array.isArray(array[i])) {
        exports.flatten(array[i], result);
      } else {
        result.push(array[i]);
      }
    }
    return result;
  };
  exports.reach = function(obj, chain, options) {
    options = options || {};
    if (typeof options === 'string') {
      options = {separator: options};
    }
    var path = chain.split(options.separator || '.');
    var ref = obj;
    for (var i = 0,
        il = path.length; i < il; ++i) {
      var key = path[i];
      if (key[0] === '-' && Array.isArray(ref)) {
        key = key.slice(1, key.length);
        key = ref.length - key;
      }
      if (!ref || !ref.hasOwnProperty(key) || (typeof ref !== 'object' && options.functions === false)) {
        exports.assert(!options.strict || i + 1 === il, 'Missing segment', key, 'in reach path ', chain);
        exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
        ref = options.default;
        break;
      }
      ref = ref[key];
    }
    return ref;
  };
  exports.formatStack = function(stack) {
    var trace = [];
    for (var i = 0,
        il = stack.length; i < il; ++i) {
      var item = stack[i];
      trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
    }
    return trace;
  };
  exports.formatTrace = function(trace) {
    var display = [];
    for (var i = 0,
        il = trace.length; i < il; ++i) {
      var row = trace[i];
      display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
    }
    return display;
  };
  exports.callStack = function(slice) {
    var v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function(err, stack) {
      return stack;
    };
    var capture = {};
    Error.captureStackTrace(capture, arguments.callee);
    var stack = capture.stack;
    Error.prepareStackTrace = v8;
    var trace = exports.formatStack(stack);
    if (slice) {
      return trace.slice(slice);
    }
    return trace;
  };
  exports.displayStack = function(slice) {
    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);
    return exports.formatTrace(trace);
  };
  exports.abortThrow = false;
  exports.abort = function(message, hideStack) {
    if ("production" === 'test' || exports.abortThrow === true) {
      throw new Error(message || 'Unknown error');
    }
    var stack = '';
    if (!hideStack) {
      stack = exports.displayStack(1).join('\n\t');
    }
    console.log('ABORT: ' + message + '\n\t' + stack);
    process.exit(1);
  };
  exports.assert = function(condition) {
    if (condition) {
      return;
    }
    if (arguments.length === 2 && arguments[1] instanceof Error) {
      throw arguments[1];
    }
    var msgs = [];
    for (var i = 1,
        il = arguments.length; i < il; ++i) {
      if (arguments[i] !== '') {
        msgs.push(arguments[i]);
      }
    }
    msgs = msgs.map(function(msg) {
      return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);
    });
    throw new Error(msgs.join(' ') || 'Unknown error');
  };
  exports.Timer = function() {
    this.ts = 0;
    this.reset();
  };
  exports.Timer.prototype.reset = function() {
    this.ts = Date.now();
  };
  exports.Timer.prototype.elapsed = function() {
    return Date.now() - this.ts;
  };
  exports.Bench = function() {
    this.ts = 0;
    this.reset();
  };
  exports.Bench.prototype.reset = function() {
    this.ts = exports.Bench.now();
  };
  exports.Bench.prototype.elapsed = function() {
    return exports.Bench.now() - this.ts;
  };
  exports.Bench.now = function() {
    var ts = process.hrtime();
    return (ts[0] * 1e3) + (ts[1] / 1e6);
  };
  exports.escapeRegex = function(string) {
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
  };
  exports.escapeHeaderAttribute = function(attribute) {
    exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');
    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');
  };
  exports.escapeHtml = function(string) {
    return Escape.escapeHtml(string);
  };
  exports.escapeJavaScript = function(string) {
    return Escape.escapeJavaScript(string);
  };
  exports.nextTick = function(callback) {
    return function() {
      var args = arguments;
      process.nextTick(function() {
        callback.apply(null, args);
      });
    };
  };
  exports.once = function(method) {
    if (method._hoekOnce) {
      return method;
    }
    var once = false;
    var wrapped = function() {
      if (!once) {
        once = true;
        method.apply(null, arguments);
      }
    };
    wrapped._hoekOnce = true;
    return wrapped;
  };
  exports.isInteger = function(value) {
    return (typeof value === 'number' && parseFloat(value) === parseInt(value, 10) && !isNaN(value));
  };
  exports.ignore = function() {};
  exports.inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }});
  };
  var formatRegExp = /%[sdj%]/g;
  exports.format = function(f) {
    if (typeof f !== 'string') {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(' ');
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
      if (x === '%%')
        return '%';
      if (i >= len)
        return x;
      switch (x) {
        case '%s':
          return String(args[i++]);
        case '%d':
          return Number(args[i++]);
        case '%j':
          return JSON.stringify(args[i++]);
        default:
          return x;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (x === null || typeof x !== 'object') {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }
    return str;
  };
  exports.transform = function(source, transform, options) {
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source object: must be null, undefined, or an object');
    var result = {};
    var keys = Object.keys(transform);
    for (var k = 0,
        kl = keys.length; k < kl; ++k) {
      var key = keys[k];
      var path = key.split('.');
      var sourcePath = transform[key];
      exports.assert(typeof sourcePath === 'string', 'All mappings must be "." delineated strings');
      var segment;
      var res = result;
      while (path.length > 1) {
        segment = path.shift();
        if (!res[segment]) {
          res[segment] = {};
        }
        res = res[segment];
      }
      segment = path.shift();
      res[segment] = exports.reach(source, sourcePath, options);
    }
    return result;
  };
  exports.stringify = function() {
    try {
      return JSON.stringify.apply(null, arguments);
    } catch (err) {
      return '[Cannot display object: ' + err.message + ']';
    }
  };
  exports.shallow = function(source) {
    var target = {};
    var keys = Object.keys(source);
    for (var i = 0,
        il = keys.length; i < il; ++i) {
      var key = keys[i];
      target[key] = source[key];
    }
    return target;
  };
  return module.exports;
});

System.registerDynamic("github:capaj/hoek-browser@2.12.0.json", [], false, function() {
  return {
    "main": "index"
  };
});

System.registerDynamic("github:capaj/hoek-browser@2.12.0/index.js", ["./lib/index"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./lib/index');
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/language.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var internals = {};
  exports.errors = {
    root: 'value',
    any: {
      unknown: 'is not allowed',
      invalid: 'contains an invalid value',
      empty: 'is not allowed to be empty',
      required: 'is required',
      allowOnly: 'must be one of {{valids}}'
    },
    alternatives: {base: 'not matching any of the allowed alternatives'},
    array: {
      base: 'must be an array',
      includes: 'at position {{pos}} does not match any of the allowed types',
      includesSingle: 'single value of {{!key}} does not match any of the allowed types',
      includesOne: 'at position {{pos}} fails because {{reason}}',
      includesOneSingle: 'single value of {{!key}} fails because {{reason}}',
      excludes: 'at position {{pos}} contains an excluded value',
      excludesSingle: 'single value of {{!key}} contains an excluded value',
      min: 'must contain at least {{limit}} items',
      max: 'must contain less than or equal to {{limit}} items',
      length: 'must contain {{limit}} items',
      sparse: 'must not be a sparse array',
      unique: 'position {{pos}} contains a duplicate value'
    },
    boolean: {base: 'must be a boolean'},
    binary: {
      base: 'must be a buffer or a string',
      min: 'must be at least {{limit}} bytes',
      max: 'must be less than or equal to {{limit}} bytes',
      length: 'must be {{limit}} bytes'
    },
    date: {
      base: 'must be a number of milliseconds or valid date string',
      min: 'must be larger than or equal to {{limit}}',
      max: 'must be less than or equal to {{limit}}',
      isoDate: 'must be a valid ISO 8601 date',
      ref: 'references {{ref}} which is not a date'
    },
    function: {base: 'must be a Function'},
    object: {
      base: 'must be an object',
      min: 'must have at least {{limit}} children',
      max: 'must have less than or equal to {{limit}} children',
      length: 'must have {{limit}} children',
      allowUnknown: 'is not allowed',
      with: 'missing required peer {{peer}}',
      without: 'conflict with forbidden peer {{peer}}',
      missing: 'must contain at least one of {{peers}}',
      xor: 'contains a conflict between exclusive peers {{peers}}',
      or: 'must contain at least one of {{peers}}',
      and: 'contains {{present}} without its required peers {{missing}}',
      nand: '{{main}} must not exist simultaneously with {{peers}}',
      assert: 'validation failed because {{ref}} failed to {{message}}',
      rename: {
        multiple: 'cannot rename child {{from}} because multiple renames are disabled and another key was already renamed to {{to}}',
        override: 'cannot rename child {{from}} because override is disabled and target {{to}} exists'
      },
      type: 'must be an instance of {{type}}'
    },
    number: {
      base: 'must be a number',
      min: 'must be larger than or equal to {{limit}}',
      max: 'must be less than or equal to {{limit}}',
      less: 'must be less than {{limit}}',
      greater: 'must be greater than {{limit}}',
      float: 'must be a float or double',
      integer: 'must be an integer',
      negative: 'must be a negative number',
      positive: 'must be a positive number',
      precision: 'must have no more than {{limit}} decimal places'
    },
    string: {
      base: 'must be a string',
      min: 'length must be at least {{limit}} characters long',
      max: 'length must be less than or equal to {{limit}} characters long',
      length: 'length must be {{limit}} characters long',
      alphanum: 'must only contain alpha-numeric characters',
      token: 'must only contain alpha-numeric and underscore characters',
      regex: {
        base: 'fails to match the required pattern',
        name: 'fails to match the {{name}} pattern'
      },
      email: 'must be a valid email',
      isoDate: 'must be a valid ISO 8601 date',
      guid: 'must be a valid GUID',
      hostname: 'must be a valid hostname',
      lowercase: 'must only contain lowercase characters',
      uppercase: 'must only contain uppercase characters',
      trim: 'must not have leading or trailing whitespace',
      creditCard: 'must be a credit card'
    }
  };
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/errors.js", ["hoek", "./language"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Hoek = $__require('hoek');
  var Language = $__require('./language');
  var internals = {};
  internals.Err = function(type, context, state, options) {
    this.type = type;
    this.context = context || {};
    this.context.key = state.key;
    this.path = state.path;
    this.options = options;
  };
  internals.Err.prototype.toString = function() {
    var self = this;
    var localized = this.options.language;
    this.context.key = localized.label || this.context.key || localized.root || Language.errors.root;
    var format = Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);
    var hasKey = /\{\{\!?key\}\}/.test(format);
    format = (hasKey ? format : '{{!key}} ' + format);
    var message = format.replace(/\{\{(\!?)([^}]+)\}\}/g, function($0, isSecure, name) {
      var value = Hoek.reach(self.context, name);
      var normalized = Array.isArray(value) ? value.join(', ') : value.toString();
      return (isSecure ? Hoek.escapeHtml(normalized) : normalized);
    });
    return message;
  };
  exports.create = function(type, context, state, options) {
    return new internals.Err(type, context, state, options);
  };
  exports.process = function(errors, object) {
    if (!errors || !errors.length) {
      return null;
    }
    var message = '';
    var details = [];
    var processErrors = function(errors, parent) {
      for (var i = 0,
          il = errors.length; i < il; ++i) {
        var item = errors[i];
        var detail = {
          message: item.toString(),
          path: internals.getPath(item),
          type: item.type,
          context: item.context
        };
        if (!parent) {
          message += (message ? '. ' : '') + detail.message;
        }
        if (item.context.reason && item.context.reason.length) {
          processErrors(item.context.reason, item.path);
        } else {
          details.push(detail);
        }
      }
    };
    processErrors(errors);
    var error = new Error(message);
    error.name = 'ValidationError';
    error.details = details;
    error._object = object;
    error.annotate = internals.annotate;
    return error;
  };
  internals.getPath = function(item) {
    var recursePath = function(it) {
      var reachedItem = Hoek.reach(it, 'context.reason.0');
      if (reachedItem && reachedItem.context) {
        return recursePath(reachedItem);
      }
      return it.path;
    };
    return recursePath(item) || item.context.key;
  };
  internals.annotate = function() {
    var obj = Hoek.clone(this._object || {});
    var lookup = {};
    var el = this.details.length;
    for (var e = el - 1; e >= 0; --e) {
      var pos = el - e;
      var error = this.details[e];
      var path = error.path.split('.');
      var ref = obj;
      for (var i = 0,
          il = path.length; i < il && ref; ++i) {
        var seg = path[i];
        if (i + 1 < il) {
          ref = ref[seg];
        } else {
          var value = ref[seg];
          if (value !== undefined) {
            delete ref[seg];
            var label = seg + '_$key$_' + pos + '_$end$_';
            ref[label] = value;
            lookup[error.path] = label;
          } else if (lookup[error.path]) {
            var replacement = lookup[error.path];
            var appended = replacement.replace('_$end$_', ', ' + pos + '_$end$_');
            ref[appended] = ref[replacement];
            lookup[error.path] = appended;
            delete ref[replacement];
          } else {
            ref['_$miss$_' + seg + '|' + pos + '_$end$_'] = '__missing__';
          }
        }
      }
    }
    var annotated = JSON.stringify(obj, null, 2);
    annotated = annotated.replace(/_\$key\$_([, \d]+)_\$end\$_\"/g, function($0, $1) {
      return '" \u001b[31m[' + $1 + ']\u001b[0m';
    });
    var message = annotated.replace(/\"_\$miss\$_([^\|]+)\|(\d+)_\$end\$_\"\: \"__missing__\"/g, function($0, $1, $2) {
      return '\u001b[41m"' + $1 + '"\u001b[0m\u001b[31m [' + $2 + ']: -- missing --\u001b[0m';
    });
    message += '\n\u001b[31m';
    for (e = 0; e < el; ++e) {
      message += '\n[' + (e + 1) + '] ' + this.details[e].message;
    }
    message += '\u001b[0m';
    return message;
  };
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/string.js", ["hoek", "./any", "./date", "./errors"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Hoek = $__require('hoek');
  var Any = $__require('./any');
  var JoiDate = $__require('./date');
  var Errors = $__require('./errors');
  var internals = {};
  internals.String = function() {
    Any.call(this);
    this._type = 'string';
    this._invalids.add('');
  };
  Hoek.inherits(internals.String, Any);
  internals.String.prototype._base = function(value, state, options) {
    if (typeof value === 'string' && options.convert) {
      if (this._flags.case) {
        value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());
      }
      if (this._flags.trim) {
        value = value.trim();
      }
    }
    return {
      value: value,
      errors: (typeof value === 'string') ? null : Errors.create('string.base', null, state, options)
    };
  };
  internals.String.prototype.insensitive = function() {
    var obj = this.clone();
    obj._flags.insensitive = true;
    return obj;
  };
  internals.String.prototype.min = function(limit) {
    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    return this._test('min', limit, function(value, state, options) {
      var length = value.length;
      if (length >= limit) {
        return null;
      }
      return Errors.create('string.min', {limit: limit}, state, options);
    });
  };
  internals.String.prototype.max = function(limit) {
    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    return this._test('max', limit, function(value, state, options) {
      var length = value.length;
      if (length <= limit) {
        return null;
      }
      return Errors.create('string.max', {limit: limit}, state, options);
    });
  };
  internals.String.prototype.creditCard = function() {
    return this._test('creditCard', undefined, function(value, state, options) {
      var i = value.length;
      var sum = 0;
      var mul = 1;
      var char;
      while (i--) {
        char = value.charAt(i) * mul;
        sum += char - (char > 9) * 9;
        mul ^= 3;
      }
      var check = (sum % 10 === 0) && (sum > 0);
      return check ? null : Errors.create('string.creditCard', null, state, options);
    });
  };
  internals.String.prototype.length = function(limit) {
    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    return this._test('length', limit, function(value, state, options) {
      var length = value.length;
      if (length === limit) {
        return null;
      }
      return Errors.create('string.length', {limit: limit}, state, options);
    });
  };
  internals.String.prototype.regex = function(pattern, name) {
    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
    pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);
    return this._test('regex', pattern, function(value, state, options) {
      if (pattern.test(value)) {
        return null;
      }
      return Errors.create((name ? 'string.regex.name' : 'string.regex.base'), {name: name}, state, options);
    });
  };
  internals.String.prototype.alphanum = function() {
    return this._test('alphanum', undefined, function(value, state, options) {
      if (/^[a-zA-Z0-9]+$/.test(value)) {
        return null;
      }
      return Errors.create('string.alphanum', null, state, options);
    });
  };
  internals.String.prototype.token = function() {
    return this._test('token', undefined, function(value, state, options) {
      if (/^\w+$/.test(value)) {
        return null;
      }
      return Errors.create('string.token', null, state, options);
    });
  };
  var isEmailRegex = /(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/;
  var isEmail = function(email) {
    return isEmailRegex.test(email);
  };
  internals.String.prototype.email = function() {
    return this._test('email', undefined, function(value, state, options) {
      if (isEmail(value)) {
        return null;
      }
      return Errors.create('string.email', null, state, options);
    });
  };
  internals.String.prototype.isoDate = function() {
    return this._test('isoDate', undefined, function(value, state, options) {
      if (JoiDate._isIsoDate(value)) {
        return null;
      }
      return Errors.create('string.isoDate', null, state, options);
    });
  };
  internals.String.prototype.guid = function() {
    var regex = /^[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}$/i;
    var regex2 = /^\{[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}\}$/i;
    return this._test('guid', undefined, function(value, state, options) {
      if (regex.test(value) || regex2.test(value)) {
        return null;
      }
      return Errors.create('string.guid', null, state, options);
    });
  };
  var ipV6reg = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
  var isIPv6 = function(adress) {
    return ipV6reg.test(adress);
  };
  internals.String.prototype.hostname = function() {
    var regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;
    return this._test('hostname', undefined, function(value, state, options) {
      if ((value.length <= 255 && regex.test(value)) || isIPv6(value)) {
        return null;
      }
      return Errors.create("string.hostname", null, state, options);
    });
  };
  internals.String.prototype.lowercase = function() {
    var obj = this._test('lowercase', undefined, function(value, state, options) {
      if (options.convert || value === value.toLocaleLowerCase()) {
        return null;
      }
      return Errors.create('string.lowercase', null, state, options);
    });
    obj._flags.case = 'lower';
    return obj;
  };
  internals.String.prototype.uppercase = function(options) {
    var obj = this._test('uppercase', undefined, function(value, state, options) {
      if (options.convert || value === value.toLocaleUpperCase()) {
        return null;
      }
      return Errors.create('string.uppercase', null, state, options);
    });
    obj._flags.case = 'upper';
    return obj;
  };
  internals.String.prototype.trim = function() {
    var obj = this._test('trim', undefined, function(value, state, options) {
      if (options.convert || value === value.trim()) {
        return null;
      }
      return Errors.create('string.trim', null, state, options);
    });
    obj._flags.trim = true;
    return obj;
  };
  module.exports = new internals.String();
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/lib/index.js", ["./any", "./cast", "./ref", "./alternatives", "./array", "./boolean", "./binary", "./date", "./function", "./number", "./object", "./string"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Any = $__require('./any');
  var Cast = $__require('./cast');
  var Ref = $__require('./ref');
  var internals = {
    alternatives: $__require('./alternatives'),
    array: $__require('./array'),
    boolean: $__require('./boolean'),
    binary: $__require('./binary'),
    date: $__require('./date'),
    func: $__require('./function'),
    number: $__require('./number'),
    object: $__require('./object'),
    string: $__require('./string')
  };
  internals.root = function() {
    var any = new Any();
    var root = any.clone();
    root.any = function() {
      return any;
    };
    root.alternatives = root.alt = function() {
      return arguments.length ? internals.alternatives.try.apply(internals.alternatives, arguments) : internals.alternatives;
    };
    root.array = function() {
      return internals.array;
    };
    root.boolean = root.bool = function() {
      return internals.boolean;
    };
    root.binary = function() {
      return internals.binary;
    };
    root.date = function() {
      return internals.date;
    };
    root.func = function() {
      return internals.func;
    };
    root.number = function() {
      return internals.number;
    };
    root.object = function() {
      return arguments.length ? internals.object.keys.apply(internals.object, arguments) : internals.object;
    };
    root.string = function() {
      return internals.string;
    };
    root.ref = function() {
      return Ref.create.apply(null, arguments);
    };
    root.isRef = function(ref) {
      return Ref.isRef(ref);
    };
    root.validate = function(value) {
      var last = arguments[arguments.length - 1];
      var callback = typeof last === 'function' ? last : null;
      var count = arguments.length - (callback ? 1 : 0);
      if (count === 1) {
        return any.validate(value, callback);
      }
      var options = count === 3 ? arguments[2] : {};
      var schema = Cast.schema(arguments[1]);
      return schema._validateWithOptions(value, options, callback);
    };
    root.describe = function() {
      var schema = arguments.length ? Cast.schema(arguments[0]) : any;
      return schema.describe();
    };
    root.compile = function(schema) {
      return Cast.schema(schema);
    };
    root.assert = function(value, schema, message) {
      message = (message ? message + ' ' : '');
      var error = root.validate(value, schema).error;
      if (error) {
        throw new Error(message + error.annotate());
      }
    };
    return root;
  };
  module.exports = internals.root();
  return module.exports;
});

System.registerDynamic("github:capaj/joi-browser@5.2.0.json", [], false, function() {
  return {
    "main": "index"
  };
});

System.registerDynamic("github:capaj/joi-browser@5.2.0/index.js", ["./lib/index"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./lib/index');
  return module.exports;
});

System.registerDynamic("npm:ms@0.7.1.json", [], false, function() {
  return {
    "main": "./index",
    "format": "cjs"
  };
});

System.registerDynamic("npm:ms@0.7.1/index.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    if ('string' == typeof val)
      return parse(val);
    return options.long ? long(val) : short(val);
  };
  function parse(str) {
    str = '' + str;
    if (str.length > 10000)
      return;
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match)
      return;
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
    }
  }
  function short(ms) {
    if (ms >= d)
      return Math.round(ms / d) + 'd';
    if (ms >= h)
      return Math.round(ms / h) + 'h';
    if (ms >= m)
      return Math.round(ms / m) + 'm';
    if (ms >= s)
      return Math.round(ms / s) + 's';
    return ms + 'ms';
  }
  function long(ms) {
    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
  }
  function plural(ms, n, name) {
    if (ms < n)
      return;
    if (ms < n * 1.5)
      return Math.floor(ms / n) + ' ' + name;
    return Math.ceil(ms / n) + ' ' + name + 's';
  }
  return module.exports;
});

System.registerDynamic("npm:debug@2.2.0/debug.js", ["ms"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  exports = module.exports = debug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = $__require('ms');
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevColor = 0;
  var prevTime;
  function selectColor() {
    return exports.colors[prevColor++ % exports.colors.length];
  }
  function debug(namespace) {
    function disabled() {}
    disabled.enabled = false;
    function enabled() {
      var self = enabled;
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      if (null == self.useColors)
        self.useColors = exports.useColors();
      if (null == self.color && self.useColors)
        self.color = selectColor();
      var args = Array.prototype.slice.call(arguments);
      args[0] = exports.coerce(args[0]);
      if ('string' !== typeof args[0]) {
        args = ['%o'].concat(args);
      }
      var index = 0;
      args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
        if (match === '%%')
          return match;
        index++;
        var formatter = exports.formatters[format];
        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      if ('function' === typeof exports.formatArgs) {
        args = exports.formatArgs.apply(self, args);
      }
      var logFn = enabled.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    enabled.enabled = true;
    var fn = exports.enabled(namespace) ? enabled : disabled;
    fn.namespace = namespace;
    return fn;
  }
  function enable(namespaces) {
    exports.save(namespaces);
    var split = (namespaces || '').split(/[\s,]+/);
    var len = split.length;
    for (var i = 0; i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  function disable() {
    exports.enable('');
  }
  function enabled(name) {
    var i,
        len;
    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
  return module.exports;
});

System.registerDynamic("npm:debug@2.2.0.json", [], false, function() {
  return {
    "main": "browser.js",
    "format": "cjs"
  };
});

System.registerDynamic("npm:debug@2.2.0/browser.js", ["./debug"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  exports = module.exports = $__require('./debug');
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
  exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
  function useColors() {
    return ('WebkitAppearance' in document.documentElement.style) || (window.console && (console.firebug || (console.exception && console.table))) || (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
  }
  exports.formatters.j = function(v) {
    return JSON.stringify(v);
  };
  function formatArgs() {
    var args = arguments;
    var useColors = this.useColors;
    args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
    if (!useColors)
      return args;
    var c = 'color: ' + this.color;
    args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-z%]/g, function(match) {
      if ('%%' === match)
        return;
      index++;
      if ('%c' === match) {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
    return args;
  }
  function log() {
    return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}
    return r;
  }
  exports.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/line/LineSeries.js", ["../helper/createListFromArray", "../../model/Series", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var createListFromArray = $__require('../helper/createListFromArray');
  var SeriesModel = $__require('../../model/Series');
  module.exports = SeriesModel.extend({
    type: 'series.line',
    dependencies: ['grid', 'polar'],
    getInitialData: function(option, ecModel) {
      if (__DEV__) {
        var coordSys = option.coordinateSystem;
        if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {
          throw new Error('Line not support coordinateSystem besides cartesian and polar');
        }
      }
      return createListFromArray(option.data, this, ecModel);
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: true,
      hoverAnimation: true,
      xAxisIndex: 0,
      yAxisIndex: 0,
      polarIndex: 0,
      clipOverflow: true,
      label: {normal: {position: 'top'}},
      lineStyle: {normal: {
          width: 2,
          type: 'solid'
        }},
      step: false,
      smooth: false,
      smoothMonotone: null,
      symbol: 'emptyCircle',
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: true,
      showAllSymbol: false,
      connectNulls: false,
      sampling: 'none',
      animationEasing: 'linear',
      progressive: 0,
      hoverLayerThreshold: Infinity
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/line/lineAnimationDiff.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function sign(val) {
    return val >= 0 ? 1 : -1;
  }
  function getStackedOnPoint(coordSys, data, idx) {
    var baseAxis = coordSys.getBaseAxis();
    var valueAxis = coordSys.getOtherAxis(baseAxis);
    var valueStart = baseAxis.onZero ? 0 : valueAxis.scale.getExtent()[0];
    var valueDim = valueAxis.dim;
    var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;
    var stackedOnSameSign;
    var stackedOn = data.stackedOn;
    var val = data.get(valueDim, idx);
    while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {
      stackedOnSameSign = stackedOn;
      break;
    }
    var stackedData = [];
    stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);
    stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;
    return coordSys.dataToPoint(stackedData);
  }
  function diffData(oldData, newData) {
    var diffResult = [];
    newData.diff(oldData).add(function(idx) {
      diffResult.push({
        cmd: '+',
        idx: idx
      });
    }).update(function(newIdx, oldIdx) {
      diffResult.push({
        cmd: '=',
        idx: oldIdx,
        idx1: newIdx
      });
    }).remove(function(idx) {
      diffResult.push({
        cmd: '-',
        idx: idx
      });
    }).execute();
    return diffResult;
  }
  module.exports = function(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys) {
    var diff = diffData(oldData, newData);
    var currPoints = [];
    var nextPoints = [];
    var currStackedPoints = [];
    var nextStackedPoints = [];
    var status = [];
    var sortedIndices = [];
    var rawIndices = [];
    var dims = newCoordSys.dimensions;
    for (var i = 0; i < diff.length; i++) {
      var diffItem = diff[i];
      var pointAdded = true;
      switch (diffItem.cmd) {
        case '=':
          var currentPt = oldData.getItemLayout(diffItem.idx);
          var nextPt = newData.getItemLayout(diffItem.idx1);
          if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {
            currentPt = nextPt.slice();
          }
          currPoints.push(currentPt);
          nextPoints.push(nextPt);
          currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);
          nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);
          rawIndices.push(newData.getRawIndex(diffItem.idx1));
          break;
        case '+':
          var idx = diffItem.idx;
          currPoints.push(oldCoordSys.dataToPoint([newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)]));
          nextPoints.push(newData.getItemLayout(idx).slice());
          currStackedPoints.push(getStackedOnPoint(oldCoordSys, newData, idx));
          nextStackedPoints.push(newStackedOnPoints[idx]);
          rawIndices.push(newData.getRawIndex(idx));
          break;
        case '-':
          var idx = diffItem.idx;
          var rawIndex = oldData.getRawIndex(idx);
          if (rawIndex !== idx) {
            currPoints.push(oldData.getItemLayout(idx));
            nextPoints.push(newCoordSys.dataToPoint([oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)]));
            currStackedPoints.push(oldStackedOnPoints[idx]);
            nextStackedPoints.push(getStackedOnPoint(newCoordSys, oldData, idx));
            rawIndices.push(rawIndex);
          } else {
            pointAdded = false;
          }
      }
      if (pointAdded) {
        status.push(diffItem);
        sortedIndices.push(sortedIndices.length);
      }
    }
    sortedIndices.sort(function(a, b) {
      return rawIndices[a] - rawIndices[b];
    });
    var sortedCurrPoints = [];
    var sortedNextPoints = [];
    var sortedCurrStackedPoints = [];
    var sortedNextStackedPoints = [];
    var sortedStatus = [];
    for (var i = 0; i < sortedIndices.length; i++) {
      var idx = sortedIndices[i];
      sortedCurrPoints[i] = currPoints[idx];
      sortedNextPoints[i] = nextPoints[idx];
      sortedCurrStackedPoints[i] = currStackedPoints[idx];
      sortedNextStackedPoints[i] = nextStackedPoints[idx];
      sortedStatus[i] = status[idx];
    }
    return {
      current: sortedCurrPoints,
      next: sortedNextPoints,
      stackedOnCurrent: sortedCurrStackedPoints,
      stackedOnNext: sortedNextStackedPoints,
      status: sortedStatus
    };
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/line/poly.js", ["zrender/lib/graphic/Path", "zrender/lib/core/vector", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var Path = $__require('zrender/lib/graphic/Path');
  var vec2 = $__require('zrender/lib/core/vector');
  var vec2Min = vec2.min;
  var vec2Max = vec2.max;
  var scaleAndAdd = vec2.scaleAndAdd;
  var v2Copy = vec2.copy;
  var v = [];
  var cp0 = [];
  var cp1 = [];
  function isPointNull(p) {
    return isNaN(p[0]) || isNaN(p[1]);
  }
  function drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
    var prevIdx = 0;
    var idx = start;
    for (var k = 0; k < segLen; k++) {
      var p = points[idx];
      if (idx >= allLen || idx < 0) {
        break;
      }
      if (isPointNull(p)) {
        if (connectNulls) {
          idx += dir;
          continue;
        }
        break;
      }
      if (idx === start) {
        ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
        v2Copy(cp0, p);
      } else {
        if (smooth > 0) {
          var nextIdx = idx + dir;
          var nextP = points[nextIdx];
          if (connectNulls) {
            while (nextP && isPointNull(points[nextIdx])) {
              nextIdx += dir;
              nextP = points[nextIdx];
            }
          }
          var ratioNextSeg = 0.5;
          var prevP = points[prevIdx];
          var nextP = points[nextIdx];
          if (!nextP || isPointNull(nextP)) {
            v2Copy(cp1, p);
          } else {
            if (isPointNull(nextP) && !connectNulls) {
              nextP = p;
            }
            vec2.sub(v, nextP, prevP);
            var lenPrevSeg;
            var lenNextSeg;
            if (smoothMonotone === 'x' || smoothMonotone === 'y') {
              var dim = smoothMonotone === 'x' ? 0 : 1;
              lenPrevSeg = Math.abs(p[dim] - prevP[dim]);
              lenNextSeg = Math.abs(p[dim] - nextP[dim]);
            } else {
              lenPrevSeg = vec2.dist(p, prevP);
              lenNextSeg = vec2.dist(p, nextP);
            }
            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
            scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));
          }
          vec2Min(cp0, cp0, smoothMax);
          vec2Max(cp0, cp0, smoothMin);
          vec2Min(cp1, cp1, smoothMax);
          vec2Max(cp1, cp1, smoothMin);
          ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);
          scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);
        } else {
          ctx.lineTo(p[0], p[1]);
        }
      }
      prevIdx = idx;
      idx += dir;
    }
    return k;
  }
  function getBoundingBox(points, smoothConstraint) {
    var ptMin = [Infinity, Infinity];
    var ptMax = [-Infinity, -Infinity];
    if (smoothConstraint) {
      for (var i = 0; i < points.length; i++) {
        var pt = points[i];
        if (pt[0] < ptMin[0]) {
          ptMin[0] = pt[0];
        }
        if (pt[1] < ptMin[1]) {
          ptMin[1] = pt[1];
        }
        if (pt[0] > ptMax[0]) {
          ptMax[0] = pt[0];
        }
        if (pt[1] > ptMax[1]) {
          ptMax[1] = pt[1];
        }
      }
    }
    return {
      min: smoothConstraint ? ptMin : ptMax,
      max: smoothConstraint ? ptMax : ptMin
    };
  }
  module.exports = {
    Polyline: Path.extend({
      type: 'ec-polyline',
      shape: {
        points: [],
        smooth: 0,
        smoothConstraint: true,
        smoothMonotone: null,
        connectNulls: false
      },
      style: {
        fill: null,
        stroke: '#000'
      },
      buildPath: function(ctx, shape) {
        var points = shape.points;
        var i = 0;
        var len = points.length;
        var result = getBoundingBox(points, shape.smoothConstraint);
        if (shape.connectNulls) {
          for (; len > 0; len--) {
            if (!isPointNull(points[len - 1])) {
              break;
            }
          }
          for (; i < len; i++) {
            if (!isPointNull(points[i])) {
              break;
            }
          }
        }
        while (i < len) {
          i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
        }
      }
    }),
    Polygon: Path.extend({
      type: 'ec-polygon',
      shape: {
        points: [],
        stackedOnPoints: [],
        smooth: 0,
        stackedOnSmooth: 0,
        smoothConstraint: true,
        smoothMonotone: null,
        connectNulls: false
      },
      buildPath: function(ctx, shape) {
        var points = shape.points;
        var stackedOnPoints = shape.stackedOnPoints;
        var i = 0;
        var len = points.length;
        var smoothMonotone = shape.smoothMonotone;
        var bbox = getBoundingBox(points, shape.smoothConstraint);
        var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);
        if (shape.connectNulls) {
          for (; len > 0; len--) {
            if (!isPointNull(points[len - 1])) {
              break;
            }
          }
          for (; i < len; i++) {
            if (!isPointNull(points[i])) {
              break;
            }
          }
        }
        while (i < len) {
          var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);
          drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
          i += k + 1;
          ctx.closePath();
        }
      }
    })
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/line/LineView.js", ["zrender/lib/core/util", "../helper/SymbolDraw", "../helper/Symbol", "./lineAnimationDiff", "../../util/graphic", "./poly", "../../view/Chart", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var SymbolDraw = $__require('../helper/SymbolDraw');
  var Symbol = $__require('../helper/Symbol');
  var lineAnimationDiff = $__require('./lineAnimationDiff');
  var graphic = $__require('../../util/graphic');
  var polyHelper = $__require('./poly');
  var ChartView = $__require('../../view/Chart');
  function isPointsSame(points1, points2) {
    if (points1.length !== points2.length) {
      return;
    }
    for (var i = 0; i < points1.length; i++) {
      var p1 = points1[i];
      var p2 = points2[i];
      if (p1[0] !== p2[0] || p1[1] !== p2[1]) {
        return;
      }
    }
    return true;
  }
  function getSmooth(smooth) {
    return typeof(smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);
  }
  function getAxisExtentWithGap(axis) {
    var extent = axis.getGlobalExtent();
    if (axis.onBand) {
      var halfBandWidth = axis.getBandWidth() / 2 - 1;
      var dir = extent[1] > extent[0] ? 1 : -1;
      extent[0] += dir * halfBandWidth;
      extent[1] -= dir * halfBandWidth;
    }
    return extent;
  }
  function sign(val) {
    return val >= 0 ? 1 : -1;
  }
  function getStackedOnPoints(coordSys, data) {
    var baseAxis = coordSys.getBaseAxis();
    var valueAxis = coordSys.getOtherAxis(baseAxis);
    var valueStart = baseAxis.onZero ? 0 : valueAxis.scale.getExtent()[0];
    var valueDim = valueAxis.dim;
    var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;
    return data.mapArray([valueDim], function(val, idx) {
      var stackedOnSameSign;
      var stackedOn = data.stackedOn;
      while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {
        stackedOnSameSign = stackedOn;
        break;
      }
      var stackedData = [];
      stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);
      stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;
      return coordSys.dataToPoint(stackedData);
    }, true);
  }
  function queryDataIndex(data, payload) {
    if (payload.dataIndex != null) {
      return payload.dataIndex;
    } else if (payload.name != null) {
      return data.indexOfName(payload.name);
    }
  }
  function createGridClipShape(cartesian, hasAnimation, seriesModel) {
    var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));
    var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));
    var isHorizontal = cartesian.getBaseAxis().isHorizontal();
    var x = Math.min(xExtent[0], xExtent[1]);
    var y = Math.min(yExtent[0], yExtent[1]);
    var width = Math.max(xExtent[0], xExtent[1]) - x;
    var height = Math.max(yExtent[0], yExtent[1]) - y;
    var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;
    var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);
    if (isHorizontal) {
      y -= expandSize;
      height += expandSize * 2;
    } else {
      x -= expandSize;
      width += expandSize * 2;
    }
    var clipPath = new graphic.Rect({shape: {
        x: x,
        y: y,
        width: width,
        height: height
      }});
    if (hasAnimation) {
      clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;
      graphic.initProps(clipPath, {shape: {
          width: width,
          height: height
        }}, seriesModel);
    }
    return clipPath;
  }
  function createPolarClipShape(polar, hasAnimation, seriesModel) {
    var angleAxis = polar.getAngleAxis();
    var radiusAxis = polar.getRadiusAxis();
    var radiusExtent = radiusAxis.getExtent();
    var angleExtent = angleAxis.getExtent();
    var RADIAN = Math.PI / 180;
    var clipPath = new graphic.Sector({shape: {
        cx: polar.cx,
        cy: polar.cy,
        r0: radiusExtent[0],
        r: radiusExtent[1],
        startAngle: -angleExtent[0] * RADIAN,
        endAngle: -angleExtent[1] * RADIAN,
        clockwise: angleAxis.inverse
      }});
    if (hasAnimation) {
      clipPath.shape.endAngle = -angleExtent[0] * RADIAN;
      graphic.initProps(clipPath, {shape: {endAngle: -angleExtent[1] * RADIAN}}, seriesModel);
    }
    return clipPath;
  }
  function createClipShape(coordSys, hasAnimation, seriesModel) {
    return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);
  }
  function turnPointsIntoStep(points, coordSys, stepTurnAt) {
    var baseAxis = coordSys.getBaseAxis();
    var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;
    var stepPoints = [];
    for (var i = 0; i < points.length - 1; i++) {
      var nextPt = points[i + 1];
      var pt = points[i];
      stepPoints.push(pt);
      var stepPt = [];
      switch (stepTurnAt) {
        case 'end':
          stepPt[baseIndex] = nextPt[baseIndex];
          stepPt[1 - baseIndex] = pt[1 - baseIndex];
          stepPoints.push(stepPt);
          break;
        case 'middle':
          var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
          var stepPt2 = [];
          stepPt[baseIndex] = stepPt2[baseIndex] = middle;
          stepPt[1 - baseIndex] = pt[1 - baseIndex];
          stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
          stepPoints.push(stepPt);
          stepPoints.push(stepPt2);
          break;
        default:
          stepPt[baseIndex] = pt[baseIndex];
          stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
          stepPoints.push(stepPt);
      }
    }
    points[i] && stepPoints.push(points[i]);
    return stepPoints;
  }
  function clamp(number, extent) {
    return Math.max(Math.min(number, extent[1]), extent[0]);
  }
  function getVisualGradient(data, coordSys) {
    var visualMetaList = data.getVisual('visualMeta');
    if (!visualMetaList || !visualMetaList.length) {
      return;
    }
    var visualMeta;
    for (var i = visualMetaList.length - 1; i >= 0; i--) {
      if (visualMetaList[i].dimension < 2) {
        visualMeta = visualMetaList[i];
        break;
      }
    }
    if (!visualMeta || coordSys.type !== 'cartesian2d') {
      if (__DEV__) {
        console.warn('Visual map on line style only support x or y dimension.');
      }
      return;
    }
    var dimension = visualMeta.dimension;
    var dimName = data.dimensions[dimension];
    var dataExtent = data.getDataExtent(dimName);
    var stops = visualMeta.stops;
    var colorStops = [];
    if (stops[0].interval) {
      stops.sort(function(a, b) {
        return a.interval[0] - b.interval[0];
      });
    }
    var firstStop = stops[0];
    var lastStop = stops[stops.length - 1];
    var min = firstStop.interval ? clamp(firstStop.interval[0], dataExtent) : firstStop.value;
    var max = lastStop.interval ? clamp(lastStop.interval[1], dataExtent) : lastStop.value;
    var stopsSpan = max - min;
    if (stopsSpan === 0) {
      return data.getItemVisual(0, 'color');
    }
    for (var i = 0; i < stops.length; i++) {
      if (stops[i].interval) {
        if (stops[i].interval[1] === stops[i].interval[0]) {
          continue;
        }
        colorStops.push({
          offset: (clamp(stops[i].interval[0], dataExtent) - min) / stopsSpan,
          color: stops[i].color
        }, {
          offset: (clamp(stops[i].interval[1], dataExtent) - min) / stopsSpan,
          color: stops[i].color
        });
      } else {
        colorStops.push({
          offset: (stops[i].value - min) / stopsSpan,
          color: stops[i].color
        });
      }
    }
    var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);
    var axis = coordSys.getAxis(dimName);
    var start = Math.round(axis.toGlobalCoord(axis.dataToCoord(min)));
    var end = Math.round(axis.toGlobalCoord(axis.dataToCoord(max)));
    gradient[dimName] = start;
    gradient[dimName + '2'] = end;
    return gradient;
  }
  module.exports = ChartView.extend({
    type: 'line',
    init: function() {
      var lineGroup = new graphic.Group();
      var symbolDraw = new SymbolDraw();
      this.group.add(symbolDraw.group);
      this._symbolDraw = symbolDraw;
      this._lineGroup = lineGroup;
    },
    render: function(seriesModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var group = this.group;
      var data = seriesModel.getData();
      var lineStyleModel = seriesModel.getModel('lineStyle.normal');
      var areaStyleModel = seriesModel.getModel('areaStyle.normal');
      var points = data.mapArray(data.getItemLayout, true);
      var isCoordSysPolar = coordSys.type === 'polar';
      var prevCoordSys = this._coordSys;
      var symbolDraw = this._symbolDraw;
      var polyline = this._polyline;
      var polygon = this._polygon;
      var lineGroup = this._lineGroup;
      var hasAnimation = seriesModel.get('animation');
      var isAreaChart = !areaStyleModel.isEmpty();
      var stackedOnPoints = getStackedOnPoints(coordSys, data);
      var showSymbol = seriesModel.get('showSymbol');
      var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys);
      var oldData = this._data;
      oldData && oldData.eachItemGraphicEl(function(el, idx) {
        if (el.__temp) {
          group.remove(el);
          oldData.setItemGraphicEl(idx, null);
        }
      });
      if (!showSymbol) {
        symbolDraw.remove();
      }
      group.add(lineGroup);
      var step = !isCoordSysPolar && seriesModel.get('step');
      if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
        showSymbol && symbolDraw.updateData(data, isSymbolIgnore);
        if (step) {
          points = turnPointsIntoStep(points, coordSys, step);
          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
        }
        polyline = this._newPolyline(points, coordSys, hasAnimation);
        if (isAreaChart) {
          polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
        }
        lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));
      } else {
        if (isAreaChart && !polygon) {
          polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
        } else if (polygon && !isAreaChart) {
          lineGroup.remove(polygon);
          polygon = this._polygon = null;
        }
        lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));
        showSymbol && symbolDraw.updateData(data, isSymbolIgnore);
        data.eachItemGraphicEl(function(el) {
          el.stopAnimation(true);
        });
        if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
          if (hasAnimation) {
            this._updateAnimation(data, stackedOnPoints, coordSys, api, step);
          } else {
            polyline.setShape({points: points});
            polygon && polygon.setShape({
              points: points,
              stackedOnPoints: stackedOnPoints
            });
          }
        }
      }
      var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');
      polyline.useStyle(zrUtil.defaults(lineStyleModel.getLineStyle(), {
        fill: 'none',
        stroke: visualColor,
        lineJoin: 'bevel'
      }));
      var smooth = seriesModel.get('smooth');
      smooth = getSmooth(seriesModel.get('smooth'));
      polyline.setShape({
        smooth: smooth,
        smoothMonotone: seriesModel.get('smoothMonotone'),
        connectNulls: seriesModel.get('connectNulls')
      });
      if (polygon) {
        var stackedOn = data.stackedOn;
        var stackedOnSmooth = 0;
        polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
          fill: visualColor,
          opacity: 0.7,
          lineJoin: 'bevel'
        }));
        if (stackedOn) {
          var stackedOnSeries = stackedOn.hostModel;
          stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));
        }
        polygon.setShape({
          smooth: smooth,
          stackedOnSmooth: stackedOnSmooth,
          smoothMonotone: seriesModel.get('smoothMonotone'),
          connectNulls: seriesModel.get('connectNulls')
        });
      }
      this._data = data;
      this._coordSys = coordSys;
      this._stackedOnPoints = stackedOnPoints;
      this._points = points;
      this._step = step;
    },
    highlight: function(seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData();
      var dataIndex = queryDataIndex(data, payload);
      if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
        var symbol = data.getItemGraphicEl(dataIndex);
        if (!symbol) {
          var pt = data.getItemLayout(dataIndex);
          symbol = new Symbol(data, dataIndex);
          symbol.position = pt;
          symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));
          symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);
          symbol.__temp = true;
          data.setItemGraphicEl(dataIndex, symbol);
          symbol.stopSymbolAnimation(true);
          this.group.add(symbol);
        }
        symbol.highlight();
      } else {
        ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
      }
    },
    downplay: function(seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData();
      var dataIndex = queryDataIndex(data, payload);
      if (dataIndex != null && dataIndex >= 0) {
        var symbol = data.getItemGraphicEl(dataIndex);
        if (symbol) {
          if (symbol.__temp) {
            data.setItemGraphicEl(dataIndex, null);
            this.group.remove(symbol);
          } else {
            symbol.downplay();
          }
        }
      } else {
        ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
      }
    },
    _newPolyline: function(points) {
      var polyline = this._polyline;
      if (polyline) {
        this._lineGroup.remove(polyline);
      }
      polyline = new polyHelper.Polyline({
        shape: {points: points},
        silent: true,
        z2: 10
      });
      this._lineGroup.add(polyline);
      this._polyline = polyline;
      return polyline;
    },
    _newPolygon: function(points, stackedOnPoints) {
      var polygon = this._polygon;
      if (polygon) {
        this._lineGroup.remove(polygon);
      }
      polygon = new polyHelper.Polygon({
        shape: {
          points: points,
          stackedOnPoints: stackedOnPoints
        },
        silent: true
      });
      this._lineGroup.add(polygon);
      this._polygon = polygon;
      return polygon;
    },
    _getSymbolIgnoreFunc: function(data, coordSys) {
      var categoryAxis = coordSys.getAxesByScale('ordinal')[0];
      if (categoryAxis && categoryAxis.isLabelIgnored) {
        return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);
      }
    },
    _updateAnimation: function(data, stackedOnPoints, coordSys, api, step) {
      var polyline = this._polyline;
      var polygon = this._polygon;
      var seriesModel = data.hostModel;
      var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys);
      var current = diff.current;
      var stackedOnCurrent = diff.stackedOnCurrent;
      var next = diff.next;
      var stackedOnNext = diff.stackedOnNext;
      if (step) {
        current = turnPointsIntoStep(diff.current, coordSys, step);
        stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
        next = turnPointsIntoStep(diff.next, coordSys, step);
        stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
      }
      polyline.shape.__points = diff.current;
      polyline.shape.points = current;
      graphic.updateProps(polyline, {shape: {points: next}}, seriesModel);
      if (polygon) {
        polygon.setShape({
          points: current,
          stackedOnPoints: stackedOnCurrent
        });
        graphic.updateProps(polygon, {shape: {
            points: next,
            stackedOnPoints: stackedOnNext,
            __points: diff.next
          }}, seriesModel);
      }
      var updatedDataInfo = [];
      var diffStatus = diff.status;
      for (var i = 0; i < diffStatus.length; i++) {
        var cmd = diffStatus[i].cmd;
        if (cmd === '=') {
          var el = data.getItemGraphicEl(diffStatus[i].idx1);
          if (el) {
            updatedDataInfo.push({
              el: el,
              ptIdx: i
            });
          }
        }
      }
      if (polyline.animators && polyline.animators.length) {
        polyline.animators[0].during(function() {
          for (var i = 0; i < updatedDataInfo.length; i++) {
            var el = updatedDataInfo[i].el;
            el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);
          }
        });
      }
    },
    remove: function(ecModel) {
      var group = this.group;
      var oldData = this._data;
      this._lineGroup.removeAll();
      this._symbolDraw.remove(true);
      oldData && oldData.eachItemGraphicEl(function(el, idx) {
        if (el.__temp) {
          group.remove(el);
          oldData.setItemGraphicEl(idx, null);
        }
      });
      this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/processor/dataSample.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var samplers = {
    average: function(frame) {
      var sum = 0;
      var count = 0;
      for (var i = 0; i < frame.length; i++) {
        if (!isNaN(frame[i])) {
          sum += frame[i];
          count++;
        }
      }
      return count === 0 ? NaN : sum / count;
    },
    sum: function(frame) {
      var sum = 0;
      for (var i = 0; i < frame.length; i++) {
        sum += frame[i] || 0;
      }
      return sum;
    },
    max: function(frame) {
      var max = -Infinity;
      for (var i = 0; i < frame.length; i++) {
        frame[i] > max && (max = frame[i]);
      }
      return max;
    },
    min: function(frame) {
      var min = Infinity;
      for (var i = 0; i < frame.length; i++) {
        frame[i] < min && (min = frame[i]);
      }
      return min;
    },
    nearest: function(frame) {
      return frame[0];
    }
  };
  var indexSampler = function(frame, value) {
    return Math.round(frame.length / 2);
  };
  module.exports = function(seriesType, ecModel, api) {
    ecModel.eachSeriesByType(seriesType, function(seriesModel) {
      var data = seriesModel.getData();
      var sampling = seriesModel.get('sampling');
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys.type === 'cartesian2d' && sampling) {
        var baseAxis = coordSys.getBaseAxis();
        var valueAxis = coordSys.getOtherAxis(baseAxis);
        var extent = baseAxis.getExtent();
        var size = extent[1] - extent[0];
        var rate = Math.round(data.count() / size);
        if (rate > 1) {
          var sampler;
          if (typeof sampling === 'string') {
            sampler = samplers[sampling];
          } else if (typeof sampling === 'function') {
            sampler = sampling;
          }
          if (sampler) {
            data = data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler);
            seriesModel.setData(data);
          }
        }
      }
    }, this);
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/line.js", ["zrender/lib/core/util", "../echarts", "./line/LineSeries", "./line/LineView", "../visual/symbol", "../layout/points", "../processor/dataSample", "../component/grid", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var echarts = $__require('../echarts');
  var PRIORITY = echarts.PRIORITY;
  $__require('./line/LineSeries');
  $__require('./line/LineView');
  echarts.registerVisual(zrUtil.curry($__require('../visual/symbol'), 'line', 'circle', 'line'));
  echarts.registerLayout(zrUtil.curry($__require('../layout/points'), 'line'));
  echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry($__require('../processor/dataSample'), 'line'));
  $__require('../component/grid');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/bar/BarSeries.js", ["../../model/Series", "../helper/createListFromArray", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SeriesModel = $__require('../../model/Series');
  var createListFromArray = $__require('../helper/createListFromArray');
  module.exports = SeriesModel.extend({
    type: 'series.bar',
    dependencies: ['grid', 'polar'],
    getInitialData: function(option, ecModel) {
      if (__DEV__) {
        var coordSys = option.coordinateSystem;
        if (coordSys !== 'cartesian2d') {
          throw new Error('Bar only support cartesian2d coordinateSystem');
        }
      }
      return createListFromArray(option.data, this, ecModel);
    },
    getMarkerPosition: function(value) {
      var coordSys = this.coordinateSystem;
      if (coordSys) {
        var pt = coordSys.dataToPoint(value, true);
        var data = this.getData();
        var offset = data.getLayout('offset');
        var size = data.getLayout('size');
        var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
        pt[offsetIndex] += offset + size / 2;
        return pt;
      }
      return [NaN, NaN];
    },
    brushSelector: 'rect',
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: true,
      xAxisIndex: 0,
      yAxisIndex: 0,
      barMinHeight: 0,
      itemStyle: {
        normal: {},
        emphasis: {}
      }
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/bar/barItemStyle.js", ["../../model/mixin/makeStyleMapper", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var getBarItemStyle = $__require('../../model/mixin/makeStyleMapper')([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);
  module.exports = {getBarItemStyle: function(excludes) {
      var style = getBarItemStyle.call(this, excludes);
      if (this.getBorderLineDash) {
        var lineDash = this.getBorderLineDash();
        lineDash && (style.lineDash = lineDash);
      }
      return style;
    }};
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/bar/BarView.js", ["zrender/lib/core/util", "../../util/graphic", "../../model/Model", "./barItemStyle", "../../echarts", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  zrUtil.extend($__require('../../model/Model').prototype, $__require('./barItemStyle'));
  function fixLayoutWithLineWidth(layout, lineWidth) {
    var signX = layout.width > 0 ? 1 : -1;
    var signY = layout.height > 0 ? 1 : -1;
    lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));
    layout.x += signX * lineWidth / 2;
    layout.y += signY * lineWidth / 2;
    layout.width -= signX * lineWidth;
    layout.height -= signY * lineWidth;
  }
  module.exports = $__require('../../echarts').extendChartView({
    type: 'bar',
    render: function(seriesModel, ecModel, api) {
      var coordinateSystemType = seriesModel.get('coordinateSystem');
      if (coordinateSystemType === 'cartesian2d') {
        this._renderOnCartesian(seriesModel, ecModel, api);
      }
      return this.group;
    },
    _renderOnCartesian: function(seriesModel, ecModel, api) {
      var group = this.group;
      var data = seriesModel.getData();
      var oldData = this._data;
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var isHorizontal = baseAxis.isHorizontal();
      var enableAnimation = seriesModel.get('animation');
      var barBorderWidthQuery = ['itemStyle', 'normal', 'barBorderWidth'];
      function createRect(dataIndex, isUpdate) {
        var layout = data.getItemLayout(dataIndex);
        var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;
        fixLayoutWithLineWidth(layout, lineWidth);
        var rect = new graphic.Rect({shape: zrUtil.extend({}, layout)});
        if (enableAnimation) {
          var rectShape = rect.shape;
          var animateProperty = isHorizontal ? 'height' : 'width';
          var animateTarget = {};
          rectShape[animateProperty] = 0;
          animateTarget[animateProperty] = layout[animateProperty];
          graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {shape: animateTarget}, seriesModel, dataIndex);
        }
        return rect;
      }
      data.diff(oldData).add(function(dataIndex) {
        if (!data.hasValue(dataIndex)) {
          return;
        }
        var rect = createRect(dataIndex);
        data.setItemGraphicEl(dataIndex, rect);
        group.add(rect);
      }).update(function(newIndex, oldIndex) {
        var rect = oldData.getItemGraphicEl(oldIndex);
        if (!data.hasValue(newIndex)) {
          group.remove(rect);
          return;
        }
        if (!rect) {
          rect = createRect(newIndex, true);
        }
        var layout = data.getItemLayout(newIndex);
        var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;
        fixLayoutWithLineWidth(layout, lineWidth);
        graphic.updateProps(rect, {shape: layout}, seriesModel, newIndex);
        data.setItemGraphicEl(newIndex, rect);
        group.add(rect);
      }).remove(function(idx) {
        var rect = oldData.getItemGraphicEl(idx);
        if (rect) {
          rect.style.text = '';
          graphic.updateProps(rect, {shape: {width: 0}}, seriesModel, idx, function() {
            group.remove(rect);
          });
        }
      }).execute();
      this._updateStyle(seriesModel, data, isHorizontal);
      this._data = data;
    },
    _updateStyle: function(seriesModel, data, isHorizontal) {
      function setLabel(style, model, color, labelText, labelPositionOutside) {
        graphic.setText(style, model, color);
        style.text = labelText;
        if (style.textPosition === 'outside') {
          style.textPosition = labelPositionOutside;
        }
      }
      data.eachItemGraphicEl(function(rect, idx) {
        var itemModel = data.getItemModel(idx);
        var color = data.getItemVisual(idx, 'color');
        var opacity = data.getItemVisual(idx, 'opacity');
        var layout = data.getItemLayout(idx);
        var itemStyleModel = itemModel.getModel('itemStyle.normal');
        var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();
        rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);
        rect.useStyle(zrUtil.defaults({
          fill: color,
          opacity: opacity
        }, itemStyleModel.getBarItemStyle()));
        var labelPositionOutside = isHorizontal ? (layout.height > 0 ? 'bottom' : 'top') : (layout.width > 0 ? 'left' : 'right');
        var labelModel = itemModel.getModel('label.normal');
        var hoverLabelModel = itemModel.getModel('label.emphasis');
        var rectStyle = rect.style;
        if (labelModel.get('show')) {
          setLabel(rectStyle, labelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal'), seriesModel.getRawValue(idx)), labelPositionOutside);
        } else {
          rectStyle.text = '';
        }
        if (hoverLabelModel.get('show')) {
          setLabel(hoverStyle, hoverLabelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis'), seriesModel.getRawValue(idx)), labelPositionOutside);
        } else {
          hoverStyle.text = '';
        }
        graphic.setHoverStyle(rect, hoverStyle);
      });
    },
    remove: function(ecModel, api) {
      var group = this.group;
      if (ecModel.get('animation')) {
        if (this._data) {
          this._data.eachItemGraphicEl(function(el) {
            el.style.text = '';
            graphic.updateProps(el, {shape: {width: 0}}, ecModel, el.dataIndex, function() {
              group.remove(el);
            });
          });
        }
      } else {
        group.removeAll();
      }
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/layout/barGrid.js", ["zrender/lib/core/util", "../util/number", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var numberUtil = $__require('../util/number');
  var parsePercent = numberUtil.parsePercent;
  function getSeriesStackId(seriesModel) {
    return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;
  }
  function getAxisKey(axis) {
    return axis.dim + axis.index;
  }
  function calBarWidthAndOffset(barSeries, api) {
    var columnsMap = {};
    zrUtil.each(barSeries, function(seriesModel, idx) {
      var data = seriesModel.getData();
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var axisExtent = baseAxis.getExtent();
      var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());
      var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {
        bandWidth: bandWidth,
        remainedWidth: bandWidth,
        autoWidthCount: 0,
        categoryGap: '20%',
        gap: '30%',
        stacks: {}
      };
      var stacks = columnsOnAxis.stacks;
      columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;
      var stackId = getSeriesStackId(seriesModel);
      if (!stacks[stackId]) {
        columnsOnAxis.autoWidthCount++;
      }
      stacks[stackId] = stacks[stackId] || {
        width: 0,
        maxWidth: 0
      };
      var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);
      var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);
      var barGap = seriesModel.get('barGap');
      var barCategoryGap = seriesModel.get('barCategoryGap');
      if (barWidth && !stacks[stackId].width) {
        barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
        stacks[stackId].width = barWidth;
        columnsOnAxis.remainedWidth -= barWidth;
      }
      barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
      (barGap != null) && (columnsOnAxis.gap = barGap);
      (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);
    });
    var result = {};
    zrUtil.each(columnsMap, function(columnsOnAxis, coordSysName) {
      result[coordSysName] = {};
      var stacks = columnsOnAxis.stacks;
      var bandWidth = columnsOnAxis.bandWidth;
      var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
      var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
      var remainedWidth = columnsOnAxis.remainedWidth;
      var autoWidthCount = columnsOnAxis.autoWidthCount;
      var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      zrUtil.each(stacks, function(column, stack) {
        var maxWidth = column.maxWidth;
        if (!column.width && maxWidth && maxWidth < autoWidth) {
          maxWidth = Math.min(maxWidth, remainedWidth);
          remainedWidth -= maxWidth;
          column.width = maxWidth;
          autoWidthCount--;
        }
      });
      autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      var widthSum = 0;
      var lastColumn;
      zrUtil.each(stacks, function(column, idx) {
        if (!column.width) {
          column.width = autoWidth;
        }
        lastColumn = column;
        widthSum += column.width * (1 + barGapPercent);
      });
      if (lastColumn) {
        widthSum -= lastColumn.width * barGapPercent;
      }
      var offset = -widthSum / 2;
      zrUtil.each(stacks, function(column, stackId) {
        result[coordSysName][stackId] = result[coordSysName][stackId] || {
          offset: offset,
          width: column.width
        };
        offset += column.width * (1 + barGapPercent);
      });
    });
    return result;
  }
  function barLayoutGrid(seriesType, ecModel, api) {
    var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function(seriesModel) {
      return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';
    }));
    var lastStackCoords = {};
    ecModel.eachSeriesByType(seriesType, function(seriesModel) {
      var data = seriesModel.getData();
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var stackId = getSeriesStackId(seriesModel);
      var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
      var columnOffset = columnLayoutInfo.offset;
      var columnWidth = columnLayoutInfo.width;
      var valueAxis = cartesian.getOtherAxis(baseAxis);
      var barMinHeight = seriesModel.get('barMinHeight') || 0;
      var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];
      var coords = cartesian.dataToPoints(data, true);
      lastStackCoords[stackId] = lastStackCoords[stackId] || [];
      data.setLayout({
        offset: columnOffset,
        size: columnWidth
      });
      data.each(valueAxis.dim, function(value, idx) {
        if (isNaN(value)) {
          return;
        }
        if (!lastStackCoords[stackId][idx]) {
          lastStackCoords[stackId][idx] = {
            p: valueAxisStart,
            n: valueAxisStart
          };
        }
        var sign = value >= 0 ? 'p' : 'n';
        var coord = coords[idx];
        var lastCoord = lastStackCoords[stackId][idx][sign];
        var x,
            y,
            width,
            height;
        if (valueAxis.isHorizontal()) {
          x = lastCoord;
          y = coord[1] + columnOffset;
          width = coord[0] - lastCoord;
          height = columnWidth;
          if (Math.abs(width) < barMinHeight) {
            width = (width < 0 ? -1 : 1) * barMinHeight;
          }
          lastStackCoords[stackId][idx][sign] += width;
        } else {
          x = coord[0] + columnOffset;
          y = lastCoord;
          width = columnWidth;
          height = coord[1] - lastCoord;
          if (Math.abs(height) < barMinHeight) {
            height = (height <= 0 ? -1 : 1) * barMinHeight;
          }
          lastStackCoords[stackId][idx][sign] += height;
        }
        data.setItemLayout(idx, {
          x: x,
          y: y,
          width: width,
          height: height
        });
      }, true);
    }, this);
  }
  module.exports = barLayoutGrid;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/bar.js", ["zrender/lib/core/util", "../coord/cartesian/Grid", "./bar/BarSeries", "./bar/BarView", "../layout/barGrid", "../echarts", "../component/grid", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  $__require('../coord/cartesian/Grid');
  $__require('./bar/BarSeries');
  $__require('./bar/BarView');
  var barLayoutGrid = $__require('../layout/barGrid');
  var echarts = $__require('../echarts');
  echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));
  echarts.registerVisual(function(ecModel) {
    ecModel.eachSeriesByType('bar', function(seriesModel) {
      var data = seriesModel.getData();
      data.setVisual('legendSymbol', 'roundRect');
    });
  });
  $__require('../component/grid');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/pie/PieSeries.js", ["../../data/List", "zrender/lib/core/util", "../../util/model", "../../data/helper/completeDimensions", "../../component/helper/selectableMixin", "../../echarts", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var List = $__require('../../data/List');
  var zrUtil = $__require('zrender/lib/core/util');
  var modelUtil = $__require('../../util/model');
  var completeDimensions = $__require('../../data/helper/completeDimensions');
  var dataSelectableMixin = $__require('../../component/helper/selectableMixin');
  var PieSeries = $__require('../../echarts').extendSeriesModel({
    type: 'series.pie',
    init: function(option) {
      PieSeries.superApply(this, 'init', arguments);
      this.legendDataProvider = function() {
        return this._dataBeforeProcessed;
      };
      this.updateSelectedMap(option.data);
      this._defaultLabelLine(option);
    },
    mergeOption: function(newOption) {
      PieSeries.superCall(this, 'mergeOption', newOption);
      this.updateSelectedMap(this.option.data);
    },
    getInitialData: function(option, ecModel) {
      var dimensions = completeDimensions(['value'], option.data);
      var list = new List(dimensions, this);
      list.initData(option.data);
      return list;
    },
    getDataParams: function(dataIndex) {
      var data = this._data;
      var params = PieSeries.superCall(this, 'getDataParams', dataIndex);
      var sum = data.getSum('value');
      params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);
      params.$vars.push('percent');
      return params;
    },
    _defaultLabelLine: function(option) {
      modelUtil.defaultEmphasis(option.labelLine, ['show']);
      var labelLineNormalOpt = option.labelLine.normal;
      var labelLineEmphasisOpt = option.labelLine.emphasis;
      labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show;
      labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show;
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      legendHoverLink: true,
      hoverAnimation: true,
      center: ['50%', '50%'],
      radius: [0, '75%'],
      clockwise: true,
      startAngle: 90,
      minAngle: 0,
      selectedOffset: 10,
      avoidLabelOverlap: true,
      label: {
        normal: {
          rotate: false,
          show: true,
          position: 'outer'
        },
        emphasis: {}
      },
      labelLine: {normal: {
          show: true,
          length: 15,
          length2: 15,
          smooth: false,
          lineStyle: {
            width: 1,
            type: 'solid'
          }
        }},
      itemStyle: {
        normal: {borderWidth: 1},
        emphasis: {}
      },
      animationEasing: 'cubicOut',
      data: []
    }
  });
  zrUtil.mixin(PieSeries, dataSelectableMixin);
  module.exports = PieSeries;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/pie/PieView.js", ["../../util/graphic", "zrender/lib/core/util", "../../view/Chart", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var zrUtil = $__require('zrender/lib/core/util');
  function updateDataSelected(uid, seriesModel, hasAnimation, api) {
    var data = seriesModel.getData();
    var dataIndex = this.dataIndex;
    var name = data.getName(dataIndex);
    var selectedOffset = seriesModel.get('selectedOffset');
    api.dispatchAction({
      type: 'pieToggleSelect',
      from: uid,
      name: name,
      seriesId: seriesModel.id
    });
    data.each(function(idx) {
      toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);
    });
  }
  function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {
    var midAngle = (layout.startAngle + layout.endAngle) / 2;
    var dx = Math.cos(midAngle);
    var dy = Math.sin(midAngle);
    var offset = isSelected ? selectedOffset : 0;
    var position = [dx * offset, dy * offset];
    hasAnimation ? el.animate().when(200, {position: position}).start('bounceOut') : el.attr('position', position);
  }
  function PiePiece(data, idx) {
    graphic.Group.call(this);
    var sector = new graphic.Sector({z2: 2});
    var polyline = new graphic.Polyline();
    var text = new graphic.Text();
    this.add(sector);
    this.add(polyline);
    this.add(text);
    this.updateData(data, idx, true);
    function onEmphasis() {
      polyline.ignore = polyline.hoverIgnore;
      text.ignore = text.hoverIgnore;
    }
    function onNormal() {
      polyline.ignore = polyline.normalIgnore;
      text.ignore = text.normalIgnore;
    }
    this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);
  }
  var piePieceProto = PiePiece.prototype;
  function getLabelStyle(data, idx, state, labelModel, labelPosition) {
    var textStyleModel = labelModel.getModel('textStyle');
    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';
    return {
      fill: textStyleModel.getTextColor() || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),
      opacity: data.getItemVisual(idx, 'opacity'),
      textFont: textStyleModel.getFont(),
      text: zrUtil.retrieve(data.hostModel.getFormattedLabel(idx, state), data.getName(idx))
    };
  }
  piePieceProto.updateData = function(data, idx, firstCreate) {
    var sector = this.childAt(0);
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout = data.getItemLayout(idx);
    var sectorShape = zrUtil.extend({}, layout);
    sectorShape.label = null;
    if (firstCreate) {
      sector.setShape(sectorShape);
      sector.shape.endAngle = layout.startAngle;
      graphic.updateProps(sector, {shape: {endAngle: layout.endAngle}}, seriesModel, idx);
    } else {
      graphic.updateProps(sector, {shape: sectorShape}, seriesModel, idx);
    }
    var itemStyleModel = itemModel.getModel('itemStyle');
    var visualColor = data.getItemVisual(idx, 'color');
    sector.useStyle(zrUtil.defaults({
      lineJoin: 'bevel',
      fill: visualColor
    }, itemStyleModel.getModel('normal').getItemStyle()));
    sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();
    toggleItemSelected(this, data.getItemLayout(idx), itemModel.get('selected'), seriesModel.get('selectedOffset'), seriesModel.get('animation'));
    function onEmphasis() {
      sector.stopAnimation(true);
      sector.animateTo({shape: {r: layout.r + 10}}, 300, 'elasticOut');
    }
    function onNormal() {
      sector.stopAnimation(true);
      sector.animateTo({shape: {r: layout.r}}, 300, 'elasticOut');
    }
    sector.off('mouseover').off('mouseout').off('emphasis').off('normal');
    if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {
      sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);
    }
    this._updateLabel(data, idx);
    graphic.setHoverStyle(this);
  };
  piePieceProto._updateLabel = function(data, idx) {
    var labelLine = this.childAt(1);
    var labelText = this.childAt(2);
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout = data.getItemLayout(idx);
    var labelLayout = layout.label;
    var visualColor = data.getItemVisual(idx, 'color');
    graphic.updateProps(labelLine, {shape: {points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]}}, seriesModel, idx);
    graphic.updateProps(labelText, {style: {
        x: labelLayout.x,
        y: labelLayout.y
      }}, seriesModel, idx);
    labelText.attr({
      style: {
        textVerticalAlign: labelLayout.verticalAlign,
        textAlign: labelLayout.textAlign,
        textFont: labelLayout.font
      },
      rotation: labelLayout.rotation,
      origin: [labelLayout.x, labelLayout.y],
      z2: 10
    });
    var labelModel = itemModel.getModel('label.normal');
    var labelHoverModel = itemModel.getModel('label.emphasis');
    var labelLineModel = itemModel.getModel('labelLine.normal');
    var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');
    var labelPosition = labelModel.get('position') || labelHoverModel.get('position');
    labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));
    labelText.ignore = labelText.normalIgnore = !labelModel.get('show');
    labelText.hoverIgnore = !labelHoverModel.get('show');
    labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');
    labelLine.hoverIgnore = !labelLineHoverModel.get('show');
    labelLine.setStyle({
      stroke: visualColor,
      opacity: data.getItemVisual(idx, 'opacity')
    });
    labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());
    labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);
    labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();
    var smooth = labelLineModel.get('smooth');
    if (smooth && smooth === true) {
      smooth = 0.4;
    }
    labelLine.setShape({smooth: smooth});
  };
  zrUtil.inherits(PiePiece, graphic.Group);
  var Pie = $__require('../../view/Chart').extend({
    type: 'pie',
    init: function() {
      var sectorGroup = new graphic.Group();
      this._sectorGroup = sectorGroup;
    },
    render: function(seriesModel, ecModel, api, payload) {
      if (payload && (payload.from === this.uid)) {
        return;
      }
      var data = seriesModel.getData();
      var oldData = this._data;
      var group = this.group;
      var hasAnimation = ecModel.get('animation');
      var isFirstRender = !oldData;
      var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);
      var selectedMode = seriesModel.get('selectedMode');
      data.diff(oldData).add(function(idx) {
        var piePiece = new PiePiece(data, idx);
        if (isFirstRender) {
          piePiece.eachChild(function(child) {
            child.stopAnimation(true);
          });
        }
        selectedMode && piePiece.on('click', onSectorClick);
        data.setItemGraphicEl(idx, piePiece);
        group.add(piePiece);
      }).update(function(newIdx, oldIdx) {
        var piePiece = oldData.getItemGraphicEl(oldIdx);
        piePiece.updateData(data, newIdx);
        piePiece.off('click');
        selectedMode && piePiece.on('click', onSectorClick);
        group.add(piePiece);
        data.setItemGraphicEl(newIdx, piePiece);
      }).remove(function(idx) {
        var piePiece = oldData.getItemGraphicEl(idx);
        group.remove(piePiece);
      }).execute();
      if (hasAnimation && isFirstRender && data.count() > 0) {
        var shape = data.getItemLayout(0);
        var r = Math.max(api.getWidth(), api.getHeight()) / 2;
        var removeClipPath = zrUtil.bind(group.removeClipPath, group);
        group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));
      }
      this._data = data;
    },
    _createClipPath: function(cx, cy, r, startAngle, clockwise, cb, seriesModel) {
      var clipPath = new graphic.Sector({shape: {
          cx: cx,
          cy: cy,
          r0: 0,
          r: r,
          startAngle: startAngle,
          endAngle: startAngle,
          clockwise: clockwise
        }});
      graphic.initProps(clipPath, {shape: {endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2}}, seriesModel, cb);
      return clipPath;
    }
  });
  module.exports = Pie;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/pie/labelLayout.js", ["zrender/lib/contain/text", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var textContain = $__require('zrender/lib/contain/text');
  function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {
    list.sort(function(a, b) {
      return a.y - b.y;
    });
    function shiftDown(start, end, delta, dir) {
      for (var j = start; j < end; j++) {
        list[j].y += delta;
        if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {
          shiftUp(j, delta / 2);
          return;
        }
      }
      shiftUp(end - 1, delta / 2);
    }
    function shiftUp(end, delta) {
      for (var j = end; j >= 0; j--) {
        list[j].y -= delta;
        if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {
          break;
        }
      }
    }
    function changeX(list, isDownList, cx, cy, r, dir) {
      var lastDeltaX = dir > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;
      for (var i = 0,
          l = list.length; i < l; i++) {
        if (list[i].position === 'center') {
          continue;
        }
        var deltaY = Math.abs(list[i].y - cy);
        var length = list[i].len;
        var length2 = list[i].len2;
        var deltaX = (deltaY < r + length) ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);
        if (isDownList && deltaX >= lastDeltaX) {
          deltaX = lastDeltaX - 10;
        }
        if (!isDownList && deltaX <= lastDeltaX) {
          deltaX = lastDeltaX + 10;
        }
        list[i].x = cx + deltaX * dir;
        lastDeltaX = deltaX;
      }
    }
    var lastY = 0;
    var delta;
    var len = list.length;
    var upList = [];
    var downList = [];
    for (var i = 0; i < len; i++) {
      delta = list[i].y - lastY;
      if (delta < 0) {
        shiftDown(i, len, -delta, dir);
      }
      lastY = list[i].y + list[i].height;
    }
    if (viewHeight - lastY < 0) {
      shiftUp(len - 1, lastY - viewHeight);
    }
    for (var i = 0; i < len; i++) {
      if (list[i].y >= cy) {
        downList.push(list[i]);
      } else {
        upList.push(list[i]);
      }
    }
    changeX(upList, false, cx, cy, r, dir);
    changeX(downList, true, cx, cy, r, dir);
  }
  function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {
    var leftList = [];
    var rightList = [];
    for (var i = 0; i < labelLayoutList.length; i++) {
      if (labelLayoutList[i].x < cx) {
        leftList.push(labelLayoutList[i]);
      } else {
        rightList.push(labelLayoutList[i]);
      }
    }
    adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);
    adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);
    for (var i = 0; i < labelLayoutList.length; i++) {
      var linePoints = labelLayoutList[i].linePoints;
      if (linePoints) {
        var dist = linePoints[1][0] - linePoints[2][0];
        if (labelLayoutList[i].x < cx) {
          linePoints[2][0] = labelLayoutList[i].x + 3;
        } else {
          linePoints[2][0] = labelLayoutList[i].x - 3;
        }
        linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;
        linePoints[1][0] = linePoints[2][0] + dist;
      }
    }
  }
  module.exports = function(seriesModel, r, viewWidth, viewHeight) {
    var data = seriesModel.getData();
    var labelLayoutList = [];
    var cx;
    var cy;
    var hasLabelRotate = false;
    data.each(function(idx) {
      var layout = data.getItemLayout(idx);
      var itemModel = data.getItemModel(idx);
      var labelModel = itemModel.getModel('label.normal');
      var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');
      var labelLineModel = itemModel.getModel('labelLine.normal');
      var labelLineLen = labelLineModel.get('length');
      var labelLineLen2 = labelLineModel.get('length2');
      var midAngle = (layout.startAngle + layout.endAngle) / 2;
      var dx = Math.cos(midAngle);
      var dy = Math.sin(midAngle);
      var textX;
      var textY;
      var linePoints;
      var textAlign;
      cx = layout.cx;
      cy = layout.cy;
      var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';
      if (labelPosition === 'center') {
        textX = layout.cx;
        textY = layout.cy;
        textAlign = 'center';
      } else {
        var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;
        var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;
        textX = x1 + dx * 3;
        textY = y1 + dy * 3;
        if (!isLabelInside) {
          var x2 = x1 + dx * (labelLineLen + r - layout.r);
          var y2 = y1 + dy * (labelLineLen + r - layout.r);
          var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);
          var y3 = y2;
          textX = x3 + (dx < 0 ? -5 : 5);
          textY = y3;
          linePoints = [[x1, y1], [x2, y2], [x3, y3]];
        }
        textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');
      }
      var font = labelModel.getModel('textStyle').getFont();
      var labelRotate = labelModel.get('rotate') ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;
      var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);
      var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');
      hasLabelRotate = !!labelRotate;
      layout.label = {
        x: textX,
        y: textY,
        position: labelPosition,
        height: textRect.height,
        len: labelLineLen,
        len2: labelLineLen2,
        linePoints: linePoints,
        textAlign: textAlign,
        verticalAlign: 'middle',
        font: font,
        rotation: labelRotate
      };
      if (!isLabelInside) {
        labelLayoutList.push(layout.label);
      }
    });
    if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {
      avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);
    }
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/pie/pieLayout.js", ["../../util/number", "./labelLayout", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var numberUtil = $__require('../../util/number');
  var parsePercent = numberUtil.parsePercent;
  var labelLayout = $__require('./labelLayout');
  var zrUtil = $__require('zrender/lib/core/util');
  var PI2 = Math.PI * 2;
  var RADIAN = Math.PI / 180;
  module.exports = function(seriesType, ecModel, api, payload) {
    ecModel.eachSeriesByType(seriesType, function(seriesModel) {
      var center = seriesModel.get('center');
      var radius = seriesModel.get('radius');
      if (!zrUtil.isArray(radius)) {
        radius = [0, radius];
      }
      if (!zrUtil.isArray(center)) {
        center = [center, center];
      }
      var width = api.getWidth();
      var height = api.getHeight();
      var size = Math.min(width, height);
      var cx = parsePercent(center[0], width);
      var cy = parsePercent(center[1], height);
      var r0 = parsePercent(radius[0], size / 2);
      var r = parsePercent(radius[1], size / 2);
      var data = seriesModel.getData();
      var startAngle = -seriesModel.get('startAngle') * RADIAN;
      var minAngle = seriesModel.get('minAngle') * RADIAN;
      var sum = data.getSum('value');
      var unitRadian = Math.PI / (sum || data.count()) * 2;
      var clockwise = seriesModel.get('clockwise');
      var roseType = seriesModel.get('roseType');
      var extent = data.getDataExtent('value');
      extent[0] = 0;
      var restAngle = PI2;
      var valueSumLargerThanMinAngle = 0;
      var currentAngle = startAngle;
      var dir = clockwise ? 1 : -1;
      data.each('value', function(value, idx) {
        var angle;
        if (roseType !== 'area') {
          angle = sum === 0 ? unitRadian : (value * unitRadian);
        } else {
          angle = PI2 / (data.count() || 1);
        }
        if (angle < minAngle) {
          angle = minAngle;
          restAngle -= minAngle;
        } else {
          valueSumLargerThanMinAngle += value;
        }
        var endAngle = currentAngle + dir * angle;
        data.setItemLayout(idx, {
          angle: angle,
          startAngle: currentAngle,
          endAngle: endAngle,
          clockwise: clockwise,
          cx: cx,
          cy: cy,
          r0: r0,
          r: roseType ? numberUtil.linearMap(value, extent, [r0, r]) : r
        });
        currentAngle = endAngle;
      }, true);
      if (restAngle < PI2) {
        if (restAngle <= 1e-3) {
          var angle = PI2 / data.count();
          data.each(function(idx) {
            var layout = data.getItemLayout(idx);
            layout.startAngle = startAngle + dir * idx * angle;
            layout.endAngle = startAngle + dir * (idx + 1) * angle;
          });
        } else {
          unitRadian = restAngle / valueSumLargerThanMinAngle;
          currentAngle = startAngle;
          data.each('value', function(value, idx) {
            var layout = data.getItemLayout(idx);
            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;
            layout.startAngle = currentAngle;
            layout.endAngle = currentAngle + dir * angle;
            currentAngle += angle;
          });
        }
      }
      labelLayout(seriesModel, r, width, height);
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/pie.js", ["zrender/lib/core/util", "../echarts", "./pie/PieSeries", "./pie/PieView", "../action/createDataSelectAction", "../visual/dataColor", "./pie/pieLayout", "../processor/dataFilter", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var echarts = $__require('../echarts');
  $__require('./pie/PieSeries');
  $__require('./pie/PieView');
  $__require('../action/createDataSelectAction')('pie', [{
    type: 'pieToggleSelect',
    event: 'pieselectchanged',
    method: 'toggleSelected'
  }, {
    type: 'pieSelect',
    event: 'pieselected',
    method: 'select'
  }, {
    type: 'pieUnSelect',
    event: 'pieunselected',
    method: 'unSelect'
  }]);
  echarts.registerVisual(zrUtil.curry($__require('../visual/dataColor'), 'pie'));
  echarts.registerLayout(zrUtil.curry($__require('./pie/pieLayout'), 'pie'));
  echarts.registerProcessor(zrUtil.curry($__require('../processor/dataFilter'), 'pie'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/scatter/ScatterSeries.js", ["../helper/createListFromArray", "../../model/Series", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var createListFromArray = $__require('../helper/createListFromArray');
  var SeriesModel = $__require('../../model/Series');
  module.exports = SeriesModel.extend({
    type: 'series.scatter',
    dependencies: ['grid', 'polar'],
    getInitialData: function(option, ecModel) {
      var list = createListFromArray(option.data, this, ecModel);
      return list;
    },
    brushSelector: 'point',
    defaultOption: {
      coordinateSystem: 'cartesian2d',
      zlevel: 0,
      z: 2,
      legendHoverLink: true,
      hoverAnimation: true,
      xAxisIndex: 0,
      yAxisIndex: 0,
      polarIndex: 0,
      geoIndex: 0,
      symbolSize: 10,
      large: false,
      largeThreshold: 2000,
      itemStyle: {normal: {opacity: 0.8}}
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/LargeSymbolDraw.js", ["../../util/graphic", "../../util/symbol", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var symbolUtil = $__require('../../util/symbol');
  var LargeSymbolPath = graphic.extendShape({
    shape: {
      points: null,
      sizes: null
    },
    symbolProxy: null,
    buildPath: function(path, shape) {
      var points = shape.points;
      var sizes = shape.sizes;
      var symbolProxy = this.symbolProxy;
      var symbolProxyShape = symbolProxy.shape;
      for (var i = 0; i < points.length; i++) {
        var pt = points[i];
        var size = sizes[i];
        if (size[0] < 4) {
          path.rect(pt[0] - size[0] / 2, pt[1] - size[1] / 2, size[0], size[1]);
        } else {
          symbolProxyShape.x = pt[0] - size[0] / 2;
          symbolProxyShape.y = pt[1] - size[1] / 2;
          symbolProxyShape.width = size[0];
          symbolProxyShape.height = size[1];
          symbolProxy.buildPath(path, symbolProxyShape, true);
        }
      }
    },
    findDataIndex: function(x, y) {
      var shape = this.shape;
      var points = shape.points;
      var sizes = shape.sizes;
      for (var i = points.length - 1; i >= 0; i--) {
        var pt = points[i];
        var size = sizes[i];
        var x0 = pt[0] - size[0] / 2;
        var y0 = pt[1] - size[1] / 2;
        if (x >= x0 && y >= y0 && x <= x0 + size[0] && y <= y0 + size[1]) {
          return i;
        }
      }
      return -1;
    }
  });
  function LargeSymbolDraw() {
    this.group = new graphic.Group();
    this._symbolEl = new LargeSymbolPath({});
  }
  var largeSymbolProto = LargeSymbolDraw.prototype;
  largeSymbolProto.updateData = function(data) {
    this.group.removeAll();
    var symbolEl = this._symbolEl;
    var seriesModel = data.hostModel;
    symbolEl.setShape({
      points: data.mapArray(data.getItemLayout),
      sizes: data.mapArray(function(idx) {
        var size = data.getItemVisual(idx, 'symbolSize');
        if (!(size instanceof Array)) {
          size = [size, size];
        }
        return size;
      })
    });
    symbolEl.symbolProxy = symbolUtil.createSymbol(data.getVisual('symbol'), 0, 0, 0, 0);
    symbolEl.setColor = symbolEl.symbolProxy.setColor;
    symbolEl.useStyle(seriesModel.getModel('itemStyle.normal').getItemStyle(['color']));
    var visualColor = data.getVisual('color');
    if (visualColor) {
      symbolEl.setColor(visualColor);
    }
    symbolEl.seriesIndex = seriesModel.seriesIndex;
    symbolEl.on('mousemove', function(e) {
      symbolEl.dataIndex = null;
      var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);
      if (dataIndex > 0) {
        symbolEl.dataIndex = dataIndex;
      }
    });
    this.group.add(symbolEl);
  };
  largeSymbolProto.updateLayout = function(seriesModel) {
    var data = seriesModel.getData();
    this._symbolEl.setShape({points: data.mapArray(data.getItemLayout)});
  };
  largeSymbolProto.remove = function() {
    this.group.removeAll();
  };
  module.exports = LargeSymbolDraw;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/scatter/ScatterView.js", ["../helper/SymbolDraw", "../helper/LargeSymbolDraw", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SymbolDraw = $__require('../helper/SymbolDraw');
  var LargeSymbolDraw = $__require('../helper/LargeSymbolDraw');
  $__require('../../echarts').extendChartView({
    type: 'scatter',
    init: function() {
      this._normalSymbolDraw = new SymbolDraw();
      this._largeSymbolDraw = new LargeSymbolDraw();
    },
    render: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var largeSymbolDraw = this._largeSymbolDraw;
      var normalSymbolDraw = this._normalSymbolDraw;
      var group = this.group;
      var symbolDraw = seriesModel.get('large') && data.count() > seriesModel.get('largeThreshold') ? largeSymbolDraw : normalSymbolDraw;
      this._symbolDraw = symbolDraw;
      symbolDraw.updateData(data);
      group.add(symbolDraw.group);
      group.remove(symbolDraw === largeSymbolDraw ? normalSymbolDraw.group : largeSymbolDraw.group);
    },
    updateLayout: function(seriesModel) {
      this._symbolDraw.updateLayout(seriesModel);
    },
    remove: function(ecModel, api) {
      this._symbolDraw && this._symbolDraw.remove(api, true);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/scatter.js", ["zrender/lib/core/util", "../echarts", "./scatter/ScatterSeries", "./scatter/ScatterView", "../visual/symbol", "../layout/points", "../component/grid", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var echarts = $__require('../echarts');
  $__require('./scatter/ScatterSeries');
  $__require('./scatter/ScatterView');
  echarts.registerVisual(zrUtil.curry($__require('../visual/symbol'), 'scatter', 'circle', null));
  echarts.registerLayout(zrUtil.curry($__require('../layout/points'), 'scatter'));
  $__require('../component/grid');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/radar/IndicatorAxis.js", ["zrender/lib/core/util", "../Axis", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Axis = $__require('../Axis');
  function IndicatorAxis(dim, scale, radiusExtent) {
    Axis.call(this, dim, scale, radiusExtent);
    this.type = 'value';
    this.angle = 0;
    this.name = '';
    this.model;
  }
  zrUtil.inherits(IndicatorAxis, Axis);
  module.exports = IndicatorAxis;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/radar/Radar.js", ["zrender/lib/core/util", "./IndicatorAxis", "../../scale/Interval", "../../util/number", "../axisHelper", "../../CoordinateSystem", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var IndicatorAxis = $__require('./IndicatorAxis');
  var IntervalScale = $__require('../../scale/Interval');
  var numberUtil = $__require('../../util/number');
  var axisHelper = $__require('../axisHelper');
  function Radar(radarModel, ecModel, api) {
    this._model = radarModel;
    this.dimensions = [];
    this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function(indicatorModel, idx) {
      var dim = 'indicator_' + idx;
      var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());
      indicatorAxis.name = indicatorModel.get('name');
      indicatorAxis.model = indicatorModel;
      indicatorModel.axis = indicatorAxis;
      this.dimensions.push(dim);
      return indicatorAxis;
    }, this);
    this.resize(radarModel, api);
    this.cx;
    this.cy;
    this.r;
    this.startAngle;
  }
  Radar.prototype.getIndicatorAxes = function() {
    return this._indicatorAxes;
  };
  Radar.prototype.dataToPoint = function(value, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
  };
  Radar.prototype.coordToPoint = function(coord, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    var angle = indicatorAxis.angle;
    var x = this.cx + coord * Math.cos(angle);
    var y = this.cy - coord * Math.sin(angle);
    return [x, y];
  };
  Radar.prototype.pointToData = function(pt) {
    var dx = pt[0] - this.cx;
    var dy = pt[1] - this.cy;
    var radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    var radian = Math.atan2(-dy, dx);
    var minRadianDiff = Infinity;
    var closestAxis;
    var closestAxisIdx = -1;
    for (var i = 0; i < this._indicatorAxes.length; i++) {
      var indicatorAxis = this._indicatorAxes[i];
      var diff = Math.abs(radian - indicatorAxis.angle);
      if (diff < minRadianDiff) {
        closestAxis = indicatorAxis;
        closestAxisIdx = i;
        minRadianDiff = diff;
      }
    }
    return [closestAxisIdx, +(closestAxis && closestAxis.coodToData(radius))];
  };
  Radar.prototype.resize = function(radarModel, api) {
    var center = radarModel.get('center');
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    var viewSize = Math.min(viewWidth, viewHeight) / 2;
    this.cx = numberUtil.parsePercent(center[0], viewWidth);
    this.cy = numberUtil.parsePercent(center[1], viewHeight);
    this.startAngle = radarModel.get('startAngle') * Math.PI / 180;
    this.r = numberUtil.parsePercent(radarModel.get('radius'), viewSize);
    zrUtil.each(this._indicatorAxes, function(indicatorAxis, idx) {
      indicatorAxis.setExtent(0, this.r);
      var angle = (this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length);
      angle = Math.atan2(Math.sin(angle), Math.cos(angle));
      indicatorAxis.angle = angle;
    }, this);
  };
  Radar.prototype.update = function(ecModel, api) {
    var indicatorAxes = this._indicatorAxes;
    var radarModel = this._model;
    zrUtil.each(indicatorAxes, function(indicatorAxis) {
      indicatorAxis.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeriesByType('radar', function(radarSeries, idx) {
      if (radarSeries.get('coordinateSystem') !== 'radar' || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel) {
        return;
      }
      var data = radarSeries.getData();
      zrUtil.each(indicatorAxes, function(indicatorAxis) {
        indicatorAxis.scale.unionExtent(data.getDataExtent(indicatorAxis.dim));
      });
    }, this);
    var splitNumber = radarModel.get('splitNumber');
    function increaseInterval(interval) {
      var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));
      var f = interval / exp10;
      if (f === 2) {
        f = 5;
      } else {
        f *= 2;
      }
      return f * exp10;
    }
    zrUtil.each(indicatorAxes, function(indicatorAxis, idx) {
      var rawExtent = axisHelper.getScaleExtent(indicatorAxis, indicatorAxis.model);
      axisHelper.niceScaleExtent(indicatorAxis, indicatorAxis.model);
      var axisModel = indicatorAxis.model;
      var scale = indicatorAxis.scale;
      var fixedMin = axisModel.get('min');
      var fixedMax = axisModel.get('max');
      var interval = scale.getInterval();
      if (fixedMin != null && fixedMax != null) {
        scale.setInterval((fixedMax - fixedMin) / splitNumber);
      } else if (fixedMin != null) {
        var max;
        do {
          max = fixedMin + interval * splitNumber;
          scale.setExtent(+fixedMin, max);
          scale.setInterval(interval);
          interval = increaseInterval(interval);
        } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));
      } else if (fixedMax != null) {
        var min;
        do {
          min = fixedMax - interval * splitNumber;
          scale.setExtent(min, +fixedMax);
          scale.setInterval(interval);
          interval = increaseInterval(interval);
        } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));
      } else {
        var nicedSplitNumber = scale.getTicks().length - 1;
        if (nicedSplitNumber > splitNumber) {
          interval = increaseInterval(interval);
        }
        var center = Math.round((rawExtent[0] + rawExtent[1]) / 2 / interval) * interval;
        var halfSplitNumber = Math.round(splitNumber / 2);
        scale.setExtent(numberUtil.round(center - halfSplitNumber * interval), numberUtil.round(center + (splitNumber - halfSplitNumber) * interval));
        scale.setInterval(interval);
      }
    });
  };
  Radar.dimensions = [];
  Radar.create = function(ecModel, api) {
    var radarList = [];
    ecModel.eachComponent('radar', function(radarModel) {
      var radar = new Radar(radarModel, ecModel, api);
      radarList.push(radar);
      radarModel.coordinateSystem = radar;
    });
    ecModel.eachSeriesByType('radar', function(radarSeries) {
      if (radarSeries.get('coordinateSystem') === 'radar') {
        radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];
      }
    });
    return radarList;
  };
  $__require('../../CoordinateSystem').register('radar', Radar);
  module.exports = Radar;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/radar/RadarModel.js", ["../axisDefault", "../../model/Model", "zrender/lib/core/util", "../axisModelCommonMixin", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var axisDefault = $__require('../axisDefault');
  var valueAxisDefault = axisDefault.valueAxis;
  var Model = $__require('../../model/Model');
  var zrUtil = $__require('zrender/lib/core/util');
  var axisModelCommonMixin = $__require('../axisModelCommonMixin');
  function defaultsShow(opt, show) {
    return zrUtil.defaults({show: show}, opt);
  }
  var RadarModel = $__require('../../echarts').extendComponentModel({
    type: 'radar',
    optionUpdated: function() {
      var boundaryGap = this.get('boundaryGap');
      var splitNumber = this.get('splitNumber');
      var scale = this.get('scale');
      var axisLine = this.get('axisLine');
      var axisTick = this.get('axisTick');
      var axisLabel = this.get('axisLabel');
      var nameTextStyle = this.get('name.textStyle');
      var showName = this.get('name.show');
      var nameFormatter = this.get('name.formatter');
      var nameGap = this.get('nameGap');
      var indicatorModels = zrUtil.map(this.get('indicator') || [], function(indicatorOpt) {
        if (indicatorOpt.max != null && indicatorOpt.max > 0) {
          indicatorOpt.min = 0;
        } else if (indicatorOpt.min != null && indicatorOpt.min < 0) {
          indicatorOpt.max = 0;
        }
        indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {
          boundaryGap: boundaryGap,
          splitNumber: splitNumber,
          scale: scale,
          axisLine: axisLine,
          axisTick: axisTick,
          axisLabel: axisLabel,
          name: indicatorOpt.text,
          nameLocation: 'end',
          nameGap: nameGap,
          nameTextStyle: nameTextStyle
        }, false);
        if (!showName) {
          indicatorOpt.name = '';
        }
        if (typeof nameFormatter === 'string') {
          indicatorOpt.name = nameFormatter.replace('{value}', indicatorOpt.name);
        } else if (typeof nameFormatter === 'function') {
          indicatorOpt.name = nameFormatter(indicatorOpt.name, indicatorOpt);
        }
        return zrUtil.extend(new Model(indicatorOpt, null, this.ecModel), axisModelCommonMixin);
      }, this);
      this.getIndicatorModels = function() {
        return indicatorModels;
      };
    },
    defaultOption: {
      zlevel: 0,
      z: 0,
      center: ['50%', '50%'],
      radius: '75%',
      startAngle: 90,
      name: {show: true},
      boundaryGap: [0, 0],
      splitNumber: 5,
      nameGap: 15,
      scale: false,
      shape: 'polygon',
      axisLine: zrUtil.merge({lineStyle: {color: '#bbb'}}, valueAxisDefault.axisLine),
      axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
      axisTick: defaultsShow(valueAxisDefault.axisTick, false),
      splitLine: defaultsShow(valueAxisDefault.splitLine, true),
      splitArea: defaultsShow(valueAxisDefault.splitArea, true),
      indicator: []
    }
  });
  module.exports = RadarModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/radar/RadarView.js", ["../axis/AxisBuilder", "zrender/lib/core/util", "../../util/graphic", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var AxisBuilder = $__require('../axis/AxisBuilder');
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var axisBuilderAttrs = ['axisLine', 'axisLabel', 'axisTick', 'axisName'];
  module.exports = $__require('../../echarts').extendComponentView({
    type: 'radar',
    render: function(radarModel, ecModel, api) {
      var group = this.group;
      group.removeAll();
      this._buildAxes(radarModel);
      this._buildSplitLineAndArea(radarModel);
    },
    _buildAxes: function(radarModel) {
      var radar = radarModel.coordinateSystem;
      var indicatorAxes = radar.getIndicatorAxes();
      var axisBuilders = zrUtil.map(indicatorAxes, function(indicatorAxis) {
        var axisBuilder = new AxisBuilder(indicatorAxis.model, {
          position: [radar.cx, radar.cy],
          rotation: indicatorAxis.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return axisBuilder;
      });
      zrUtil.each(axisBuilders, function(axisBuilder) {
        zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
        this.group.add(axisBuilder.getGroup());
      }, this);
    },
    _buildSplitLineAndArea: function(radarModel) {
      var radar = radarModel.coordinateSystem;
      var splitNumber = radarModel.get('splitNumber');
      var indicatorAxes = radar.getIndicatorAxes();
      if (!indicatorAxes.length) {
        return;
      }
      var shape = radarModel.get('shape');
      var splitLineModel = radarModel.getModel('splitLine');
      var splitAreaModel = radarModel.getModel('splitArea');
      var lineStyleModel = splitLineModel.getModel('lineStyle');
      var areaStyleModel = splitAreaModel.getModel('areaStyle');
      var showSplitLine = splitLineModel.get('show');
      var showSplitArea = splitAreaModel.get('show');
      var splitLineColors = lineStyleModel.get('color');
      var splitAreaColors = areaStyleModel.get('color');
      splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];
      splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];
      var splitLines = [];
      var splitAreas = [];
      function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
        var colorIndex = idx % areaOrLineColorList.length;
        areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];
        return colorIndex;
      }
      if (shape === 'circle') {
        var ticksRadius = indicatorAxes[0].getTicksCoords();
        var cx = radar.cx;
        var cy = radar.cy;
        for (var i = 0; i < ticksRadius.length; i++) {
          if (showSplitLine) {
            var colorIndex = getColorIndex(splitLines, splitLineColors, i);
            splitLines[colorIndex].push(new graphic.Circle({shape: {
                cx: cx,
                cy: cy,
                r: ticksRadius[i]
              }}));
          }
          if (showSplitArea && i < ticksRadius.length - 1) {
            var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);
            splitAreas[colorIndex].push(new graphic.Ring({shape: {
                cx: cx,
                cy: cy,
                r0: ticksRadius[i],
                r: ticksRadius[i + 1]
              }}));
          }
        }
      } else {
        var axesTicksPoints = zrUtil.map(indicatorAxes, function(indicatorAxis, idx) {
          var ticksCoords = indicatorAxis.getTicksCoords();
          return zrUtil.map(ticksCoords, function(tickCoord) {
            return radar.coordToPoint(tickCoord, idx);
          });
        });
        var prevPoints = [];
        for (var i = 0; i <= splitNumber; i++) {
          var points = [];
          for (var j = 0; j < indicatorAxes.length; j++) {
            points.push(axesTicksPoints[j][i]);
          }
          points.push(points[0].slice());
          if (showSplitLine) {
            var colorIndex = getColorIndex(splitLines, splitLineColors, i);
            splitLines[colorIndex].push(new graphic.Polyline({shape: {points: points}}));
          }
          if (showSplitArea && prevPoints) {
            var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);
            splitAreas[colorIndex].push(new graphic.Polygon({shape: {points: points.concat(prevPoints)}}));
          }
          prevPoints = points.slice().reverse();
        }
      }
      var lineStyle = lineStyleModel.getLineStyle();
      var areaStyle = areaStyleModel.getAreaStyle();
      zrUtil.each(splitAreas, function(splitAreas, idx) {
        this.group.add(graphic.mergePath(splitAreas, {
          style: zrUtil.defaults({
            stroke: 'none',
            fill: splitAreaColors[idx % splitAreaColors.length]
          }, areaStyle),
          silent: true
        }));
      }, this);
      zrUtil.each(splitLines, function(splitLines, idx) {
        this.group.add(graphic.mergePath(splitLines, {
          style: zrUtil.defaults({
            fill: 'none',
            stroke: splitLineColors[idx % splitLineColors.length]
          }, lineStyle),
          silent: true
        }));
      }, this);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/radar.js", ["../coord/radar/Radar", "../coord/radar/RadarModel", "./radar/RadarView", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../coord/radar/Radar');
  $__require('../coord/radar/RadarModel');
  $__require('./radar/RadarView');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/radar/RadarSeries.js", ["../../model/Series", "../../data/List", "../../data/helper/completeDimensions", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SeriesModel = $__require('../../model/Series');
  var List = $__require('../../data/List');
  var completeDimensions = $__require('../../data/helper/completeDimensions');
  var zrUtil = $__require('zrender/lib/core/util');
  var RadarSeries = SeriesModel.extend({
    type: 'series.radar',
    dependencies: ['radar'],
    init: function(option) {
      RadarSeries.superApply(this, 'init', arguments);
      this.legendDataProvider = function() {
        return this._dataBeforeProcessed;
      };
    },
    getInitialData: function(option, ecModel) {
      var data = option.data || [];
      var dimensions = completeDimensions([], data, [], 'indicator_');
      var list = new List(dimensions, this);
      list.initData(data);
      return list;
    },
    formatTooltip: function(dataIndex) {
      var value = this.getRawValue(dataIndex);
      var coordSys = this.coordinateSystem;
      var indicatorAxes = coordSys.getIndicatorAxes();
      return (this._data.getName(dataIndex) == '' ? this.name : this._data.getName(dataIndex)) + '<br/>' + zrUtil.map(indicatorAxes, function(axis, idx) {
        return axis.name + ' : ' + value[idx];
      }).join('<br />');
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'radar',
      legendHoverLink: true,
      radarIndex: 0,
      lineStyle: {normal: {
          width: 2,
          type: 'solid'
        }},
      label: {normal: {position: 'top'}},
      symbol: 'emptyCircle',
      symbolSize: 4
    }
  });
  module.exports = RadarSeries;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/radar/RadarView.js", ["../../util/graphic", "zrender/lib/core/util", "../../util/symbol", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var zrUtil = $__require('zrender/lib/core/util');
  var symbolUtil = $__require('../../util/symbol');
  function normalizeSymbolSize(symbolSize) {
    if (!zrUtil.isArray(symbolSize)) {
      symbolSize = [+symbolSize, +symbolSize];
    }
    return symbolSize;
  }
  module.exports = $__require('../../echarts').extendChartView({
    type: 'radar',
    render: function(seriesModel, ecModel, api) {
      var polar = seriesModel.coordinateSystem;
      var group = this.group;
      var data = seriesModel.getData();
      var oldData = this._data;
      function createSymbol(data, idx) {
        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
        var color = data.getItemVisual(idx, 'color');
        if (symbolType === 'none') {
          return;
        }
        var symbolPath = symbolUtil.createSymbol(symbolType, -0.5, -0.5, 1, 1, color);
        symbolPath.attr({
          style: {strokeNoScale: true},
          z2: 100,
          scale: normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'))
        });
        return symbolPath;
      }
      function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {
        symbolGroup.removeAll();
        for (var i = 0; i < newPoints.length - 1; i++) {
          var symbolPath = createSymbol(data, idx);
          if (symbolPath) {
            symbolPath.__dimIdx = i;
            if (oldPoints[i]) {
              symbolPath.attr('position', oldPoints[i]);
              graphic[isInit ? 'initProps' : 'updateProps'](symbolPath, {position: newPoints[i]}, seriesModel, idx);
            } else {
              symbolPath.attr('position', newPoints[i]);
            }
            symbolGroup.add(symbolPath);
          }
        }
      }
      function getInitialPoints(points) {
        return zrUtil.map(points, function(pt) {
          return [polar.cx, polar.cy];
        });
      }
      data.diff(oldData).add(function(idx) {
        var points = data.getItemLayout(idx);
        if (!points) {
          return;
        }
        var polygon = new graphic.Polygon();
        var polyline = new graphic.Polyline();
        var target = {shape: {points: points}};
        polygon.shape.points = getInitialPoints(points);
        polyline.shape.points = getInitialPoints(points);
        graphic.initProps(polygon, target, seriesModel, idx);
        graphic.initProps(polyline, target, seriesModel, idx);
        var itemGroup = new graphic.Group();
        var symbolGroup = new graphic.Group();
        itemGroup.add(polyline);
        itemGroup.add(polygon);
        itemGroup.add(symbolGroup);
        updateSymbols(polyline.shape.points, points, symbolGroup, data, idx, true);
        data.setItemGraphicEl(idx, itemGroup);
      }).update(function(newIdx, oldIdx) {
        var itemGroup = oldData.getItemGraphicEl(oldIdx);
        var polyline = itemGroup.childAt(0);
        var polygon = itemGroup.childAt(1);
        var symbolGroup = itemGroup.childAt(2);
        var target = {shape: {points: data.getItemLayout(newIdx)}};
        if (!target.shape.points) {
          return;
        }
        updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
        graphic.updateProps(polyline, target, seriesModel);
        graphic.updateProps(polygon, target, seriesModel);
        data.setItemGraphicEl(newIdx, itemGroup);
      }).remove(function(idx) {
        group.remove(oldData.getItemGraphicEl(idx));
      }).execute();
      data.eachItemGraphicEl(function(itemGroup, idx) {
        var itemModel = data.getItemModel(idx);
        var polyline = itemGroup.childAt(0);
        var polygon = itemGroup.childAt(1);
        var symbolGroup = itemGroup.childAt(2);
        var color = data.getItemVisual(idx, 'color');
        group.add(itemGroup);
        polyline.useStyle(zrUtil.defaults(itemModel.getModel('lineStyle.normal').getLineStyle(), {
          fill: 'none',
          stroke: color
        }));
        polyline.hoverStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();
        var areaStyleModel = itemModel.getModel('areaStyle.normal');
        var hoverAreaStyleModel = itemModel.getModel('areaStyle.emphasis');
        var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
        var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();
        hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;
        polygon.ignore = polygonIgnore;
        polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
          fill: color,
          opacity: 0.7
        }));
        polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();
        var itemStyle = itemModel.getModel('itemStyle.normal').getItemStyle(['color']);
        var itemHoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle();
        var labelModel = itemModel.getModel('label.normal');
        var labelHoverModel = itemModel.getModel('label.emphasis');
        symbolGroup.eachChild(function(symbolPath) {
          symbolPath.setStyle(itemStyle);
          symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);
          var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);
          graphic.setText(symbolPath.style, labelModel, color);
          symbolPath.setStyle({text: labelModel.get('show') ? zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal', null, symbolPath.__dimIdx), defaultText) : ''});
          graphic.setText(symbolPath.hoverStyle, labelHoverModel, color);
          symbolPath.hoverStyle.text = labelHoverModel.get('show') ? zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis', null, symbolPath.__dimIdx), defaultText) : '';
        });
        function onEmphasis() {
          polygon.attr('ignore', hoverPolygonIgnore);
        }
        function onNormal() {
          polygon.attr('ignore', polygonIgnore);
        }
        itemGroup.off('mouseover').off('mouseout').off('normal').off('emphasis');
        itemGroup.on('emphasis', onEmphasis).on('mouseover', onEmphasis).on('normal', onNormal).on('mouseout', onNormal);
        graphic.setHoverStyle(itemGroup);
      });
      this._data = data;
    },
    remove: function() {
      this.group.removeAll();
      this._data = null;
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/radar/radarLayout.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(ecModel) {
    ecModel.eachSeriesByType('radar', function(seriesModel) {
      var data = seriesModel.getData();
      var points = [];
      var coordSys = seriesModel.coordinateSystem;
      if (!coordSys) {
        return;
      }
      function pointsConverter(val, idx) {
        points[idx] = points[idx] || [];
        points[idx][i] = coordSys.dataToPoint(val, i);
      }
      for (var i = 0; i < coordSys.getIndicatorAxes().length; i++) {
        var dim = data.dimensions[i];
        data.each(dim, pointsConverter);
      }
      data.each(function(idx) {
        points[idx][0] && points[idx].push(points[idx][0].slice());
        data.setItemLayout(idx, points[idx]);
      });
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/radar/backwardCompat.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  module.exports = function(option) {
    var polarOptArr = option.polar;
    if (polarOptArr) {
      if (!zrUtil.isArray(polarOptArr)) {
        polarOptArr = [polarOptArr];
      }
      var polarNotRadar = [];
      zrUtil.each(polarOptArr, function(polarOpt, idx) {
        if (polarOpt.indicator) {
          if (polarOpt.type && !polarOpt.shape) {
            polarOpt.shape = polarOpt.type;
          }
          option.radar = option.radar || [];
          if (!zrUtil.isArray(option.radar)) {
            option.radar = [option.radar];
          }
          option.radar.push(polarOpt);
        } else {
          polarNotRadar.push(polarOpt);
        }
      });
      option.polar = polarNotRadar;
    }
    zrUtil.each(option.series, function(seriesOpt) {
      if (seriesOpt.type === 'radar' && seriesOpt.polarIndex) {
        seriesOpt.radarIndex = seriesOpt.polarIndex;
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/radar.js", ["zrender/lib/core/util", "../echarts", "../component/radar", "./radar/RadarSeries", "./radar/RadarView", "../visual/dataColor", "../visual/symbol", "./radar/radarLayout", "../processor/dataFilter", "./radar/backwardCompat", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var echarts = $__require('../echarts');
  $__require('../component/radar');
  $__require('./radar/RadarSeries');
  $__require('./radar/RadarView');
  echarts.registerVisual(zrUtil.curry($__require('../visual/dataColor'), 'radar'));
  echarts.registerVisual(zrUtil.curry($__require('../visual/symbol'), 'radar', 'circle', null));
  echarts.registerLayout($__require('./radar/radarLayout'));
  echarts.registerProcessor(zrUtil.curry($__require('../processor/dataFilter'), 'radar'));
  echarts.registerPreprocessor($__require('./radar/backwardCompat'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/map/MapSeries.js", ["../../data/List", "../../model/Series", "zrender/lib/core/util", "../../data/helper/completeDimensions", "../../util/format", "../../component/helper/selectableMixin", "../../coord/geo/geoCreator", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var List = $__require('../../data/List');
  var SeriesModel = $__require('../../model/Series');
  var zrUtil = $__require('zrender/lib/core/util');
  var completeDimensions = $__require('../../data/helper/completeDimensions');
  var formatUtil = $__require('../../util/format');
  var encodeHTML = formatUtil.encodeHTML;
  var addCommas = formatUtil.addCommas;
  var dataSelectableMixin = $__require('../../component/helper/selectableMixin');
  var geoCreator = $__require('../../coord/geo/geoCreator');
  var MapSeries = SeriesModel.extend({
    type: 'series.map',
    layoutMode: 'box',
    needsDrawMap: false,
    seriesGroup: [],
    init: function(option) {
      option = this._fillOption(option, option.map);
      this.option = option;
      MapSeries.superApply(this, 'init', arguments);
      this.updateSelectedMap(option.data);
    },
    getInitialData: function(option) {
      var dimensions = completeDimensions(['value'], option.data || []);
      var list = new List(dimensions, this);
      list.initData(option.data);
      return list;
    },
    mergeOption: function(newOption) {
      if (newOption.data) {
        newOption = this._fillOption(newOption, this.option.map);
      }
      MapSeries.superCall(this, 'mergeOption', newOption);
      this.updateSelectedMap(this.option.data);
    },
    _fillOption: function(option, mapName) {
      option = zrUtil.extend({}, option);
      option.data = geoCreator.getFilledRegions(option.data, mapName);
      return option;
    },
    getRawValue: function(dataIndex) {
      return this._data.get('value', dataIndex);
    },
    getRegionModel: function(regionName) {
      var data = this.getData();
      return data.getItemModel(data.indexOfName(regionName));
    },
    formatTooltip: function(dataIndex) {
      var data = this.getData();
      var formattedValue = addCommas(this.getRawValue(dataIndex));
      var name = data.getName(dataIndex);
      var seriesGroup = this.seriesGroup;
      var seriesNames = [];
      for (var i = 0; i < seriesGroup.length; i++) {
        var otherIndex = seriesGroup[i].originalData.indexOfName(name);
        if (!isNaN(seriesGroup[i].originalData.get('value', otherIndex))) {
          seriesNames.push(encodeHTML(seriesGroup[i].name));
        }
      }
      return seriesNames.join(', ') + '<br />' + name + ' : ' + formattedValue;
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'geo',
      map: 'china',
      left: 'center',
      top: 'center',
      aspectScale: 0.75,
      showLegendSymbol: true,
      dataRangeHoverLink: true,
      center: null,
      zoom: 1,
      scaleLimit: null,
      label: {
        normal: {
          show: false,
          textStyle: {color: '#000'}
        },
        emphasis: {
          show: true,
          textStyle: {color: 'rgb(100,0,0)'}
        }
      },
      itemStyle: {
        normal: {
          borderWidth: 0.5,
          borderColor: '#444',
          areaColor: '#eee'
        },
        emphasis: {areaColor: 'rgba(255,215,0,0.8)'}
      }
    },
    setZoom: function(zoom) {
      this.option.zoom = zoom;
    },
    setCenter: function(center) {
      this.option.center = center;
    }
  });
  zrUtil.mixin(MapSeries, dataSelectableMixin);
  module.exports = MapSeries;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/map/MapView.js", ["../../util/graphic", "../../component/helper/MapDraw", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var MapDraw = $__require('../../component/helper/MapDraw');
  $__require('../../echarts').extendChartView({
    type: 'map',
    render: function(mapModel, ecModel, api, payload) {
      if (payload && payload.type === 'mapToggleSelect' && payload.from === this.uid) {
        return;
      }
      var group = this.group;
      group.removeAll();
      if (!(payload && payload.type === 'geoRoam' && payload.component === 'series' && payload.name === mapModel.name)) {
        if (mapModel.needsDrawMap) {
          var mapDraw = this._mapDraw || new MapDraw(api, true);
          group.add(mapDraw.group);
          mapDraw.draw(mapModel, ecModel, api, this, payload);
          this._mapDraw = mapDraw;
        } else {
          this._mapDraw && this._mapDraw.remove();
          this._mapDraw = null;
        }
      } else {
        var mapDraw = this._mapDraw;
        mapDraw && group.add(mapDraw.group);
      }
      mapModel.get('showLegendSymbol') && ecModel.getComponent('legend') && this._renderSymbols(mapModel, ecModel, api);
    },
    remove: function() {
      this._mapDraw && this._mapDraw.remove();
      this._mapDraw = null;
      this.group.removeAll();
    },
    _renderSymbols: function(mapModel, ecModel, api) {
      var originalData = mapModel.originalData;
      var group = this.group;
      originalData.each('value', function(value, idx) {
        if (isNaN(value)) {
          return;
        }
        var layout = originalData.getItemLayout(idx);
        if (!layout || !layout.point) {
          return;
        }
        var point = layout.point;
        var offset = layout.offset;
        var circle = new graphic.Circle({
          style: {fill: mapModel.getData().getVisual('color')},
          shape: {
            cx: point[0] + offset * 9,
            cy: point[1],
            r: 3
          },
          silent: true,
          z2: 10
        });
        if (!offset) {
          var fullData = mapModel.mainSeries.getData();
          var name = originalData.getName(idx);
          var labelText = name;
          var fullIndex = fullData.indexOfName(name);
          var itemModel = originalData.getItemModel(idx);
          var labelModel = itemModel.getModel('label.normal');
          var hoverLabelModel = itemModel.getModel('label.emphasis');
          var textStyleModel = labelModel.getModel('textStyle');
          var hoverTextStyleModel = hoverLabelModel.getModel('textStyle');
          var polygonGroups = fullData.getItemGraphicEl(fullIndex);
          circle.setStyle({textPosition: 'bottom'});
          var onEmphasis = function() {
            circle.setStyle({
              text: hoverLabelModel.get('show') ? labelText : '',
              textFill: hoverTextStyleModel.getTextColor(),
              textFont: hoverTextStyleModel.getFont()
            });
          };
          var onNormal = function() {
            circle.setStyle({
              text: labelModel.get('show') ? labelText : '',
              textFill: textStyleModel.getTextColor(),
              textFont: textStyleModel.getFont()
            });
          };
          polygonGroups.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);
          onNormal();
        }
        group.add(circle);
      });
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/map/mapSymbolLayout.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  module.exports = function(ecModel) {
    var processedMapType = {};
    ecModel.eachSeriesByType('map', function(mapSeries) {
      var mapType = mapSeries.get('map');
      if (processedMapType[mapType]) {
        return;
      }
      var mapSymbolOffsets = {};
      zrUtil.each(mapSeries.seriesGroup, function(subMapSeries) {
        var geo = subMapSeries.coordinateSystem;
        var data = subMapSeries.originalData;
        if (subMapSeries.get('showLegendSymbol') && ecModel.getComponent('legend')) {
          data.each('value', function(value, idx) {
            var name = data.getName(idx);
            var region = geo.getRegion(name);
            if (!region || isNaN(value)) {
              return;
            }
            var offset = mapSymbolOffsets[name] || 0;
            var point = geo.dataToPoint(region.center);
            mapSymbolOffsets[name] = offset + 1;
            data.setItemLayout(idx, {
              point: point,
              offset: offset
            });
          });
        }
      });
      var data = mapSeries.getData();
      data.each(function(idx) {
        var name = data.getName(idx);
        var layout = data.getItemLayout(idx) || {};
        layout.showLabel = !mapSymbolOffsets[name];
        data.setItemLayout(idx, layout);
      });
      processedMapType[mapType] = true;
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/map/mapVisual.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(ecModel) {
    ecModel.eachSeriesByType('map', function(seriesModel) {
      var colorList = seriesModel.get('color');
      var itemStyleModel = seriesModel.getModel('itemStyle.normal');
      var areaColor = itemStyleModel.get('areaColor');
      var color = itemStyleModel.get('color') || colorList[seriesModel.seriesIndex % colorList.length];
      seriesModel.getData().setVisual({
        'areaColor': areaColor,
        'color': color
      });
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/map/mapDataStatistic.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  function dataStatistics(datas, statisticType) {
    var dataNameMap = {};
    var dims = ['value'];
    for (var i = 0; i < datas.length; i++) {
      datas[i].each(dims, function(value, idx) {
        var name = datas[i].getName(idx);
        dataNameMap[name] = dataNameMap[name] || [];
        if (!isNaN(value)) {
          dataNameMap[name].push(value);
        }
      });
    }
    return datas[0].map(dims, function(value, idx) {
      var name = datas[0].getName(idx);
      var sum = 0;
      var min = Infinity;
      var max = -Infinity;
      var len = dataNameMap[name].length;
      for (var i = 0; i < len; i++) {
        min = Math.min(min, dataNameMap[name][i]);
        max = Math.max(max, dataNameMap[name][i]);
        sum += dataNameMap[name][i];
      }
      var result;
      if (statisticType === 'min') {
        result = min;
      } else if (statisticType === 'max') {
        result = max;
      } else if (statisticType === 'average') {
        result = sum / len;
      } else {
        result = sum;
      }
      return len === 0 ? NaN : result;
    });
  }
  module.exports = function(ecModel) {
    var seriesGroupByMapType = {};
    ecModel.eachSeriesByType('map', function(seriesModel) {
      var mapType = seriesModel.get('map');
      seriesGroupByMapType[mapType] = seriesGroupByMapType[mapType] || [];
      seriesGroupByMapType[mapType].push(seriesModel);
    });
    zrUtil.each(seriesGroupByMapType, function(seriesList, mapType) {
      var data = dataStatistics(zrUtil.map(seriesList, function(seriesModel) {
        return seriesModel.getData();
      }), seriesList[0].get('mapValueCalculation'));
      for (var i = 0; i < seriesList.length; i++) {
        seriesList[i].originalData = seriesList[i].getData();
      }
      for (var i = 0; i < seriesList.length; i++) {
        seriesList[i].seriesGroup = seriesList;
        seriesList[i].needsDrawMap = i === 0;
        seriesList[i].setData(data.cloneShallow());
        seriesList[i].mainSeries = seriesList[0];
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/map/backwardCompat.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  module.exports = function(option) {
    var mapSeries = [];
    zrUtil.each(option.series, function(seriesOpt) {
      if (seriesOpt.type === 'map') {
        mapSeries.push(seriesOpt);
      }
    });
    zrUtil.each(mapSeries, function(seriesOpt) {
      seriesOpt.map = seriesOpt.map || seriesOpt.mapType;
      zrUtil.defaults(seriesOpt, seriesOpt.mapLocation);
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/action/createDataSelectAction.js", ["../echarts", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../echarts');
  var zrUtil = $__require('zrender/lib/core/util');
  module.exports = function(seriesType, actionInfos) {
    zrUtil.each(actionInfos, function(actionInfo) {
      actionInfo.update = 'updateView';
      echarts.registerAction(actionInfo, function(payload, ecModel) {
        var selected = {};
        ecModel.eachComponent({
          mainType: 'series',
          subType: seriesType,
          query: payload
        }, function(seriesModel) {
          if (seriesModel[actionInfo.method]) {
            seriesModel[actionInfo.method](payload.name);
          }
          var data = seriesModel.getData();
          data.each(function(idx) {
            var name = data.getName(idx);
            selected[name] = seriesModel.isSelected(name) || false;
          });
        });
        return {
          name: payload.name,
          selected: selected
        };
      });
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/map.js", ["../echarts", "./map/MapSeries", "./map/MapView", "../action/geoRoam", "../coord/geo/geoCreator", "./map/mapSymbolLayout", "./map/mapVisual", "./map/mapDataStatistic", "./map/backwardCompat", "../action/createDataSelectAction", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../echarts');
  var PRIORITY = echarts.PRIORITY;
  $__require('./map/MapSeries');
  $__require('./map/MapView');
  $__require('../action/geoRoam');
  $__require('../coord/geo/geoCreator');
  echarts.registerLayout($__require('./map/mapSymbolLayout'));
  echarts.registerVisual($__require('./map/mapVisual'));
  echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, $__require('./map/mapDataStatistic'));
  echarts.registerPreprocessor($__require('./map/backwardCompat'));
  $__require('../action/createDataSelectAction')('map', [{
    type: 'mapToggleSelect',
    event: 'mapselectchanged',
    method: 'toggleSelected'
  }, {
    type: 'mapSelect',
    event: 'mapselected',
    method: 'select'
  }, {
    type: 'mapUnSelect',
    event: 'mapunselected',
    method: 'unSelect'
  }]);
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/data/Tree.js", ["zrender/lib/core/util", "../model/Model", "./List", "./helper/linkList", "./helper/completeDimensions", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Model = $__require('../model/Model');
  var List = $__require('./List');
  var linkList = $__require('./helper/linkList');
  var completeDimensions = $__require('./helper/completeDimensions');
  var TreeNode = function(name, hostTree) {
    this.name = name || '';
    this.depth = 0;
    this.height = 0;
    this.parentNode = null;
    this.dataIndex = -1;
    this.children = [];
    this.viewChildren = [];
    this.hostTree = hostTree;
  };
  TreeNode.prototype = {
    constructor: TreeNode,
    isRemoved: function() {
      return this.dataIndex < 0;
    },
    eachNode: function(options, cb, context) {
      if (typeof options === 'function') {
        context = cb;
        cb = options;
        options = null;
      }
      options = options || {};
      if (zrUtil.isString(options)) {
        options = {order: options};
      }
      var order = options.order || 'preorder';
      var children = this[options.attr || 'children'];
      var suppressVisitSub;
      order === 'preorder' && (suppressVisitSub = cb.call(context, this));
      for (var i = 0; !suppressVisitSub && i < children.length; i++) {
        children[i].eachNode(options, cb, context);
      }
      order === 'postorder' && cb.call(context, this);
    },
    updateDepthAndHeight: function(depth) {
      var height = 0;
      this.depth = depth;
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        child.updateDepthAndHeight(depth + 1);
        if (child.height > height) {
          height = child.height;
        }
      }
      this.height = height + 1;
    },
    getNodeById: function(id) {
      if (this.getId() === id) {
        return this;
      }
      for (var i = 0,
          children = this.children,
          len = children.length; i < len; i++) {
        var res = children[i].getNodeById(id);
        if (res) {
          return res;
        }
      }
    },
    contains: function(node) {
      if (node === this) {
        return true;
      }
      for (var i = 0,
          children = this.children,
          len = children.length; i < len; i++) {
        var res = children[i].contains(node);
        if (res) {
          return res;
        }
      }
    },
    getAncestors: function(includeSelf) {
      var ancestors = [];
      var node = includeSelf ? this : this.parentNode;
      while (node) {
        ancestors.push(node);
        node = node.parentNode;
      }
      ancestors.reverse();
      return ancestors;
    },
    getValue: function(dimension) {
      var data = this.hostTree.data;
      return data.get(data.getDimension(dimension || 'value'), this.dataIndex);
    },
    setLayout: function(layout, merge) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);
    },
    getLayout: function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    },
    getModel: function(path) {
      if (this.dataIndex < 0) {
        return;
      }
      var hostTree = this.hostTree;
      var itemModel = hostTree.data.getItemModel(this.dataIndex);
      var levelModel = this.getLevelModel();
      return itemModel.getModel(path, (levelModel || hostTree.hostModel).getModel(path));
    },
    getLevelModel: function() {
      return (this.hostTree.levelModels || [])[this.depth];
    },
    setVisual: function(key, value) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
    },
    getVisual: function(key, ignoreParent) {
      return this.hostTree.data.getItemVisual(this.dataIndex, key, ignoreParent);
    },
    getRawIndex: function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    },
    getId: function() {
      return this.hostTree.data.getId(this.dataIndex);
    }
  };
  function Tree(hostModel, levelOptions) {
    this.root;
    this.data;
    this._nodes = [];
    this.hostModel = hostModel;
    this.levelModels = zrUtil.map(levelOptions || [], function(levelDefine) {
      return new Model(levelDefine, hostModel, hostModel.ecModel);
    });
  }
  Tree.prototype = {
    constructor: Tree,
    type: 'tree',
    eachNode: function(options, cb, context) {
      this.root.eachNode(options, cb, context);
    },
    getNodeByDataIndex: function(dataIndex) {
      var rawIndex = this.data.getRawIndex(dataIndex);
      return this._nodes[rawIndex];
    },
    getNodeByName: function(name) {
      return this.root.getNodeByName(name);
    },
    update: function() {
      var data = this.data;
      var nodes = this._nodes;
      for (var i = 0,
          len = nodes.length; i < len; i++) {
        nodes[i].dataIndex = -1;
      }
      for (var i = 0,
          len = data.count(); i < len; i++) {
        nodes[data.getRawIndex(i)].dataIndex = i;
      }
    },
    clearLayouts: function() {
      this.data.clearItemLayouts();
    }
  };
  Tree.createTree = function(dataRoot, hostModel, levelOptions) {
    var tree = new Tree(hostModel, levelOptions);
    var listData = [];
    buildHierarchy(dataRoot);
    function buildHierarchy(dataNode, parentNode) {
      listData.push(dataNode);
      var node = new TreeNode(dataNode.name, tree);
      parentNode ? addChild(node, parentNode) : (tree.root = node);
      tree._nodes.push(node);
      var children = dataNode.children;
      if (children) {
        for (var i = 0; i < children.length; i++) {
          buildHierarchy(children[i], node);
        }
      }
    }
    tree.root.updateDepthAndHeight(0);
    var dimensions = completeDimensions([{name: 'value'}], listData);
    var list = new List(dimensions, hostModel);
    list.initData(listData);
    linkList({
      mainData: list,
      struct: tree,
      structAttr: 'tree'
    });
    tree.update();
    return tree;
  };
  function addChild(child, node) {
    var children = node.children;
    if (child.parentNode === node) {
      return;
    }
    children.push(child);
    child.parentNode = node;
  }
  module.exports = Tree;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/treemap/TreemapSeries.js", ["../../model/Series", "../../data/Tree", "zrender/lib/core/util", "../../model/Model", "../../util/format", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SeriesModel = $__require('../../model/Series');
  var Tree = $__require('../../data/Tree');
  var zrUtil = $__require('zrender/lib/core/util');
  var Model = $__require('../../model/Model');
  var formatUtil = $__require('../../util/format');
  var encodeHTML = formatUtil.encodeHTML;
  var addCommas = formatUtil.addCommas;
  module.exports = SeriesModel.extend({
    type: 'series.treemap',
    dependencies: ['grid', 'polar'],
    _viewRoot: null,
    defaultOption: {
      progressive: 0,
      hoverLayerThreshold: Infinity,
      left: 'center',
      top: 'middle',
      right: null,
      bottom: null,
      width: '80%',
      height: '80%',
      sort: true,
      clipWindow: 'origin',
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: '',
      visualDimension: 0,
      zoomToNodeRatio: 0.32 * 0.32,
      roam: true,
      nodeClick: 'zoomToNode',
      animation: true,
      animationDurationUpdate: 900,
      animationEasing: 'quinticInOut',
      breadcrumb: {
        show: true,
        height: 22,
        left: 'center',
        top: 'bottom',
        emptyItemWidth: 25,
        itemStyle: {
          normal: {
            color: 'rgba(0,0,0,0.7)',
            borderColor: 'rgba(255,255,255,0.7)',
            borderWidth: 1,
            shadowColor: 'rgba(150,150,150,1)',
            shadowBlur: 3,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            textStyle: {color: '#fff'}
          },
          emphasis: {textStyle: {}}
        }
      },
      label: {normal: {
          show: true,
          position: 'inside',
          textStyle: {
            color: '#fff',
            ellipsis: true
          }
        }},
      itemStyle: {
        normal: {
          color: null,
          colorAlpha: null,
          colorSaturation: null,
          borderWidth: 0,
          gapWidth: 0,
          borderColor: '#fff',
          borderColorSaturation: null
        },
        emphasis: {}
      },
      color: [],
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: 'index',
      visibleMin: 10,
      childrenVisibleMin: null,
      levels: []
    },
    getInitialData: function(option, ecModel) {
      var data = option.data || [];
      var rootName = option.name;
      rootName == null && (rootName = option.name);
      var root = {
        name: rootName,
        children: option.data
      };
      var value0 = (data[0] || {}).value;
      completeTreeValue(root, zrUtil.isArray(value0) ? value0.length : -1);
      var levels = option.levels || [];
      levels = option.levels = setDefault(levels, ecModel);
      return Tree.createTree(root, this, levels).data;
    },
    optionUpdated: function() {
      this.resetViewRoot();
    },
    formatTooltip: function(dataIndex) {
      var data = this.getData();
      var value = this.getRawValue(dataIndex);
      var formattedValue = zrUtil.isArray(value) ? addCommas(value[0]) : addCommas(value);
      var name = data.getName(dataIndex);
      return encodeHTML(name) + ': ' + formattedValue;
    },
    getDataParams: function(dataIndex) {
      var params = SeriesModel.prototype.getDataParams.apply(this, arguments);
      var data = this.getData();
      var node = data.tree.getNodeByDataIndex(dataIndex);
      var treePathInfo = params.treePathInfo = [];
      while (node) {
        var nodeDataIndex = node.dataIndex;
        treePathInfo.push({
          name: node.name,
          dataIndex: nodeDataIndex,
          value: this.getRawValue(nodeDataIndex)
        });
        node = node.parentNode;
      }
      treePathInfo.reverse();
      return params;
    },
    setLayoutInfo: function(layoutInfo) {
      this.layoutInfo = this.layoutInfo || {};
      zrUtil.extend(this.layoutInfo, layoutInfo);
    },
    mapIdToIndex: function(id) {
      var idIndexMap = this._idIndexMap;
      if (!idIndexMap) {
        idIndexMap = this._idIndexMap = {};
        this._idIndexMapCount = 0;
      }
      var index = idIndexMap[id];
      if (index == null) {
        idIndexMap[id] = index = this._idIndexMapCount++;
      }
      return index;
    },
    getViewRoot: function() {
      return this._viewRoot;
    },
    resetViewRoot: function(viewRoot) {
      viewRoot ? (this._viewRoot = viewRoot) : (viewRoot = this._viewRoot);
      var root = this.getData().tree.root;
      if (!viewRoot || (viewRoot !== root && !root.contains(viewRoot))) {
        this._viewRoot = root;
      }
    }
  });
  function completeTreeValue(dataNode, arrValueLength) {
    var sum = 0;
    zrUtil.each(dataNode.children, function(child) {
      completeTreeValue(child, arrValueLength);
      var childValue = child.value;
      zrUtil.isArray(childValue) && (childValue = childValue[0]);
      sum += childValue;
    });
    var thisValue = dataNode.value;
    if (arrValueLength >= 0) {
      if (!zrUtil.isArray(thisValue)) {
        dataNode.value = new Array(arrValueLength);
      } else {
        thisValue = thisValue[0];
      }
    }
    if (thisValue == null || isNaN(thisValue)) {
      thisValue = sum;
    }
    if (thisValue < 0) {
      thisValue = 0;
    }
    arrValueLength >= 0 ? (dataNode.value[0] = thisValue) : (dataNode.value = thisValue);
  }
  function setDefault(levels, ecModel) {
    var globalColorList = ecModel.get('color');
    if (!globalColorList) {
      return;
    }
    levels = levels || [];
    var hasColorDefine;
    zrUtil.each(levels, function(levelDefine) {
      var model = new Model(levelDefine);
      var modelColor = model.get('color');
      if (model.get('itemStyle.normal.color') || (modelColor && modelColor !== 'none')) {
        hasColorDefine = true;
      }
    });
    if (!hasColorDefine) {
      var level0 = levels[0] || (levels[0] = {});
      level0.color = globalColorList.slice();
    }
    return levels;
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/treemap/Breadcrumb.js", ["../../util/graphic", "../../util/layout", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var layout = $__require('../../util/layout');
  var zrUtil = $__require('zrender/lib/core/util');
  var TEXT_PADDING = 8;
  var ITEM_GAP = 8;
  var ARRAY_LENGTH = 5;
  function Breadcrumb(containerGroup, onSelect) {
    this.group = new graphic.Group();
    containerGroup.add(this.group);
    this._onSelect = onSelect || zrUtil.noop;
  }
  Breadcrumb.prototype = {
    constructor: Breadcrumb,
    render: function(seriesModel, api, targetNode) {
      var model = seriesModel.getModel('breadcrumb');
      var thisGroup = this.group;
      thisGroup.removeAll();
      if (!model.get('show') || !targetNode) {
        return;
      }
      var normalStyleModel = model.getModel('itemStyle.normal');
      var textStyleModel = normalStyleModel.getModel('textStyle');
      var layoutParam = {
        pos: {
          left: model.get('left'),
          right: model.get('right'),
          top: model.get('top'),
          bottom: model.get('bottom')
        },
        box: {
          width: api.getWidth(),
          height: api.getHeight()
        },
        emptyItemWidth: model.get('emptyItemWidth'),
        totalWidth: 0,
        renderList: []
      };
      this._prepare(model, targetNode, layoutParam, textStyleModel);
      this._renderContent(model, targetNode, layoutParam, normalStyleModel, textStyleModel);
      layout.positionGroup(thisGroup, layoutParam.pos, layoutParam.box);
    },
    _prepare: function(model, targetNode, layoutParam, textStyleModel) {
      for (var node = targetNode; node; node = node.parentNode) {
        var text = node.getModel().get('name');
        var textRect = textStyleModel.getTextRect(text);
        var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
        layoutParam.totalWidth += itemWidth + ITEM_GAP;
        layoutParam.renderList.push({
          node: node,
          text: text,
          width: itemWidth
        });
      }
    },
    _renderContent: function(model, targetNode, layoutParam, normalStyleModel, textStyleModel) {
      var lastX = 0;
      var emptyItemWidth = layoutParam.emptyItemWidth;
      var height = model.get('height');
      var availableSize = layout.getAvailableSize(layoutParam.pos, layoutParam.box);
      var totalWidth = layoutParam.totalWidth;
      var renderList = layoutParam.renderList;
      for (var i = renderList.length - 1; i >= 0; i--) {
        var item = renderList[i];
        var itemWidth = item.width;
        var text = item.text;
        if (totalWidth > availableSize.width) {
          totalWidth -= itemWidth - emptyItemWidth;
          itemWidth = emptyItemWidth;
          text = '';
        }
        this.group.add(new graphic.Polygon({
          shape: {points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)},
          style: zrUtil.defaults(normalStyleModel.getItemStyle(), {
            lineJoin: 'bevel',
            text: text,
            textFill: textStyleModel.getTextColor(),
            textFont: textStyleModel.getFont()
          }),
          z: 10,
          onclick: zrUtil.bind(this._onSelect, this, item.node)
        }));
        lastX += itemWidth + ITEM_GAP;
      }
    },
    remove: function() {
      this.group.removeAll();
    }
  };
  function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
    var points = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]];
    !tail && points.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);
    !head && points.push([x, y + itemHeight / 2]);
    return points;
  }
  module.exports = Breadcrumb;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/util/animation.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  function createWrap() {
    var storage = [];
    var elExistsMap = {};
    var doneCallback;
    return {
      add: function(el, target, time, delay, easing) {
        if (zrUtil.isString(delay)) {
          easing = delay;
          delay = 0;
        }
        if (elExistsMap[el.id]) {
          return false;
        }
        elExistsMap[el.id] = 1;
        storage.push({
          el: el,
          target: target,
          time: time,
          delay: delay,
          easing: easing
        });
        return true;
      },
      done: function(callback) {
        doneCallback = callback;
        return this;
      },
      start: function() {
        var count = storage.length;
        for (var i = 0,
            len = storage.length; i < len; i++) {
          var item = storage[i];
          item.el.animateTo(item.target, item.time, item.delay, item.easing, done);
        }
        return this;
        function done() {
          count--;
          if (!count) {
            storage.length = 0;
            elExistsMap = {};
            doneCallback && doneCallback();
          }
        }
      }
    };
  }
  module.exports = {createWrap: createWrap};
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/treemap/TreemapView.js", ["zrender/lib/core/util", "../../util/graphic", "../../data/DataDiffer", "./helper", "./Breadcrumb", "../../component/helper/RoamController", "zrender/lib/core/BoundingRect", "zrender/lib/core/matrix", "../../util/animation", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var DataDiffer = $__require('../../data/DataDiffer');
  var helper = $__require('./helper');
  var Breadcrumb = $__require('./Breadcrumb');
  var RoamController = $__require('../../component/helper/RoamController');
  var BoundingRect = $__require('zrender/lib/core/BoundingRect');
  var matrix = $__require('zrender/lib/core/matrix');
  var animationUtil = $__require('../../util/animation');
  var bind = zrUtil.bind;
  var Group = graphic.Group;
  var Rect = graphic.Rect;
  var each = zrUtil.each;
  var DRAG_THRESHOLD = 3;
  var PATH_LABEL_NORMAL = ['label', 'normal'];
  var PATH_LABEL_EMPHASIS = ['label', 'emphasis'];
  var Z_BASE = 10;
  var Z_BG = 1;
  var Z_CONTENT = 2;
  module.exports = $__require('../../echarts').extendChartView({
    type: 'treemap',
    init: function(o, api) {
      this._containerGroup;
      this._storage = createStorage();
      this._oldTree;
      this._breadcrumb;
      this._controller;
      this._state = 'ready';
      this._mayClick;
    },
    render: function(seriesModel, ecModel, api, payload) {
      var models = ecModel.findComponents({
        mainType: 'series',
        subType: 'treemap',
        query: payload
      });
      if (zrUtil.indexOf(models, seriesModel) < 0) {
        return;
      }
      this.seriesModel = seriesModel;
      this.api = api;
      this.ecModel = ecModel;
      var targetInfo = helper.retrieveTargetInfo(payload, seriesModel);
      var payloadType = payload && payload.type;
      var layoutInfo = seriesModel.layoutInfo;
      var isInit = !this._oldTree;
      var thisStorage = this._storage;
      var reRoot = (payloadType === 'treemapRootToNode' && targetInfo && thisStorage) ? {
        rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
        direction: payload.direction
      } : null;
      var containerGroup = this._giveContainerGroup(layoutInfo);
      var renderResult = this._doRender(containerGroup, seriesModel, reRoot);
      (!isInit && (!payloadType || payloadType === 'treemapZoomToNode' || payloadType === 'treemapRootToNode')) ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();
      this._resetController(api);
      this._renderBreadcrumb(seriesModel, api, targetInfo);
    },
    _giveContainerGroup: function(layoutInfo) {
      var containerGroup = this._containerGroup;
      if (!containerGroup) {
        containerGroup = this._containerGroup = new Group();
        this._initEvents(containerGroup);
        this.group.add(containerGroup);
      }
      containerGroup.attr('position', [layoutInfo.x, layoutInfo.y]);
      return containerGroup;
    },
    _doRender: function(containerGroup, seriesModel, reRoot) {
      var thisTree = seriesModel.getData().tree;
      var oldTree = this._oldTree;
      var lastsForAnimation = createStorage();
      var thisStorage = createStorage();
      var oldStorage = this._storage;
      var willInvisibleEls = [];
      var doRenderNode = zrUtil.curry(renderNode, seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls);
      dualTravel(thisTree.root ? [thisTree.root] : [], (oldTree && oldTree.root) ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0);
      var willDeleteEls = clearStorage(oldStorage);
      this._oldTree = thisTree;
      this._storage = thisStorage;
      return {
        lastsForAnimation: lastsForAnimation,
        willDeleteEls: willDeleteEls,
        renderFinally: renderFinally
      };
      function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
        if (sameTree) {
          oldViewChildren = thisViewChildren;
          each(thisViewChildren, function(child, index) {
            !child.isRemoved() && processNode(index, index);
          });
        } else {
          (new DataDiffer(oldViewChildren, thisViewChildren, getKey, getKey)).add(processNode).update(processNode).remove(zrUtil.curry(processNode, null)).execute();
        }
        function getKey(node) {
          return node.getId();
        }
        function processNode(newIndex, oldIndex) {
          var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
          var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
          var group = doRenderNode(thisNode, oldNode, parentGroup, depth);
          group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);
        }
      }
      function clearStorage(storage) {
        var willDeleteEls = createStorage();
        storage && each(storage, function(store, storageName) {
          var delEls = willDeleteEls[storageName];
          each(store, function(el) {
            el && (delEls.push(el), el.__tmWillDelete = 1);
          });
        });
        return willDeleteEls;
      }
      function renderFinally() {
        each(willDeleteEls, function(els) {
          each(els, function(el) {
            el.parent && el.parent.remove(el);
          });
        });
        each(willInvisibleEls, function(el) {
          el.invisible = true;
          el.dirty();
        });
      }
    },
    _doAnimation: function(containerGroup, renderResult, seriesModel, reRoot) {
      if (!seriesModel.get('animation')) {
        return;
      }
      var duration = seriesModel.get('animationDurationUpdate');
      var easing = seriesModel.get('animationEasing');
      var animationWrap = animationUtil.createWrap();
      each(renderResult.willDeleteEls, function(store, storageName) {
        each(store, function(el, rawIndex) {
          if (el.invisible) {
            return;
          }
          var parent = el.parent;
          var target;
          if (reRoot && reRoot.direction === 'drillDown') {
            target = parent === reRoot.rootNodeGroup ? {
              shape: {
                x: 0,
                y: 0,
                width: parent.__tmNodeWidth,
                height: parent.__tmNodeHeight
              },
              style: {opacity: 0}
            } : {style: {opacity: 0}};
          } else {
            var targetX = 0;
            var targetY = 0;
            if (!parent.__tmWillDelete) {
              targetX = parent.__tmNodeWidth / 2;
              targetY = parent.__tmNodeHeight / 2;
            }
            target = storageName === 'nodeGroup' ? {
              position: [targetX, targetY],
              style: {opacity: 0}
            } : {
              shape: {
                x: targetX,
                y: targetY,
                width: 0,
                height: 0
              },
              style: {opacity: 0}
            };
          }
          target && animationWrap.add(el, target, duration, easing);
        });
      });
      each(this._storage, function(store, storageName) {
        each(store, function(el, rawIndex) {
          var last = renderResult.lastsForAnimation[storageName][rawIndex];
          var target = {};
          if (!last) {
            return;
          }
          if (storageName === 'nodeGroup') {
            if (last.old) {
              target.position = el.position.slice();
              el.attr('position', last.old);
            }
          } else {
            if (last.old) {
              target.shape = zrUtil.extend({}, el.shape);
              el.setShape(last.old);
            }
            if (last.fadein) {
              el.setStyle('opacity', 0);
              target.style = {opacity: 1};
            } else if (el.style.opacity !== 1) {
              target.style = {opacity: 1};
            }
          }
          animationWrap.add(el, target, duration, easing);
        });
      }, this);
      this._state = 'animating';
      animationWrap.done(bind(function() {
        this._state = 'ready';
        renderResult.renderFinally();
      }, this)).start();
    },
    _resetController: function(api) {
      var controller = this._controller;
      if (!controller) {
        controller = this._controller = new RoamController(api.getZr());
        controller.enable(this.seriesModel.get('roam'));
        controller.on('pan', bind(this._onPan, this));
        controller.on('zoom', bind(this._onZoom, this));
      }
      var rect = new BoundingRect(0, 0, api.getWidth(), api.getHeight());
      controller.rectProvider = function() {
        return rect;
      };
    },
    _clearController: function() {
      var controller = this._controller;
      if (controller) {
        controller.off('pan').off('zoom');
        controller = null;
      }
    },
    _onPan: function(dx, dy) {
      this._mayClick = false;
      if (this._state !== 'animating' && (Math.abs(dx) > DRAG_THRESHOLD || Math.abs(dy) > DRAG_THRESHOLD)) {
        var root = this.seriesModel.getData().tree.root;
        if (!root) {
          return;
        }
        var rootLayout = root.getLayout();
        if (!rootLayout) {
          return;
        }
        this.api.dispatchAction({
          type: 'treemapMove',
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: rootLayout.x + dx,
            y: rootLayout.y + dy,
            width: rootLayout.width,
            height: rootLayout.height
          }
        });
      }
    },
    _onZoom: function(scale, mouseX, mouseY) {
      this._mayClick = false;
      if (this._state !== 'animating') {
        var root = this.seriesModel.getData().tree.root;
        if (!root) {
          return;
        }
        var rootLayout = root.getLayout();
        if (!rootLayout) {
          return;
        }
        var rect = new BoundingRect(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
        var layoutInfo = this.seriesModel.layoutInfo;
        mouseX -= layoutInfo.x;
        mouseY -= layoutInfo.y;
        var m = matrix.create();
        matrix.translate(m, m, [-mouseX, -mouseY]);
        matrix.scale(m, m, [scale, scale]);
        matrix.translate(m, m, [mouseX, mouseY]);
        rect.applyTransform(m);
        this.api.dispatchAction({
          type: 'treemapRender',
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
          }
        });
      }
    },
    _initEvents: function(containerGroup) {
      containerGroup.on('mousedown', function(e) {
        this._state === 'ready' && (this._mayClick = true);
      }, this);
      containerGroup.on('mouseup', function(e) {
        if (this._mayClick) {
          this._mayClick = false;
          this._state === 'ready' && onClick.call(this, e);
        }
      }, this);
      function onClick(e) {
        var nodeClick = this.seriesModel.get('nodeClick', true);
        if (!nodeClick) {
          return;
        }
        var targetInfo = this.findTarget(e.offsetX, e.offsetY);
        if (!targetInfo) {
          return;
        }
        var node = targetInfo.node;
        if (node.getLayout().isLeafRoot) {
          this._rootToNode(targetInfo);
        } else {
          if (nodeClick === 'zoomToNode') {
            this._zoomToNode(targetInfo);
          } else if (nodeClick === 'link') {
            var itemModel = node.hostTree.data.getItemModel(node.dataIndex);
            var link = itemModel.get('link', true);
            var linkTarget = itemModel.get('target', true) || 'blank';
            link && window.open(link, linkTarget);
          }
        }
      }
    },
    _renderBreadcrumb: function(seriesModel, api, targetInfo) {
      if (!targetInfo) {
        targetInfo = this.findTarget(api.getWidth() / 2, api.getHeight() / 2);
        if (!targetInfo) {
          targetInfo = {node: seriesModel.getData().tree.root};
        }
      }
      (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group, bind(onSelect, this)))).render(seriesModel, api, targetInfo.node);
      function onSelect(node) {
        if (this._state !== 'animating') {
          helper.aboveViewRoot(seriesModel.getViewRoot(), node) ? this._rootToNode({node: node}) : this._zoomToNode({node: node});
        }
      }
    },
    remove: function() {
      this._clearController();
      this._containerGroup && this._containerGroup.removeAll();
      this._storage = createStorage();
      this._state = 'ready';
      this._breadcrumb && this._breadcrumb.remove();
    },
    dispose: function() {
      this._clearController();
    },
    _zoomToNode: function(targetInfo) {
      this.api.dispatchAction({
        type: 'treemapZoomToNode',
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: targetInfo.node
      });
    },
    _rootToNode: function(targetInfo) {
      this.api.dispatchAction({
        type: 'treemapRootToNode',
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: targetInfo.node
      });
    },
    findTarget: function(x, y) {
      var targetInfo;
      var viewRoot = this.seriesModel.getViewRoot();
      viewRoot.eachNode({
        attr: 'viewChildren',
        order: 'preorder'
      }, function(node) {
        var bgEl = this._storage.background[node.getRawIndex()];
        if (bgEl) {
          var point = bgEl.transformCoordToLocal(x, y);
          var shape = bgEl.shape;
          if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {
            targetInfo = {
              node: node,
              offsetX: point[0],
              offsetY: point[1]
            };
          } else {
            return false;
          }
        }
      }, this);
      return targetInfo;
    }
  });
  function createStorage() {
    return {
      nodeGroup: [],
      background: [],
      content: []
    };
  }
  function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {
    if (!thisNode) {
      return;
    }
    var thisLayout = thisNode.getLayout();
    if (!thisLayout || !thisLayout.isInView) {
      return;
    }
    var thisWidth = thisLayout.width;
    var thisHeight = thisLayout.height;
    var thisInvisible = thisLayout.invisible;
    var thisRawIndex = thisNode.getRawIndex();
    var oldRawIndex = oldNode && oldNode.getRawIndex();
    var group = giveGraphic('nodeGroup', Group);
    if (!group) {
      return;
    }
    parentGroup.add(group);
    group.attr('position', [thisLayout.x || 0, thisLayout.y || 0]);
    group.__tmNodeWidth = thisWidth;
    group.__tmNodeHeight = thisHeight;
    if (thisLayout.isAboveViewRoot) {
      return group;
    }
    var bg = giveGraphic('background', Rect, depth, Z_BG);
    if (bg) {
      bg.setShape({
        x: 0,
        y: 0,
        width: thisWidth,
        height: thisHeight
      });
      updateStyle(bg, function() {
        bg.setStyle('fill', thisNode.getVisual('borderColor', true));
      });
      group.add(bg);
    }
    var thisViewChildren = thisNode.viewChildren;
    if (!thisViewChildren || !thisViewChildren.length) {
      var content = giveGraphic('content', Rect, depth, Z_CONTENT);
      content && renderContent(group);
    }
    return group;
    function renderContent(group) {
      content.dataIndex = thisNode.dataIndex;
      content.seriesIndex = seriesModel.seriesIndex;
      var borderWidth = thisLayout.borderWidth;
      var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
      var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
      content.culling = true;
      content.setShape({
        x: borderWidth,
        y: borderWidth,
        width: contentWidth,
        height: contentHeight
      });
      var visualColor = thisNode.getVisual('color', true);
      updateStyle(content, function() {
        var normalStyle = {fill: visualColor};
        var emphasisStyle = thisNode.getModel('itemStyle.emphasis').getItemStyle();
        prepareText(normalStyle, emphasisStyle, visualColor, contentWidth, contentHeight);
        content.setStyle(normalStyle);
        graphic.setHoverStyle(content, emphasisStyle);
      });
      group.add(content);
    }
    function updateStyle(element, cb) {
      if (!thisInvisible) {
        cb();
        if (!element.__tmWillVisible) {
          element.invisible = false;
        }
      } else {
        !element.invisible && willInvisibleEls.push(element);
      }
    }
    function prepareText(normalStyle, emphasisStyle, visualColor, contentWidth, contentHeight) {
      var nodeModel = thisNode.getModel();
      var text = nodeModel.get('name');
      if (thisLayout.isLeafRoot) {
        var iconChar = seriesModel.get('drillDownIcon', true);
        text = iconChar ? iconChar + ' ' + text : test;
      }
      setText(text, normalStyle, nodeModel, PATH_LABEL_NORMAL, visualColor, contentWidth, contentHeight);
      setText(text, emphasisStyle, nodeModel, PATH_LABEL_EMPHASIS, visualColor, contentWidth, contentHeight);
    }
    function setText(text, style, nodeModel, labelPath, visualColor, contentWidth, contentHeight) {
      var labelModel = nodeModel.getModel(labelPath);
      var labelTextStyleModel = labelModel.getModel('textStyle');
      graphic.setText(style, labelModel, visualColor);
      style.textAlign = labelTextStyleModel.get('align');
      style.textVerticalAlign = labelTextStyleModel.get('baseline');
      var textRect = labelTextStyleModel.getTextRect(text);
      if (!labelModel.getShallow('show') || textRect.height > contentHeight) {
        style.text = '';
      } else if (textRect.width > contentWidth) {
        style.text = labelTextStyleModel.get('ellipsis') ? labelTextStyleModel.truncateText(text, contentWidth, null, {minChar: 2}) : '';
      } else {
        style.text = text;
      }
    }
    function giveGraphic(storageName, Ctor, depth, z) {
      var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
      var lasts = lastsForAnimation[storageName];
      if (element) {
        oldStorage[storageName][oldRawIndex] = null;
        prepareAnimationWhenHasOld(lasts, element, storageName);
      } else if (!thisInvisible) {
        element = new Ctor({z: calculateZ(depth, z)});
        element.__tmDepth = depth;
        element.__tmStorageName = storageName;
        prepareAnimationWhenNoOld(lasts, element, storageName);
      }
      return (thisStorage[storageName][thisRawIndex] = element);
    }
    function prepareAnimationWhenHasOld(lasts, element, storageName) {
      var lastCfg = lasts[thisRawIndex] = {};
      lastCfg.old = storageName === 'nodeGroup' ? element.position.slice() : zrUtil.extend({}, element.shape);
    }
    function prepareAnimationWhenNoOld(lasts, element, storageName) {
      var lastCfg = lasts[thisRawIndex] = {};
      var parentNode = thisNode.parentNode;
      if (parentNode && (!reRoot || reRoot.direction === 'drillDown')) {
        var parentOldX = 0;
        var parentOldY = 0;
        var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];
        if (!reRoot && parentOldBg && parentOldBg.old) {
          parentOldX = parentOldBg.old.width;
          parentOldY = parentOldBg.old.height;
        }
        lastCfg.old = storageName === 'nodeGroup' ? [0, parentOldY] : {
          x: parentOldX,
          y: parentOldY,
          width: 0,
          height: 0
        };
      }
      lastCfg.fadein = storageName !== 'nodeGroup';
    }
  }
  function calculateZ(depth, zInLevel) {
    var zb = depth * Z_BASE + zInLevel;
    return (zb - 1) / zb;
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/treemap/treemapAction.js", ["../../echarts", "./helper", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../../echarts');
  var helper = $__require('./helper');
  var noop = function() {};
  var actionTypes = ['treemapZoomToNode', 'treemapRender', 'treemapMove'];
  for (var i = 0; i < actionTypes.length; i++) {
    echarts.registerAction({
      type: actionTypes[i],
      update: 'updateView'
    }, noop);
  }
  echarts.registerAction({
    type: 'treemapRootToNode',
    update: 'updateView'
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'series',
      subType: 'treemap',
      query: payload
    }, handleRootToNode);
    function handleRootToNode(model, index) {
      var targetInfo = helper.retrieveTargetInfo(payload, model);
      if (targetInfo) {
        var originViewRoot = model.getViewRoot();
        if (originViewRoot) {
          payload.direction = helper.aboveViewRoot(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown';
        }
        model.resetViewRoot(targetInfo.node);
      }
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/treemap/treemapVisual.js", ["../../visual/VisualMapping", "zrender/lib/tool/color", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var VisualMapping = $__require('../../visual/VisualMapping');
  var zrColor = $__require('zrender/lib/tool/color');
  var zrUtil = $__require('zrender/lib/core/util');
  var isArray = zrUtil.isArray;
  var ITEM_STYLE_NORMAL = 'itemStyle.normal';
  module.exports = function(ecModel, api, payload) {
    var condition = {
      mainType: 'series',
      subType: 'treemap',
      query: payload
    };
    ecModel.eachComponent(condition, function(seriesModel) {
      var tree = seriesModel.getData().tree;
      var root = tree.root;
      var seriesItemStyleModel = seriesModel.getModel(ITEM_STYLE_NORMAL);
      if (root.isRemoved()) {
        return;
      }
      var levelItemStyles = zrUtil.map(tree.levelModels, function(levelModel) {
        return levelModel ? levelModel.get(ITEM_STYLE_NORMAL) : null;
      });
      travelTree(root, {}, levelItemStyles, seriesItemStyleModel, seriesModel.getViewRoot().getAncestors(), seriesModel);
    });
  };
  function travelTree(node, designatedVisual, levelItemStyles, seriesItemStyleModel, viewRootAncestors, seriesModel) {
    var nodeModel = node.getModel();
    var nodeLayout = node.getLayout();
    if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
      return;
    }
    var nodeItemStyleModel = node.getModel(ITEM_STYLE_NORMAL);
    var levelItemStyle = levelItemStyles[node.depth];
    var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel);
    var borderColor = nodeItemStyleModel.get('borderColor');
    var borderColorSaturation = nodeItemStyleModel.get('borderColorSaturation');
    var thisNodeColor;
    if (borderColorSaturation != null) {
      thisNodeColor = calculateColor(visuals, node);
      borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
    }
    node.setVisual('borderColor', borderColor);
    var viewChildren = node.viewChildren;
    if (!viewChildren || !viewChildren.length) {
      thisNodeColor = calculateColor(visuals, node);
      node.setVisual('color', thisNodeColor);
    } else {
      var mapping = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren);
      zrUtil.each(viewChildren, function(child, index) {
        if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
          var childVisual = mapVisual(nodeModel, visuals, child, index, mapping, seriesModel);
          travelTree(child, childVisual, levelItemStyles, seriesItemStyleModel, viewRootAncestors, seriesModel);
        }
      });
    }
  }
  function buildVisuals(nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel) {
    var visuals = zrUtil.extend({}, designatedVisual);
    zrUtil.each(['color', 'colorAlpha', 'colorSaturation'], function(visualName) {
      var val = nodeItemStyleModel.get(visualName, true);
      val == null && levelItemStyle && (val = levelItemStyle[visualName]);
      val == null && (val = designatedVisual[visualName]);
      val == null && (val = seriesItemStyleModel.get(visualName));
      val != null && (visuals[visualName] = val);
    });
    return visuals;
  }
  function calculateColor(visuals) {
    var color = getValueVisualDefine(visuals, 'color');
    if (color) {
      var colorAlpha = getValueVisualDefine(visuals, 'colorAlpha');
      var colorSaturation = getValueVisualDefine(visuals, 'colorSaturation');
      if (colorSaturation) {
        color = zrColor.modifyHSL(color, null, null, colorSaturation);
      }
      if (colorAlpha) {
        color = zrColor.modifyAlpha(color, colorAlpha);
      }
      return color;
    }
  }
  function calculateBorderColor(borderColorSaturation, thisNodeColor) {
    return thisNodeColor != null ? zrColor.modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;
  }
  function getValueVisualDefine(visuals, name) {
    var value = visuals[name];
    if (value != null && value !== 'none') {
      return value;
    }
  }
  function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
    if (!viewChildren || !viewChildren.length) {
      return;
    }
    var rangeVisual = getRangeVisual(nodeModel, 'color') || (visuals.color != null && visuals.color !== 'none' && (getRangeVisual(nodeModel, 'colorAlpha') || getRangeVisual(nodeModel, 'colorSaturation')));
    if (!rangeVisual) {
      return;
    }
    var colorMappingBy = nodeModel.get('colorMappingBy');
    var opt = {
      type: rangeVisual.name,
      dataExtent: nodeLayout.dataExtent,
      visual: rangeVisual.range
    };
    if (opt.type === 'color' && (colorMappingBy === 'index' || colorMappingBy === 'id')) {
      opt.mappingMethod = 'category';
      opt.loop = true;
    } else {
      opt.mappingMethod = 'linear';
    }
    var mapping = new VisualMapping(opt);
    mapping.__drColorMappingBy = colorMappingBy;
    return mapping;
  }
  function getRangeVisual(nodeModel, name) {
    var range = nodeModel.get(name);
    return (isArray(range) && range.length) ? {
      name: name,
      range: range
    } : null;
  }
  function mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {
    var childVisuals = zrUtil.extend({}, visuals);
    if (mapping) {
      var mappingType = mapping.type;
      var colorMappingBy = mappingType === 'color' && mapping.__drColorMappingBy;
      var value = colorMappingBy === 'index' ? index : colorMappingBy === 'id' ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get('visualDimension'));
      childVisuals[mappingType] = mapping.mapValueToVisual(value);
    }
    return childVisuals;
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/treemap/helper.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var helper = {
    retrieveTargetInfo: function(payload, seriesModel) {
      if (payload && (payload.type === 'treemapZoomToNode' || payload.type === 'treemapRootToNode')) {
        var root = seriesModel.getData().tree.root;
        var targetNode = payload.targetNode;
        if (targetNode && root.contains(targetNode)) {
          return {node: targetNode};
        }
        var targetNodeId = payload.targetNodeId;
        if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
          return {node: targetNode};
        }
      }
    },
    getPathToRoot: function(node) {
      var path = [];
      while (node) {
        node = node.parentNode;
        node && path.push(node);
      }
      return path.reverse();
    },
    aboveViewRoot: function(viewRoot, node) {
      var viewPath = helper.getPathToRoot(viewRoot);
      return zrUtil.indexOf(viewPath, node) >= 0;
    }
  };
  module.exports = helper;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/treemap/treemapLayout.js", ["zrender/lib/core/util", "../../util/number", "../../util/layout", "./helper", "zrender/lib/core/BoundingRect", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var numberUtil = $__require('../../util/number');
  var layout = $__require('../../util/layout');
  var helper = $__require('./helper');
  var BoundingRect = $__require('zrender/lib/core/BoundingRect');
  var helper = $__require('./helper');
  var mathMax = Math.max;
  var mathMin = Math.min;
  var parsePercent = numberUtil.parsePercent;
  var retrieveValue = zrUtil.retrieve;
  var each = zrUtil.each;
  function update(ecModel, api, payload) {
    var condition = {
      mainType: 'series',
      subType: 'treemap',
      query: payload
    };
    ecModel.eachComponent(condition, function(seriesModel) {
      var ecWidth = api.getWidth();
      var ecHeight = api.getHeight();
      var seriesOption = seriesModel.option;
      var size = seriesOption.size || [];
      var containerWidth = parsePercent(retrieveValue(seriesOption.width, size[0]), ecWidth);
      var containerHeight = parsePercent(retrieveValue(seriesOption.height, size[1]), ecHeight);
      var layoutInfo = layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
      var payloadType = payload && payload.type;
      var targetInfo = helper.retrieveTargetInfo(payload, seriesModel);
      var rootRect = (payloadType === 'treemapRender' || payloadType === 'treemapMove') ? payload.rootRect : null;
      var viewRoot = seriesModel.getViewRoot();
      var viewAbovePath = helper.getPathToRoot(viewRoot);
      if (payloadType !== 'treemapMove') {
        var rootSize = payloadType === 'treemapZoomToNode' ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];
        var sort = seriesOption.sort;
        if (sort && sort !== 'asc' && sort !== 'desc') {
          sort = 'desc';
        }
        var options = {
          squareRatio: seriesOption.squareRatio,
          sort: sort,
          leafDepth: seriesOption.leafDepth
        };
        viewRoot.hostTree.clearLayouts();
        var viewRootLayout = {
          x: 0,
          y: 0,
          width: rootSize[0],
          height: rootSize[1],
          area: rootSize[0] * rootSize[1]
        };
        viewRoot.setLayout(viewRootLayout);
        squarify(viewRoot, options, false, 0);
        var viewRootLayout = viewRoot.getLayout();
        each(viewAbovePath, function(node, index) {
          var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();
          node.setLayout(zrUtil.extend({
            dataExtent: [childValue, childValue],
            borderWidth: 0
          }, viewRootLayout));
        });
      }
      var treeRoot = seriesModel.getData().tree.root;
      treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
      seriesModel.setLayoutInfo(layoutInfo);
      prunning(treeRoot, new BoundingRect(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);
    });
  }
  function squarify(node, options, hideChildren, depth) {
    var width;
    var height;
    if (node.isRemoved()) {
      return;
    }
    var thisLayout = node.getLayout();
    width = thisLayout.width;
    height = thisLayout.height;
    var itemStyleModel = node.getModel('itemStyle.normal');
    var borderWidth = itemStyleModel.get('borderWidth');
    var halfGapWidth = itemStyleModel.get('gapWidth') / 2;
    var layoutOffset = borderWidth - halfGapWidth;
    var nodeModel = node.getModel();
    node.setLayout({borderWidth: borderWidth}, true);
    width = mathMax(width - 2 * layoutOffset, 0);
    height = mathMax(height - 2 * layoutOffset, 0);
    var totalArea = width * height;
    var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);
    if (!viewChildren.length) {
      return;
    }
    var rect = {
      x: layoutOffset,
      y: layoutOffset,
      width: width,
      height: height
    };
    var rowFixedLength = mathMin(width, height);
    var best = Infinity;
    var row = [];
    row.area = 0;
    for (var i = 0,
        len = viewChildren.length; i < len; ) {
      var child = viewChildren[i];
      row.push(child);
      row.area += child.getLayout().area;
      var score = worst(row, rowFixedLength, options.squareRatio);
      if (score <= best) {
        i++;
        best = score;
      } else {
        row.area -= row.pop().getLayout().area;
        position(row, rowFixedLength, rect, halfGapWidth, false);
        rowFixedLength = mathMin(rect.width, rect.height);
        row.length = row.area = 0;
        best = Infinity;
      }
    }
    if (row.length) {
      position(row, rowFixedLength, rect, halfGapWidth, true);
    }
    if (!hideChildren) {
      var childrenVisibleMin = nodeModel.get('childrenVisibleMin');
      if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
        hideChildren = true;
      }
    }
    for (var i = 0,
        len = viewChildren.length; i < len; i++) {
      squarify(viewChildren[i], options, hideChildren, depth + 1);
    }
  }
  function initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {
    var viewChildren = node.children || [];
    var orderBy = options.sort;
    orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);
    var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;
    if (hideChildren && !overLeafDepth) {
      return (node.viewChildren = []);
    }
    viewChildren = zrUtil.filter(viewChildren, function(child) {
      return !child.isRemoved();
    });
    sort(viewChildren, orderBy);
    var info = statistic(nodeModel, viewChildren, orderBy);
    if (info.sum === 0) {
      return (node.viewChildren = []);
    }
    info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);
    if (info.sum === 0) {
      return (node.viewChildren = []);
    }
    for (var i = 0,
        len = viewChildren.length; i < len; i++) {
      var area = viewChildren[i].getValue() / info.sum * totalArea;
      viewChildren[i].setLayout({area: area});
    }
    if (overLeafDepth) {
      viewChildren.length && node.setLayout({isLeafRoot: true}, true);
      viewChildren.length = 0;
    }
    node.viewChildren = viewChildren;
    node.setLayout({dataExtent: info.dataExtent}, true);
    return viewChildren;
  }
  function filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {
    if (!orderBy) {
      return sum;
    }
    var visibleMin = nodeModel.get('visibleMin');
    var len = orderedChildren.length;
    var deletePoint = len;
    for (var i = len - 1; i >= 0; i--) {
      var value = orderedChildren[orderBy === 'asc' ? len - i - 1 : i].getValue();
      if (value / sum * totalArea < visibleMin) {
        deletePoint = i;
        sum -= value;
      }
    }
    orderBy === 'asc' ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);
    return sum;
  }
  function sort(viewChildren, orderBy) {
    if (orderBy) {
      viewChildren.sort(function(a, b) {
        return orderBy === 'asc' ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
      });
    }
    return viewChildren;
  }
  function statistic(nodeModel, children, orderBy) {
    var sum = 0;
    for (var i = 0,
        len = children.length; i < len; i++) {
      sum += children[i].getValue();
    }
    var dimension = nodeModel.get('visualDimension');
    var dataExtent;
    if (!children || !children.length) {
      dataExtent = [NaN, NaN];
    } else if (dimension === 'value' && orderBy) {
      dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];
      orderBy === 'asc' && dataExtent.reverse();
    } else {
      var dataExtent = [Infinity, -Infinity];
      each(children, function(child) {
        var value = child.getValue(dimension);
        value < dataExtent[0] && (dataExtent[0] = value);
        value > dataExtent[1] && (dataExtent[1] = value);
      });
    }
    return {
      sum: sum,
      dataExtent: dataExtent
    };
  }
  function worst(row, rowFixedLength, ratio) {
    var areaMax = 0;
    var areaMin = Infinity;
    for (var i = 0,
        area,
        len = row.length; i < len; i++) {
      area = row[i].getLayout().area;
      if (area) {
        area < areaMin && (areaMin = area);
        area > areaMax && (areaMax = area);
      }
    }
    var squareArea = row.area * row.area;
    var f = rowFixedLength * rowFixedLength * ratio;
    return squareArea ? mathMax((f * areaMax) / squareArea, squareArea / (f * areaMin)) : Infinity;
  }
  function position(row, rowFixedLength, rect, halfGapWidth, flush) {
    var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
    var idx1WhenH = 1 - idx0WhenH;
    var xy = ['x', 'y'];
    var wh = ['width', 'height'];
    var last = rect[xy[idx0WhenH]];
    var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;
    if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
      rowOtherLength = rect[wh[idx1WhenH]];
    }
    for (var i = 0,
        rowLen = row.length; i < rowLen; i++) {
      var node = row[i];
      var nodeLayout = {};
      var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
      var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax(rowOtherLength - 2 * halfGapWidth, 0);
      var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
      var modWH = (i === rowLen - 1 || remain < step) ? remain : step;
      var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax(modWH - 2 * halfGapWidth, 0);
      nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin(halfGapWidth, wh1 / 2);
      nodeLayout[xy[idx0WhenH]] = last + mathMin(halfGapWidth, wh0 / 2);
      last += modWH;
      node.setLayout(nodeLayout, true);
    }
    rect[xy[idx1WhenH]] += rowOtherLength;
    rect[wh[idx1WhenH]] -= rowOtherLength;
  }
  function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
    var currNode = (targetInfo || {}).node;
    var defaultSize = [containerWidth, containerHeight];
    if (!currNode || currNode === viewRoot) {
      return defaultSize;
    }
    var parent;
    var viewArea = containerWidth * containerHeight;
    var area = viewArea * seriesModel.option.zoomToNodeRatio;
    while (parent = currNode.parentNode) {
      var sum = 0;
      var siblings = parent.children;
      for (var i = 0,
          len = siblings.length; i < len; i++) {
        sum += siblings[i].getValue();
      }
      var currNodeValue = currNode.getValue();
      if (currNodeValue === 0) {
        return defaultSize;
      }
      area *= sum / currNodeValue;
      var borderWidth = parent.getModel('itemStyle.normal').get('borderWidth');
      if (isFinite(borderWidth)) {
        area += 4 * borderWidth * borderWidth + 4 * borderWidth * Math.pow(area, 0.5);
      }
      area > numberUtil.MAX_SAFE_INTEGER && (area = numberUtil.MAX_SAFE_INTEGER);
      currNode = parent;
    }
    area < viewArea && (area = viewArea);
    var scale = Math.pow(area / viewArea, 0.5);
    return [containerWidth * scale, containerHeight * scale];
  }
  function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
    if (rootRect) {
      return {
        x: rootRect.x,
        y: rootRect.y
      };
    }
    var defaultPosition = {
      x: 0,
      y: 0
    };
    if (!targetInfo) {
      return defaultPosition;
    }
    var targetNode = targetInfo.node;
    var layout = targetNode.getLayout();
    if (!layout) {
      return defaultPosition;
    }
    var targetCenter = [layout.width / 2, layout.height / 2];
    var node = targetNode;
    while (node) {
      var nodeLayout = node.getLayout();
      targetCenter[0] += nodeLayout.x;
      targetCenter[1] += nodeLayout.y;
      node = node.parentNode;
    }
    return {
      x: layoutInfo.width / 2 - targetCenter[0],
      y: layoutInfo.height / 2 - targetCenter[1]
    };
  }
  function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {
    var nodeLayout = node.getLayout();
    var nodeInViewAbovePath = viewAbovePath[depth];
    var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;
    if ((nodeInViewAbovePath && !isAboveViewRoot) || (depth === viewAbovePath.length && node !== viewRoot)) {
      return;
    }
    node.setLayout({
      isInView: true,
      invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
      isAboveViewRoot: isAboveViewRoot
    }, true);
    var childClipRect = new BoundingRect(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
    each(node.viewChildren || [], function(child) {
      prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);
    });
  }
  module.exports = update;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/treemap.js", ["../echarts", "./treemap/TreemapSeries", "./treemap/TreemapView", "./treemap/treemapAction", "./treemap/treemapVisual", "./treemap/treemapLayout", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../echarts');
  $__require('./treemap/TreemapSeries');
  $__require('./treemap/TreemapView');
  $__require('./treemap/treemapAction');
  echarts.registerVisual($__require('./treemap/treemapVisual'));
  echarts.registerLayout($__require('./treemap/treemapLayout'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/GraphSeries.js", ["../../data/List", "zrender/lib/core/util", "../../util/model", "../../model/Model", "../helper/createGraphFromNodeEdge", "../../echarts", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var List = $__require('../../data/List');
  var zrUtil = $__require('zrender/lib/core/util');
  var modelUtil = $__require('../../util/model');
  var Model = $__require('../../model/Model');
  var createGraphFromNodeEdge = $__require('../helper/createGraphFromNodeEdge');
  var GraphSeries = $__require('../../echarts').extendSeriesModel({
    type: 'series.graph',
    init: function(option) {
      GraphSeries.superApply(this, 'init', arguments);
      this.legendDataProvider = function() {
        return this._categoriesData;
      };
      this.fillDataTextStyle(option.edges || option.links);
      this._updateCategoriesData();
    },
    mergeOption: function(option) {
      GraphSeries.superApply(this, 'mergeOption', arguments);
      this.fillDataTextStyle(option.edges || option.links);
      this._updateCategoriesData();
    },
    mergeDefaultAndTheme: function(option) {
      GraphSeries.superApply(this, 'mergeDefaultAndTheme', arguments);
      modelUtil.defaultEmphasis(option.edgeLabel, modelUtil.LABEL_OPTIONS);
    },
    getInitialData: function(option, ecModel) {
      var edges = option.edges || option.links || [];
      var nodes = option.data || option.nodes || [];
      var self = this;
      if (nodes && edges) {
        return createGraphFromNodeEdge(nodes, edges, this, true, beforeLink).data;
      }
      function beforeLink(nodeData, edgeData) {
        nodeData.wrapMethod('getItemModel', function(model) {
          var categoriesModels = self._categoriesModels;
          var categoryIdx = model.getShallow('category');
          var categoryModel = categoriesModels[categoryIdx];
          if (categoryModel) {
            categoryModel.parentModel = model.parentModel;
            model.parentModel = categoryModel;
          }
          return model;
        });
        var edgeLabelModel = self.getModel('edgeLabel');
        var wrappedGetEdgeModel = function(path, parentModel) {
          var pathArr = (path || '').split('.');
          if (pathArr[0] === 'label') {
            parentModel = parentModel || edgeLabelModel.getModel(pathArr.slice(1));
          }
          var model = Model.prototype.getModel.call(this, pathArr, parentModel);
          model.getModel = wrappedGetEdgeModel;
          return model;
        };
        edgeData.wrapMethod('getItemModel', function(model) {
          model.getModel = wrappedGetEdgeModel;
          return model;
        });
      }
    },
    getGraph: function() {
      return this.getData().graph;
    },
    getEdgeData: function() {
      return this.getGraph().edgeData;
    },
    getCategoriesData: function() {
      return this._categoriesData;
    },
    formatTooltip: function(dataIndex, multipleSeries, dataType) {
      if (dataType === 'edge') {
        var nodeData = this.getData();
        var params = this.getDataParams(dataIndex, dataType);
        var edge = nodeData.graph.getEdgeByIndex(dataIndex);
        var sourceName = nodeData.getName(edge.node1.dataIndex);
        var targetName = nodeData.getName(edge.node2.dataIndex);
        var html = sourceName + ' > ' + targetName;
        if (params.value) {
          html += ' : ' + params.value;
        }
        return html;
      } else {
        return GraphSeries.superApply(this, 'formatTooltip', arguments);
      }
    },
    _updateCategoriesData: function() {
      var categories = zrUtil.map(this.option.categories || [], function(category) {
        return category.value != null ? category : zrUtil.extend({value: 0}, category);
      });
      var categoriesData = new List(['value'], this);
      categoriesData.initData(categories);
      this._categoriesData = categoriesData;
      this._categoriesModels = categoriesData.mapArray(function(idx) {
        return categoriesData.getItemModel(idx, true);
      });
    },
    setZoom: function(zoom) {
      this.option.zoom = zoom;
    },
    setCenter: function(center) {
      this.option.center = center;
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'view',
      xAxisIndex: 0,
      yAxisIndex: 0,
      polarIndex: 0,
      geoIndex: 0,
      legendHoverLink: true,
      hoverAnimation: true,
      layout: null,
      focusNodeAdjacency: false,
      force: {
        initLayout: null,
        repulsion: 50,
        gravity: 0.1,
        edgeLength: 30,
        layoutAnimation: true
      },
      left: 'center',
      top: 'center',
      symbol: 'circle',
      symbolSize: 10,
      edgeSymbol: ['none', 'none'],
      edgeSymbolSize: 10,
      edgeLabel: {
        normal: {position: 'middle'},
        emphasis: {}
      },
      draggable: false,
      roam: false,
      center: null,
      zoom: 1,
      nodeScaleRatio: 0.6,
      label: {
        normal: {
          show: false,
          formatter: '{b}'
        },
        emphasis: {show: true}
      },
      itemStyle: {
        normal: {},
        emphasis: {}
      },
      lineStyle: {
        normal: {
          color: '#aaa',
          width: 1,
          curveness: 0,
          opacity: 0.5
        },
        emphasis: {}
      }
    }
  });
  module.exports = GraphSeries;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/adjustEdge.js", ["zrender/lib/core/curve", "zrender/lib/core/vector", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var curveTool = $__require('zrender/lib/core/curve');
  var vec2 = $__require('zrender/lib/core/vector');
  var v1 = [];
  var v2 = [];
  var v3 = [];
  var quadraticAt = curveTool.quadraticAt;
  var v2DistSquare = vec2.distSquare;
  var mathAbs = Math.abs;
  function intersectCurveCircle(curvePoints, center, radius) {
    var p0 = curvePoints[0];
    var p1 = curvePoints[1];
    var p2 = curvePoints[2];
    var d = Infinity;
    var t;
    var radiusSquare = radius * radius;
    var interval = 0.1;
    for (var _t = 0.1; _t <= 0.9; _t += 0.1) {
      v1[0] = quadraticAt(p0[0], p1[0], p2[0], _t);
      v1[1] = quadraticAt(p0[1], p1[1], p2[1], _t);
      var diff = mathAbs(v2DistSquare(v1, center) - radiusSquare);
      if (diff < d) {
        d = diff;
        t = _t;
      }
    }
    for (var i = 0; i < 32; i++) {
      var next = t + interval;
      v2[0] = quadraticAt(p0[0], p1[0], p2[0], t);
      v2[1] = quadraticAt(p0[1], p1[1], p2[1], t);
      v3[0] = quadraticAt(p0[0], p1[0], p2[0], next);
      v3[1] = quadraticAt(p0[1], p1[1], p2[1], next);
      var diff = v2DistSquare(v2, center) - radiusSquare;
      if (mathAbs(diff) < 1e-2) {
        break;
      }
      var nextDiff = v2DistSquare(v3, center) - radiusSquare;
      interval /= 2;
      if (diff < 0) {
        if (nextDiff >= 0) {
          t = t + interval;
        } else {
          t = t - interval;
        }
      } else {
        if (nextDiff >= 0) {
          t = t - interval;
        } else {
          t = t + interval;
        }
      }
    }
    return t;
  }
  module.exports = function(graph, scale) {
    var tmp0 = [];
    var quadraticSubdivide = curveTool.quadraticSubdivide;
    var pts = [[], [], []];
    var pts2 = [[], []];
    var v = [];
    scale /= 2;
    graph.eachEdge(function(edge, idx) {
      var linePoints = edge.getLayout();
      var fromSymbol = edge.getVisual('fromSymbol');
      var toSymbol = edge.getVisual('toSymbol');
      if (!linePoints.__original) {
        linePoints.__original = [vec2.clone(linePoints[0]), vec2.clone(linePoints[1])];
        if (linePoints[2]) {
          linePoints.__original.push(vec2.clone(linePoints[2]));
        }
      }
      var originalPoints = linePoints.__original;
      if (linePoints[2] != null) {
        vec2.copy(pts[0], originalPoints[0]);
        vec2.copy(pts[1], originalPoints[2]);
        vec2.copy(pts[2], originalPoints[1]);
        if (fromSymbol && fromSymbol != 'none') {
          var symbolSize = edge.node1.getVisual('symbolSize');
          if (symbolSize instanceof Array) {
            symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
          }
          var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale);
          quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
          pts[0][0] = tmp0[3];
          pts[1][0] = tmp0[4];
          quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
          pts[0][1] = tmp0[3];
          pts[1][1] = tmp0[4];
        }
        if (toSymbol && toSymbol != 'none') {
          var symbolSize = edge.node1.getVisual('symbolSize');
          if (symbolSize instanceof Array) {
            symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
          }
          var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale);
          quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
          pts[1][0] = tmp0[1];
          pts[2][0] = tmp0[2];
          quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
          pts[1][1] = tmp0[1];
          pts[2][1] = tmp0[2];
        }
        vec2.copy(linePoints[0], pts[0]);
        vec2.copy(linePoints[1], pts[2]);
        vec2.copy(linePoints[2], pts[1]);
      } else {
        vec2.copy(pts2[0], originalPoints[0]);
        vec2.copy(pts2[1], originalPoints[1]);
        vec2.sub(v, pts2[1], pts2[0]);
        vec2.normalize(v, v);
        if (fromSymbol && fromSymbol != 'none') {
          vec2.scaleAndAdd(pts2[0], pts2[0], v, edge.node1.getVisual('symbolSize') * scale);
        }
        if (toSymbol && toSymbol != 'none') {
          vec2.scaleAndAdd(pts2[1], pts2[1], v, -edge.node2.getVisual('symbolSize') * scale);
        }
        vec2.copy(linePoints[0], pts2[0]);
        vec2.copy(linePoints[1], pts2[1]);
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/GraphView.js", ["../helper/SymbolDraw", "../helper/LineDraw", "../../component/helper/RoamController", "../../util/graphic", "./adjustEdge", "zrender/lib/core/util", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SymbolDraw = $__require('../helper/SymbolDraw');
  var LineDraw = $__require('../helper/LineDraw');
  var RoamController = $__require('../../component/helper/RoamController');
  var graphic = $__require('../../util/graphic');
  var adjustEdge = $__require('./adjustEdge');
  var zrUtil = $__require('zrender/lib/core/util');
  var nodeOpacityPath = ['itemStyle', 'normal', 'opacity'];
  var lineOpacityPath = ['lineStyle', 'normal', 'opacity'];
  function getItemOpacity(item, opacityPath) {
    return item.getVisual('opacity') || item.getModel().get(opacityPath);
  }
  $__require('../../echarts').extendChartView({
    type: 'graph',
    init: function(ecModel, api) {
      var symbolDraw = new SymbolDraw();
      var lineDraw = new LineDraw();
      var group = this.group;
      var controller = new RoamController(api.getZr(), group);
      group.add(symbolDraw.group);
      group.add(lineDraw.group);
      this._symbolDraw = symbolDraw;
      this._lineDraw = lineDraw;
      this._controller = controller;
      this._firstRender = true;
    },
    render: function(seriesModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      this._model = seriesModel;
      this._nodeScaleRatio = seriesModel.get('nodeScaleRatio');
      var symbolDraw = this._symbolDraw;
      var lineDraw = this._lineDraw;
      var group = this.group;
      if (coordSys.type === 'view') {
        var groupNewProp = {
          position: coordSys.position,
          scale: coordSys.scale
        };
        if (this._firstRender) {
          group.attr(groupNewProp);
        } else {
          graphic.updateProps(group, groupNewProp, seriesModel);
        }
      }
      adjustEdge(seriesModel.getGraph(), this._getNodeGlobalScale(seriesModel));
      var data = seriesModel.getData();
      symbolDraw.updateData(data);
      var edgeData = seriesModel.getEdgeData();
      lineDraw.updateData(edgeData);
      this._updateNodeAndLinkScale();
      this._updateController(seriesModel, api);
      clearTimeout(this._layoutTimeout);
      var forceLayout = seriesModel.forceLayout;
      var layoutAnimation = seriesModel.get('force.layoutAnimation');
      if (forceLayout) {
        this._startForceLayoutIteration(forceLayout, layoutAnimation);
      }
      data.eachItemGraphicEl(function(el, idx) {
        var itemModel = data.getItemModel(idx);
        el.off('drag').off('dragend');
        var draggable = data.getItemModel(idx).get('draggable');
        if (draggable) {
          el.on('drag', function() {
            if (forceLayout) {
              forceLayout.warmUp();
              !this._layouting && this._startForceLayoutIteration(forceLayout, layoutAnimation);
              forceLayout.setFixed(idx);
              data.setItemLayout(idx, el.position);
            }
          }, this).on('dragend', function() {
            if (forceLayout) {
              forceLayout.setUnfixed(idx);
            }
          }, this);
        }
        el.setDraggable(draggable && forceLayout);
        el.off('mouseover', this._focusNodeAdjacency);
        el.off('mouseout', this._unfocusAll);
        if (itemModel.get('focusNodeAdjacency')) {
          el.on('mouseover', this._focusNodeAdjacency, this);
          el.on('mouseout', this._unfocusAll, this);
        }
      }, this);
      this._firstRender = false;
    },
    _focusNodeAdjacency: function(e) {
      var data = this._model.getData();
      var graph = data.graph;
      var el = e.target;
      var dataIndex = el.dataIndex;
      var dataType = el.dataType;
      function fadeOutItem(item, opacityPath) {
        var opacity = getItemOpacity(item, opacityPath);
        var el = item.getGraphicEl();
        if (opacity == null) {
          opacity = 1;
        }
        el.traverse(function(child) {
          child.trigger('normal');
          if (child.type !== 'group') {
            child.setStyle('opacity', opacity * 0.1);
          }
        });
      }
      function fadeInItem(item, opacityPath) {
        var opacity = getItemOpacity(item, opacityPath);
        var el = item.getGraphicEl();
        el.traverse(function(child) {
          child.trigger('emphasis');
          if (child.type !== 'group') {
            child.setStyle('opacity', opacity);
          }
        });
      }
      if (dataIndex !== null && dataType !== 'edge') {
        graph.eachNode(function(node) {
          fadeOutItem(node, nodeOpacityPath);
        });
        graph.eachEdge(function(edge) {
          fadeOutItem(edge, lineOpacityPath);
        });
        var node = graph.getNodeByIndex(dataIndex);
        fadeInItem(node, nodeOpacityPath);
        zrUtil.each(node.edges, function(edge) {
          if (edge.dataIndex < 0) {
            return;
          }
          fadeInItem(edge, lineOpacityPath);
          fadeInItem(edge.node1, nodeOpacityPath);
          fadeInItem(edge.node2, nodeOpacityPath);
        });
      }
    },
    _unfocusAll: function() {
      var data = this._model.getData();
      var graph = data.graph;
      graph.eachNode(function(node) {
        var opacity = getItemOpacity(node, nodeOpacityPath);
        node.getGraphicEl().traverse(function(child) {
          child.trigger('normal');
          if (child.type !== 'group') {
            child.setStyle('opacity', opacity);
          }
        });
      });
      graph.eachEdge(function(edge) {
        var opacity = getItemOpacity(edge, lineOpacityPath);
        edge.getGraphicEl().traverse(function(child) {
          child.trigger('normal');
          if (child.type !== 'group') {
            child.setStyle('opacity', opacity);
          }
        });
      });
    },
    _startForceLayoutIteration: function(forceLayout, layoutAnimation) {
      var self = this;
      (function step() {
        forceLayout.step(function(stopped) {
          self.updateLayout(self._model);
          (self._layouting = !stopped) && (layoutAnimation ? (self._layoutTimeout = setTimeout(step, 16)) : step());
        });
      })();
    },
    _updateController: function(seriesModel, api) {
      var controller = this._controller;
      var group = this.group;
      controller.rectProvider = function() {
        var rect = group.getBoundingRect();
        rect.applyTransform(group.transform);
        return rect;
      };
      if (seriesModel.coordinateSystem.type !== 'view') {
        controller.disable();
        return;
      }
      controller.enable(seriesModel.get('roam'));
      controller.zoomLimit = seriesModel.get('scaleLimit');
      controller.zoom = seriesModel.coordinateSystem.getZoom();
      controller.off('pan').off('zoom').on('pan', function(dx, dy) {
        api.dispatchAction({
          seriesId: seriesModel.id,
          type: 'graphRoam',
          dx: dx,
          dy: dy
        });
      }).on('zoom', function(zoom, mouseX, mouseY) {
        api.dispatchAction({
          seriesId: seriesModel.id,
          type: 'graphRoam',
          zoom: zoom,
          originX: mouseX,
          originY: mouseY
        });
        this._updateNodeAndLinkScale();
        adjustEdge(seriesModel.getGraph(), this._getNodeGlobalScale(seriesModel));
        this._lineDraw.updateLayout();
      }, this);
    },
    _updateNodeAndLinkScale: function() {
      var seriesModel = this._model;
      var data = seriesModel.getData();
      var nodeScale = this._getNodeGlobalScale(seriesModel);
      var invScale = [nodeScale, nodeScale];
      data.eachItemGraphicEl(function(el, idx) {
        el.attr('scale', invScale);
      });
    },
    _getNodeGlobalScale: function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys.type !== 'view') {
        return 1;
      }
      var nodeScaleRatio = this._nodeScaleRatio;
      var groupScale = coordSys.scale;
      var groupZoom = (groupScale && groupScale[0]) || 1;
      var roamZoom = coordSys.getZoom();
      var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
      return nodeScale / groupZoom;
    },
    updateLayout: function(seriesModel) {
      adjustEdge(seriesModel.getGraph(), this._getNodeGlobalScale(seriesModel));
      this._symbolDraw.updateLayout();
      this._lineDraw.updateLayout();
    },
    remove: function(ecModel, api) {
      this._symbolDraw && this._symbolDraw.remove();
      this._lineDraw && this._lineDraw.remove();
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/roamAction.js", ["../../echarts", "../../action/roamHelper", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../../echarts');
  var roamHelper = $__require('../../action/roamHelper');
  var actionInfo = {
    type: 'graphRoam',
    event: 'graphRoam',
    update: 'none'
  };
  echarts.registerAction(actionInfo, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'series',
      query: payload
    }, function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var res = roamHelper.updateCenterAndZoom(coordSys, payload);
      seriesModel.setCenter && seriesModel.setCenter(res.center);
      seriesModel.setZoom && seriesModel.setZoom(res.zoom);
    });
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/categoryFilter.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(ecModel) {
    var legendModels = ecModel.findComponents({mainType: 'legend'});
    if (!legendModels || !legendModels.length) {
      return;
    }
    ecModel.eachSeriesByType('graph', function(graphSeries) {
      var categoriesData = graphSeries.getCategoriesData();
      var graph = graphSeries.getGraph();
      var data = graph.data;
      var categoryNames = categoriesData.mapArray(categoriesData.getName);
      data.filterSelf(function(idx) {
        var model = data.getItemModel(idx);
        var category = model.getShallow('category');
        if (category != null) {
          if (typeof category === 'number') {
            category = categoryNames[category];
          }
          for (var i = 0; i < legendModels.length; i++) {
            if (!legendModels[i].isSelected(category)) {
              return false;
            }
          }
        }
        return true;
      });
    }, this);
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/categoryVisual.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(ecModel) {
    ecModel.eachSeriesByType('graph', function(seriesModel) {
      var categoriesData = seriesModel.getCategoriesData();
      var data = seriesModel.getData();
      var categoryNameIdxMap = {};
      categoriesData.each(function(idx) {
        var name = categoriesData.getName(idx);
        categoryNameIdxMap[name] = idx;
        var itemModel = categoriesData.getItemModel(idx);
        var color = itemModel.get('itemStyle.normal.color') || seriesModel.getColorFromPalette(name);
        categoriesData.setItemVisual(idx, 'color', color);
      });
      if (categoriesData.count()) {
        data.each(function(idx) {
          var model = data.getItemModel(idx);
          var category = model.getShallow('category');
          if (category != null) {
            if (typeof category === 'string') {
              category = categoryNameIdxMap[category];
            }
            if (!data.getItemVisual(idx, 'color', true)) {
              data.setItemVisual(idx, 'color', categoriesData.getItemVisual(category, 'color'));
            }
          }
        });
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/edgeVisual.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function normalize(a) {
    if (!(a instanceof Array)) {
      a = [a, a];
    }
    return a;
  }
  module.exports = function(ecModel) {
    ecModel.eachSeriesByType('graph', function(seriesModel) {
      var graph = seriesModel.getGraph();
      var edgeData = seriesModel.getEdgeData();
      var symbolType = normalize(seriesModel.get('edgeSymbol'));
      var symbolSize = normalize(seriesModel.get('edgeSymbolSize'));
      edgeData.setVisual('fromSymbol', symbolType && symbolType[0]);
      edgeData.setVisual('toSymbol', symbolType && symbolType[1]);
      edgeData.setVisual('fromSymbolSize', symbolSize && symbolSize[0]);
      edgeData.setVisual('toSymbolSize', symbolSize && symbolSize[1]);
      edgeData.setVisual('color', seriesModel.get('lineStyle.normal.color'));
      edgeData.each(function(idx) {
        var itemModel = edgeData.getItemModel(idx);
        var edge = graph.getEdgeByIndex(idx);
        var symbolType = normalize(itemModel.getShallow('symbol', true));
        var symbolSize = normalize(itemModel.getShallow('symbolSize', true));
        var color = itemModel.get('lineStyle.normal.color');
        switch (color) {
          case 'source':
            color = edge.node1.getVisual('color');
            break;
          case 'target':
            color = edge.node2.getVisual('color');
            break;
        }
        symbolType[0] && edge.setVisual('fromSymbol', symbolType[0]);
        symbolType[1] && edge.setVisual('toSymbol', symbolType[1]);
        symbolSize[0] && edge.setVisual('fromSymbolSize', symbolSize[0]);
        symbolSize[1] && edge.setVisual('toSymbolSize', symbolSize[1]);
        edge.setVisual('color', color);
      });
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/simpleLayout.js", ["./simpleLayoutHelper", "./simpleLayoutEdge", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var simpleLayoutHelper = $__require('./simpleLayoutHelper');
  var simpleLayoutEdge = $__require('./simpleLayoutEdge');
  module.exports = function(ecModel, api) {
    ecModel.eachSeriesByType('graph', function(seriesModel) {
      var layout = seriesModel.get('layout');
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type !== 'view') {
        var data = seriesModel.getData();
        data.each(coordSys.dimensions, function(x, y, idx) {
          if (!isNaN(x) && !isNaN(y)) {
            data.setItemLayout(idx, coordSys.dataToPoint([x, y]));
          } else {
            data.setItemLayout(idx, [NaN, NaN]);
          }
        });
        simpleLayoutEdge(data.graph);
      } else if (!layout || layout === 'none') {
        simpleLayoutHelper(seriesModel);
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/circularLayout.js", ["./circularLayoutHelper", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var circularLayoutHelper = $__require('./circularLayoutHelper');
  module.exports = function(ecModel) {
    ecModel.eachSeriesByType('graph', function(seriesModel) {
      if (seriesModel.get('layout') === 'circular') {
        circularLayoutHelper(seriesModel);
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/forceHelper.js", ["zrender/lib/core/vector", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var vec2 = $__require('zrender/lib/core/vector');
  var scaleAndAdd = vec2.scaleAndAdd;
  module.exports = function(nodes, edges, opts) {
    var rect = opts.rect;
    var width = rect.width;
    var height = rect.height;
    var center = [rect.x + width / 2, rect.y + height / 2];
    var gravity = opts.gravity == null ? 0.1 : opts.gravity;
    for (var i = 0; i < nodes.length; i++) {
      var n = nodes[i];
      if (!n.p) {
        n.p = vec2.create(width * (Math.random() - 0.5) + center[0], height * (Math.random() - 0.5) + center[1]);
      }
      n.pp = vec2.clone(n.p);
      n.edges = null;
    }
    var friction = 0.6;
    return {
      warmUp: function() {
        friction = 0.5;
      },
      setFixed: function(idx) {
        nodes[idx].fixed = true;
      },
      setUnfixed: function(idx) {
        nodes[idx].fixed = false;
      },
      step: function(cb) {
        var v12 = [];
        var nLen = nodes.length;
        for (var i = 0; i < edges.length; i++) {
          var e = edges[i];
          var n1 = e.n1;
          var n2 = e.n2;
          vec2.sub(v12, n2.p, n1.p);
          var d = vec2.len(v12) - e.d;
          var w = n2.w / (n1.w + n2.w);
          vec2.normalize(v12, v12);
          !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
          !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
        }
        for (var i = 0; i < nLen; i++) {
          var n = nodes[i];
          if (!n.fixed) {
            vec2.sub(v12, center, n.p);
            vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction);
          }
        }
        for (var i = 0; i < nLen; i++) {
          var n1 = nodes[i];
          for (var j = i + 1; j < nLen; j++) {
            var n2 = nodes[j];
            vec2.sub(v12, n2.p, n1.p);
            var d = vec2.len(v12);
            if (d === 0) {
              vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);
              d = 1;
            }
            var repFact = (n1.rep + n2.rep) / d / d;
            !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
            !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
          }
        }
        var v = [];
        for (var i = 0; i < nLen; i++) {
          var n = nodes[i];
          if (!n.fixed) {
            vec2.sub(v, n.p, n.pp);
            vec2.scaleAndAdd(n.p, n.p, v, friction);
            vec2.copy(n.pp, n.p);
          }
        }
        friction = friction * 0.992;
        cb && cb(nodes, edges, friction < 0.01);
      }
    };
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/simpleLayoutEdge.js", ["zrender/lib/core/vector", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var vec2 = $__require('zrender/lib/core/vector');
  module.exports = function(graph) {
    graph.eachEdge(function(edge) {
      var curveness = edge.getModel().get('lineStyle.normal.curveness') || 0;
      var p1 = vec2.clone(edge.node1.getLayout());
      var p2 = vec2.clone(edge.node2.getLayout());
      var points = [p1, p2];
      if (curveness > 0) {
        points.push([(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness]);
      }
      edge.setLayout(points);
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/simpleLayoutHelper.js", ["./simpleLayoutEdge", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var simpleLayoutEdge = $__require('./simpleLayoutEdge');
  module.exports = function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.type !== 'view') {
      return;
    }
    var graph = seriesModel.getGraph();
    graph.eachNode(function(node) {
      var model = node.getModel();
      node.setLayout([+model.get('x'), +model.get('y')]);
    });
    simpleLayoutEdge(graph);
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/circularLayoutHelper.js", ["zrender/lib/core/vector", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var vec2 = $__require('zrender/lib/core/vector');
  module.exports = function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.type !== 'view') {
      return;
    }
    var rect = coordSys.getBoundingRect();
    var nodeData = seriesModel.getData();
    var graph = nodeData.graph;
    var angle = 0;
    var sum = nodeData.getSum('value');
    var unitAngle = Math.PI * 2 / (sum || nodeData.count());
    var cx = rect.width / 2 + rect.x;
    var cy = rect.height / 2 + rect.y;
    var r = Math.min(rect.width, rect.height) / 2;
    graph.eachNode(function(node) {
      var value = node.getValue('value');
      angle += unitAngle * (sum ? value : 2) / 2;
      node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
      angle += unitAngle * (sum ? value : 2) / 2;
    });
    graph.eachEdge(function(edge) {
      var curveness = edge.getModel().get('lineStyle.normal.curveness') || 0;
      var p1 = vec2.clone(edge.node1.getLayout());
      var p2 = vec2.clone(edge.node2.getLayout());
      var cp1;
      var x12 = (p1[0] + p2[0]) / 2;
      var y12 = (p1[1] + p2[1]) / 2;
      if (curveness > 0) {
        curveness *= 3;
        cp1 = [cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness)];
      }
      edge.setLayout([p1, p2, cp1]);
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/forceLayout.js", ["./forceHelper", "../../util/number", "./simpleLayoutHelper", "./circularLayoutHelper", "zrender/lib/core/vector", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var forceHelper = $__require('./forceHelper');
  var numberUtil = $__require('../../util/number');
  var simpleLayoutHelper = $__require('./simpleLayoutHelper');
  var circularLayoutHelper = $__require('./circularLayoutHelper');
  var vec2 = $__require('zrender/lib/core/vector');
  module.exports = function(ecModel) {
    ecModel.eachSeriesByType('graph', function(graphSeries) {
      var coordSys = graphSeries.coordinateSystem;
      if (coordSys && coordSys.type !== 'view') {
        return;
      }
      if (graphSeries.get('layout') === 'force') {
        var preservedPoints = graphSeries.preservedPoints || {};
        var graph = graphSeries.getGraph();
        var nodeData = graph.data;
        var edgeData = graph.edgeData;
        var forceModel = graphSeries.getModel('force');
        var initLayout = forceModel.get('initLayout');
        if (graphSeries.preservedPoints) {
          nodeData.each(function(idx) {
            var id = nodeData.getId(idx);
            nodeData.setItemLayout(idx, preservedPoints[id] || [NaN, NaN]);
          });
        } else if (!initLayout || initLayout === 'none') {
          simpleLayoutHelper(graphSeries);
        } else if (initLayout === 'circular') {
          circularLayoutHelper(graphSeries);
        }
        var nodeDataExtent = nodeData.getDataExtent('value');
        var repulsion = forceModel.get('repulsion');
        var edgeLength = forceModel.get('edgeLength');
        var nodes = nodeData.mapArray('value', function(value, idx) {
          var point = nodeData.getItemLayout(idx);
          var rep = numberUtil.linearMap(value, nodeDataExtent, [0, repulsion]) || (repulsion / 2);
          return {
            w: rep,
            rep: rep,
            p: (!point || isNaN(point[0]) || isNaN(point[1])) ? null : point
          };
        });
        var edges = edgeData.mapArray('value', function(value, idx) {
          var edge = graph.getEdgeByIndex(idx);
          return {
            n1: nodes[edge.node1.dataIndex],
            n2: nodes[edge.node2.dataIndex],
            d: edgeLength,
            curveness: edge.getModel().get('lineStyle.normal.curveness') || 0
          };
        });
        var coordSys = graphSeries.coordinateSystem;
        var rect = coordSys.getBoundingRect();
        var forceInstance = forceHelper(nodes, edges, {
          rect: rect,
          gravity: forceModel.get('gravity')
        });
        var oldStep = forceInstance.step;
        forceInstance.step = function(cb) {
          for (var i = 0,
              l = nodes.length; i < l; i++) {
            if (nodes[i].fixed) {
              vec2.copy(nodes[i].p, graph.getNodeByIndex(i).getLayout());
            }
          }
          oldStep(function(nodes, edges, stopped) {
            for (var i = 0,
                l = nodes.length; i < l; i++) {
              if (!nodes[i].fixed) {
                graph.getNodeByIndex(i).setLayout(nodes[i].p);
              }
              preservedPoints[nodeData.getId(i)] = nodes[i].p;
            }
            for (var i = 0,
                l = edges.length; i < l; i++) {
              var e = edges[i];
              var edge = graph.getEdgeByIndex(i);
              var p1 = e.n1.p;
              var p2 = e.n2.p;
              var points = edge.getLayout();
              points = points ? points.slice() : [];
              points[0] = points[0] || [];
              points[1] = points[1] || [];
              vec2.copy(points[0], p1);
              vec2.copy(points[1], p2);
              if (e.curveness > 0) {
                points[2] = [(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness];
              }
              edge.setLayout(points);
            }
            cb && cb(stopped);
          });
        };
        graphSeries.forceLayout = forceInstance;
        graphSeries.preservedPoints = preservedPoints;
        forceInstance.step();
      } else {
        graphSeries.forceLayout = null;
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph/createView.js", ["../../coord/View", "../../util/layout", "zrender/lib/core/bbox", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var View = $__require('../../coord/View');
  var layout = $__require('../../util/layout');
  var bbox = $__require('zrender/lib/core/bbox');
  function getViewRect(seriesModel, api, aspect) {
    var option = seriesModel.getBoxLayoutParams();
    option.aspect = aspect;
    return layout.getLayoutRect(option, {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }
  module.exports = function(ecModel, api) {
    var viewList = [];
    ecModel.eachSeriesByType('graph', function(seriesModel) {
      var coordSysType = seriesModel.get('coordinateSystem');
      if (!coordSysType || coordSysType === 'view') {
        var viewCoordSys = new View();
        viewList.push(viewCoordSys);
        var data = seriesModel.getData();
        var positions = data.mapArray(function(idx) {
          var itemModel = data.getItemModel(idx);
          return [+itemModel.get('x'), +itemModel.get('y')];
        });
        var min = [];
        var max = [];
        bbox.fromPoints(positions, min, max);
        if (max[0] - min[0] === 0) {
          max[0] += 1;
          min[0] -= 1;
        }
        if (max[1] - min[1] === 0) {
          max[1] += 1;
          min[1] -= 1;
        }
        var aspect = (max[0] - min[0]) / (max[1] - min[1]);
        var viewRect = getViewRect(seriesModel, api, aspect);
        if (isNaN(aspect)) {
          min = [viewRect.x, viewRect.y];
          max = [viewRect.x + viewRect.width, viewRect.y + viewRect.height];
        }
        var bbWidth = max[0] - min[0];
        var bbHeight = max[1] - min[1];
        var viewWidth = viewRect.width;
        var viewHeight = viewRect.height;
        viewCoordSys = seriesModel.coordinateSystem = new View();
        viewCoordSys.zoomLimit = seriesModel.get('scaleLimit');
        viewCoordSys.setBoundingRect(min[0], min[1], bbWidth, bbHeight);
        viewCoordSys.setViewRect(viewRect.x, viewRect.y, viewWidth, viewHeight);
        viewCoordSys.setCenter(seriesModel.get('center'));
        viewCoordSys.setZoom(seriesModel.get('zoom'));
      }
    });
    return viewList;
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/graph.js", ["../echarts", "zrender/lib/core/util", "./graph/GraphSeries", "./graph/GraphView", "./graph/roamAction", "./graph/categoryFilter", "../visual/symbol", "./graph/categoryVisual", "./graph/edgeVisual", "./graph/simpleLayout", "./graph/circularLayout", "./graph/forceLayout", "./graph/createView", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../echarts');
  var zrUtil = $__require('zrender/lib/core/util');
  $__require('./graph/GraphSeries');
  $__require('./graph/GraphView');
  $__require('./graph/roamAction');
  echarts.registerProcessor($__require('./graph/categoryFilter'));
  echarts.registerVisual(zrUtil.curry($__require('../visual/symbol'), 'graph', 'circle', null));
  echarts.registerVisual($__require('./graph/categoryVisual'));
  echarts.registerVisual($__require('./graph/edgeVisual'));
  echarts.registerLayout($__require('./graph/simpleLayout'));
  echarts.registerLayout($__require('./graph/circularLayout'));
  echarts.registerLayout($__require('./graph/forceLayout'));
  echarts.registerCoordinateSystem('graphView', {create: $__require('./graph/createView')});
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/gauge/GaugeSeries.js", ["../../data/List", "../../model/Series", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var List = $__require('../../data/List');
  var SeriesModel = $__require('../../model/Series');
  var zrUtil = $__require('zrender/lib/core/util');
  var GaugeSeries = SeriesModel.extend({
    type: 'series.gauge',
    getInitialData: function(option, ecModel) {
      var list = new List(['value'], this);
      var dataOpt = option.data || [];
      if (!zrUtil.isArray(dataOpt)) {
        dataOpt = [dataOpt];
      }
      list.initData(dataOpt);
      return list;
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      center: ['50%', '50%'],
      legendHoverLink: true,
      radius: '75%',
      startAngle: 225,
      endAngle: -45,
      clockwise: true,
      min: 0,
      max: 100,
      splitNumber: 10,
      axisLine: {
        show: true,
        lineStyle: {
          color: [[0.2, '#91c7ae'], [0.8, '#63869e'], [1, '#c23531']],
          width: 30
        }
      },
      splitLine: {
        show: true,
        length: 30,
        lineStyle: {
          color: '#eee',
          width: 2,
          type: 'solid'
        }
      },
      axisTick: {
        show: true,
        splitNumber: 5,
        length: 8,
        lineStyle: {
          color: '#eee',
          width: 1,
          type: 'solid'
        }
      },
      axisLabel: {
        show: true,
        distance: 5,
        textStyle: {color: 'auto'}
      },
      pointer: {
        show: true,
        length: '80%',
        width: 8
      },
      itemStyle: {normal: {color: 'auto'}},
      title: {
        show: true,
        offsetCenter: [0, '-40%'],
        textStyle: {
          color: '#333',
          fontSize: 15
        }
      },
      detail: {
        show: true,
        backgroundColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        borderColor: '#ccc',
        width: 100,
        height: 40,
        offsetCenter: [0, '40%'],
        textStyle: {
          color: 'auto',
          fontSize: 30
        }
      }
    }
  });
  module.exports = GaugeSeries;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/gauge/PointerPath.js", ["zrender/lib/graphic/Path", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('zrender/lib/graphic/Path').extend({
    type: 'echartsGaugePointer',
    shape: {
      angle: 0,
      width: 10,
      r: 10,
      x: 0,
      y: 0
    },
    buildPath: function(ctx, shape) {
      var mathCos = Math.cos;
      var mathSin = Math.sin;
      var r = shape.r;
      var width = shape.width;
      var angle = shape.angle;
      var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);
      var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);
      angle = shape.angle - Math.PI / 2;
      ctx.moveTo(x, y);
      ctx.lineTo(shape.x + mathCos(angle) * width, shape.y + mathSin(angle) * width);
      ctx.lineTo(shape.x + mathCos(shape.angle) * r, shape.y + mathSin(shape.angle) * r);
      ctx.lineTo(shape.x - mathCos(angle) * width, shape.y - mathSin(angle) * width);
      ctx.lineTo(x, y);
      return;
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/gauge/GaugeView.js", ["./PointerPath", "../../util/graphic", "../../util/number", "../../view/Chart", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var PointerPath = $__require('./PointerPath');
  var graphic = $__require('../../util/graphic');
  var numberUtil = $__require('../../util/number');
  var parsePercent = numberUtil.parsePercent;
  function parsePosition(seriesModel, api) {
    var center = seriesModel.get('center');
    var width = api.getWidth();
    var height = api.getHeight();
    var size = Math.min(width, height);
    var cx = parsePercent(center[0], api.getWidth());
    var cy = parsePercent(center[1], api.getHeight());
    var r = parsePercent(seriesModel.get('radius'), size / 2);
    return {
      cx: cx,
      cy: cy,
      r: r
    };
  }
  function formatLabel(label, labelFormatter) {
    if (labelFormatter) {
      if (typeof labelFormatter === 'string') {
        label = labelFormatter.replace('{value}', label);
      } else if (typeof labelFormatter === 'function') {
        label = labelFormatter(label);
      }
    }
    return label;
  }
  var PI2 = Math.PI * 2;
  var GaugeView = $__require('../../view/Chart').extend({
    type: 'gauge',
    render: function(seriesModel, ecModel, api) {
      this.group.removeAll();
      var colorList = seriesModel.get('axisLine.lineStyle.color');
      var posInfo = parsePosition(seriesModel, api);
      this._renderMain(seriesModel, ecModel, api, colorList, posInfo);
    },
    _renderMain: function(seriesModel, ecModel, api, colorList, posInfo) {
      var group = this.group;
      var axisLineModel = seriesModel.getModel('axisLine');
      var lineStyleModel = axisLineModel.getModel('lineStyle');
      var clockwise = seriesModel.get('clockwise');
      var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;
      var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;
      var angleRangeSpan = (endAngle - startAngle) % PI2;
      var prevEndAngle = startAngle;
      var axisLineWidth = lineStyleModel.get('width');
      for (var i = 0; i < colorList.length; i++) {
        var percent = Math.min(Math.max(colorList[i][0], 0), 1);
        var endAngle = startAngle + angleRangeSpan * percent;
        var sector = new graphic.Sector({
          shape: {
            startAngle: prevEndAngle,
            endAngle: endAngle,
            cx: posInfo.cx,
            cy: posInfo.cy,
            clockwise: clockwise,
            r0: posInfo.r - axisLineWidth,
            r: posInfo.r
          },
          silent: true
        });
        sector.setStyle({fill: colorList[i][1]});
        sector.setStyle(lineStyleModel.getLineStyle(['color', 'borderWidth', 'borderColor']));
        group.add(sector);
        prevEndAngle = endAngle;
      }
      var getColor = function(percent) {
        if (percent <= 0) {
          return colorList[0][1];
        }
        for (var i = 0; i < colorList.length; i++) {
          if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {
            return colorList[i][1];
          }
        }
        return colorList[i - 1][1];
      };
      if (!clockwise) {
        var tmp = startAngle;
        startAngle = endAngle;
        endAngle = tmp;
      }
      this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);
      this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);
      this._renderTitle(seriesModel, ecModel, api, getColor, posInfo);
      this._renderDetail(seriesModel, ecModel, api, getColor, posInfo);
    },
    _renderTicks: function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
      var group = this.group;
      var cx = posInfo.cx;
      var cy = posInfo.cy;
      var r = posInfo.r;
      var minVal = seriesModel.get('min');
      var maxVal = seriesModel.get('max');
      var splitLineModel = seriesModel.getModel('splitLine');
      var tickModel = seriesModel.getModel('axisTick');
      var labelModel = seriesModel.getModel('axisLabel');
      var splitNumber = seriesModel.get('splitNumber');
      var subSplitNumber = tickModel.get('splitNumber');
      var splitLineLen = parsePercent(splitLineModel.get('length'), r);
      var tickLen = parsePercent(tickModel.get('length'), r);
      var angle = startAngle;
      var step = (endAngle - startAngle) / splitNumber;
      var subStep = step / subSplitNumber;
      var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();
      var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();
      var textStyleModel = labelModel.getModel('textStyle');
      for (var i = 0; i <= splitNumber; i++) {
        var unitX = Math.cos(angle);
        var unitY = Math.sin(angle);
        if (splitLineModel.get('show')) {
          var splitLine = new graphic.Line({
            shape: {
              x1: unitX * r + cx,
              y1: unitY * r + cy,
              x2: unitX * (r - splitLineLen) + cx,
              y2: unitY * (r - splitLineLen) + cy
            },
            style: splitLineStyle,
            silent: true
          });
          if (splitLineStyle.stroke === 'auto') {
            splitLine.setStyle({stroke: getColor(i / splitNumber)});
          }
          group.add(splitLine);
        }
        if (labelModel.get('show')) {
          var label = formatLabel(numberUtil.round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));
          var distance = labelModel.get('distance');
          var text = new graphic.Text({
            style: {
              text: label,
              x: unitX * (r - splitLineLen - distance) + cx,
              y: unitY * (r - splitLineLen - distance) + cy,
              fill: textStyleModel.getTextColor(),
              textFont: textStyleModel.getFont(),
              textVerticalAlign: unitY < -0.4 ? 'top' : (unitY > 0.4 ? 'bottom' : 'middle'),
              textAlign: unitX < -0.4 ? 'left' : (unitX > 0.4 ? 'right' : 'center')
            },
            silent: true
          });
          if (text.style.fill === 'auto') {
            text.setStyle({fill: getColor(i / splitNumber)});
          }
          group.add(text);
        }
        if (tickModel.get('show') && i !== splitNumber) {
          for (var j = 0; j <= subSplitNumber; j++) {
            var unitX = Math.cos(angle);
            var unitY = Math.sin(angle);
            var tickLine = new graphic.Line({
              shape: {
                x1: unitX * r + cx,
                y1: unitY * r + cy,
                x2: unitX * (r - tickLen) + cx,
                y2: unitY * (r - tickLen) + cy
              },
              silent: true,
              style: tickLineStyle
            });
            if (tickLineStyle.stroke === 'auto') {
              tickLine.setStyle({stroke: getColor((i + j / subSplitNumber) / splitNumber)});
            }
            group.add(tickLine);
            angle += subStep;
          }
          angle -= subStep;
        } else {
          angle += step;
        }
      }
    },
    _renderPointer: function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
      var valueExtent = [+seriesModel.get('min'), +seriesModel.get('max')];
      var angleExtent = [startAngle, endAngle];
      if (!clockwise) {
        angleExtent = angleExtent.reverse();
      }
      var data = seriesModel.getData();
      var oldData = this._data;
      var group = this.group;
      data.diff(oldData).add(function(idx) {
        var pointer = new PointerPath({shape: {angle: startAngle}});
        graphic.updateProps(pointer, {shape: {angle: numberUtil.linearMap(data.get('value', idx), valueExtent, angleExtent, true)}}, seriesModel);
        group.add(pointer);
        data.setItemGraphicEl(idx, pointer);
      }).update(function(newIdx, oldIdx) {
        var pointer = oldData.getItemGraphicEl(oldIdx);
        graphic.updateProps(pointer, {shape: {angle: numberUtil.linearMap(data.get('value', newIdx), valueExtent, angleExtent, true)}}, seriesModel);
        group.add(pointer);
        data.setItemGraphicEl(newIdx, pointer);
      }).remove(function(idx) {
        var pointer = oldData.getItemGraphicEl(idx);
        group.remove(pointer);
      }).execute();
      data.eachItemGraphicEl(function(pointer, idx) {
        var itemModel = data.getItemModel(idx);
        var pointerModel = itemModel.getModel('pointer');
        pointer.setShape({
          x: posInfo.cx,
          y: posInfo.cy,
          width: parsePercent(pointerModel.get('width'), posInfo.r),
          r: parsePercent(pointerModel.get('length'), posInfo.r)
        });
        pointer.useStyle(itemModel.getModel('itemStyle.normal').getItemStyle());
        if (pointer.style.fill === 'auto') {
          pointer.setStyle('fill', getColor((data.get('value', idx) - valueExtent[0]) / (valueExtent[1] - valueExtent[0])));
        }
        graphic.setHoverStyle(pointer, itemModel.getModel('itemStyle.emphasis').getItemStyle());
      });
      this._data = data;
    },
    _renderTitle: function(seriesModel, ecModel, api, getColor, posInfo) {
      var titleModel = seriesModel.getModel('title');
      if (titleModel.get('show')) {
        var textStyleModel = titleModel.getModel('textStyle');
        var offsetCenter = titleModel.get('offsetCenter');
        var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);
        var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);
        var text = new graphic.Text({style: {
            x: x,
            y: y,
            text: seriesModel.getData().getName(0),
            fill: textStyleModel.getTextColor(),
            textFont: textStyleModel.getFont(),
            textAlign: 'center',
            textVerticalAlign: 'middle'
          }});
        this.group.add(text);
      }
    },
    _renderDetail: function(seriesModel, ecModel, api, getColor, posInfo) {
      var detailModel = seriesModel.getModel('detail');
      var minVal = seriesModel.get('min');
      var maxVal = seriesModel.get('max');
      if (detailModel.get('show')) {
        var textStyleModel = detailModel.getModel('textStyle');
        var offsetCenter = detailModel.get('offsetCenter');
        var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);
        var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);
        var width = parsePercent(detailModel.get('width'), posInfo.r);
        var height = parsePercent(detailModel.get('height'), posInfo.r);
        var value = seriesModel.getData().get('value', 0);
        var rect = new graphic.Rect({
          shape: {
            x: x - width / 2,
            y: y - height / 2,
            width: width,
            height: height
          },
          style: {
            text: formatLabel(value, detailModel.get('formatter')),
            fill: detailModel.get('backgroundColor'),
            textFill: textStyleModel.getTextColor(),
            textFont: textStyleModel.getFont()
          }
        });
        if (rect.style.textFill === 'auto') {
          rect.setStyle('textFill', getColor(numberUtil.linearMap(value, [minVal, maxVal], [0, 1], true)));
        }
        rect.setStyle(detailModel.getItemStyle(['color']));
        this.group.add(rect);
      }
    }
  });
  module.exports = GaugeView;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/gauge.js", ["./gauge/GaugeSeries", "./gauge/GaugeView", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./gauge/GaugeSeries');
  $__require('./gauge/GaugeView');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/funnel/FunnelSeries.js", ["../../data/List", "../../util/model", "../../data/helper/completeDimensions", "../../echarts", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var List = $__require('../../data/List');
  var modelUtil = $__require('../../util/model');
  var completeDimensions = $__require('../../data/helper/completeDimensions');
  var FunnelSeries = $__require('../../echarts').extendSeriesModel({
    type: 'series.funnel',
    init: function(option) {
      FunnelSeries.superApply(this, 'init', arguments);
      this.legendDataProvider = function() {
        return this._dataBeforeProcessed;
      };
      this._defaultLabelLine(option);
    },
    getInitialData: function(option, ecModel) {
      var dimensions = completeDimensions(['value'], option.data);
      var list = new List(dimensions, this);
      list.initData(option.data);
      return list;
    },
    _defaultLabelLine: function(option) {
      modelUtil.defaultEmphasis(option.labelLine, ['show']);
      var labelLineNormalOpt = option.labelLine.normal;
      var labelLineEmphasisOpt = option.labelLine.emphasis;
      labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show;
      labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show;
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      legendHoverLink: true,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      minSize: '0%',
      maxSize: '100%',
      sort: 'descending',
      gap: 0,
      funnelAlign: 'center',
      label: {
        normal: {
          show: true,
          position: 'outer'
        },
        emphasis: {show: true}
      },
      labelLine: {
        normal: {
          show: true,
          length: 20,
          lineStyle: {
            width: 1,
            type: 'solid'
          }
        },
        emphasis: {}
      },
      itemStyle: {
        normal: {
          borderColor: '#fff',
          borderWidth: 1
        },
        emphasis: {}
      }
    }
  });
  module.exports = FunnelSeries;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/funnel/FunnelView.js", ["../../util/graphic", "zrender/lib/core/util", "../../view/Chart", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var zrUtil = $__require('zrender/lib/core/util');
  function FunnelPiece(data, idx) {
    graphic.Group.call(this);
    var polygon = new graphic.Polygon();
    var labelLine = new graphic.Polyline();
    var text = new graphic.Text();
    this.add(polygon);
    this.add(labelLine);
    this.add(text);
    this.updateData(data, idx, true);
    function onEmphasis() {
      labelLine.ignore = labelLine.hoverIgnore;
      text.ignore = text.hoverIgnore;
    }
    function onNormal() {
      labelLine.ignore = labelLine.normalIgnore;
      text.ignore = text.normalIgnore;
    }
    this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);
  }
  var funnelPieceProto = FunnelPiece.prototype;
  function getLabelStyle(data, idx, state, labelModel) {
    var textStyleModel = labelModel.getModel('textStyle');
    var position = labelModel.get('position');
    var isLabelInside = position === 'inside' || position === 'inner' || position === 'center';
    return {
      fill: textStyleModel.getTextColor() || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),
      textFont: textStyleModel.getFont(),
      text: zrUtil.retrieve(data.hostModel.getFormattedLabel(idx, state), data.getName(idx))
    };
  }
  var opacityAccessPath = ['itemStyle', 'normal', 'opacity'];
  funnelPieceProto.updateData = function(data, idx, firstCreate) {
    var polygon = this.childAt(0);
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout = data.getItemLayout(idx);
    var opacity = data.getItemModel(idx).get(opacityAccessPath);
    opacity = opacity == null ? 1 : opacity;
    polygon.useStyle({});
    if (firstCreate) {
      polygon.setShape({points: layout.points});
      polygon.setStyle({opacity: 0});
      graphic.initProps(polygon, {style: {opacity: opacity}}, seriesModel, idx);
    } else {
      graphic.updateProps(polygon, {
        style: {opacity: opacity},
        shape: {points: layout.points}
      }, seriesModel, idx);
    }
    var itemStyleModel = itemModel.getModel('itemStyle');
    var visualColor = data.getItemVisual(idx, 'color');
    polygon.setStyle(zrUtil.defaults({
      lineJoin: 'round',
      fill: visualColor
    }, itemStyleModel.getModel('normal').getItemStyle(['opacity'])));
    polygon.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();
    this._updateLabel(data, idx);
    graphic.setHoverStyle(this);
  };
  funnelPieceProto._updateLabel = function(data, idx) {
    var labelLine = this.childAt(1);
    var labelText = this.childAt(2);
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout = data.getItemLayout(idx);
    var labelLayout = layout.label;
    var visualColor = data.getItemVisual(idx, 'color');
    graphic.updateProps(labelLine, {shape: {points: labelLayout.linePoints || labelLayout.linePoints}}, seriesModel, idx);
    graphic.updateProps(labelText, {style: {
        x: labelLayout.x,
        y: labelLayout.y
      }}, seriesModel, idx);
    labelText.attr({
      style: {
        textAlign: labelLayout.textAlign,
        textVerticalAlign: labelLayout.verticalAlign,
        textFont: labelLayout.font
      },
      rotation: labelLayout.rotation,
      origin: [labelLayout.x, labelLayout.y],
      z2: 10
    });
    var labelModel = itemModel.getModel('label.normal');
    var labelHoverModel = itemModel.getModel('label.emphasis');
    var labelLineModel = itemModel.getModel('labelLine.normal');
    var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');
    labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel));
    labelText.ignore = labelText.normalIgnore = !labelModel.get('show');
    labelText.hoverIgnore = !labelHoverModel.get('show');
    labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');
    labelLine.hoverIgnore = !labelLineHoverModel.get('show');
    labelLine.setStyle({stroke: visualColor});
    labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());
    labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel);
    labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();
  };
  zrUtil.inherits(FunnelPiece, graphic.Group);
  var Funnel = $__require('../../view/Chart').extend({
    type: 'funnel',
    render: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var oldData = this._data;
      var group = this.group;
      data.diff(oldData).add(function(idx) {
        var funnelPiece = new FunnelPiece(data, idx);
        data.setItemGraphicEl(idx, funnelPiece);
        group.add(funnelPiece);
      }).update(function(newIdx, oldIdx) {
        var piePiece = oldData.getItemGraphicEl(oldIdx);
        piePiece.updateData(data, newIdx);
        group.add(piePiece);
        data.setItemGraphicEl(newIdx, piePiece);
      }).remove(function(idx) {
        var piePiece = oldData.getItemGraphicEl(idx);
        group.remove(piePiece);
      }).execute();
      this._data = data;
    },
    remove: function() {
      this.group.removeAll();
      this._data = null;
    }
  });
  module.exports = Funnel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/visual/dataColor.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(seriesType, ecModel) {
    var paletteScope = {};
    ecModel.eachRawSeriesByType(seriesType, function(seriesModel) {
      var dataAll = seriesModel.getRawData();
      var idxMap = {};
      if (!ecModel.isSeriesFiltered(seriesModel)) {
        var data = seriesModel.getData();
        data.each(function(idx) {
          var rawIdx = data.getRawIndex(idx);
          idxMap[rawIdx] = idx;
        });
        dataAll.each(function(rawIdx) {
          var itemModel = dataAll.getItemModel(rawIdx);
          var filteredIdx = idxMap[rawIdx];
          var singleDataColor = data.getItemVisual(filteredIdx, 'color', true);
          if (!singleDataColor) {
            var color = itemModel.get('itemStyle.normal.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);
            dataAll.setItemVisual(rawIdx, 'color', color);
            data.setItemVisual(filteredIdx, 'color', color);
          } else {
            dataAll.setItemVisual(rawIdx, 'color', singleDataColor);
          }
        });
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/funnel/funnelLayout.js", ["../../util/layout", "../../util/number", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var layout = $__require('../../util/layout');
  var number = $__require('../../util/number');
  var parsePercent = number.parsePercent;
  function getViewRect(seriesModel, api) {
    return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }
  function getSortedIndices(data, sort) {
    var valueArr = data.mapArray('value', function(val) {
      return val;
    });
    var indices = [];
    var isAscending = sort === 'ascending';
    for (var i = 0,
        len = data.count(); i < len; i++) {
      indices[i] = i;
    }
    indices.sort(function(a, b) {
      return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
    });
    return indices;
  }
  function labelLayout(data) {
    data.each(function(idx) {
      var itemModel = data.getItemModel(idx);
      var labelModel = itemModel.getModel('label.normal');
      var labelPosition = labelModel.get('position');
      var labelLineModel = itemModel.getModel('labelLine.normal');
      var layout = data.getItemLayout(idx);
      var points = layout.points;
      var isLabelInside = labelPosition === 'inner' || labelPosition === 'inside' || labelPosition === 'center';
      var textAlign;
      var textX;
      var textY;
      var linePoints;
      if (isLabelInside) {
        textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;
        textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;
        textAlign = 'center';
        linePoints = [[textX, textY], [textX, textY]];
      } else {
        var x1;
        var y1;
        var x2;
        var labelLineLen = labelLineModel.get('length');
        if (labelPosition === 'left') {
          x1 = (points[3][0] + points[0][0]) / 2;
          y1 = (points[3][1] + points[0][1]) / 2;
          x2 = x1 - labelLineLen;
          textX = x2 - 5;
          textAlign = 'right';
        } else {
          x1 = (points[1][0] + points[2][0]) / 2;
          y1 = (points[1][1] + points[2][1]) / 2;
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = 'left';
        }
        var y2 = y1;
        linePoints = [[x1, y1], [x2, y2]];
        textY = y2;
      }
      layout.label = {
        linePoints: linePoints,
        x: textX,
        y: textY,
        verticalAlign: 'middle',
        textAlign: textAlign,
        inside: isLabelInside
      };
    });
  }
  module.exports = function(ecModel, api, payload) {
    ecModel.eachSeriesByType('funnel', function(seriesModel) {
      var data = seriesModel.getData();
      var sort = seriesModel.get('sort');
      var viewRect = getViewRect(seriesModel, api);
      var indices = getSortedIndices(data, sort);
      var sizeExtent = [parsePercent(seriesModel.get('minSize'), viewRect.width), parsePercent(seriesModel.get('maxSize'), viewRect.width)];
      var dataExtent = data.getDataExtent('value');
      var min = seriesModel.get('min');
      var max = seriesModel.get('max');
      if (min == null) {
        min = Math.min(dataExtent[0], 0);
      }
      if (max == null) {
        max = dataExtent[1];
      }
      var funnelAlign = seriesModel.get('funnelAlign');
      var gap = seriesModel.get('gap');
      var itemHeight = (viewRect.height - gap * (data.count() - 1)) / data.count();
      var y = viewRect.y;
      var getLinePoints = function(idx, offY) {
        var val = data.get('value', idx) || 0;
        var itemWidth = number.linearMap(val, [min, max], sizeExtent, true);
        var x0;
        switch (funnelAlign) {
          case 'left':
            x0 = viewRect.x;
            break;
          case 'center':
            x0 = viewRect.x + (viewRect.width - itemWidth) / 2;
            break;
          case 'right':
            x0 = viewRect.x + viewRect.width - itemWidth;
            break;
        }
        return [[x0, offY], [x0 + itemWidth, offY]];
      };
      if (sort === 'ascending') {
        itemHeight = -itemHeight;
        gap = -gap;
        y += viewRect.height;
        indices = indices.reverse();
      }
      for (var i = 0; i < indices.length; i++) {
        var idx = indices[i];
        var nextIdx = indices[i + 1];
        var start = getLinePoints(idx, y);
        var end = getLinePoints(nextIdx, y + itemHeight);
        y += itemHeight + gap;
        data.setItemLayout(idx, {points: start.concat(end.slice().reverse())});
      }
      labelLayout(data);
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/processor/dataFilter.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(seriesType, ecModel) {
    var legendModels = ecModel.findComponents({mainType: 'legend'});
    if (!legendModels || !legendModels.length) {
      return;
    }
    ecModel.eachSeriesByType(seriesType, function(series) {
      var data = series.getData();
      data.filterSelf(function(idx) {
        var name = data.getName(idx);
        for (var i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(name)) {
            return false;
          }
        }
        return true;
      }, this);
    }, this);
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/funnel.js", ["zrender/lib/core/util", "../echarts", "./funnel/FunnelSeries", "./funnel/FunnelView", "../visual/dataColor", "./funnel/funnelLayout", "../processor/dataFilter", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var echarts = $__require('../echarts');
  $__require('./funnel/FunnelSeries');
  $__require('./funnel/FunnelView');
  echarts.registerVisual(zrUtil.curry($__require('../visual/dataColor'), 'funnel'));
  echarts.registerLayout($__require('./funnel/funnelLayout'));
  echarts.registerProcessor(zrUtil.curry($__require('../processor/dataFilter'), 'funnel'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/parallel/ParallelSeries.js", ["../../data/List", "zrender/lib/core/util", "../../model/Series", "../../data/helper/completeDimensions", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var List = $__require('../../data/List');
  var zrUtil = $__require('zrender/lib/core/util');
  var SeriesModel = $__require('../../model/Series');
  var completeDimensions = $__require('../../data/helper/completeDimensions');
  module.exports = SeriesModel.extend({
    type: 'series.parallel',
    dependencies: ['parallel'],
    getInitialData: function(option, ecModel) {
      var parallelModel = ecModel.getComponent('parallel', this.get('parallelIndex'));
      var parallelAxisIndices = parallelModel.parallelAxisIndex;
      var rawData = option.data;
      var modelDims = parallelModel.dimensions;
      var dataDims = generateDataDims(modelDims, rawData);
      var dataDimsInfo = zrUtil.map(dataDims, function(dim, dimIndex) {
        var modelDimsIndex = zrUtil.indexOf(modelDims, dim);
        var axisModel = modelDimsIndex >= 0 && ecModel.getComponent('parallelAxis', parallelAxisIndices[modelDimsIndex]);
        if (axisModel && axisModel.get('type') === 'category') {
          translateCategoryValue(axisModel, dim, rawData);
          return {
            name: dim,
            type: 'ordinal'
          };
        } else if (modelDimsIndex < 0) {
          return completeDimensions.guessOrdinal(rawData, dimIndex) ? {
            name: dim,
            type: 'ordinal'
          } : dim;
        } else {
          return dim;
        }
      });
      var list = new List(dataDimsInfo, this);
      list.initData(rawData);
      if (this.option.progressive) {
        this.option.animation = false;
      }
      return list;
    },
    getRawIndicesByActiveState: function(activeState) {
      var coordSys = this.coordinateSystem;
      var data = this.getData();
      var indices = [];
      coordSys.eachActiveState(data, function(theActiveState, dataIndex) {
        if (activeState === theActiveState) {
          indices.push(data.getRawIndex(dataIndex));
        }
      });
      return indices;
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'parallel',
      parallelIndex: 0,
      label: {
        normal: {show: false},
        emphasis: {show: false}
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {normal: {
          width: 1,
          opacity: 0.45,
          type: 'solid'
        }},
      progressive: false,
      smooth: false,
      animationEasing: 'linear'
    }
  });
  function translateCategoryValue(axisModel, dim, rawData) {
    var axisData = axisModel.get('data');
    var numberDim = convertDimNameToNumber(dim);
    if (axisData && axisData.length) {
      zrUtil.each(rawData, function(dataItem) {
        if (!dataItem) {
          return;
        }
        var index = zrUtil.indexOf(axisData, dataItem[numberDim]);
        dataItem[numberDim] = index >= 0 ? index : NaN;
      });
    }
  }
  function convertDimNameToNumber(dimName) {
    return +dimName.replace('dim', '');
  }
  function generateDataDims(modelDims, rawData) {
    var maxDimNum = 0;
    zrUtil.each(modelDims, function(dimName) {
      var numberDim = convertDimNameToNumber(dimName);
      numberDim > maxDimNum && (maxDimNum = numberDim);
    });
    var firstItem = rawData[0];
    if (firstItem && firstItem.length - 1 > maxDimNum) {
      maxDimNum = firstItem.length - 1;
    }
    var dataDims = [];
    for (var i = 0; i <= maxDimNum; i++) {
      dataDims.push('dim' + i);
    }
    return dataDims;
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/parallel/ParallelView.js", ["../../util/graphic", "zrender/lib/core/util", "../../view/Chart", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var zrUtil = $__require('zrender/lib/core/util');
  var SMOOTH = 0.3;
  var ParallelView = $__require('../../view/Chart').extend({
    type: 'parallel',
    init: function() {
      this._dataGroup = new graphic.Group();
      this.group.add(this._dataGroup);
      this._data;
    },
    render: function(seriesModel, ecModel, api, payload) {
      this._renderForNormal(seriesModel);
    },
    _renderForNormal: function(seriesModel) {
      var dataGroup = this._dataGroup;
      var data = seriesModel.getData();
      var oldData = this._data;
      var coordSys = seriesModel.coordinateSystem;
      var dimensions = coordSys.dimensions;
      var option = seriesModel.option;
      var smooth = option.smooth ? SMOOTH : null;
      data.diff(oldData).add(add).update(update).remove(remove).execute();
      updateElCommon(data, smooth);
      if (!this._data) {
        var clipPath = createGridClipShape(coordSys, seriesModel, function() {
          setTimeout(function() {
            dataGroup.removeClipPath();
          });
        });
        dataGroup.setClipPath(clipPath);
      }
      this._data = data;
      function add(newDataIndex) {
        addEl(data, dataGroup, newDataIndex, dimensions, coordSys, null, smooth);
      }
      function update(newDataIndex, oldDataIndex) {
        var line = oldData.getItemGraphicEl(oldDataIndex);
        var points = createLinePoints(data, newDataIndex, dimensions, coordSys);
        data.setItemGraphicEl(newDataIndex, line);
        graphic.updateProps(line, {shape: {points: points}}, seriesModel, newDataIndex);
      }
      function remove(oldDataIndex) {
        var line = oldData.getItemGraphicEl(oldDataIndex);
        dataGroup.remove(line);
      }
    },
    remove: function() {
      this._dataGroup && this._dataGroup.removeAll();
      this._data = null;
    }
  });
  function createGridClipShape(coordSys, seriesModel, cb) {
    var parallelModel = coordSys.model;
    var rect = coordSys.getRect();
    var rectEl = new graphic.Rect({shape: {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      }});
    var dim = parallelModel.get('layout') === 'horizontal' ? 'width' : 'height';
    rectEl.setShape(dim, 0);
    graphic.initProps(rectEl, {shape: {
        width: rect.width,
        height: rect.height
      }}, seriesModel, cb);
    return rectEl;
  }
  function createLinePoints(data, dataIndex, dimensions, coordSys) {
    var points = [];
    for (var i = 0; i < dimensions.length; i++) {
      var dimName = dimensions[i];
      var value = data.get(dimName, dataIndex);
      if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {
        points.push(coordSys.dataToPoint(value, dimName));
      }
    }
    return points;
  }
  function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {
    var points = createLinePoints(data, dataIndex, dimensions, coordSys);
    var line = new graphic.Polyline({
      shape: {points: points},
      silent: true,
      z2: 10
    });
    dataGroup.add(line);
    data.setItemGraphicEl(dataIndex, line);
  }
  function updateElCommon(data, smooth) {
    var seriesStyleModel = data.hostModel.getModel('lineStyle.normal');
    var lineStyle = seriesStyleModel.getLineStyle();
    data.eachItemGraphicEl(function(line, dataIndex) {
      if (data.hasItemOption) {
        var itemModel = data.getItemModel(dataIndex);
        var lineStyleModel = itemModel.getModel('lineStyle.normal', seriesStyleModel);
        lineStyle = lineStyleModel.getLineStyle();
      }
      line.useStyle(zrUtil.extend(lineStyle, {
        fill: null,
        stroke: data.getItemVisual(dataIndex, 'color'),
        opacity: data.getItemVisual(dataIndex, 'opacity')
      }));
      line.shape.smooth = smooth;
    });
  }
  function isEmptyValue(val, axisType) {
    return axisType === 'category' ? val == null : (val == null || isNaN(val));
  }
  module.exports = ParallelView;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/parallel/parallelVisual.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(ecModel) {
    ecModel.eachSeriesByType('parallel', function(seriesModel) {
      var itemStyleModel = seriesModel.getModel('itemStyle.normal');
      var lineStyleModel = seriesModel.getModel('lineStyle.normal');
      var globalColors = ecModel.get('color');
      var color = lineStyleModel.get('color') || itemStyleModel.get('color') || globalColors[seriesModel.seriesIndex % globalColors.length];
      var inactiveOpacity = seriesModel.get('inactiveOpacity');
      var activeOpacity = seriesModel.get('activeOpacity');
      var lineStyle = seriesModel.getModel('lineStyle.normal').getLineStyle();
      var coordSys = seriesModel.coordinateSystem;
      var data = seriesModel.getData();
      var opacityMap = {
        normal: lineStyle.opacity,
        active: activeOpacity,
        inactive: inactiveOpacity
      };
      coordSys.eachActiveState(data, function(activeState, dataIndex) {
        data.setItemVisual(dataIndex, 'opacity', opacityMap[activeState]);
      });
      data.setVisual('color', color);
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/parallel.js", ["../echarts", "../component/parallel", "./parallel/ParallelSeries", "./parallel/ParallelView", "./parallel/parallelVisual", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../echarts');
  $__require('../component/parallel');
  $__require('./parallel/ParallelSeries');
  $__require('./parallel/ParallelView');
  echarts.registerVisual($__require('./parallel/parallelVisual'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/data/Graph.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Graph = function(directed) {
    this._directed = directed || false;
    this.nodes = [];
    this.edges = [];
    this._nodesMap = {};
    this._edgesMap = {};
    this.data;
    this.edgeData;
  };
  var graphProto = Graph.prototype;
  graphProto.type = 'graph';
  graphProto.isDirected = function() {
    return this._directed;
  };
  graphProto.addNode = function(id, dataIndex) {
    id = id || ('' + dataIndex);
    var nodesMap = this._nodesMap;
    if (nodesMap[id]) {
      return;
    }
    var node = new Node(id, dataIndex);
    node.hostGraph = this;
    this.nodes.push(node);
    nodesMap[id] = node;
    return node;
  };
  graphProto.getNodeByIndex = function(dataIndex) {
    var rawIdx = this.data.getRawIndex(dataIndex);
    return this.nodes[rawIdx];
  };
  graphProto.getNodeById = function(id) {
    return this._nodesMap[id];
  };
  graphProto.addEdge = function(n1, n2, dataIndex) {
    var nodesMap = this._nodesMap;
    var edgesMap = this._edgesMap;
    if (typeof n1 === 'number') {
      n1 = this.nodes[n1];
    }
    if (typeof n2 === 'number') {
      n2 = this.nodes[n2];
    }
    if (!(n1 instanceof Node)) {
      n1 = nodesMap[n1];
    }
    if (!(n2 instanceof Node)) {
      n2 = nodesMap[n2];
    }
    if (!n1 || !n2) {
      return;
    }
    var key = n1.id + '-' + n2.id;
    if (edgesMap[key]) {
      return;
    }
    var edge = new Edge(n1, n2, dataIndex);
    edge.hostGraph = this;
    if (this._directed) {
      n1.outEdges.push(edge);
      n2.inEdges.push(edge);
    }
    n1.edges.push(edge);
    if (n1 !== n2) {
      n2.edges.push(edge);
    }
    this.edges.push(edge);
    edgesMap[key] = edge;
    return edge;
  };
  graphProto.getEdgeByIndex = function(dataIndex) {
    var rawIdx = this.edgeData.getRawIndex(dataIndex);
    return this.edges[rawIdx];
  };
  graphProto.getEdge = function(n1, n2) {
    if (n1 instanceof Node) {
      n1 = n1.id;
    }
    if (n2 instanceof Node) {
      n2 = n2.id;
    }
    var edgesMap = this._edgesMap;
    if (this._directed) {
      return edgesMap[n1 + '-' + n2];
    } else {
      return edgesMap[n1 + '-' + n2] || edgesMap[n2 + '-' + n1];
    }
  };
  graphProto.eachNode = function(cb, context) {
    var nodes = this.nodes;
    var len = nodes.length;
    for (var i = 0; i < len; i++) {
      if (nodes[i].dataIndex >= 0) {
        cb.call(context, nodes[i], i);
      }
    }
  };
  graphProto.eachEdge = function(cb, context) {
    var edges = this.edges;
    var len = edges.length;
    for (var i = 0; i < len; i++) {
      if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {
        cb.call(context, edges[i], i);
      }
    }
  };
  graphProto.breadthFirstTraverse = function(cb, startNode, direction, context) {
    if (!(startNode instanceof Node)) {
      startNode = this._nodesMap[startNode];
    }
    if (!startNode) {
      return;
    }
    var edgeType = direction === 'out' ? 'outEdges' : (direction === 'in' ? 'inEdges' : 'edges');
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].__visited = false;
    }
    if (cb.call(context, startNode, null)) {
      return;
    }
    var queue = [startNode];
    while (queue.length) {
      var currentNode = queue.shift();
      var edges = currentNode[edgeType];
      for (var i = 0; i < edges.length; i++) {
        var e = edges[i];
        var otherNode = e.node1 === currentNode ? e.node2 : e.node1;
        if (!otherNode.__visited) {
          if (cb.call(otherNode, otherNode, currentNode)) {
            return;
          }
          queue.push(otherNode);
          otherNode.__visited = true;
        }
      }
    }
  };
  graphProto.update = function() {
    var data = this.data;
    var edgeData = this.edgeData;
    var nodes = this.nodes;
    var edges = this.edges;
    for (var i = 0,
        len = nodes.length; i < len; i++) {
      nodes[i].dataIndex = -1;
    }
    for (var i = 0,
        len = data.count(); i < len; i++) {
      nodes[data.getRawIndex(i)].dataIndex = i;
    }
    edgeData.filterSelf(function(idx) {
      var edge = edges[edgeData.getRawIndex(idx)];
      return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
    });
    for (var i = 0,
        len = edges.length; i < len; i++) {
      edges[i].dataIndex = -1;
    }
    for (var i = 0,
        len = edgeData.count(); i < len; i++) {
      edges[edgeData.getRawIndex(i)].dataIndex = i;
    }
  };
  graphProto.clone = function() {
    var graph = new Graph(this._directed);
    var nodes = this.nodes;
    var edges = this.edges;
    for (var i = 0; i < nodes.length; i++) {
      graph.addNode(nodes[i].id, nodes[i].dataIndex);
    }
    for (var i = 0; i < edges.length; i++) {
      var e = edges[i];
      graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);
    }
    return graph;
  };
  function Node(id, dataIndex) {
    this.id = id == null ? '' : id;
    this.inEdges = [];
    this.outEdges = [];
    this.edges = [];
    this.hostGraph;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }
  Node.prototype = {
    constructor: Node,
    degree: function() {
      return this.edges.length;
    },
    inDegree: function() {
      return this.inEdges.length;
    },
    outDegree: function() {
      return this.outEdges.length;
    },
    getModel: function(path) {
      if (this.dataIndex < 0) {
        return;
      }
      var graph = this.hostGraph;
      var itemModel = graph.data.getItemModel(this.dataIndex);
      return itemModel.getModel(path);
    }
  };
  function Edge(n1, n2, dataIndex) {
    this.node1 = n1;
    this.node2 = n2;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }
  Edge.prototype.getModel = function(path) {
    if (this.dataIndex < 0) {
      return;
    }
    var graph = this.hostGraph;
    var itemModel = graph.edgeData.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  };
  var createGraphDataProxyMixin = function(hostName, dataName) {
    return {
      getValue: function(dimension) {
        var data = this[hostName][dataName];
        return data.get(data.getDimension(dimension || 'value'), this.dataIndex);
      },
      setVisual: function(key, value) {
        this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);
      },
      getVisual: function(key, ignoreParent) {
        return this[hostName][dataName].getItemVisual(this.dataIndex, key, ignoreParent);
      },
      setLayout: function(layout, merge) {
        this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge);
      },
      getLayout: function() {
        return this[hostName][dataName].getItemLayout(this.dataIndex);
      },
      getGraphicEl: function() {
        return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
      },
      getRawIndex: function() {
        return this[hostName][dataName].getRawIndex(this.dataIndex);
      }
    };
  };
  zrUtil.mixin(Node, createGraphDataProxyMixin('hostGraph', 'data'));
  zrUtil.mixin(Edge, createGraphDataProxyMixin('hostGraph', 'edgeData'));
  Graph.Node = Node;
  Graph.Edge = Edge;
  module.exports = Graph;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/data/helper/linkList.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var each = zrUtil.each;
  var DATAS = '\0__link_datas';
  var MAIN_DATA = '\0__link_mainData';
  function linkList(opt) {
    var mainData = opt.mainData;
    var datas = opt.datas;
    if (!datas) {
      datas = {main: mainData};
      opt.datasAttr = {main: 'data'};
    }
    opt.datas = opt.mainData = null;
    linkAll(mainData, datas, opt);
    each(datas, function(data) {
      each(mainData.TRANSFERABLE_METHODS, function(methodName) {
        data.wrapMethod(methodName, zrUtil.curry(transferInjection, opt));
      });
    });
    mainData.wrapMethod('cloneShallow', zrUtil.curry(cloneShallowInjection, opt));
    each(mainData.CHANGABLE_METHODS, function(methodName) {
      mainData.wrapMethod(methodName, zrUtil.curry(changeInjection, opt));
    });
    zrUtil.assert(datas[mainData.dataType] === mainData);
  }
  function transferInjection(opt, res) {
    if (isMainData(this)) {
      var datas = zrUtil.extend({}, this[DATAS]);
      datas[this.dataType] = res;
      linkAll(res, datas, opt);
    } else {
      linkSingle(res, this.dataType, this[MAIN_DATA], opt);
    }
    return res;
  }
  function changeInjection(opt, res) {
    opt.struct && opt.struct.update(this);
    return res;
  }
  function cloneShallowInjection(opt, res) {
    each(res[DATAS], function(data, dataType) {
      data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
    });
    return res;
  }
  function getLinkedData(dataType) {
    var mainData = this[MAIN_DATA];
    return (dataType == null || mainData == null) ? mainData : mainData[DATAS][dataType];
  }
  function isMainData(data) {
    return data[MAIN_DATA] === data;
  }
  function linkAll(mainData, datas, opt) {
    mainData[DATAS] = {};
    each(datas, function(data, dataType) {
      linkSingle(data, dataType, mainData, opt);
    });
  }
  function linkSingle(data, dataType, mainData, opt) {
    mainData[DATAS][dataType] = data;
    data[MAIN_DATA] = mainData;
    data.dataType = dataType;
    if (opt.struct) {
      data[opt.structAttr] = opt.struct;
      opt.struct[opt.datasAttr[dataType]] = data;
    }
    data.getLinkedData = getLinkedData;
  }
  module.exports = linkList;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/createGraphFromNodeEdge.js", ["../../data/List", "../../data/Graph", "../../data/helper/linkList", "../../data/helper/completeDimensions", "../../CoordinateSystem", "zrender/lib/core/util", "./createListFromArray", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var List = $__require('../../data/List');
  var Graph = $__require('../../data/Graph');
  var linkList = $__require('../../data/helper/linkList');
  var completeDimensions = $__require('../../data/helper/completeDimensions');
  var CoordinateSystem = $__require('../../CoordinateSystem');
  var zrUtil = $__require('zrender/lib/core/util');
  var createListFromArray = $__require('./createListFromArray');
  module.exports = function(nodes, edges, hostModel, directed, beforeLink) {
    var graph = new Graph(directed);
    for (var i = 0; i < nodes.length; i++) {
      graph.addNode(zrUtil.retrieve(nodes[i].id, nodes[i].name, i), i);
    }
    var linkNameList = [];
    var validEdges = [];
    for (var i = 0; i < edges.length; i++) {
      var link = edges[i];
      var source = link.source;
      var target = link.target;
      if (graph.addEdge(source, target, i)) {
        validEdges.push(link);
        linkNameList.push(zrUtil.retrieve(link.id, source + ' > ' + target));
      }
    }
    var coordSys = hostModel.get('coordinateSystem');
    var nodeData;
    if (coordSys === 'cartesian2d' || coordSys === 'polar') {
      nodeData = createListFromArray(nodes, hostModel, hostModel.ecModel);
    } else {
      var coordSysCtor = CoordinateSystem.get(coordSys);
      var dimensionNames = completeDimensions(((coordSysCtor && coordSysCtor.type !== 'view') ? (coordSysCtor.dimensions || []) : []).concat(['value']), nodes);
      nodeData = new List(dimensionNames, hostModel);
      nodeData.initData(nodes);
    }
    var edgeData = new List(['value'], hostModel);
    edgeData.initData(validEdges, linkNameList);
    beforeLink && beforeLink(nodeData, edgeData);
    linkList({
      mainData: nodeData,
      struct: graph,
      structAttr: 'graph',
      datas: {
        node: nodeData,
        edge: edgeData
      },
      datasAttr: {
        node: 'data',
        edge: 'edgeData'
      }
    });
    graph.update();
    return graph;
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/sankey/SankeySeries.js", ["../../model/Series", "../helper/createGraphFromNodeEdge", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SeriesModel = $__require('../../model/Series');
  var createGraphFromNodeEdge = $__require('../helper/createGraphFromNodeEdge');
  var SankeySeries = SeriesModel.extend({
    type: 'series.sankey',
    layoutInfo: null,
    getInitialData: function(option, ecModel) {
      var links = option.edges || option.links;
      var nodes = option.data || option.nodes;
      if (nodes && links) {
        var graph = createGraphFromNodeEdge(nodes, links, this, true);
        return graph.data;
      }
    },
    getGraph: function() {
      return this.getData().graph;
    },
    getEdgeData: function() {
      return this.getGraph().edgeData;
    },
    formatTooltip: function(dataIndex, multipleSeries, dataType) {
      if (dataType === 'edge') {
        var params = this.getDataParams(dataIndex, dataType);
        var rawDataOpt = params.data;
        var html = rawDataOpt.source + ' -- ' + rawDataOpt.target;
        if (params.value) {
          html += ' : ' + params.value;
        }
        return html;
      } else {
        return SankeySeries.superCall(this, 'formatTooltip', dataIndex, multipleSeries);
      }
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'view',
      layout: null,
      left: '5%',
      top: '5%',
      right: '20%',
      bottom: '5%',
      nodeWidth: 20,
      nodeGap: 8,
      layoutIterations: 32,
      label: {
        normal: {
          show: true,
          position: 'right',
          textStyle: {
            color: '#000',
            fontSize: 12
          }
        },
        emphasis: {show: true}
      },
      itemStyle: {normal: {
          borderWidth: 1,
          borderColor: '#333'
        }},
      lineStyle: {
        normal: {
          color: '#314656',
          opacity: 0.2,
          curveness: 0.5
        },
        emphasis: {opacity: 0.6}
      },
      animationEasing: 'linear',
      animationDuration: 1000
    }
  });
  module.exports = SankeySeries;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/sankey/SankeyView.js", ["../../util/graphic", "zrender/lib/core/util", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var zrUtil = $__require('zrender/lib/core/util');
  var SankeyShape = graphic.extendShape({
    shape: {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      cpx1: 0,
      cpy1: 0,
      cpx2: 0,
      cpy2: 0,
      extent: 0
    },
    buildPath: function(ctx, shape) {
      var halfExtent = shape.extent / 2;
      ctx.moveTo(shape.x1, shape.y1 - halfExtent);
      ctx.bezierCurveTo(shape.cpx1, shape.cpy1 - halfExtent, shape.cpx2, shape.cpy2 - halfExtent, shape.x2, shape.y2 - halfExtent);
      ctx.lineTo(shape.x2, shape.y2 + halfExtent);
      ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + halfExtent, shape.cpx1, shape.cpy1 + halfExtent, shape.x1, shape.y1 + halfExtent);
      ctx.closePath();
    }
  });
  module.exports = $__require('../../echarts').extendChartView({
    type: 'sankey',
    _model: null,
    render: function(seriesModel, ecModel, api) {
      var graph = seriesModel.getGraph();
      var group = this.group;
      var layoutInfo = seriesModel.layoutInfo;
      var nodeData = seriesModel.getData();
      var edgeData = seriesModel.getData('edge');
      this._model = seriesModel;
      group.removeAll();
      group.position = [layoutInfo.x, layoutInfo.y];
      graph.eachNode(function(node) {
        var layout = node.getLayout();
        var itemModel = node.getModel();
        var labelModel = itemModel.getModel('label.normal');
        var textStyleModel = labelModel.getModel('textStyle');
        var labelHoverModel = itemModel.getModel('label.emphasis');
        var textStyleHoverModel = labelHoverModel.getModel('textStyle');
        var rect = new graphic.Rect({
          shape: {
            x: layout.x,
            y: layout.y,
            width: node.getLayout().dx,
            height: node.getLayout().dy
          },
          style: {
            text: labelModel.get('show') ? seriesModel.getFormattedLabel(node.dataIndex, 'normal') || node.id : '',
            textFont: textStyleModel.getFont(),
            textFill: textStyleModel.getTextColor(),
            textPosition: labelModel.get('position')
          }
        });
        rect.setStyle(zrUtil.defaults({fill: node.getVisual('color')}, itemModel.getModel('itemStyle.normal').getItemStyle()));
        graphic.setHoverStyle(rect, zrUtil.extend(node.getModel('itemStyle.emphasis'), {
          text: labelHoverModel.get('show') ? seriesModel.getFormattedLabel(node.dataIndex, 'emphasis') || node.id : '',
          textFont: textStyleHoverModel.getFont(),
          textFill: textStyleHoverModel.getTextColor(),
          textPosition: labelHoverModel.get('position')
        }));
        group.add(rect);
        nodeData.setItemGraphicEl(node.dataIndex, rect);
        rect.dataType = 'node';
      });
      graph.eachEdge(function(edge) {
        var curve = new SankeyShape();
        curve.dataIndex = edge.dataIndex;
        curve.seriesIndex = seriesModel.seriesIndex;
        curve.dataType = 'edge';
        var lineStyleModel = edge.getModel('lineStyle.normal');
        var curvature = lineStyleModel.get('curveness');
        var n1Layout = edge.node1.getLayout();
        var n2Layout = edge.node2.getLayout();
        var edgeLayout = edge.getLayout();
        curve.shape.extent = Math.max(1, edgeLayout.dy);
        var x1 = n1Layout.x + n1Layout.dx;
        var y1 = n1Layout.y + edgeLayout.sy + edgeLayout.dy / 2;
        var x2 = n2Layout.x;
        var y2 = n2Layout.y + edgeLayout.ty + edgeLayout.dy / 2;
        var cpx1 = x1 * (1 - curvature) + x2 * curvature;
        var cpy1 = y1;
        var cpx2 = x1 * curvature + x2 * (1 - curvature);
        var cpy2 = y2;
        curve.setShape({
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2,
          cpx1: cpx1,
          cpy1: cpy1,
          cpx2: cpx2,
          cpy2: cpy2
        });
        curve.setStyle(lineStyleModel.getItemStyle());
        switch (curve.style.fill) {
          case 'source':
            curve.style.fill = edge.node1.getVisual('color');
            break;
          case 'target':
            curve.style.fill = edge.node2.getVisual('color');
            break;
          default:
        }
        graphic.setHoverStyle(curve, edge.getModel('lineStyle.emphasis').getItemStyle());
        group.add(curve);
        edgeData.setItemGraphicEl(edge.dataIndex, curve);
      });
      if (!this._data && seriesModel.get('animation')) {
        group.setClipPath(createGridClipShape(group.getBoundingRect(), seriesModel, function() {
          group.removeClipPath();
        }));
      }
      this._data = seriesModel.getData();
    }
  });
  function createGridClipShape(rect, seriesModel, cb) {
    var rectEl = new graphic.Rect({shape: {
        x: rect.x - 10,
        y: rect.y - 10,
        width: 0,
        height: rect.height + 20
      }});
    graphic.initProps(rectEl, {shape: {
        width: rect.width + 20,
        height: rect.height + 20
      }}, seriesModel, cb);
    return rectEl;
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/util/array/nest.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  function nest() {
    var keysFunction = [];
    var sortKeysFunction = [];
    function map(array, depth) {
      if (depth >= keysFunction.length) {
        return array;
      }
      var i = -1;
      var n = array.length;
      var keyFunction = keysFunction[depth++];
      var mapObject = {};
      var valuesByKey = {};
      while (++i < n) {
        var keyValue = keyFunction(array[i]);
        var values = valuesByKey[keyValue];
        if (values) {
          values.push(array[i]);
        } else {
          valuesByKey[keyValue] = [array[i]];
        }
      }
      zrUtil.each(valuesByKey, function(value, key) {
        mapObject[key] = map(value, depth);
      });
      return mapObject;
    }
    function entriesMap(mapObject, depth) {
      if (depth >= keysFunction.length) {
        return mapObject;
      }
      var array = [];
      var sortKeyFunction = sortKeysFunction[depth++];
      zrUtil.each(mapObject, function(value, key) {
        array.push({
          key: key,
          values: entriesMap(value, depth)
        });
      });
      if (sortKeyFunction) {
        return array.sort(function(a, b) {
          return sortKeyFunction(a.key, b.key);
        });
      } else {
        return array;
      }
    }
    return {
      key: function(d) {
        keysFunction.push(d);
        return this;
      },
      sortKeys: function(order) {
        sortKeysFunction[keysFunction.length - 1] = order;
        return this;
      },
      entries: function(array) {
        return entriesMap(map(array, 0), 0);
      }
    };
  }
  module.exports = nest;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/sankey/sankeyLayout.js", ["../../util/layout", "../../util/array/nest", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var layout = $__require('../../util/layout');
  var nest = $__require('../../util/array/nest');
  var zrUtil = $__require('zrender/lib/core/util');
  module.exports = function(ecModel, api, payload) {
    ecModel.eachSeriesByType('sankey', function(seriesModel) {
      var nodeWidth = seriesModel.get('nodeWidth');
      var nodeGap = seriesModel.get('nodeGap');
      var layoutInfo = getViewRect(seriesModel, api);
      seriesModel.layoutInfo = layoutInfo;
      var width = layoutInfo.width;
      var height = layoutInfo.height;
      var graph = seriesModel.getGraph();
      var nodes = graph.nodes;
      var edges = graph.edges;
      computeNodeValues(nodes);
      var filteredNodes = nodes.filter(function(node) {
        return node.getLayout().value === 0;
      });
      var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get('layoutIterations');
      layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations);
    });
  };
  function getViewRect(seriesModel, api) {
    return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }
  function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations) {
    computeNodeBreadths(nodes, nodeWidth, width);
    computeNodeDepths(nodes, edges, height, nodeGap, iterations);
    computeEdgeDepths(nodes);
  }
  function computeNodeValues(nodes) {
    zrUtil.each(nodes, function(node) {
      var value1 = sum(node.outEdges, getEdgeValue);
      var value2 = sum(node.inEdges, getEdgeValue);
      var value = Math.max(value1, value2);
      node.setLayout({value: value}, true);
    });
  }
  function computeNodeBreadths(nodes, nodeWidth, width) {
    var remainNodes = nodes;
    var nextNode = null;
    var x = 0;
    var kx = 0;
    while (remainNodes.length) {
      nextNode = [];
      for (var i = 0,
          len = remainNodes.length; i < len; i++) {
        var node = remainNodes[i];
        node.setLayout({x: x}, true);
        node.setLayout({dx: nodeWidth}, true);
        for (var j = 0,
            lenj = node.outEdges.length; j < lenj; j++) {
          nextNode.push(node.outEdges[j].node2);
        }
      }
      remainNodes = nextNode;
      ++x;
    }
    moveSinksRight(nodes, x);
    kx = (width - nodeWidth) / (x - 1);
    scaleNodeBreadths(nodes, kx);
  }
  function moveSinksRight(nodes, x) {
    zrUtil.each(nodes, function(node) {
      if (!node.outEdges.length) {
        node.setLayout({x: x - 1}, true);
      }
    });
  }
  function scaleNodeBreadths(nodes, kx) {
    zrUtil.each(nodes, function(node) {
      var nodeX = node.getLayout().x * kx;
      node.setLayout({x: nodeX}, true);
    });
  }
  function computeNodeDepths(nodes, edges, height, nodeGap, iterations) {
    var nodesByBreadth = nest().key(function(d) {
      return d.getLayout().x;
    }).sortKeys(ascending).entries(nodes).map(function(d) {
      return d.values;
    });
    initializeNodeDepth(nodes, nodesByBreadth, edges, height, nodeGap);
    resolveCollisions(nodesByBreadth, nodeGap, height);
    for (var alpha = 1; iterations > 0; iterations--) {
      alpha *= 0.99;
      relaxRightToLeft(nodesByBreadth, alpha);
      resolveCollisions(nodesByBreadth, nodeGap, height);
      relaxLeftToRight(nodesByBreadth, alpha);
      resolveCollisions(nodesByBreadth, nodeGap, height);
    }
  }
  function initializeNodeDepth(nodes, nodesByBreadth, edges, height, nodeGap) {
    var kyArray = [];
    zrUtil.each(nodesByBreadth, function(nodes) {
      var n = nodes.length;
      var sum = 0;
      zrUtil.each(nodes, function(node) {
        sum += node.getLayout().value;
      });
      var ky = (height - (n - 1) * nodeGap) / sum;
      kyArray.push(ky);
    });
    kyArray.sort(function(a, b) {
      return a - b;
    });
    var ky0 = kyArray[0];
    zrUtil.each(nodesByBreadth, function(nodes) {
      zrUtil.each(nodes, function(node, i) {
        node.setLayout({y: i}, true);
        var nodeDy = node.getLayout().value * ky0;
        node.setLayout({dy: nodeDy}, true);
      });
    });
    zrUtil.each(edges, function(edge) {
      var edgeDy = +edge.getValue() * ky0;
      edge.setLayout({dy: edgeDy}, true);
    });
  }
  function resolveCollisions(nodesByBreadth, nodeGap, height) {
    zrUtil.each(nodesByBreadth, function(nodes) {
      var node;
      var dy;
      var y0 = 0;
      var n = nodes.length;
      var i;
      nodes.sort(ascendingDepth);
      for (i = 0; i < n; i++) {
        node = nodes[i];
        dy = y0 - node.getLayout().y;
        if (dy > 0) {
          var nodeY = node.getLayout().y + dy;
          node.setLayout({y: nodeY}, true);
        }
        y0 = node.getLayout().y + node.getLayout().dy + nodeGap;
      }
      dy = y0 - nodeGap - height;
      if (dy > 0) {
        var nodeY = node.getLayout().y - dy;
        node.setLayout({y: nodeY}, true);
        y0 = node.getLayout().y;
        for (i = n - 2; i >= 0; --i) {
          node = nodes[i];
          dy = node.getLayout().y + node.getLayout().dy + nodeGap - y0;
          if (dy > 0) {
            nodeY = node.getLayout().y - dy;
            node.setLayout({y: nodeY}, true);
          }
          y0 = node.getLayout().y;
        }
      }
    });
  }
  function relaxRightToLeft(nodesByBreadth, alpha) {
    zrUtil.each(nodesByBreadth.slice().reverse(), function(nodes) {
      zrUtil.each(nodes, function(node) {
        if (node.outEdges.length) {
          var y = sum(node.outEdges, weightedTarget) / sum(node.outEdges, getEdgeValue);
          var nodeY = node.getLayout().y + (y - center(node)) * alpha;
          node.setLayout({y: nodeY}, true);
        }
      });
    });
  }
  function weightedTarget(edge) {
    return center(edge.node2) * edge.getValue();
  }
  function relaxLeftToRight(nodesByBreadth, alpha) {
    zrUtil.each(nodesByBreadth, function(nodes) {
      zrUtil.each(nodes, function(node) {
        if (node.inEdges.length) {
          var y = sum(node.inEdges, weightedSource) / sum(node.inEdges, getEdgeValue);
          var nodeY = node.getLayout().y + (y - center(node)) * alpha;
          node.setLayout({y: nodeY}, true);
        }
      });
    });
  }
  function weightedSource(edge) {
    return center(edge.node1) * edge.getValue();
  }
  function computeEdgeDepths(nodes) {
    zrUtil.each(nodes, function(node) {
      node.outEdges.sort(ascendingTargetDepth);
      node.inEdges.sort(ascendingSourceDepth);
    });
    zrUtil.each(nodes, function(node) {
      var sy = 0;
      var ty = 0;
      zrUtil.each(node.outEdges, function(edge) {
        edge.setLayout({sy: sy}, true);
        sy += edge.getLayout().dy;
      });
      zrUtil.each(node.inEdges, function(edge) {
        edge.setLayout({ty: ty}, true);
        ty += edge.getLayout().dy;
      });
    });
  }
  function ascendingTargetDepth(a, b) {
    return a.node2.getLayout().y - b.node2.getLayout().y;
  }
  function ascendingSourceDepth(a, b) {
    return a.node1.getLayout().y - b.node1.getLayout().y;
  }
  function sum(array, f) {
    var s = 0;
    var n = array.length;
    var a;
    var i = -1;
    if (arguments.length === 1) {
      while (++i < n) {
        a = +array[i];
        if (!isNaN(a)) {
          s += a;
        }
      }
    } else {
      while (++i < n) {
        a = +f.call(array, array[i], i);
        if (!isNaN(a)) {
          s += a;
        }
      }
    }
    return s;
  }
  function center(node) {
    return node.getLayout().y + node.getLayout().dy / 2;
  }
  function ascendingDepth(a, b) {
    return a.getLayout().y - b.getLayout().y;
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a == b ? 0 : NaN;
  }
  function getEdgeValue(edge) {
    return edge.getValue();
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/sankey/sankeyVisual.js", ["../../visual/VisualMapping", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var VisualMapping = $__require('../../visual/VisualMapping');
  module.exports = function(ecModel, payload) {
    ecModel.eachSeriesByType('sankey', function(seriesModel) {
      var graph = seriesModel.getGraph();
      var nodes = graph.nodes;
      nodes.sort(function(a, b) {
        return a.getLayout().value - b.getLayout().value;
      });
      var minValue = nodes[0].getLayout().value;
      var maxValue = nodes[nodes.length - 1].getLayout().value;
      nodes.forEach(function(node) {
        var mapping = new VisualMapping({
          type: 'color',
          mappingMethod: 'linear',
          dataExtent: [minValue, maxValue],
          visual: seriesModel.get('color')
        });
        var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);
        node.setVisual('color', mapValueToColor);
        var itemModel = node.getModel();
        var customColor = itemModel.get('itemStyle.normal.color');
        if (customColor != null) {
          node.setVisual('color', customColor);
        }
      });
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/sankey.js", ["../echarts", "./sankey/SankeySeries", "./sankey/SankeyView", "./sankey/sankeyLayout", "./sankey/sankeyVisual", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../echarts');
  $__require('./sankey/SankeySeries');
  $__require('./sankey/SankeyView');
  echarts.registerLayout($__require('./sankey/sankeyLayout'));
  echarts.registerVisual($__require('./sankey/sankeyVisual'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/boxplot/BoxplotSeries.js", ["zrender/lib/core/util", "../../model/Series", "../helper/whiskerBoxCommon", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var SeriesModel = $__require('../../model/Series');
  var whiskerBoxCommon = $__require('../helper/whiskerBoxCommon');
  var BoxplotSeries = SeriesModel.extend({
    type: 'series.boxplot',
    dependencies: ['xAxis', 'yAxis', 'grid'],
    valueDimensions: ['min', 'Q1', 'median', 'Q3', 'max'],
    dimensions: null,
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: true,
      hoverAnimation: true,
      xAxisIndex: 0,
      yAxisIndex: 0,
      layout: null,
      boxWidth: [7, 50],
      itemStyle: {
        normal: {
          color: '#fff',
          borderWidth: 1
        },
        emphasis: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 2,
          shadowOffsetY: 2,
          shadowColor: 'rgba(0,0,0,0.4)'
        }
      },
      animationEasing: 'elasticOut',
      animationDuration: 800
    }
  });
  zrUtil.mixin(BoxplotSeries, whiskerBoxCommon.seriesModelMixin, true);
  module.exports = BoxplotSeries;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/boxplot/BoxplotView.js", ["zrender/lib/core/util", "../../view/Chart", "../../util/graphic", "../helper/whiskerBoxCommon", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var ChartView = $__require('../../view/Chart');
  var graphic = $__require('../../util/graphic');
  var whiskerBoxCommon = $__require('../helper/whiskerBoxCommon');
  var BoxplotView = ChartView.extend({
    type: 'boxplot',
    getStyleUpdater: function() {
      return updateStyle;
    }
  });
  zrUtil.mixin(BoxplotView, whiskerBoxCommon.viewMixin, true);
  var normalStyleAccessPath = ['itemStyle', 'normal'];
  var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];
  function updateStyle(itemGroup, data, idx) {
    var itemModel = data.getItemModel(idx);
    var normalItemStyleModel = itemModel.getModel(normalStyleAccessPath);
    var borderColor = data.getItemVisual(idx, 'color');
    var itemStyle = normalItemStyleModel.getItemStyle(['borderColor']);
    var whiskerEl = itemGroup.childAt(itemGroup.whiskerIndex);
    whiskerEl.style.set(itemStyle);
    whiskerEl.style.stroke = borderColor;
    whiskerEl.dirty();
    var bodyEl = itemGroup.childAt(itemGroup.bodyIndex);
    bodyEl.style.set(itemStyle);
    bodyEl.style.stroke = borderColor;
    bodyEl.dirty();
    var hoverStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
    graphic.setHoverStyle(itemGroup, hoverStyle);
  }
  module.exports = BoxplotView;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/boxplot/boxplotVisual.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var borderColorQuery = ['itemStyle', 'normal', 'borderColor'];
  module.exports = function(ecModel, api) {
    var globalColors = ecModel.get('color');
    ecModel.eachRawSeriesByType('boxplot', function(seriesModel) {
      var defaulColor = globalColors[seriesModel.seriesIndex % globalColors.length];
      var data = seriesModel.getData();
      data.setVisual({
        legendSymbol: 'roundRect',
        color: seriesModel.get(borderColorQuery) || defaulColor
      });
      if (!ecModel.isSeriesFiltered(seriesModel)) {
        data.each(function(idx) {
          var itemModel = data.getItemModel(idx);
          data.setItemVisual(idx, {color: itemModel.get(borderColorQuery, true)});
        });
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/boxplot/boxplotLayout.js", ["zrender/lib/core/util", "../../util/number", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var numberUtil = $__require('../../util/number');
  var parsePercent = numberUtil.parsePercent;
  var each = zrUtil.each;
  module.exports = function(ecModel) {
    var groupResult = groupSeriesByAxis(ecModel);
    each(groupResult, function(groupItem) {
      var seriesModels = groupItem.seriesModels;
      if (!seriesModels.length) {
        return;
      }
      calculateBase(groupItem);
      each(seriesModels, function(seriesModel, idx) {
        layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);
      });
    });
  };
  function groupSeriesByAxis(ecModel) {
    var result = [];
    var axisList = [];
    ecModel.eachSeriesByType('boxplot', function(seriesModel) {
      var baseAxis = seriesModel.getBaseAxis();
      var idx = zrUtil.indexOf(axisList, baseAxis);
      if (idx < 0) {
        idx = axisList.length;
        axisList[idx] = baseAxis;
        result[idx] = {
          axis: baseAxis,
          seriesModels: []
        };
      }
      result[idx].seriesModels.push(seriesModel);
    });
    return result;
  }
  function calculateBase(groupItem) {
    var extent;
    var baseAxis = groupItem.axis;
    var seriesModels = groupItem.seriesModels;
    var seriesCount = seriesModels.length;
    var boxWidthList = groupItem.boxWidthList = [];
    var boxOffsetList = groupItem.boxOffsetList = [];
    var boundList = [];
    var bandWidth;
    if (baseAxis.type === 'category') {
      bandWidth = baseAxis.getBandWidth();
    } else {
      var maxDataCount = 0;
      each(seriesModels, function(seriesModel) {
        maxDataCount = Math.max(maxDataCount, seriesModel.getData().count());
      });
      extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / maxDataCount;
    }
    each(seriesModels, function(seriesModel) {
      var boxWidthBound = seriesModel.get('boxWidth');
      if (!zrUtil.isArray(boxWidthBound)) {
        boxWidthBound = [boxWidthBound, boxWidthBound];
      }
      boundList.push([parsePercent(boxWidthBound[0], bandWidth) || 0, parsePercent(boxWidthBound[1], bandWidth) || 0]);
    });
    var availableWidth = bandWidth * 0.8 - 2;
    var boxGap = availableWidth / seriesCount * 0.3;
    var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
    var base = boxWidth / 2 - availableWidth / 2;
    each(seriesModels, function(seriesModel, idx) {
      boxOffsetList.push(base);
      base += boxGap + boxWidth;
      boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));
    });
  }
  function layoutSingleSeries(seriesModel, offset, boxWidth) {
    var coordSys = seriesModel.coordinateSystem;
    var data = seriesModel.getData();
    var dimensions = seriesModel.dimensions;
    var chartLayout = seriesModel.get('layout');
    var halfWidth = boxWidth / 2;
    data.each(dimensions, function() {
      var args = arguments;
      var dimLen = dimensions.length;
      var axisDimVal = args[0];
      var idx = args[dimLen];
      var variableDim = chartLayout === 'horizontal' ? 0 : 1;
      var constDim = 1 - variableDim;
      var median = getPoint(args[3]);
      var end1 = getPoint(args[1]);
      var end5 = getPoint(args[5]);
      var whiskerEnds = [[end1, getPoint(args[2])], [end5, getPoint(args[4])]];
      layEndLine(end1);
      layEndLine(end5);
      layEndLine(median);
      var bodyEnds = [];
      addBodyEnd(whiskerEnds[0][1], 0);
      addBodyEnd(whiskerEnds[1][1], 1);
      data.setItemLayout(idx, {
        chartLayout: chartLayout,
        initBaseline: median[constDim],
        median: median,
        bodyEnds: bodyEnds,
        whiskerEnds: whiskerEnds
      });
      function getPoint(val) {
        var p = [];
        p[variableDim] = axisDimVal;
        p[constDim] = val;
        var point;
        if (isNaN(axisDimVal) || isNaN(val)) {
          point = [NaN, NaN];
        } else {
          point = coordSys.dataToPoint(p);
          point[variableDim] += offset;
        }
        return point;
      }
      function addBodyEnd(point, start) {
        var point1 = point.slice();
        var point2 = point.slice();
        point1[variableDim] += halfWidth;
        point2[variableDim] -= halfWidth;
        start ? bodyEnds.push(point1, point2) : bodyEnds.push(point2, point1);
      }
      function layEndLine(endCenter) {
        var line = [endCenter.slice(), endCenter.slice()];
        line[0][variableDim] -= halfWidth;
        line[1][variableDim] += halfWidth;
        whiskerEnds.push(line);
      }
    });
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/boxplot.js", ["../echarts", "./boxplot/BoxplotSeries", "./boxplot/BoxplotView", "./boxplot/boxplotVisual", "./boxplot/boxplotLayout", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../echarts');
  $__require('./boxplot/BoxplotSeries');
  $__require('./boxplot/BoxplotView');
  echarts.registerVisual($__require('./boxplot/boxplotVisual'));
  echarts.registerLayout($__require('./boxplot/boxplotLayout'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/candlestick/CandlestickSeries.js", ["zrender/lib/core/util", "../../model/Series", "../helper/whiskerBoxCommon", "../../util/format", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var SeriesModel = $__require('../../model/Series');
  var whiskerBoxCommon = $__require('../helper/whiskerBoxCommon');
  var formatUtil = $__require('../../util/format');
  var encodeHTML = formatUtil.encodeHTML;
  var addCommas = formatUtil.addCommas;
  var CandlestickSeries = SeriesModel.extend({
    type: 'series.candlestick',
    dependencies: ['xAxis', 'yAxis', 'grid'],
    valueDimensions: ['open', 'close', 'lowest', 'highest'],
    dimensions: null,
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: true,
      hoverAnimation: true,
      xAxisIndex: 0,
      yAxisIndex: 0,
      layout: null,
      itemStyle: {
        normal: {
          color: '#c23531',
          color0: '#314656',
          borderWidth: 1,
          borderColor: '#c23531',
          borderColor0: '#314656'
        },
        emphasis: {borderWidth: 2}
      },
      animationUpdate: false,
      animationEasing: 'linear',
      animationDuration: 300
    },
    getShadowDim: function() {
      return 'open';
    },
    formatTooltip: function(dataIndex, mutipleSeries) {
      var valueHTMLArr = zrUtil.map(this.valueDimensions, function(dim) {
        return dim + ': ' + addCommas(this._data.get(dim, dataIndex));
      }, this);
      return encodeHTML(this.name) + '<br />' + valueHTMLArr.join('<br />');
    },
    brushSelector: function(itemLayout, selectors) {
      return selectors.rect(itemLayout.brushRect);
    }
  });
  zrUtil.mixin(CandlestickSeries, whiskerBoxCommon.seriesModelMixin, true);
  module.exports = CandlestickSeries;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/WhiskerBoxDraw.js", ["zrender/lib/core/util", "../../util/graphic", "zrender/lib/graphic/Path", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var Path = $__require('zrender/lib/graphic/Path');
  var WhiskerPath = Path.extend({
    type: 'whiskerInBox',
    shape: {},
    buildPath: function(ctx, shape) {
      for (var i in shape) {
        if (i.indexOf('ends') === 0) {
          var pts = shape[i];
          ctx.moveTo(pts[0][0], pts[0][1]);
          ctx.lineTo(pts[1][0], pts[1][1]);
        }
      }
    }
  });
  function WhiskerBox(data, idx, styleUpdater, isInit) {
    graphic.Group.call(this);
    this.bodyIndex;
    this.whiskerIndex;
    this.styleUpdater = styleUpdater;
    this._createContent(data, idx, isInit);
    this.updateData(data, idx, isInit);
    this._seriesModel;
  }
  var whiskerBoxProto = WhiskerBox.prototype;
  whiskerBoxProto._createContent = function(data, idx, isInit) {
    var itemLayout = data.getItemLayout(idx);
    var constDim = itemLayout.chartLayout === 'horizontal' ? 1 : 0;
    var count = 0;
    this.add(new graphic.Polygon({
      shape: {points: isInit ? transInit(itemLayout.bodyEnds, constDim, itemLayout) : itemLayout.bodyEnds},
      style: {strokeNoScale: true},
      z2: 100
    }));
    this.bodyIndex = count++;
    var whiskerEnds = zrUtil.map(itemLayout.whiskerEnds, function(ends) {
      return isInit ? transInit(ends, constDim, itemLayout) : ends;
    });
    this.add(new WhiskerPath({
      shape: makeWhiskerEndsShape(whiskerEnds),
      style: {strokeNoScale: true},
      z2: 100
    }));
    this.whiskerIndex = count++;
  };
  function transInit(points, dim, itemLayout) {
    return zrUtil.map(points, function(point) {
      point = point.slice();
      point[dim] = itemLayout.initBaseline;
      return point;
    });
  }
  function makeWhiskerEndsShape(whiskerEnds) {
    var shape = {};
    zrUtil.each(whiskerEnds, function(ends, i) {
      shape['ends' + i] = ends;
    });
    return shape;
  }
  whiskerBoxProto.updateData = function(data, idx, isInit) {
    var seriesModel = this._seriesModel = data.hostModel;
    var itemLayout = data.getItemLayout(idx);
    var updateMethod = graphic[isInit ? 'initProps' : 'updateProps'];
    updateMethod(this.childAt(this.bodyIndex), {shape: {points: itemLayout.bodyEnds}}, seriesModel, idx);
    updateMethod(this.childAt(this.whiskerIndex), {shape: makeWhiskerEndsShape(itemLayout.whiskerEnds)}, seriesModel, idx);
    this.styleUpdater.call(null, this, data, idx);
  };
  zrUtil.inherits(WhiskerBox, graphic.Group);
  function WhiskerBoxDraw(styleUpdater) {
    this.group = new graphic.Group();
    this.styleUpdater = styleUpdater;
  }
  var whiskerBoxDrawProto = WhiskerBoxDraw.prototype;
  whiskerBoxDrawProto.updateData = function(data) {
    var group = this.group;
    var oldData = this._data;
    var styleUpdater = this.styleUpdater;
    data.diff(oldData).add(function(newIdx) {
      if (data.hasValue(newIdx)) {
        var symbolEl = new WhiskerBox(data, newIdx, styleUpdater, true);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      if (!data.hasValue(newIdx)) {
        group.remove(symbolEl);
        return;
      }
      if (!symbolEl) {
        symbolEl = new WhiskerBox(data, newIdx, styleUpdater);
      } else {
        symbolEl.updateData(data, newIdx);
      }
      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && group.remove(el);
    }).execute();
    this._data = data;
  };
  whiskerBoxDrawProto.remove = function() {
    var group = this.group;
    var data = this._data;
    this._data = null;
    data && data.eachItemGraphicEl(function(el) {
      el && group.remove(el);
    });
  };
  module.exports = WhiskerBoxDraw;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/whiskerBoxCommon.js", ["../../data/List", "../../data/helper/completeDimensions", "../helper/WhiskerBoxDraw", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var List = $__require('../../data/List');
  var completeDimensions = $__require('../../data/helper/completeDimensions');
  var WhiskerBoxDraw = $__require('../helper/WhiskerBoxDraw');
  var zrUtil = $__require('zrender/lib/core/util');
  function getItemValue(item) {
    return item.value == null ? item : item.value;
  }
  var seriesModelMixin = {
    _baseAxisDim: null,
    getInitialData: function(option, ecModel) {
      var categories;
      var xAxisModel = ecModel.getComponent('xAxis', this.get('xAxisIndex'));
      var yAxisModel = ecModel.getComponent('yAxis', this.get('yAxisIndex'));
      var xAxisType = xAxisModel.get('type');
      var yAxisType = yAxisModel.get('type');
      var addOrdinal;
      if (xAxisType === 'category') {
        option.layout = 'horizontal';
        categories = xAxisModel.getCategories();
        addOrdinal = true;
      } else if (yAxisType === 'category') {
        option.layout = 'vertical';
        categories = yAxisModel.getCategories();
        addOrdinal = true;
      } else {
        option.layout = option.layout || 'horizontal';
      }
      this._baseAxisDim = option.layout === 'horizontal' ? 'x' : 'y';
      var data = option.data;
      var dimensions = this.dimensions = ['base'].concat(this.valueDimensions);
      completeDimensions(dimensions, data);
      var list = new List(dimensions, this);
      list.initData(data, categories ? categories.slice() : null, function(dataItem, dimName, idx, dimIdx) {
        var value = getItemValue(dataItem);
        return addOrdinal ? (dimName === 'base' ? idx : value[dimIdx - 1]) : value[dimIdx];
      });
      return list;
    },
    coordDimToDataDim: function(axisDim) {
      var dims = this.valueDimensions.slice();
      var baseDim = ['base'];
      var map = {
        horizontal: {
          x: baseDim,
          y: dims
        },
        vertical: {
          x: dims,
          y: baseDim
        }
      };
      return map[this.get('layout')][axisDim];
    },
    dataDimToCoordDim: function(dataDim) {
      var dim;
      zrUtil.each(['x', 'y'], function(coordDim, index) {
        var dataDims = this.coordDimToDataDim(coordDim);
        if (zrUtil.indexOf(dataDims, dataDim) >= 0) {
          dim = coordDim;
        }
      }, this);
      return dim;
    },
    getBaseAxis: function() {
      var dim = this._baseAxisDim;
      return this.ecModel.getComponent(dim + 'Axis', this.get(dim + 'AxisIndex')).axis;
    }
  };
  var viewMixin = {
    init: function() {
      var whiskerBoxDraw = this._whiskerBoxDraw = new WhiskerBoxDraw(this.getStyleUpdater());
      this.group.add(whiskerBoxDraw.group);
    },
    render: function(seriesModel, ecModel, api) {
      this._whiskerBoxDraw.updateData(seriesModel.getData());
    },
    remove: function(ecModel) {
      this._whiskerBoxDraw.remove();
    }
  };
  module.exports = {
    seriesModelMixin: seriesModelMixin,
    viewMixin: viewMixin
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/candlestick/CandlestickView.js", ["zrender/lib/core/util", "../../view/Chart", "../../util/graphic", "../helper/whiskerBoxCommon", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var ChartView = $__require('../../view/Chart');
  var graphic = $__require('../../util/graphic');
  var whiskerBoxCommon = $__require('../helper/whiskerBoxCommon');
  var CandlestickView = ChartView.extend({
    type: 'candlestick',
    getStyleUpdater: function() {
      return updateStyle;
    }
  });
  zrUtil.mixin(CandlestickView, whiskerBoxCommon.viewMixin, true);
  var normalStyleAccessPath = ['itemStyle', 'normal'];
  var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];
  function updateStyle(itemGroup, data, idx) {
    var itemModel = data.getItemModel(idx);
    var normalItemStyleModel = itemModel.getModel(normalStyleAccessPath);
    var color = data.getItemVisual(idx, 'color');
    var borderColor = data.getItemVisual(idx, 'borderColor') || color;
    var itemStyle = normalItemStyleModel.getItemStyle(['color', 'color0', 'borderColor', 'borderColor0']);
    var whiskerEl = itemGroup.childAt(itemGroup.whiskerIndex);
    whiskerEl.useStyle(itemStyle);
    whiskerEl.style.stroke = borderColor;
    var bodyEl = itemGroup.childAt(itemGroup.bodyIndex);
    bodyEl.useStyle(itemStyle);
    bodyEl.style.fill = color;
    bodyEl.style.stroke = borderColor;
    var hoverStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
    graphic.setHoverStyle(itemGroup, hoverStyle);
  }
  module.exports = CandlestickView;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/candlestick/preprocessor.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  module.exports = function(option) {
    if (!option || !zrUtil.isArray(option.series)) {
      return;
    }
    zrUtil.each(option.series, function(seriesItem) {
      if (zrUtil.isObject(seriesItem) && seriesItem.type === 'k') {
        seriesItem.type = 'candlestick';
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/candlestick/candlestickVisual.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var positiveBorderColorQuery = ['itemStyle', 'normal', 'borderColor'];
  var negativeBorderColorQuery = ['itemStyle', 'normal', 'borderColor0'];
  var positiveColorQuery = ['itemStyle', 'normal', 'color'];
  var negativeColorQuery = ['itemStyle', 'normal', 'color0'];
  module.exports = function(ecModel, api) {
    ecModel.eachRawSeriesByType('candlestick', function(seriesModel) {
      var data = seriesModel.getData();
      data.setVisual({legendSymbol: 'roundRect'});
      if (!ecModel.isSeriesFiltered(seriesModel)) {
        data.each(function(idx) {
          var itemModel = data.getItemModel(idx);
          var sign = data.getItemLayout(idx).sign;
          data.setItemVisual(idx, {
            color: itemModel.get(sign > 0 ? positiveColorQuery : negativeColorQuery),
            borderColor: itemModel.get(sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery)
          });
        });
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/candlestick/candlestickLayout.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var CANDLE_MIN_WIDTH = 2;
  var CANDLE_MIN_NICE_WIDTH = 5;
  var GPA_MIN = 4;
  module.exports = function(ecModel) {
    ecModel.eachSeriesByType('candlestick', function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var data = seriesModel.getData();
      var dimensions = seriesModel.dimensions;
      var chartLayout = seriesModel.get('layout');
      var candleWidth = calculateCandleWidth(seriesModel, data);
      data.each(dimensions, function() {
        var args = arguments;
        var dimLen = dimensions.length;
        var axisDimVal = args[0];
        var idx = args[dimLen];
        var variableDim = chartLayout === 'horizontal' ? 0 : 1;
        var constDim = 1 - variableDim;
        var openVal = args[1];
        var closeVal = args[2];
        var lowestVal = args[3];
        var highestVal = args[4];
        var ocLow = Math.min(openVal, closeVal);
        var ocHigh = Math.max(openVal, closeVal);
        var ocLowPoint = getPoint(ocLow);
        var ocHighPoint = getPoint(ocHigh);
        var lowestPoint = getPoint(lowestVal);
        var highestPoint = getPoint(highestVal);
        var whiskerEnds = [[highestPoint, ocHighPoint], [lowestPoint, ocLowPoint]];
        var bodyEnds = [];
        addBodyEnd(ocHighPoint, 0);
        addBodyEnd(ocLowPoint, 1);
        data.setItemLayout(idx, {
          chartLayout: chartLayout,
          sign: openVal > closeVal ? -1 : openVal < closeVal ? 1 : 0,
          initBaseline: openVal > closeVal ? ocHighPoint[constDim] : ocLowPoint[constDim],
          bodyEnds: bodyEnds,
          whiskerEnds: whiskerEnds,
          brushRect: makeBrushRect()
        });
        function getPoint(val) {
          var p = [];
          p[variableDim] = axisDimVal;
          p[constDim] = val;
          return (isNaN(axisDimVal) || isNaN(val)) ? [NaN, NaN] : coordSys.dataToPoint(p);
        }
        function addBodyEnd(point, start) {
          var point1 = point.slice();
          var point2 = point.slice();
          point1[variableDim] += candleWidth / 2;
          point2[variableDim] -= candleWidth / 2;
          start ? bodyEnds.push(point1, point2) : bodyEnds.push(point2, point1);
        }
        function makeBrushRect() {
          var pmin = getPoint(Math.min(openVal, closeVal, lowestVal, highestVal));
          var pmax = getPoint(Math.max(openVal, closeVal, lowestVal, highestVal));
          pmin[variableDim] -= candleWidth / 2;
          pmax[variableDim] -= candleWidth / 2;
          return {
            x: pmin[0],
            y: pmin[1],
            width: constDim ? candleWidth : pmax[0] - pmin[0],
            height: constDim ? pmax[1] - pmin[1] : candleWidth
          };
        }
      }, true);
    });
  };
  function calculateCandleWidth(seriesModel, data) {
    var baseAxis = seriesModel.getBaseAxis();
    var extent;
    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count());
    return bandWidth / 2 - 2 > CANDLE_MIN_NICE_WIDTH ? bandWidth / 2 - 2 : bandWidth - CANDLE_MIN_NICE_WIDTH > GPA_MIN ? CANDLE_MIN_NICE_WIDTH : Math.max(bandWidth - GPA_MIN, CANDLE_MIN_WIDTH);
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/candlestick.js", ["../echarts", "./candlestick/CandlestickSeries", "./candlestick/CandlestickView", "./candlestick/preprocessor", "./candlestick/candlestickVisual", "./candlestick/candlestickLayout", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../echarts');
  $__require('./candlestick/CandlestickSeries');
  $__require('./candlestick/CandlestickView');
  echarts.registerPreprocessor($__require('./candlestick/preprocessor'));
  echarts.registerVisual($__require('./candlestick/candlestickVisual'));
  echarts.registerLayout($__require('./candlestick/candlestickLayout'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/effectScatter/EffectScatterSeries.js", ["../helper/createListFromArray", "../../model/Series", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var createListFromArray = $__require('../helper/createListFromArray');
  var SeriesModel = $__require('../../model/Series');
  module.exports = SeriesModel.extend({
    type: 'series.effectScatter',
    dependencies: ['grid', 'polar'],
    getInitialData: function(option, ecModel) {
      var list = createListFromArray(option.data, this, ecModel);
      return list;
    },
    brushSelector: 'point',
    defaultOption: {
      coordinateSystem: 'cartesian2d',
      zlevel: 0,
      z: 2,
      legendHoverLink: true,
      effectType: 'ripple',
      showEffectOn: 'render',
      rippleEffect: {
        period: 4,
        scale: 2.5,
        brushType: 'fill'
      },
      xAxisIndex: 0,
      yAxisIndex: 0,
      polarIndex: 0,
      geoIndex: 0,
      symbolSize: 10
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/EffectSymbol.js", ["zrender/lib/core/util", "../../util/symbol", "../../util/graphic", "../../util/number", "./Symbol", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var symbolUtil = $__require('../../util/symbol');
  var graphic = $__require('../../util/graphic');
  var numberUtil = $__require('../../util/number');
  var Symbol = $__require('./Symbol');
  var Group = graphic.Group;
  var EFFECT_RIPPLE_NUMBER = 3;
  function normalizeSymbolSize(symbolSize) {
    if (!zrUtil.isArray(symbolSize)) {
      symbolSize = [+symbolSize, +symbolSize];
    }
    return symbolSize;
  }
  function updateRipplePath(rippleGroup, effectCfg) {
    rippleGroup.eachChild(function(ripplePath) {
      ripplePath.attr({
        z: effectCfg.z,
        zlevel: effectCfg.zlevel,
        style: {
          stroke: effectCfg.brushType === 'stroke' ? effectCfg.color : null,
          fill: effectCfg.brushType === 'fill' ? effectCfg.color : null
        }
      });
    });
  }
  function EffectSymbol(data, idx) {
    Group.call(this);
    var symbol = new Symbol(data, idx);
    var rippleGroup = new Group();
    this.add(symbol);
    this.add(rippleGroup);
    rippleGroup.beforeUpdate = function() {
      this.attr(symbol.getScale());
    };
    this.updateData(data, idx);
  }
  var effectSymbolProto = EffectSymbol.prototype;
  effectSymbolProto.stopEffectAnimation = function() {
    this.childAt(1).removeAll();
  };
  effectSymbolProto.startEffectAnimation = function(effectCfg) {
    var symbolType = effectCfg.symbolType;
    var color = effectCfg.color;
    var rippleGroup = this.childAt(1);
    for (var i = 0; i < EFFECT_RIPPLE_NUMBER; i++) {
      var ripplePath = symbolUtil.createSymbol(symbolType, -0.5, -0.5, 1, 1, color);
      ripplePath.attr({
        style: {strokeNoScale: true},
        z2: 99,
        silent: true,
        scale: [1, 1]
      });
      var delay = -i / EFFECT_RIPPLE_NUMBER * effectCfg.period + effectCfg.effectOffset;
      ripplePath.animate('', true).when(effectCfg.period, {scale: [effectCfg.rippleScale, effectCfg.rippleScale]}).delay(delay).start();
      ripplePath.animateStyle(true).when(effectCfg.period, {opacity: 0}).delay(delay).start();
      rippleGroup.add(ripplePath);
    }
    updateRipplePath(rippleGroup, effectCfg);
  };
  effectSymbolProto.updateEffectAnimation = function(effectCfg) {
    var oldEffectCfg = this._effectCfg;
    var rippleGroup = this.childAt(1);
    var DIFFICULT_PROPS = ['symbolType', 'period', 'rippleScale'];
    for (var i = 0; i < DIFFICULT_PROPS; i++) {
      var propName = DIFFICULT_PROPS[i];
      if (oldEffectCfg[propName] !== effectCfg[propName]) {
        this.stopEffectAnimation();
        this.startEffectAnimation(effectCfg);
        return;
      }
    }
    updateRipplePath(rippleGroup, effectCfg);
  };
  effectSymbolProto.highlight = function() {
    this.trigger('emphasis');
  };
  effectSymbolProto.downplay = function() {
    this.trigger('normal');
  };
  effectSymbolProto.updateData = function(data, idx) {
    var seriesModel = data.hostModel;
    this.childAt(0).updateData(data, idx);
    var rippleGroup = this.childAt(1);
    var itemModel = data.getItemModel(idx);
    var symbolType = data.getItemVisual(idx, 'symbol');
    var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
    var color = data.getItemVisual(idx, 'color');
    rippleGroup.attr('scale', symbolSize);
    rippleGroup.traverse(function(ripplePath) {
      ripplePath.attr({fill: color});
    });
    var symbolOffset = itemModel.getShallow('symbolOffset');
    if (symbolOffset) {
      var pos = rippleGroup.position;
      pos[0] = numberUtil.parsePercent(symbolOffset[0], symbolSize[0]);
      pos[1] = numberUtil.parsePercent(symbolOffset[1], symbolSize[1]);
    }
    rippleGroup.rotation = (itemModel.getShallow('symbolRotate') || 0) * Math.PI / 180 || 0;
    var effectCfg = {};
    effectCfg.showEffectOn = seriesModel.get('showEffectOn');
    effectCfg.rippleScale = itemModel.get('rippleEffect.scale');
    effectCfg.brushType = itemModel.get('rippleEffect.brushType');
    effectCfg.period = itemModel.get('rippleEffect.period') * 1000;
    effectCfg.effectOffset = idx / data.count();
    effectCfg.z = itemModel.getShallow('z') || 0;
    effectCfg.zlevel = itemModel.getShallow('zlevel') || 0;
    effectCfg.symbolType = symbolType;
    effectCfg.color = color;
    this.off('mouseover').off('mouseout').off('emphasis').off('normal');
    if (effectCfg.showEffectOn === 'render') {
      this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);
      this._effectCfg = effectCfg;
    } else {
      this._effectCfg = null;
      this.stopEffectAnimation();
      var symbol = this.childAt(0);
      var onEmphasis = function() {
        symbol.trigger('emphasis');
        if (effectCfg.showEffectOn !== 'render') {
          this.startEffectAnimation(effectCfg);
        }
      };
      var onNormal = function() {
        symbol.trigger('normal');
        if (effectCfg.showEffectOn !== 'render') {
          this.stopEffectAnimation();
        }
      };
      this.on('mouseover', onEmphasis, this).on('mouseout', onNormal, this).on('emphasis', onEmphasis, this).on('normal', onNormal, this);
    }
    this._effectCfg = effectCfg;
  };
  effectSymbolProto.fadeOut = function(cb) {
    this.off('mouseover').off('mouseout').off('emphasis').off('normal');
    cb && cb();
  };
  zrUtil.inherits(EffectSymbol, Group);
  module.exports = EffectSymbol;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/effectScatter/EffectScatterView.js", ["../helper/SymbolDraw", "../helper/EffectSymbol", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SymbolDraw = $__require('../helper/SymbolDraw');
  var EffectSymbol = $__require('../helper/EffectSymbol');
  $__require('../../echarts').extendChartView({
    type: 'effectScatter',
    init: function() {
      this._symbolDraw = new SymbolDraw(EffectSymbol);
    },
    render: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var effectSymbolDraw = this._symbolDraw;
      effectSymbolDraw.updateData(data);
      this.group.add(effectSymbolDraw.group);
    },
    updateLayout: function() {
      this._symbolDraw.updateLayout();
    },
    remove: function(ecModel, api) {
      this._symbolDraw && this._symbolDraw.remove(api);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/visual/symbol.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(seriesType, defaultSymbolType, legendSymbol, ecModel, api) {
    ecModel.eachRawSeriesByType(seriesType, function(seriesModel) {
      var data = seriesModel.getData();
      var symbolType = seriesModel.get('symbol') || defaultSymbolType;
      var symbolSize = seriesModel.get('symbolSize');
      data.setVisual({
        legendSymbol: legendSymbol || symbolType,
        symbol: symbolType,
        symbolSize: symbolSize
      });
      if (!ecModel.isSeriesFiltered(seriesModel)) {
        if (typeof symbolSize === 'function') {
          data.each(function(idx) {
            var rawValue = seriesModel.getRawValue(idx);
            var params = seriesModel.getDataParams(idx);
            data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));
          });
        }
        data.each(function(idx) {
          var itemModel = data.getItemModel(idx);
          var itemSymbolType = itemModel.getShallow('symbol', true);
          var itemSymbolSize = itemModel.getShallow('symbolSize', true);
          if (itemSymbolType != null) {
            data.setItemVisual(idx, 'symbol', itemSymbolType);
          }
          if (itemSymbolSize != null) {
            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);
          }
        });
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/layout/points.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(seriesType, ecModel) {
    ecModel.eachSeriesByType(seriesType, function(seriesModel) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys) {
        var dims = coordSys.dimensions;
        if (coordSys.type === 'singleAxis') {
          data.each(dims[0], function(x, idx) {
            data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));
          });
        } else {
          data.each(dims, function(x, y, idx) {
            data.setItemLayout(idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y]));
          }, true);
        }
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/effectScatter.js", ["zrender/lib/core/util", "../echarts", "./effectScatter/EffectScatterSeries", "./effectScatter/EffectScatterView", "../visual/symbol", "../layout/points", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var echarts = $__require('../echarts');
  $__require('./effectScatter/EffectScatterSeries');
  $__require('./effectScatter/EffectScatterView');
  echarts.registerVisual(zrUtil.curry($__require('../visual/symbol'), 'effectScatter', 'circle', null));
  echarts.registerLayout(zrUtil.curry($__require('../layout/points'), 'effectScatter'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/lines/LinesSeries.js", ["../../model/Series", "../../data/List", "zrender/lib/core/util", "../../CoordinateSystem", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SeriesModel = $__require('../../model/Series');
  var List = $__require('../../data/List');
  var zrUtil = $__require('zrender/lib/core/util');
  var CoordinateSystem = $__require('../../CoordinateSystem');
  function preprocessOption(seriesOpt) {
    var data = seriesOpt.data;
    if (data && data[0] && data[0][0] && data[0][0].coord) {
      if (__DEV__) {
        console.warn('Lines data configuration has been changed to' + ' { coords:[[1,2],[2,3]] }');
      }
      seriesOpt.data = zrUtil.map(data, function(itemOpt) {
        var coords = [itemOpt[0].coord, itemOpt[1].coord];
        var target = {coords: coords};
        if (itemOpt[0].name) {
          target.fromName = itemOpt[0].name;
        }
        if (itemOpt[1].name) {
          target.toName = itemOpt[1].name;
        }
        return zrUtil.mergeAll([target, itemOpt[0], itemOpt[1]]);
      });
    }
  }
  var LinesSeries = SeriesModel.extend({
    type: 'series.lines',
    dependencies: ['grid', 'polar'],
    visualColorAccessPath: 'lineStyle.normal.color',
    init: function(option) {
      preprocessOption(option);
      LinesSeries.superApply(this, 'init', arguments);
    },
    mergeOption: function(option) {
      preprocessOption(option);
      LinesSeries.superApply(this, 'mergeOption', arguments);
    },
    getInitialData: function(option, ecModel) {
      if (__DEV__) {
        var CoordSys = CoordinateSystem.get(option.coordinateSystem);
        if (!CoordSys) {
          throw new Error('Unkown coordinate system ' + option.coordinateSystem);
        }
      }
      var lineData = new List(['value'], this);
      lineData.hasItemOption = false;
      lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
        if (dataItem instanceof Array) {
          return NaN;
        } else {
          lineData.hasItemOption = true;
          var value = dataItem.value;
          if (value) {
            return value instanceof Array ? value[dimIndex] : value;
          }
        }
      });
      return lineData;
    },
    formatTooltip: function(dataIndex) {
      var data = this.getData();
      var itemModel = data.getItemModel(dataIndex);
      var name = itemModel.get('name');
      if (name) {
        return name;
      }
      var fromName = itemModel.get('fromName');
      var toName = itemModel.get('toName');
      return fromName + ' > ' + toName;
    },
    defaultOption: {
      coordinateSystem: 'geo',
      zlevel: 0,
      z: 2,
      legendHoverLink: true,
      hoverAnimation: true,
      xAxisIndex: 0,
      yAxisIndex: 0,
      geoIndex: 0,
      effect: {
        show: false,
        period: 4,
        constantSpeed: 0,
        symbol: 'circle',
        symbolSize: 3,
        loop: true,
        trailLength: 0.2
      },
      large: false,
      largeThreshold: 2000,
      polyline: false,
      label: {normal: {
          show: false,
          position: 'end'
        }},
      lineStyle: {normal: {opacity: 0.5}}
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/Polyline.js", ["../../util/graphic", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var zrUtil = $__require('zrender/lib/core/util');
  function Polyline(lineData, idx, seriesScope) {
    graphic.Group.call(this);
    this._createPolyline(lineData, idx, seriesScope);
  }
  var polylineProto = Polyline.prototype;
  polylineProto._createPolyline = function(lineData, idx, seriesScope) {
    var points = lineData.getItemLayout(idx);
    var line = new graphic.Polyline({shape: {points: points}});
    this.add(line);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  polylineProto.updateData = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childAt(0);
    var target = {shape: {points: lineData.getItemLayout(idx)}};
    graphic.updateProps(line, target, seriesModel, idx);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  polylineProto._updateCommonStl = function(lineData, idx, seriesScope) {
    var line = this.childAt(0);
    var itemModel = lineData.getItemModel(idx);
    var visualColor = lineData.getItemVisual(idx, 'color');
    var lineStyle = seriesScope && seriesScope.lineStyle;
    var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
    if (!seriesScope || lineData.hasItemOption) {
      lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();
      hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();
    }
    line.useStyle(zrUtil.defaults({
      strokeNoScale: true,
      fill: 'none',
      stroke: visualColor
    }, lineStyle));
    line.hoverStyle = hoverLineStyle;
    graphic.setHoverStyle(this);
  };
  polylineProto.updateLayout = function(lineData, idx) {
    var polyline = this.childAt(0);
    polyline.setShape('points', lineData.getItemLayout(idx));
  };
  zrUtil.inherits(Polyline, graphic.Group);
  module.exports = Polyline;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/EffectLine.js", ["../../util/graphic", "./Line", "zrender/lib/core/util", "../../util/symbol", "zrender/lib/core/vector", "zrender/lib/core/curve", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var Line = $__require('./Line');
  var zrUtil = $__require('zrender/lib/core/util');
  var symbolUtil = $__require('../../util/symbol');
  var vec2 = $__require('zrender/lib/core/vector');
  var curveUtil = $__require('zrender/lib/core/curve');
  function EffectLine(lineData, idx, seriesScope) {
    graphic.Group.call(this);
    this.add(this.createLine(lineData, idx, seriesScope));
    this._updateEffectSymbol(lineData, idx);
  }
  var effectLineProto = EffectLine.prototype;
  effectLineProto.createLine = function(lineData, idx, seriesScope) {
    return new Line(lineData, idx, seriesScope);
  };
  effectLineProto._updateEffectSymbol = function(lineData, idx) {
    var itemModel = lineData.getItemModel(idx);
    var effectModel = itemModel.getModel('effect');
    var size = effectModel.get('symbolSize');
    var symbolType = effectModel.get('symbol');
    if (!zrUtil.isArray(size)) {
      size = [size, size];
    }
    var color = effectModel.get('color') || lineData.getItemVisual(idx, 'color');
    var symbol = this.childAt(1);
    if (this._symbolType !== symbolType) {
      this.remove(symbol);
      symbol = symbolUtil.createSymbol(symbolType, -0.5, -0.5, 1, 1, color);
      symbol.z2 = 100;
      symbol.culling = true;
      this.add(symbol);
    }
    if (!symbol) {
      return;
    }
    symbol.setStyle('shadowColor', color);
    symbol.setStyle(effectModel.getItemStyle(['color']));
    symbol.attr('scale', size);
    symbol.setColor(color);
    symbol.attr('scale', size);
    this._symbolType = symbolType;
    this._updateEffectAnimation(lineData, effectModel, idx);
  };
  effectLineProto._updateEffectAnimation = function(lineData, effectModel, idx) {
    var symbol = this.childAt(1);
    if (!symbol) {
      return;
    }
    var self = this;
    var points = lineData.getItemLayout(idx);
    var period = effectModel.get('period') * 1000;
    var loop = effectModel.get('loop');
    var constantSpeed = effectModel.get('constantSpeed');
    var delayExpr = effectModel.get('delay') || function(idx) {
      return idx / lineData.count() * period / 3;
    };
    var isDelayFunc = typeof delayExpr === 'function';
    symbol.ignore = true;
    this.updateAnimationPoints(symbol, points);
    if (constantSpeed > 0) {
      period = this.getLineLength(symbol) / constantSpeed * 1000;
    }
    if (period !== this._period || loop !== this._loop) {
      symbol.stopAnimation();
      var delay = delayExpr;
      if (isDelayFunc) {
        delay = delayExpr(idx);
      }
      if (symbol.__t > 0) {
        delay = -period * symbol.__t;
      }
      symbol.__t = 0;
      var animator = symbol.animate('', loop).when(period, {__t: 1}).delay(delay).during(function() {
        self.updateSymbolPosition(symbol);
      });
      if (!loop) {
        animator.done(function() {
          self.remove(symbol);
        });
      }
      animator.start();
    }
    this._period = period;
    this._loop = loop;
  };
  effectLineProto.getLineLength = function(symbol) {
    return (vec2.dist(symbol.__p1, symbol.__cp1) + vec2.dist(symbol.__cp1, symbol.__p2));
  };
  effectLineProto.updateAnimationPoints = function(symbol, points) {
    symbol.__p1 = points[0];
    symbol.__p2 = points[1];
    symbol.__cp1 = points[2] || [(points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2];
  };
  effectLineProto.updateData = function(lineData, idx, seriesScope) {
    this.childAt(0).updateData(lineData, idx, seriesScope);
    this._updateEffectSymbol(lineData, idx);
  };
  effectLineProto.updateSymbolPosition = function(symbol) {
    var p1 = symbol.__p1;
    var p2 = symbol.__p2;
    var cp1 = symbol.__cp1;
    var t = symbol.__t;
    var pos = symbol.position;
    var quadraticAt = curveUtil.quadraticAt;
    var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
    pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
    pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
    var tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
    var ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
    symbol.ignore = false;
  };
  effectLineProto.updateLayout = function(lineData, idx) {
    this.childAt(0).updateLayout(lineData, idx);
    var effectModel = lineData.getItemModel(idx).getModel('effect');
    this._updateEffectAnimation(lineData, effectModel, idx);
  };
  zrUtil.inherits(EffectLine, graphic.Group);
  module.exports = EffectLine;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/EffectPolyline.js", ["./Polyline", "zrender/lib/core/util", "./EffectLine", "zrender/lib/core/vector", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var Polyline = $__require('./Polyline');
  var zrUtil = $__require('zrender/lib/core/util');
  var EffectLine = $__require('./EffectLine');
  var vec2 = $__require('zrender/lib/core/vector');
  function EffectPolyline(lineData, idx, seriesScope) {
    EffectLine.call(this, lineData, idx, seriesScope);
    this._lastFrame = 0;
    this._lastFramePercent = 0;
  }
  var effectPolylineProto = EffectPolyline.prototype;
  effectPolylineProto.createLine = function(lineData, idx, seriesScope) {
    return new Polyline(lineData, idx, seriesScope);
  };
  effectPolylineProto.updateAnimationPoints = function(symbol, points) {
    this._points = points;
    var accLenArr = [0];
    var len = 0;
    for (var i = 1; i < points.length; i++) {
      var p1 = points[i - 1];
      var p2 = points[i];
      len += vec2.dist(p1, p2);
      accLenArr.push(len);
    }
    if (len === 0) {
      return;
    }
    for (var i = 0; i < accLenArr.length; i++) {
      accLenArr[i] /= len;
    }
    this._offsets = accLenArr;
    this._length = len;
  };
  effectPolylineProto.getLineLength = function(symbol) {
    return this._length;
  };
  effectPolylineProto.updateSymbolPosition = function(symbol) {
    var t = symbol.__t;
    var points = this._points;
    var offsets = this._offsets;
    var len = points.length;
    if (!offsets) {
      return;
    }
    var lastFrame = this._lastFrame;
    var frame;
    if (t < this._lastFramePercent) {
      var start = Math.min(lastFrame + 1, len - 1);
      for (frame = start; frame >= 0; frame--) {
        if (offsets[frame] <= t) {
          break;
        }
      }
      frame = Math.min(frame, len - 2);
    } else {
      for (var frame = lastFrame; frame < len; frame++) {
        if (offsets[frame] > t) {
          break;
        }
      }
      frame = Math.min(frame - 1, len - 2);
    }
    vec2.lerp(symbol.position, points[frame], points[frame + 1], (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]));
    this._lastFrame = frame;
    this._lastFramePercent = t;
    symbol.ignore = false;
  };
  zrUtil.inherits(EffectPolyline, EffectLine);
  module.exports = EffectPolyline;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/LargeLineDraw.js", ["../../util/graphic", "zrender/lib/contain/quadratic", "zrender/lib/contain/line", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var quadraticContain = $__require('zrender/lib/contain/quadratic');
  var lineContain = $__require('zrender/lib/contain/line');
  var LargeLineShape = graphic.extendShape({
    shape: {
      polyline: false,
      segs: []
    },
    buildPath: function(path, shape) {
      var segs = shape.segs;
      var isPolyline = shape.polyline;
      for (var i = 0; i < segs.length; i++) {
        var seg = segs[i];
        if (isPolyline) {
          path.moveTo(seg[0][0], seg[0][1]);
          for (var j = 1; j < seg.length; j++) {
            path.lineTo(seg[j][0], seg[j][1]);
          }
        } else {
          path.moveTo(seg[0][0], seg[0][1]);
          if (seg.length > 2) {
            path.quadraticCurveTo(seg[2][0], seg[2][1], seg[1][0], seg[1][1]);
          } else {
            path.lineTo(seg[1][0], seg[1][1]);
          }
        }
      }
    },
    findDataIndex: function(x, y) {
      var shape = this.shape;
      var segs = shape.segs;
      var isPolyline = shape.polyline;
      var lineWidth = Math.max(this.style.lineWidth, 1);
      for (var i = 0; i < segs.length; i++) {
        var seg = segs[i];
        if (isPolyline) {
          for (var j = 1; j < seg.length; j++) {
            if (lineContain.containStroke(seg[j - 1][0], seg[j - 1][1], seg[j][0], seg[j][1], lineWidth, x, y)) {
              return i;
            }
          }
        } else {
          if (seg.length > 2) {
            if (quadraticContain.containStroke(seg[0][0], seg[0][1], seg[2][0], seg[2][1], seg[1][0], seg[1][1], lineWidth, x, y)) {
              return i;
            }
          } else {
            if (lineContain.containStroke(seg[0][0], seg[0][1], seg[1][0], seg[1][1], lineWidth, x, y)) {
              return i;
            }
          }
        }
      }
      return -1;
    }
  });
  function LargeLineDraw() {
    this.group = new graphic.Group();
    this._lineEl = new LargeLineShape();
  }
  var largeLineProto = LargeLineDraw.prototype;
  largeLineProto.updateData = function(data) {
    this.group.removeAll();
    var lineEl = this._lineEl;
    var seriesModel = data.hostModel;
    lineEl.setShape({
      segs: data.mapArray(data.getItemLayout),
      polyline: seriesModel.get('polyline')
    });
    lineEl.useStyle(seriesModel.getModel('lineStyle.normal').getLineStyle());
    var visualColor = data.getVisual('color');
    if (visualColor) {
      lineEl.setStyle('stroke', visualColor);
    }
    lineEl.setStyle('fill');
    lineEl.seriesIndex = seriesModel.seriesIndex;
    lineEl.on('mousemove', function(e) {
      lineEl.dataIndex = null;
      var dataIndex = lineEl.findDataIndex(e.offsetX, e.offsetY);
      if (dataIndex > 0) {
        lineEl.dataIndex = dataIndex;
      }
    });
    this.group.add(lineEl);
  };
  largeLineProto.updateLayout = function(seriesModel) {
    var data = seriesModel.getData();
    this._lineEl.setShape({segs: data.mapArray(data.getItemLayout)});
  };
  largeLineProto.remove = function() {
    this.group.removeAll();
  };
  module.exports = LargeLineDraw;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/lines/LinesView.js", ["../helper/LineDraw", "../helper/EffectLine", "../helper/Line", "../helper/Polyline", "../helper/EffectPolyline", "../helper/LargeLineDraw", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var LineDraw = $__require('../helper/LineDraw');
  var EffectLine = $__require('../helper/EffectLine');
  var Line = $__require('../helper/Line');
  var Polyline = $__require('../helper/Polyline');
  var EffectPolyline = $__require('../helper/EffectPolyline');
  var LargeLineDraw = $__require('../helper/LargeLineDraw');
  $__require('../../echarts').extendChartView({
    type: 'lines',
    init: function() {},
    render: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var lineDraw = this._lineDraw;
      var hasEffect = seriesModel.get('effect.show');
      var isPolyline = seriesModel.get('polyline');
      var isLarge = seriesModel.get('large') && data.count() >= seriesModel.get('largeThreshold');
      if (__DEV__) {
        if (hasEffect && isLarge) {
          console.warn('Large lines not support effect');
        }
      }
      if (hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLarge !== this._isLarge) {
        if (lineDraw) {
          lineDraw.remove();
        }
        lineDraw = this._lineDraw = isLarge ? new LargeLineDraw() : new LineDraw(isPolyline ? (hasEffect ? EffectPolyline : Polyline) : (hasEffect ? EffectLine : Line));
        this._hasEffet = hasEffect;
        this._isPolyline = isPolyline;
        this._isLarge = isLarge;
      }
      var zlevel = seriesModel.get('zlevel');
      var trailLength = seriesModel.get('effect.trailLength');
      var zr = api.getZr();
      zr.painter.getLayer(zlevel).clear(true);
      if (this._lastZlevel != null) {
        zr.configLayer(this._lastZlevel, {motionBlur: false});
      }
      if (hasEffect && trailLength) {
        if (__DEV__) {
          var notInIndividual = false;
          ecModel.eachSeries(function(otherSeriesModel) {
            if (otherSeriesModel !== seriesModel && otherSeriesModel.get('zlevel') === zlevel) {
              notInIndividual = true;
            }
          });
          notInIndividual && console.warn('Lines with trail effect should have an individual zlevel');
        }
        zr.configLayer(zlevel, {
          motionBlur: true,
          lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)
        });
      }
      this.group.add(lineDraw.group);
      lineDraw.updateData(data);
      this._lastZlevel = zlevel;
    },
    updateLayout: function(seriesModel, ecModel, api) {
      this._lineDraw.updateLayout(seriesModel);
      var zr = api.getZr();
      zr.painter.getLayer(this._lastZlevel).clear(true);
    },
    remove: function(ecModel, api) {
      this._lineDraw && this._lineDraw.remove(api, true);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/lines/linesLayout.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(ecModel) {
    ecModel.eachSeriesByType('lines', function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var lineData = seriesModel.getData();
      lineData.each(function(idx) {
        var itemModel = lineData.getItemModel(idx);
        var coords = (itemModel.option instanceof Array) ? itemModel.option : itemModel.get('coords');
        if (__DEV__) {
          if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) {
            throw new Error('Invalid coords ' + JSON.stringify(coords) + '. Lines must have 2d coords array in data item.');
          }
        }
        var pts = [];
        if (seriesModel.get('polyline')) {
          for (var i = 0; i < coords.length; i++) {
            pts.push(coordSys.dataToPoint(coords[i]));
          }
        } else {
          pts[0] = coordSys.dataToPoint(coords[0]);
          pts[1] = coordSys.dataToPoint(coords[1]);
          var curveness = itemModel.get('lineStyle.normal.curveness');
          if (curveness > 0) {
            pts[2] = [(pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness];
          }
        }
        lineData.setItemLayout(idx, pts);
      });
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/lines.js", ["./lines/LinesSeries", "./lines/LinesView", "../echarts", "./lines/linesLayout", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./lines/LinesSeries');
  $__require('./lines/LinesView');
  var echarts = $__require('../echarts');
  echarts.registerLayout($__require('./lines/linesLayout'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/data/helper/completeDimensions.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  function completeDimensions(dimensions, data, defaultNames, extraPrefix) {
    if (!data) {
      return dimensions;
    }
    var value0 = retrieveValue(data[0]);
    var dimSize = zrUtil.isArray(value0) && value0.length || 1;
    defaultNames = defaultNames || [];
    extraPrefix = extraPrefix || 'extra';
    for (var i = 0; i < dimSize; i++) {
      if (!dimensions[i]) {
        var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));
        dimensions[i] = guessOrdinal(data, i) ? {
          type: 'ordinal',
          name: name
        } : name;
      }
    }
    return dimensions;
  }
  var guessOrdinal = completeDimensions.guessOrdinal = function(data, dimIndex) {
    for (var i = 0,
        len = data.length; i < len; i++) {
      var value = retrieveValue(data[i]);
      if (!zrUtil.isArray(value)) {
        return false;
      }
      var value = value[dimIndex];
      if (value != null && isFinite(value)) {
        return false;
      } else if (zrUtil.isString(value) && value !== '-') {
        return true;
      }
    }
    return false;
  };
  function retrieveValue(o) {
    return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;
  }
  module.exports = completeDimensions;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/createListFromArray.js", ["../../data/List", "../../data/helper/completeDimensions", "zrender/lib/core/util", "../../util/model", "../../CoordinateSystem", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var List = $__require('../../data/List');
  var completeDimensions = $__require('../../data/helper/completeDimensions');
  var zrUtil = $__require('zrender/lib/core/util');
  var modelUtil = $__require('../../util/model');
  var CoordinateSystem = $__require('../../CoordinateSystem');
  var getDataItemValue = modelUtil.getDataItemValue;
  var converDataValue = modelUtil.converDataValue;
  function firstDataNotNull(data) {
    var i = 0;
    while (i < data.length && data[i] == null) {
      i++;
    }
    return data[i];
  }
  function ifNeedCompleteOrdinalData(data) {
    var sampleItem = firstDataNotNull(data);
    return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));
  }
  function createListFromArray(data, seriesModel, ecModel) {
    data = data || [];
    if (__DEV__) {
      if (!zrUtil.isArray(data)) {
        throw new Error('Invalid data.');
      }
    }
    var coordSysName = seriesModel.get('coordinateSystem');
    var creator = creators[coordSysName];
    var registeredCoordSys = CoordinateSystem.get(coordSysName);
    var axesInfo = creator && creator(data, seriesModel, ecModel);
    var dimensions = axesInfo && axesInfo.dimensions;
    if (!dimensions) {
      dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];
      dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));
    }
    var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;
    var list = new List(dimensions, seriesModel);
    var nameList = createNameList(axesInfo, data);
    var categories = {};
    var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data)) ? function(itemOpt, dimName, dataIndex, dimIndex) {
      if (modelUtil.isDataItemOption(itemOpt)) {
        list.hasItemOption = true;
      }
      return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);
    } : function(itemOpt, dimName, dataIndex, dimIndex) {
      var value = getDataItemValue(itemOpt);
      var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);
      if (modelUtil.isDataItemOption(itemOpt)) {
        list.hasItemOption = true;
      }
      var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;
      if (categoryAxesModels && categoryAxesModels[dimName]) {
        if (typeof val === 'string') {
          categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();
          val = zrUtil.indexOf(categories[dimName], val);
          if (val < 0 && !isNaN(val)) {
            val = +val;
          }
        }
      }
      return val;
    };
    list.hasItemOption = false;
    list.initData(data, nameList, dimValueGetter);
    return list;
  }
  function isStackable(axisType) {
    return axisType !== 'category' && axisType !== 'time';
  }
  function getDimTypeByAxis(axisType) {
    return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';
  }
  var creators = {
    cartesian2d: function(data, seriesModel, ecModel) {
      var xAxisModel = ecModel.getComponent('xAxis', seriesModel.get('xAxisIndex'));
      var yAxisModel = ecModel.getComponent('yAxis', seriesModel.get('yAxisIndex'));
      if (__DEV__) {
        if (!xAxisModel) {
          throw new Error('xAxis "' + seriesModel.get('xAxisIndex') + '" not found');
        }
        if (!yAxisModel) {
          throw new Error('yAxis "' + seriesModel.get('yAxisIndex') + '" not found');
        }
      }
      var xAxisType = xAxisModel.get('type');
      var yAxisType = yAxisModel.get('type');
      var dimensions = [{
        name: 'x',
        type: getDimTypeByAxis(xAxisType),
        stackable: isStackable(xAxisType)
      }, {
        name: 'y',
        type: getDimTypeByAxis(yAxisType),
        stackable: isStackable(yAxisType)
      }];
      var isXAxisCateogry = xAxisType === 'category';
      var isYAxisCategory = yAxisType === 'category';
      completeDimensions(dimensions, data, ['x', 'y', 'z']);
      var categoryAxesModels = {};
      if (isXAxisCateogry) {
        categoryAxesModels.x = xAxisModel;
      }
      if (isYAxisCategory) {
        categoryAxesModels.y = yAxisModel;
      }
      return {
        dimensions: dimensions,
        categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),
        categoryAxesModels: categoryAxesModels
      };
    },
    polar: function(data, seriesModel, ecModel) {
      var polarIndex = seriesModel.get('polarIndex') || 0;
      var axisFinder = function(axisModel) {
        return axisModel.get('polarIndex') === polarIndex;
      };
      var angleAxisModel = ecModel.findComponents({
        mainType: 'angleAxis',
        filter: axisFinder
      })[0];
      var radiusAxisModel = ecModel.findComponents({
        mainType: 'radiusAxis',
        filter: axisFinder
      })[0];
      if (__DEV__) {
        if (!angleAxisModel) {
          throw new Error('angleAxis option not found');
        }
        if (!radiusAxisModel) {
          throw new Error('radiusAxis option not found');
        }
      }
      var radiusAxisType = radiusAxisModel.get('type');
      var angleAxisType = angleAxisModel.get('type');
      var dimensions = [{
        name: 'radius',
        type: getDimTypeByAxis(radiusAxisType),
        stackable: isStackable(radiusAxisType)
      }, {
        name: 'angle',
        type: getDimTypeByAxis(angleAxisType),
        stackable: isStackable(angleAxisType)
      }];
      var isAngleAxisCateogry = angleAxisType === 'category';
      var isRadiusAxisCateogry = radiusAxisType === 'category';
      completeDimensions(dimensions, data, ['radius', 'angle', 'value']);
      var categoryAxesModels = {};
      if (isRadiusAxisCateogry) {
        categoryAxesModels.radius = radiusAxisModel;
      }
      if (isAngleAxisCateogry) {
        categoryAxesModels.angle = angleAxisModel;
      }
      return {
        dimensions: dimensions,
        categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),
        categoryAxesModels: categoryAxesModels
      };
    },
    geo: function(data, seriesModel, ecModel) {
      return {dimensions: completeDimensions([{name: 'lng'}, {name: 'lat'}], data, ['lng', 'lat', 'value'])};
    }
  };
  function createNameList(result, data) {
    var nameList = [];
    var categoryDim = result && result.dimensions[result.categoryIndex];
    var categoryAxisModel;
    if (categoryDim) {
      categoryAxisModel = result.categoryAxesModels[categoryDim.name];
    }
    if (categoryAxisModel) {
      var categories = categoryAxisModel.getCategories();
      if (categories) {
        var dataLen = data.length;
        if (zrUtil.isArray(data[0]) && data[0].length > 1) {
          nameList = [];
          for (var i = 0; i < dataLen; i++) {
            nameList[i] = categories[data[i][result.categoryIndex || 0]];
          }
        } else {
          nameList = categories.slice(0);
        }
      }
    }
    return nameList;
  }
  module.exports = createListFromArray;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/heatmap/HeatmapSeries.js", ["../../model/Series", "../helper/createListFromArray", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SeriesModel = $__require('../../model/Series');
  var createListFromArray = $__require('../helper/createListFromArray');
  module.exports = SeriesModel.extend({
    type: 'series.heatmap',
    getInitialData: function(option, ecModel) {
      return createListFromArray(option.data, this, ecModel);
    },
    defaultOption: {
      coordinateSystem: 'cartesian2d',
      zlevel: 0,
      z: 2,
      xAxisIndex: 0,
      yAxisIndex: 0,
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/heatmap/HeatmapLayer.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var GRADIENT_LEVELS = 256;
  var zrUtil = $__require('zrender/lib/core/util');
  function Heatmap() {
    var canvas = zrUtil.createCanvas();
    this.canvas = canvas;
    this.blurSize = 30;
    this.pointSize = 20;
    this.maxOpacity = 1;
    this.minOpacity = 0;
    this._gradientPixels = {};
  }
  Heatmap.prototype = {
    update: function(data, width, height, normalize, colorFunc, isInRange) {
      var brush = this._getBrush();
      var gradientInRange = this._getGradient(data, colorFunc, 'inRange');
      var gradientOutOfRange = this._getGradient(data, colorFunc, 'outOfRange');
      var r = this.pointSize + this.blurSize;
      var canvas = this.canvas;
      var ctx = canvas.getContext('2d');
      var len = data.length;
      canvas.width = width;
      canvas.height = height;
      for (var i = 0; i < len; ++i) {
        var p = data[i];
        var x = p[0];
        var y = p[1];
        var value = p[2];
        var alpha = normalize(value);
        ctx.globalAlpha = alpha;
        ctx.drawImage(brush, x - r, y - r);
      }
      var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var pixels = imageData.data;
      var offset = 0;
      var pixelLen = pixels.length;
      var minOpacity = this.minOpacity;
      var maxOpacity = this.maxOpacity;
      var diffOpacity = maxOpacity - minOpacity;
      while (offset < pixelLen) {
        var alpha = pixels[offset + 3] / 256;
        var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;
        if (alpha > 0) {
          var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;
          alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
          pixels[offset++] = gradient[gradientOffset];
          pixels[offset++] = gradient[gradientOffset + 1];
          pixels[offset++] = gradient[gradientOffset + 2];
          pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
        } else {
          offset += 4;
        }
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas;
    },
    _getBrush: function() {
      var brushCanvas = this._brushCanvas || (this._brushCanvas = zrUtil.createCanvas());
      var r = this.pointSize + this.blurSize;
      var d = r * 2;
      brushCanvas.width = d;
      brushCanvas.height = d;
      var ctx = brushCanvas.getContext('2d');
      ctx.clearRect(0, 0, d, d);
      ctx.shadowOffsetX = d;
      ctx.shadowBlur = this.blurSize;
      ctx.shadowColor = '#000';
      ctx.beginPath();
      ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fill();
      return brushCanvas;
    },
    _getGradient: function(data, colorFunc, state) {
      var gradientPixels = this._gradientPixels;
      var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
      var color = [];
      var off = 0;
      for (var i = 0; i < 256; i++) {
        colorFunc[state](i / 255, true, color);
        pixelsSingleState[off++] = color[0];
        pixelsSingleState[off++] = color[1];
        pixelsSingleState[off++] = color[2];
        pixelsSingleState[off++] = color[3];
      }
      return pixelsSingleState;
    }
  };
  module.exports = Heatmap;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/heatmap/HeatmapView.js", ["../../util/graphic", "./HeatmapLayer", "zrender/lib/core/util", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var HeatmapLayer = $__require('./HeatmapLayer');
  var zrUtil = $__require('zrender/lib/core/util');
  function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
    var dataSpan = dataExtent[1] - dataExtent[0];
    pieceList = zrUtil.map(pieceList, function(piece) {
      return {interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan]};
    });
    var len = pieceList.length;
    var lastIndex = 0;
    return function(val) {
      for (var i = lastIndex; i < len; i++) {
        var interval = pieceList[i].interval;
        if (interval[0] <= val && val <= interval[1]) {
          lastIndex = i;
          break;
        }
      }
      if (i === len) {
        for (var i = lastIndex - 1; i >= 0; i--) {
          var interval = pieceList[i].interval;
          if (interval[0] <= val && val <= interval[1]) {
            lastIndex = i;
            break;
          }
        }
      }
      return i >= 0 && i < len && selected[i];
    };
  }
  function getIsInContinuousRange(dataExtent, range) {
    var dataSpan = dataExtent[1] - dataExtent[0];
    range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan];
    return function(val) {
      return val >= range[0] && val <= range[1];
    };
  }
  function isGeoCoordSys(coordSys) {
    var dimensions = coordSys.dimensions;
    return dimensions[0] === 'lng' && dimensions[1] === 'lat';
  }
  module.exports = $__require('../../echarts').extendChartView({
    type: 'heatmap',
    render: function(seriesModel, ecModel, api) {
      var visualMapOfThisSeries;
      ecModel.eachComponent('visualMap', function(visualMap) {
        visualMap.eachTargetSeries(function(targetSeries) {
          if (targetSeries === seriesModel) {
            visualMapOfThisSeries = visualMap;
          }
        });
      });
      if (__DEV__) {
        if (!visualMapOfThisSeries) {
          throw new Error('Heatmap must use with visualMap');
        }
      }
      this.group.removeAll();
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys.type === 'cartesian2d') {
        this._renderOnCartesian(coordSys, seriesModel, api);
      } else if (isGeoCoordSys(coordSys)) {
        this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);
      }
    },
    _renderOnCartesian: function(cartesian, seriesModel, api) {
      var xAxis = cartesian.getAxis('x');
      var yAxis = cartesian.getAxis('y');
      var group = this.group;
      if (__DEV__) {
        if (!(xAxis.type === 'category' && yAxis.type === 'category')) {
          throw new Error('Heatmap on cartesian must have two category axes');
        }
        if (!(xAxis.onBand && yAxis.onBand)) {
          throw new Error('Heatmap on cartesian must have two axes with boundaryGap true');
        }
      }
      var width = xAxis.getBandWidth();
      var height = yAxis.getBandWidth();
      var data = seriesModel.getData();
      var itemStyleQuery = 'itemStyle.normal';
      var hoverItemStyleQuery = 'itemStyle.emphasis';
      var labelQuery = 'label.normal';
      var hoverLabelQuery = 'label.emphasis';
      var style = seriesModel.getModel(itemStyleQuery).getItemStyle(['color']);
      var hoverStl = seriesModel.getModel(hoverItemStyleQuery).getItemStyle();
      var labelModel = seriesModel.getModel('label.normal');
      var hoverLabelModel = seriesModel.getModel('label.emphasis');
      data.each(['x', 'y', 'z'], function(x, y, z, idx) {
        var itemModel = data.getItemModel(idx);
        var point = cartesian.dataToPoint([x, y]);
        if (isNaN(z)) {
          return;
        }
        var rect = new graphic.Rect({
          shape: {
            x: point[0] - width / 2,
            y: point[1] - height / 2,
            width: width,
            height: height
          },
          style: {
            fill: data.getItemVisual(idx, 'color'),
            opacity: data.getItemVisual(idx, 'opacity')
          }
        });
        if (data.hasItemOption) {
          style = itemModel.getModel(itemStyleQuery).getItemStyle(['color']);
          hoverStl = itemModel.getModel(hoverItemStyleQuery).getItemStyle();
          labelModel = itemModel.getModel(labelQuery);
          hoverLabelModel = itemModel.getModel(hoverLabelQuery);
        }
        var rawValue = seriesModel.getRawValue(idx);
        var defaultText = '-';
        if (rawValue && rawValue[2] != null) {
          defaultText = rawValue[2];
        }
        if (labelModel.getShallow('show')) {
          graphic.setText(style, labelModel);
          style.text = seriesModel.getFormattedLabel(idx, 'normal') || defaultText;
        }
        if (hoverLabelModel.getShallow('show')) {
          graphic.setText(hoverStl, hoverLabelModel);
          hoverStl.text = seriesModel.getFormattedLabel(idx, 'emphasis') || defaultText;
        }
        rect.setStyle(style);
        graphic.setHoverStyle(rect, data.hasItemOption ? hoverStl : zrUtil.extend({}, hoverStl));
        group.add(rect);
        data.setItemGraphicEl(idx, rect);
      });
    },
    _renderOnGeo: function(geo, seriesModel, visualMapModel, api) {
      var inRangeVisuals = visualMapModel.targetVisuals.inRange;
      var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;
      var data = seriesModel.getData();
      var hmLayer = this._hmLayer || (this._hmLayer || new HeatmapLayer());
      hmLayer.blurSize = seriesModel.get('blurSize');
      hmLayer.pointSize = seriesModel.get('pointSize');
      hmLayer.minOpacity = seriesModel.get('minOpacity');
      hmLayer.maxOpacity = seriesModel.get('maxOpacity');
      var rect = geo.getViewRect().clone();
      var roamTransform = geo.getRoamTransform().transform;
      rect.applyTransform(roamTransform);
      var x = Math.max(rect.x, 0);
      var y = Math.max(rect.y, 0);
      var x2 = Math.min(rect.width + rect.x, api.getWidth());
      var y2 = Math.min(rect.height + rect.y, api.getHeight());
      var width = x2 - x;
      var height = y2 - y;
      var points = data.mapArray(['lng', 'lat', 'value'], function(lng, lat, value) {
        var pt = geo.dataToPoint([lng, lat]);
        pt[0] -= x;
        pt[1] -= y;
        pt.push(value);
        return pt;
      });
      var dataExtent = visualMapModel.getExtent();
      var isInRange = visualMapModel.type === 'visualMap.continuous' ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
      hmLayer.update(points, width, height, inRangeVisuals.color.getNormalizer(), {
        inRange: inRangeVisuals.color.getColorMapper(),
        outOfRange: outOfRangeVisuals.color.getColorMapper()
      }, isInRange);
      var img = new graphic.Image({
        style: {
          width: width,
          height: height,
          x: x,
          y: y,
          image: hmLayer.canvas
        },
        silent: true
      });
      this.group.add(img);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/heatmap.js", ["./heatmap/HeatmapSeries", "./heatmap/HeatmapView", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./heatmap/HeatmapSeries');
  $__require('./heatmap/HeatmapView');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/cartesian/Cartesian.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  function dimAxisMapper(dim) {
    return this._axes[dim];
  }
  var Cartesian = function(name) {
    this._axes = {};
    this._dimList = [];
    this.name = name || '';
  };
  Cartesian.prototype = {
    constructor: Cartesian,
    type: 'cartesian',
    getAxis: function(dim) {
      return this._axes[dim];
    },
    getAxes: function() {
      return zrUtil.map(this._dimList, dimAxisMapper, this);
    },
    getAxesByScale: function(scaleType) {
      scaleType = scaleType.toLowerCase();
      return zrUtil.filter(this.getAxes(), function(axis) {
        return axis.scale.type === scaleType;
      });
    },
    addAxis: function(axis) {
      var dim = axis.dim;
      this._axes[dim] = axis;
      this._dimList.push(dim);
    },
    dataToCoord: function(val) {
      return this._dataCoordConvert(val, 'dataToCoord');
    },
    coordToData: function(val) {
      return this._dataCoordConvert(val, 'coordToData');
    },
    _dataCoordConvert: function(input, method) {
      var dimList = this._dimList;
      var output = input instanceof Array ? [] : {};
      for (var i = 0; i < dimList.length; i++) {
        var dim = dimList[i];
        var axis = this._axes[dim];
        output[dim] = axis[method](input[dim]);
      }
      return output;
    }
  };
  module.exports = Cartesian;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/cartesian/Cartesian2D.js", ["zrender/lib/core/util", "./Cartesian", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Cartesian = $__require('./Cartesian');
  function Cartesian2D(name) {
    Cartesian.call(this, name);
  }
  Cartesian2D.prototype = {
    constructor: Cartesian2D,
    type: 'cartesian2d',
    dimensions: ['x', 'y'],
    getBaseAxis: function() {
      return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');
    },
    containPoint: function(point) {
      var axisX = this.getAxis('x');
      var axisY = this.getAxis('y');
      return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
    },
    containData: function(data) {
      return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);
    },
    dataToPoints: function(data, stack) {
      return data.mapArray(['x', 'y'], function(x, y) {
        return this.dataToPoint([x, y]);
      }, stack, this);
    },
    dataToPoint: function(data, clamp) {
      var xAxis = this.getAxis('x');
      var yAxis = this.getAxis('y');
      return [xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)), yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))];
    },
    pointToData: function(point, clamp) {
      var xAxis = this.getAxis('x');
      var yAxis = this.getAxis('y');
      return [xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp), yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)];
    },
    getOtherAxis: function(axis) {
      return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
    }
  };
  zrUtil.inherits(Cartesian2D, Cartesian);
  module.exports = Cartesian2D;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/cartesian/axisLabelInterval.js", ["zrender/lib/core/util", "../axisHelper", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var axisHelper = $__require('../axisHelper');
  module.exports = function(axis) {
    var axisModel = axis.model;
    var labelModel = axisModel.getModel('axisLabel');
    var labelInterval = labelModel.get('interval');
    if (!(axis.type === 'category' && labelInterval === 'auto')) {
      return labelInterval === 'auto' ? 0 : labelInterval;
    }
    return axisHelper.getAxisLabelInterval(zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis), axisModel.getFormattedLabels(), labelModel.getModel('textStyle').getFont(), axis.isHorizontal());
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/cartesian/Axis2D.js", ["zrender/lib/core/util", "../Axis", "./axisLabelInterval", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Axis = $__require('../Axis');
  var axisLabelInterval = $__require('./axisLabelInterval');
  var Axis2D = function(dim, scale, coordExtent, axisType, position) {
    Axis.call(this, dim, scale, coordExtent);
    this.type = axisType || 'value';
    this.position = position || 'bottom';
  };
  Axis2D.prototype = {
    constructor: Axis2D,
    index: 0,
    onZero: false,
    model: null,
    isHorizontal: function() {
      var position = this.position;
      return position === 'top' || position === 'bottom';
    },
    getGlobalExtent: function() {
      var ret = this.getExtent();
      ret[0] = this.toGlobalCoord(ret[0]);
      ret[1] = this.toGlobalCoord(ret[1]);
      return ret;
    },
    getLabelInterval: function() {
      var labelInterval = this._labelInterval;
      if (!labelInterval) {
        labelInterval = this._labelInterval = axisLabelInterval(this);
      }
      return labelInterval;
    },
    isLabelIgnored: function(idx) {
      if (this.type === 'category') {
        var labelInterval = this.getLabelInterval();
        return ((typeof labelInterval === 'function') && !labelInterval(idx, this.scale.getLabel(idx))) || idx % (labelInterval + 1);
      }
    },
    toLocalCoord: null,
    toGlobalCoord: null
  };
  zrUtil.inherits(Axis2D, Axis);
  module.exports = Axis2D;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/cartesian/GridModel.js", ["./AxisModel", "../../model/Component", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./AxisModel');
  var ComponentModel = $__require('../../model/Component');
  module.exports = ComponentModel.extend({
    type: 'grid',
    dependencies: ['xAxis', 'yAxis'],
    layoutMode: 'box',
    coordinateSystem: null,
    defaultOption: {
      show: false,
      zlevel: 0,
      z: 0,
      left: '10%',
      top: 60,
      right: '10%',
      bottom: 60,
      containLabel: false,
      backgroundColor: 'rgba(0,0,0,0)',
      borderWidth: 1,
      borderColor: '#ccc'
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/cartesian/Grid.js", ["../../util/layout", "../../coord/axisHelper", "zrender/lib/core/util", "./Cartesian2D", "./Axis2D", "./GridModel", "../../CoordinateSystem", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var factory = exports;
  var layout = $__require('../../util/layout');
  var axisHelper = $__require('../../coord/axisHelper');
  var zrUtil = $__require('zrender/lib/core/util');
  var Cartesian2D = $__require('./Cartesian2D');
  var Axis2D = $__require('./Axis2D');
  var each = zrUtil.each;
  var ifAxisCrossZero = axisHelper.ifAxisCrossZero;
  var niceScaleExtent = axisHelper.niceScaleExtent;
  $__require('./GridModel');
  function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
    return ecModel.getComponent('grid', axisModel.get('gridIndex')) === gridModel;
  }
  function getLabelUnionRect(axis) {
    var axisModel = axis.model;
    var labels = axisModel.getFormattedLabels();
    var rect;
    var step = 1;
    var labelCount = labels.length;
    if (labelCount > 40) {
      step = Math.ceil(labelCount / 40);
    }
    for (var i = 0; i < labelCount; i += step) {
      if (!axis.isLabelIgnored(i)) {
        var singleRect = axisModel.getTextRect(labels[i]);
        rect ? rect.union(singleRect) : (rect = singleRect);
      }
    }
    return rect;
  }
  function Grid(gridModel, ecModel, api) {
    this._coordsMap = {};
    this._coordsList = [];
    this._axesMap = {};
    this._axesList = [];
    this._initCartesian(gridModel, ecModel, api);
    this._model = gridModel;
  }
  var gridProto = Grid.prototype;
  gridProto.type = 'grid';
  gridProto.getRect = function() {
    return this._rect;
  };
  gridProto.update = function(ecModel, api) {
    var axesMap = this._axesMap;
    this._updateScale(ecModel, this._model);
    function ifAxisCanNotOnZero(otherAxisDim) {
      var axes = axesMap[otherAxisDim];
      for (var idx in axes) {
        var axis = axes[idx];
        if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {
          return true;
        }
      }
      return false;
    }
    each(axesMap.x, function(xAxis) {
      niceScaleExtent(xAxis, xAxis.model);
    });
    each(axesMap.y, function(yAxis) {
      niceScaleExtent(yAxis, yAxis.model);
    });
    each(axesMap.x, function(xAxis) {
      if (ifAxisCanNotOnZero('y')) {
        xAxis.onZero = false;
      }
    });
    each(axesMap.y, function(yAxis) {
      if (ifAxisCanNotOnZero('x')) {
        yAxis.onZero = false;
      }
    });
    this.resize(this._model, api);
  };
  gridProto.resize = function(gridModel, api) {
    var gridRect = layout.getLayoutRect(gridModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._rect = gridRect;
    var axesList = this._axesList;
    adjustAxes();
    if (gridModel.get('containLabel')) {
      each(axesList, function(axis) {
        if (!axis.model.get('axisLabel.inside')) {
          var labelUnionRect = getLabelUnionRect(axis);
          if (labelUnionRect) {
            var dim = axis.isHorizontal() ? 'height' : 'width';
            var margin = axis.model.get('axisLabel.margin');
            gridRect[dim] -= labelUnionRect[dim] + margin;
            if (axis.position === 'top') {
              gridRect.y += labelUnionRect.height + margin;
            } else if (axis.position === 'left') {
              gridRect.x += labelUnionRect.width + margin;
            }
          }
        }
      });
      adjustAxes();
    }
    function adjustAxes() {
      each(axesList, function(axis) {
        var isHorizontal = axis.isHorizontal();
        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
        var idx = axis.inverse ? 1 : 0;
        axis.setExtent(extent[idx], extent[1 - idx]);
        updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);
      });
    }
  };
  gridProto.getAxis = function(axisType, axisIndex) {
    var axesMapOnDim = this._axesMap[axisType];
    if (axesMapOnDim != null) {
      if (axisIndex == null) {
        for (var name in axesMapOnDim) {
          return axesMapOnDim[name];
        }
      }
      return axesMapOnDim[axisIndex];
    }
  };
  gridProto.getCartesian = function(xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
      return this._coordsMap[key];
    } else {
      for (var i = 0,
          coordList = this._coordsList; i < coordList.length; i++) {
        if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {
          return coordList[i];
        }
      }
    }
  };
  gridProto._initCartesian = function(gridModel, ecModel, api) {
    var axisPositionUsed = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    var axesMap = {
      x: {},
      y: {}
    };
    var axesCount = {
      x: 0,
      y: 0
    };
    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);
    if (!axesCount.x || !axesCount.y) {
      this._axesMap = {};
      this._axesList = [];
      return;
    }
    this._axesMap = axesMap;
    each(axesMap.x, function(xAxis, xAxisIndex) {
      each(axesMap.y, function(yAxis, yAxisIndex) {
        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
        var cartesian = new Cartesian2D(key);
        cartesian.grid = this;
        this._coordsMap[key] = cartesian;
        this._coordsList.push(cartesian);
        cartesian.addAxis(xAxis);
        cartesian.addAxis(yAxis);
      }, this);
    }, this);
    function createAxisCreator(axisType) {
      return function(axisModel, idx) {
        if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {
          return;
        }
        var axisPosition = axisModel.get('position');
        if (axisType === 'x') {
          if (axisPosition !== 'top' && axisPosition !== 'bottom') {
            axisPosition = 'bottom';
            if (axisPositionUsed[axisPosition]) {
              axisPosition = axisPosition === 'top' ? 'bottom' : 'top';
            }
          }
        } else {
          if (axisPosition !== 'left' && axisPosition !== 'right') {
            axisPosition = 'left';
            if (axisPositionUsed[axisPosition]) {
              axisPosition = axisPosition === 'left' ? 'right' : 'left';
            }
          }
        }
        axisPositionUsed[axisPosition] = true;
        var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);
        var isCategory = axis.type === 'category';
        axis.onBand = isCategory && axisModel.get('boundaryGap');
        axis.inverse = axisModel.get('inverse');
        axis.onZero = axisModel.get('axisLine.onZero');
        axisModel.axis = axis;
        axis.model = axisModel;
        axis.grid = this;
        axis.index = idx;
        this._axesList.push(axis);
        axesMap[axisType][idx] = axis;
        axesCount[axisType]++;
      };
    }
  };
  gridProto._updateScale = function(ecModel, gridModel) {
    zrUtil.each(this._axesList, function(axis) {
      axis.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get('coordinateSystem') === 'cartesian2d') {
        var xAxisIndex = seriesModel.get('xAxisIndex');
        var yAxisIndex = seriesModel.get('yAxisIndex');
        var xAxisModel = ecModel.getComponent('xAxis', xAxisIndex);
        var yAxisModel = ecModel.getComponent('yAxis', yAxisIndex);
        if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {
          return;
        }
        var cartesian = this.getCartesian(xAxisIndex, yAxisIndex);
        var data = seriesModel.getData();
        var xAxis = cartesian.getAxis('x');
        var yAxis = cartesian.getAxis('y');
        if (data.type === 'list') {
          unionExtent(data, xAxis, seriesModel);
          unionExtent(data, yAxis, seriesModel);
        }
      }
    }, this);
    function unionExtent(data, axis, seriesModel) {
      each(seriesModel.coordDimToDataDim(axis.dim), function(dim) {
        axis.scale.unionExtent(data.getDataExtent(dim, axis.scale.type !== 'ordinal'));
      });
    }
  };
  function updateAxisTransfrom(axis, coordBase) {
    var axisExtent = axis.getExtent();
    var axisExtentSum = axisExtent[0] + axisExtent[1];
    axis.toGlobalCoord = axis.dim === 'x' ? function(coord) {
      return coord + coordBase;
    } : function(coord) {
      return axisExtentSum - coord + coordBase;
    };
    axis.toLocalCoord = axis.dim === 'x' ? function(coord) {
      return coord - coordBase;
    } : function(coord) {
      return axisExtentSum - coord + coordBase;
    };
  }
  Grid.create = function(ecModel, api) {
    var grids = [];
    ecModel.eachComponent('grid', function(gridModel, idx) {
      var grid = new Grid(gridModel, ecModel, api);
      grid.name = 'grid_' + idx;
      grid.resize(gridModel, api);
      gridModel.coordinateSystem = grid;
      grids.push(grid);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get('coordinateSystem') !== 'cartesian2d') {
        return;
      }
      var xAxisIndex = seriesModel.get('xAxisIndex');
      var yAxisIndex = seriesModel.get('yAxisIndex');
      var xAxisModel = ecModel.getComponent('xAxis', xAxisIndex);
      if (__DEV__) {
        var yAxisModel = ecModel.getComponent('yAxis', yAxisIndex);
        if (xAxisModel.get('gridIndex') !== yAxisModel.get('gridIndex')) {
          throw new Error('xAxis and yAxis must use the same grid');
        }
      }
      var grid = grids[xAxisModel.get('gridIndex')];
      seriesModel.coordinateSystem = grid.getCartesian(xAxisIndex, yAxisIndex);
    });
    return grids;
  };
  Grid.dimensions = Cartesian2D.prototype.dimensions;
  $__require('../../CoordinateSystem').register('cartesian2d', Grid);
  module.exports = Grid;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/cartesian/AxisModel.js", ["../../model/Component", "zrender/lib/core/util", "../axisModelCreator", "../axisModelCommonMixin", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ComponentModel = $__require('../../model/Component');
  var zrUtil = $__require('zrender/lib/core/util');
  var axisModelCreator = $__require('../axisModelCreator');
  var AxisModel = ComponentModel.extend({
    type: 'cartesian2dAxis',
    axis: null,
    init: function() {
      AxisModel.superApply(this, 'init', arguments);
      this._resetRange();
    },
    mergeOption: function() {
      AxisModel.superApply(this, 'mergeOption', arguments);
      this._resetRange();
    },
    restoreData: function() {
      AxisModel.superApply(this, 'restoreData', arguments);
      this._resetRange();
    },
    setRange: function(rangeStart, rangeEnd) {
      this.option.rangeStart = rangeStart;
      this.option.rangeEnd = rangeEnd;
    },
    getMin: function() {
      var option = this.option;
      return option.rangeStart != null ? option.rangeStart : option.min;
    },
    getMax: function() {
      var option = this.option;
      return option.rangeEnd != null ? option.rangeEnd : option.max;
    },
    getNeedCrossZero: function() {
      var option = this.option;
      return (option.rangeStart != null || option.rangeEnd != null) ? false : !option.scale;
    },
    _resetRange: function() {
      this.option.rangeStart = this.option.rangeEnd = null;
    }
  });
  function getAxisType(axisDim, option) {
    return option.type || (option.data ? 'category' : 'value');
  }
  zrUtil.merge(AxisModel.prototype, $__require('../axisModelCommonMixin'));
  var extraOption = {
    gridIndex: 0,
    offset: 0
  };
  axisModelCreator('x', AxisModel, getAxisType, extraOption);
  axisModelCreator('y', AxisModel, getAxisType, extraOption);
  module.exports = AxisModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/axis/AxisView.js", ["zrender/lib/core/util", "../../util/graphic", "./AxisBuilder", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var AxisBuilder = $__require('./AxisBuilder');
  var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;
  var getInterval = AxisBuilder.getInterval;
  var axisBuilderAttrs = ['axisLine', 'axisLabel', 'axisTick', 'axisName'];
  var selfBuilderAttrs = ['splitArea', 'splitLine'];
  var AxisView = $__require('../../echarts').extendComponentView({
    type: 'axis',
    render: function(axisModel, ecModel) {
      this.group.removeAll();
      var oldAxisGroup = this._axisGroup;
      this._axisGroup = new graphic.Group();
      this.group.add(this._axisGroup);
      if (!axisModel.get('show')) {
        return;
      }
      var gridModel = ecModel.getComponent('grid', axisModel.get('gridIndex'));
      var layout = layoutAxis(gridModel, axisModel);
      var axisBuilder = new AxisBuilder(axisModel, layout);
      zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
      this._axisGroup.add(axisBuilder.getGroup());
      zrUtil.each(selfBuilderAttrs, function(name) {
        if (axisModel.get(name + '.show')) {
          this['_' + name](axisModel, gridModel, layout.labelInterval);
        }
      }, this);
      graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    },
    _splitLine: function(axisModel, gridModel, labelInterval) {
      var axis = axisModel.axis;
      var splitLineModel = axisModel.getModel('splitLine');
      var lineStyleModel = splitLineModel.getModel('lineStyle');
      var lineColors = lineStyleModel.get('color');
      var lineInterval = getInterval(splitLineModel, labelInterval);
      lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];
      var gridRect = gridModel.coordinateSystem.getRect();
      var isHorizontal = axis.isHorizontal();
      var lineCount = 0;
      var ticksCoords = axis.getTicksCoords();
      var ticks = axis.scale.getTicks();
      var p1 = [];
      var p2 = [];
      var lineStyle = lineStyleModel.getLineStyle();
      for (var i = 0; i < ticksCoords.length; i++) {
        if (ifIgnoreOnTick(axis, i, lineInterval)) {
          continue;
        }
        var tickCoord = axis.toGlobalCoord(ticksCoords[i]);
        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }
        var colorIndex = (lineCount++) % lineColors.length;
        this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({
          anid: 'line_' + ticks[i],
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: zrUtil.defaults({stroke: lineColors[colorIndex]}, lineStyle),
          silent: true
        })));
      }
    },
    _splitArea: function(axisModel, gridModel, labelInterval) {
      var axis = axisModel.axis;
      var splitAreaModel = axisModel.getModel('splitArea');
      var areaStyleModel = splitAreaModel.getModel('areaStyle');
      var areaColors = areaStyleModel.get('color');
      var gridRect = gridModel.coordinateSystem.getRect();
      var ticksCoords = axis.getTicksCoords();
      var ticks = axis.scale.getTicks();
      var prevX = axis.toGlobalCoord(ticksCoords[0]);
      var prevY = axis.toGlobalCoord(ticksCoords[0]);
      var count = 0;
      var areaInterval = getInterval(splitAreaModel, labelInterval);
      var areaStyle = areaStyleModel.getAreaStyle();
      areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];
      for (var i = 1; i < ticksCoords.length; i++) {
        if (ifIgnoreOnTick(axis, i, areaInterval)) {
          continue;
        }
        var tickCoord = axis.toGlobalCoord(ticksCoords[i]);
        var x;
        var y;
        var width;
        var height;
        if (axis.isHorizontal()) {
          x = prevX;
          y = gridRect.y;
          width = tickCoord - x;
          height = gridRect.height;
        } else {
          x = gridRect.x;
          y = prevY;
          width = gridRect.width;
          height = tickCoord - y;
        }
        var colorIndex = (count++) % areaColors.length;
        this._axisGroup.add(new graphic.Rect({
          anid: 'area_' + ticks[i],
          shape: {
            x: x,
            y: y,
            width: width,
            height: height
          },
          style: zrUtil.defaults({fill: areaColors[colorIndex]}, areaStyle),
          silent: true
        }));
        prevX = x + width;
        prevY = y + height;
      }
    }
  });
  AxisView.extend({type: 'xAxis'});
  AxisView.extend({type: 'yAxis'});
  function layoutAxis(gridModel, axisModel) {
    var grid = gridModel.coordinateSystem;
    var axis = axisModel.axis;
    var layout = {};
    var rawAxisPosition = axis.position;
    var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;
    var axisDim = axis.dim;
    var rect = grid.getRect();
    var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
    var axisOffset = axisModel.get('offset') || 0;
    var posMap = {
      x: {
        top: rectBound[2] - axisOffset,
        bottom: rectBound[3] + axisOffset
      },
      y: {
        left: rectBound[0] - axisOffset,
        right: rectBound[1] + axisOffset
      }
    };
    posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);
    posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);
    function getZero(dim, val) {
      var theAxis = grid.getAxis(dim);
      return theAxis.toGlobalCoord(theAxis.dataToCoord(0));
    }
    layout.position = [axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0], axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]];
    layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);
    var dirMap = {
      top: -1,
      bottom: 1,
      left: -1,
      right: 1
    };
    layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
    if (axis.onZero) {
      layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;
    }
    if (axisModel.getModel('axisTick').get('inside')) {
      layout.tickDirection = -layout.tickDirection;
    }
    if (axisModel.getModel('axisLabel').get('inside')) {
      layout.labelDirection = -layout.labelDirection;
    }
    var labelRotation = axisModel.getModel('axisLabel').get('rotate');
    layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;
    layout.labelInterval = axis.getLabelInterval();
    layout.z2 = 1;
    return layout;
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/axis.js", ["../coord/cartesian/AxisModel", "./axis/AxisView", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../coord/cartesian/AxisModel');
  $__require('./axis/AxisView');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/grid.js", ["../util/graphic", "zrender/lib/core/util", "../coord/cartesian/Grid", "./axis", "../echarts", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../util/graphic');
  var zrUtil = $__require('zrender/lib/core/util');
  $__require('../coord/cartesian/Grid');
  $__require('./axis');
  $__require('../echarts').extendComponentView({
    type: 'grid',
    render: function(gridModel, ecModel) {
      this.group.removeAll();
      if (gridModel.get('show')) {
        this.group.add(new graphic.Rect({
          shape: gridModel.coordinateSystem.getRect(),
          style: zrUtil.defaults({fill: gridModel.get('backgroundColor')}, gridModel.getItemStyle()),
          silent: true
        }));
      }
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/legend/LegendModel.js", ["zrender/lib/core/util", "../../model/Model", "../../echarts", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Model = $__require('../../model/Model');
  var LegendModel = $__require('../../echarts').extendComponentModel({
    type: 'legend',
    dependencies: ['series'],
    layoutMode: {
      type: 'box',
      ignoreSize: true
    },
    init: function(option, parentModel, ecModel) {
      this.mergeDefaultAndTheme(option, ecModel);
      option.selected = option.selected || {};
    },
    mergeOption: function(option) {
      LegendModel.superCall(this, 'mergeOption', option);
    },
    optionUpdated: function() {
      this._updateData(this.ecModel);
      var legendData = this._data;
      if (legendData[0] && this.get('selectedMode') === 'single') {
        var hasSelected = false;
        for (var i = 0; i < legendData.length; i++) {
          var name = legendData[i].get('name');
          if (this.isSelected(name)) {
            this.select(name);
            hasSelected = true;
            break;
          }
        }
        !hasSelected && this.select(legendData[0].get('name'));
      }
    },
    _updateData: function(ecModel) {
      var legendData = zrUtil.map(this.get('data') || [], function(dataItem) {
        if (typeof dataItem === 'string' || typeof dataItem === 'number') {
          dataItem = {name: dataItem};
        }
        return new Model(dataItem, this, this.ecModel);
      }, this);
      this._data = legendData;
      var availableNames = zrUtil.map(ecModel.getSeries(), function(series) {
        return series.name;
      });
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.legendDataProvider) {
          var data = seriesModel.legendDataProvider();
          availableNames = availableNames.concat(data.mapArray(data.getName));
        }
      });
      this._availableNames = availableNames;
    },
    getData: function() {
      return this._data;
    },
    select: function(name) {
      var selected = this.option.selected;
      var selectedMode = this.get('selectedMode');
      if (selectedMode === 'single') {
        var data = this._data;
        zrUtil.each(data, function(dataItem) {
          selected[dataItem.get('name')] = false;
        });
      }
      selected[name] = true;
    },
    unSelect: function(name) {
      if (this.get('selectedMode') !== 'single') {
        this.option.selected[name] = false;
      }
    },
    toggleSelected: function(name) {
      var selected = this.option.selected;
      if (!(name in selected)) {
        selected[name] = true;
      }
      this[selected[name] ? 'unSelect' : 'select'](name);
    },
    isSelected: function(name) {
      var selected = this.option.selected;
      return !((name in selected) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;
    },
    defaultOption: {
      zlevel: 0,
      z: 4,
      show: true,
      orient: 'horizontal',
      left: 'center',
      top: 'top',
      align: 'auto',
      backgroundColor: 'rgba(0,0,0,0)',
      borderColor: '#ccc',
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      inactiveColor: '#ccc',
      textStyle: {color: '#333'},
      selectedMode: true,
      tooltip: {show: false}
    }
  });
  module.exports = LegendModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/legend/legendAction.js", ["../../echarts", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../../echarts');
  var zrUtil = $__require('zrender/lib/core/util');
  function legendSelectActionHandler(methodName, payload, ecModel) {
    var selectedMap = {};
    var isToggleSelect = methodName === 'toggleSelected';
    var isSelected;
    ecModel.eachComponent('legend', function(legendModel) {
      if (isToggleSelect && isSelected != null) {
        legendModel[isSelected ? 'select' : 'unSelect'](payload.name);
      } else {
        legendModel[methodName](payload.name);
        isSelected = legendModel.isSelected(payload.name);
      }
      var legendData = legendModel.getData();
      zrUtil.each(legendData, function(model) {
        var name = model.get('name');
        if (name === '\n' || name === '') {
          return;
        }
        var isItemSelected = legendModel.isSelected(name);
        if (name in selectedMap) {
          selectedMap[name] = selectedMap[name] && isItemSelected;
        } else {
          selectedMap[name] = isItemSelected;
        }
      });
    });
    return {
      name: payload.name,
      selected: selectedMap
    };
  }
  echarts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));
  echarts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));
  echarts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/legend/LegendView.js", ["zrender/lib/core/util", "../../util/symbol", "../../util/graphic", "../helper/listComponent", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var symbolCreator = $__require('../../util/symbol');
  var graphic = $__require('../../util/graphic');
  var listComponentHelper = $__require('../helper/listComponent');
  var curry = zrUtil.curry;
  function dispatchSelectAction(name, api) {
    api.dispatchAction({
      type: 'legendToggleSelect',
      name: name
    });
  }
  function dispatchHighlightAction(seriesModel, dataName, api) {
    var el = api.getZr().storage.getDisplayList()[0];
    if (!(el && el.useHoverLayer)) {
      seriesModel.get('legendHoverLink') && api.dispatchAction({
        type: 'highlight',
        seriesName: seriesModel.name,
        name: dataName
      });
    }
  }
  function dispatchDownplayAction(seriesModel, dataName, api) {
    var el = api.getZr().storage.getDisplayList()[0];
    if (!(el && el.useHoverLayer)) {
      seriesModel.get('legendHoverLink') && api.dispatchAction({
        type: 'downplay',
        seriesName: seriesModel.name,
        name: dataName
      });
    }
  }
  module.exports = $__require('../../echarts').extendComponentView({
    type: 'legend',
    init: function() {
      this._symbolTypeStore = {};
    },
    render: function(legendModel, ecModel, api) {
      var group = this.group;
      group.removeAll();
      if (!legendModel.get('show')) {
        return;
      }
      var selectMode = legendModel.get('selectedMode');
      var itemAlign = legendModel.get('align');
      if (itemAlign === 'auto') {
        itemAlign = (legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical') ? 'right' : 'left';
      }
      var legendDrawedMap = {};
      zrUtil.each(legendModel.getData(), function(itemModel) {
        var name = itemModel.get('name');
        if (name === '' || name === '\n') {
          group.add(new graphic.Group({newline: true}));
          return;
        }
        var seriesModel = ecModel.getSeriesByName(name)[0];
        if (legendDrawedMap[name]) {
          return;
        }
        if (seriesModel) {
          var data = seriesModel.getData();
          var color = data.getVisual('color');
          if (typeof color === 'function') {
            color = color(seriesModel.getDataParams(0));
          }
          var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';
          var symbolType = data.getVisual('symbol');
          var itemGroup = this._createItem(name, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);
          itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, '', api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, '', api));
          legendDrawedMap[name] = true;
        } else {
          ecModel.eachRawSeries(function(seriesModel) {
            if (legendDrawedMap[name]) {
              return;
            }
            if (seriesModel.legendDataProvider) {
              var data = seriesModel.legendDataProvider();
              var idx = data.indexOfName(name);
              if (idx < 0) {
                return;
              }
              var color = data.getItemVisual(idx, 'color');
              var legendSymbolType = 'roundRect';
              var itemGroup = this._createItem(name, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode);
              itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));
              legendDrawedMap[name] = true;
            }
          }, this);
        }
        if (__DEV__) {
          if (!legendDrawedMap[name]) {
            console.warn(name + ' series not exists. Legend data should be same with series name or data name.');
          }
        }
      }, this);
      listComponentHelper.layout(group, legendModel, api);
      listComponentHelper.addBackground(group, legendModel);
    },
    _createItem: function(name, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {
      var itemWidth = legendModel.get('itemWidth');
      var itemHeight = legendModel.get('itemHeight');
      var inactiveColor = legendModel.get('inactiveColor');
      var isSelected = legendModel.isSelected(name);
      var itemGroup = new graphic.Group();
      var textStyleModel = itemModel.getModel('textStyle');
      var itemIcon = itemModel.get('icon');
      var tooltipModel = itemModel.getModel('tooltip');
      legendSymbolType = itemIcon || legendSymbolType;
      itemGroup.add(symbolCreator.createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor));
      if (!itemIcon && symbolType && ((symbolType !== legendSymbolType) || symbolType == 'none')) {
        var size = itemHeight * 0.8;
        if (symbolType === 'none') {
          symbolType = 'circle';
        }
        itemGroup.add(symbolCreator.createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor));
      }
      var textX = itemAlign === 'left' ? itemWidth + 5 : -5;
      var textAlign = itemAlign;
      var formatter = legendModel.get('formatter');
      var content = name;
      if (typeof formatter === 'string' && formatter) {
        content = formatter.replace('{name}', name);
      } else if (typeof formatter === 'function') {
        content = formatter(name);
      }
      var text = new graphic.Text({style: {
          text: content,
          x: textX,
          y: itemHeight / 2,
          fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
          textFont: textStyleModel.getFont(),
          textAlign: textAlign,
          textVerticalAlign: 'middle'
        }});
      itemGroup.add(text);
      var hitRect = new graphic.Rect({
        shape: itemGroup.getBoundingRect(),
        invisible: true,
        tooltip: tooltipModel.get('show') ? zrUtil.extend({
          content: name,
          formatter: function() {
            return name;
          },
          formatterParams: {
            componentType: 'legend',
            legendIndex: legendModel.componentIndex,
            name: name,
            $vars: ['name']
          }
        }, tooltipModel.option) : null
      });
      itemGroup.add(hitRect);
      itemGroup.eachChild(function(child) {
        child.silent = true;
      });
      hitRect.silent = !selectMode;
      this.group.add(itemGroup);
      graphic.setHoverStyle(itemGroup);
      return itemGroup;
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/legend/legendFilter.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(ecModel) {
    var legendModels = ecModel.findComponents({mainType: 'legend'});
    if (legendModels && legendModels.length) {
      ecModel.filterSeries(function(series) {
        for (var i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(series.name)) {
            return false;
          }
        }
        return true;
      });
    }
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/legend.js", ["./legend/LegendModel", "./legend/legendAction", "./legend/LegendView", "../echarts", "./legend/legendFilter", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./legend/LegendModel');
  $__require('./legend/legendAction');
  $__require('./legend/LegendView');
  var echarts = $__require('../echarts');
  echarts.registerProcessor($__require('./legend/legendFilter'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/tooltip/TooltipModel.js", ["../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../../echarts').extendComponentModel({
    type: 'tooltip',
    defaultOption: {
      zlevel: 0,
      z: 8,
      show: true,
      showContent: true,
      trigger: 'item',
      triggerOn: 'mousemove',
      alwaysShowContent: false,
      showDelay: 0,
      hideDelay: 100,
      transitionDuration: 0.4,
      enterable: false,
      backgroundColor: 'rgba(50,50,50,0.7)',
      borderColor: '#333',
      borderRadius: 4,
      borderWidth: 0,
      padding: 5,
      extraCssText: '',
      axisPointer: {
        type: 'line',
        axis: 'auto',
        animation: true,
        animationDurationUpdate: 200,
        animationEasingUpdate: 'exponentialOut',
        lineStyle: {
          color: '#555',
          width: 1,
          type: 'solid'
        },
        crossStyle: {
          color: '#555',
          width: 1,
          type: 'dashed',
          textStyle: {}
        },
        shadowStyle: {color: 'rgba(150,150,150,0.3)'}
      },
      textStyle: {
        color: '#fff',
        fontSize: 14
      }
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/tooltip/TooltipContent.js", ["zrender/lib/core/util", "zrender/lib/tool/color", "zrender/lib/core/event", "../../util/format", "zrender/lib/core/env", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var zrColor = $__require('zrender/lib/tool/color');
  var eventUtil = $__require('zrender/lib/core/event');
  var formatUtil = $__require('../../util/format');
  var each = zrUtil.each;
  var toCamelCase = formatUtil.toCamelCase;
  var env = $__require('zrender/lib/core/env');
  var vendors = ['', '-webkit-', '-moz-', '-o-'];
  var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';
  function assembleTransition(duration) {
    var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
    var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;
    return zrUtil.map(vendors, function(vendorPrefix) {
      return vendorPrefix + 'transition:' + transitionText;
    }).join(';');
  }
  function assembleFont(textStyleModel) {
    var cssText = [];
    var fontSize = textStyleModel.get('fontSize');
    var color = textStyleModel.getTextColor();
    color && cssText.push('color:' + color);
    cssText.push('font:' + textStyleModel.getFont());
    fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');
    each(['decoration', 'align'], function(name) {
      var val = textStyleModel.get(name);
      val && cssText.push('text-' + name + ':' + val);
    });
    return cssText.join(';');
  }
  function assembleCssText(tooltipModel) {
    tooltipModel = tooltipModel;
    var cssText = [];
    var transitionDuration = tooltipModel.get('transitionDuration');
    var backgroundColor = tooltipModel.get('backgroundColor');
    var textStyleModel = tooltipModel.getModel('textStyle');
    var padding = tooltipModel.get('padding');
    transitionDuration && cssText.push(assembleTransition(transitionDuration));
    if (backgroundColor) {
      if (env.canvasSupported) {
        cssText.push('background-Color:' + backgroundColor);
      } else {
        cssText.push('background-Color:#' + zrColor.toHex(backgroundColor));
        cssText.push('filter:alpha(opacity=70)');
      }
    }
    each(['width', 'color', 'radius'], function(name) {
      var borderName = 'border-' + name;
      var camelCase = toCamelCase(borderName);
      var val = tooltipModel.get(camelCase);
      val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
    });
    cssText.push(assembleFont(textStyleModel));
    if (padding != null) {
      cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');
    }
    return cssText.join(';') + ';';
  }
  function TooltipContent(container, api) {
    var el = document.createElement('div');
    var zr = api.getZr();
    this.el = el;
    this._x = api.getWidth() / 2;
    this._y = api.getHeight() / 2;
    container.appendChild(el);
    this._container = container;
    this._show = false;
    this._hideTimeout;
    var self = this;
    el.onmouseenter = function() {
      if (self.enterable) {
        clearTimeout(self._hideTimeout);
        self._show = true;
      }
      self._inContent = true;
    };
    el.onmousemove = function(e) {
      if (!self.enterable) {
        var handler = zr.handler;
        eventUtil.normalizeEvent(container, e);
        handler.dispatch('mousemove', e);
      }
    };
    el.onmouseleave = function() {
      if (self.enterable) {
        if (self._show) {
          self.hideLater(self._hideDelay);
        }
      }
      self._inContent = false;
    };
    compromiseMobile(el, container);
  }
  function compromiseMobile(tooltipContentEl, container) {
    eventUtil.addEventListener(container, 'touchstart', preventDefault);
    eventUtil.addEventListener(container, 'touchmove', preventDefault);
    eventUtil.addEventListener(container, 'touchend', preventDefault);
    function preventDefault(e) {
      if (contains(e.target)) {
        e.preventDefault();
      }
    }
    function contains(targetEl) {
      while (targetEl && targetEl !== container) {
        if (targetEl === tooltipContentEl) {
          return true;
        }
        targetEl = targetEl.parentNode;
      }
    }
  }
  TooltipContent.prototype = {
    constructor: TooltipContent,
    enterable: true,
    update: function() {
      var container = this._container;
      var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
      var domStyle = container.style;
      if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
        domStyle.position = 'relative';
      }
    },
    show: function(tooltipModel) {
      clearTimeout(this._hideTimeout);
      var el = this.el;
      el.style.cssText = gCssText + assembleCssText(tooltipModel) + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || '');
      el.style.display = el.innerHTML ? 'block' : 'none';
      this._show = true;
    },
    setContent: function(content) {
      var el = this.el;
      el.innerHTML = content;
      el.style.display = content ? 'block' : 'none';
    },
    moveTo: function(x, y) {
      var style = this.el.style;
      style.left = x + 'px';
      style.top = y + 'px';
      this._x = x;
      this._y = y;
    },
    hide: function() {
      this.el.style.display = 'none';
      this._show = false;
    },
    hideLater: function(time) {
      if (this._show && !(this._inContent && this.enterable)) {
        if (time) {
          this._hideDelay = time;
          this._show = false;
          this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
        } else {
          this.hide();
        }
      }
    },
    isShow: function() {
      return this._show;
    }
  };
  module.exports = TooltipContent;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/tooltip/TooltipView.js", ["./TooltipContent", "../../util/graphic", "zrender/lib/core/util", "../../util/format", "../../util/number", "zrender/lib/core/env", "../../model/Model", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var TooltipContent = $__require('./TooltipContent');
  var graphic = $__require('../../util/graphic');
  var zrUtil = $__require('zrender/lib/core/util');
  var formatUtil = $__require('../../util/format');
  var numberUtil = $__require('../../util/number');
  var parsePercent = numberUtil.parsePercent;
  var env = $__require('zrender/lib/core/env');
  var Model = $__require('../../model/Model');
  function dataEqual(a, b) {
    if (!a || !b) {
      return false;
    }
    var round = numberUtil.round;
    return round(a[0]) === round(b[0]) && round(a[1]) === round(b[1]);
  }
  function makeLineShape(x1, y1, x2, y2) {
    return {
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2
    };
  }
  function makeRectShape(x, y, width, height) {
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  }
  function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
    return {
      cx: cx,
      cy: cy,
      r0: r0,
      r: r,
      startAngle: startAngle,
      endAngle: endAngle,
      clockwise: true
    };
  }
  function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {
    var width = el.clientWidth;
    var height = el.clientHeight;
    var gap = 20;
    if (x + width + gap > viewWidth) {
      x -= width + gap;
    } else {
      x += gap;
    }
    if (y + height + gap > viewHeight) {
      y -= height + gap;
    } else {
      y += gap;
    }
    return [x, y];
  }
  function calcTooltipPosition(position, rect, dom) {
    var domWidth = dom.clientWidth;
    var domHeight = dom.clientHeight;
    var gap = 5;
    var x = 0;
    var y = 0;
    var rectWidth = rect.width;
    var rectHeight = rect.height;
    switch (position) {
      case 'inside':
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y + rectHeight / 2 - domHeight / 2;
        break;
      case 'top':
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y - domHeight - gap;
        break;
      case 'bottom':
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y + rectHeight + gap;
        break;
      case 'left':
        x = rect.x - domWidth - gap;
        y = rect.y + rectHeight / 2 - domHeight / 2;
        break;
      case 'right':
        x = rect.x + rectWidth + gap;
        y = rect.y + rectHeight / 2 - domHeight / 2;
    }
    return [x, y];
  }
  function updatePosition(positionExpr, x, y, content, params, el, api) {
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    var rect = el && el.getBoundingRect().clone();
    el && rect.applyTransform(el.transform);
    if (typeof positionExpr === 'function') {
      positionExpr = positionExpr([x, y], params, content.el, rect);
    }
    if (zrUtil.isArray(positionExpr)) {
      x = parsePercent(positionExpr[0], viewWidth);
      y = parsePercent(positionExpr[1], viewHeight);
    } else if (typeof positionExpr === 'string' && el) {
      var pos = calcTooltipPosition(positionExpr, rect, content.el);
      x = pos[0];
      y = pos[1];
    } else {
      var pos = refixTooltipPosition(x, y, content.el, viewWidth, viewHeight);
      x = pos[0];
      y = pos[1];
    }
    content.moveTo(x, y);
  }
  function ifSeriesSupportAxisTrigger(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var trigger = seriesModel.get('tooltip.trigger', true);
    return !(!coordSys || (coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'singleAxis') || trigger === 'item');
  }
  $__require('../../echarts').extendComponentView({
    type: 'tooltip',
    _axisPointers: {},
    init: function(ecModel, api) {
      if (env.node) {
        return;
      }
      var tooltipContent = new TooltipContent(api.getDom(), api);
      this._tooltipContent = tooltipContent;
      api.on('showTip', this._manuallyShowTip, this);
      api.on('hideTip', this._manuallyHideTip, this);
    },
    render: function(tooltipModel, ecModel, api) {
      if (env.node) {
        return;
      }
      this.group.removeAll();
      this._axisPointers = {};
      this._tooltipModel = tooltipModel;
      this._ecModel = ecModel;
      this._api = api;
      this._lastHover = {};
      var tooltipContent = this._tooltipContent;
      tooltipContent.update();
      tooltipContent.enterable = tooltipModel.get('enterable');
      this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
      this._seriesGroupByAxis = this._prepareAxisTriggerData(tooltipModel, ecModel);
      var crossText = this._crossText;
      if (crossText) {
        this.group.add(crossText);
      }
      if (this._lastX != null && this._lastY != null) {
        var self = this;
        clearTimeout(this._refreshUpdateTimeout);
        this._refreshUpdateTimeout = setTimeout(function() {
          self._manuallyShowTip({
            x: self._lastX,
            y: self._lastY
          });
        });
      }
      var zr = this._api.getZr();
      zr.off('click', this._tryShow);
      zr.off('mousemove', this._mousemove);
      zr.off('mouseout', this._hide);
      zr.off('globalout', this._hide);
      if (tooltipModel.get('triggerOn') === 'click') {
        zr.on('click', this._tryShow, this);
      } else {
        zr.on('mousemove', this._mousemove, this);
        zr.on('mouseout', this._hide, this);
        zr.on('globalout', this._hide, this);
      }
    },
    _mousemove: function(e) {
      var showDelay = this._tooltipModel.get('showDelay');
      var self = this;
      clearTimeout(this._showTimeout);
      if (showDelay > 0) {
        this._showTimeout = setTimeout(function() {
          self._tryShow(e);
        }, showDelay);
      } else {
        this._tryShow(e);
      }
    },
    _manuallyShowTip: function(event) {
      if (event.from === this.uid) {
        return;
      }
      var ecModel = this._ecModel;
      var seriesIndex = event.seriesIndex;
      var dataIndex = event.dataIndex;
      var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
      var api = this._api;
      if (event.x == null || event.y == null) {
        if (!seriesModel) {
          ecModel.eachSeries(function(_series) {
            if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {
              seriesModel = _series;
            }
          });
        }
        if (seriesModel) {
          var data = seriesModel.getData();
          if (dataIndex == null) {
            dataIndex = data.indexOfName(event.name);
          }
          var el = data.getItemGraphicEl(dataIndex);
          var cx,
              cy;
          var coordSys = seriesModel.coordinateSystem;
          if (coordSys && coordSys.dataToPoint) {
            var point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function(dim) {
              return seriesModel.coordDimToDataDim(dim)[0];
            }), dataIndex, true));
            cx = point && point[0];
            cy = point && point[1];
          } else if (el) {
            var rect = el.getBoundingRect().clone();
            rect.applyTransform(el.transform);
            cx = rect.x + rect.width / 2;
            cy = rect.y + rect.height / 2;
          }
          if (cx != null && cy != null) {
            this._tryShow({
              offsetX: cx,
              offsetY: cy,
              target: el,
              event: {}
            });
          }
        }
      } else {
        var el = api.getZr().handler.findHover(event.x, event.y);
        this._tryShow({
          offsetX: event.x,
          offsetY: event.y,
          target: el,
          event: {}
        });
      }
    },
    _manuallyHideTip: function(e) {
      if (e.from === this.uid) {
        return;
      }
      this._hide();
    },
    _prepareAxisTriggerData: function(tooltipModel, ecModel) {
      var seriesGroupByAxis = {};
      ecModel.eachSeries(function(seriesModel) {
        if (ifSeriesSupportAxisTrigger(seriesModel)) {
          var coordSys = seriesModel.coordinateSystem;
          var baseAxis;
          var key;
          if (coordSys.type === 'cartesian2d') {
            baseAxis = coordSys.getBaseAxis();
            key = baseAxis.dim + baseAxis.index;
          } else if (coordSys.type === 'singleAxis') {
            baseAxis = coordSys.getAxis();
            key = baseAxis.dim + baseAxis.type;
          } else {
            baseAxis = coordSys.getBaseAxis();
            key = baseAxis.dim + coordSys.name;
          }
          seriesGroupByAxis[key] = seriesGroupByAxis[key] || {
            coordSys: [],
            series: []
          };
          seriesGroupByAxis[key].coordSys.push(coordSys);
          seriesGroupByAxis[key].series.push(seriesModel);
        }
      }, this);
      return seriesGroupByAxis;
    },
    _tryShow: function(e) {
      var el = e.target;
      var tooltipModel = this._tooltipModel;
      var globalTrigger = tooltipModel.get('trigger');
      var ecModel = this._ecModel;
      var api = this._api;
      if (!tooltipModel) {
        return;
      }
      this._lastX = e.offsetX;
      this._lastY = e.offsetY;
      if (el && el.dataIndex != null) {
        var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
        var dataIndex = el.dataIndex;
        var itemModel = dataModel.getData().getItemModel(dataIndex);
        if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {
          this._showAxisTooltip(tooltipModel, ecModel, e);
        } else {
          this._ticket = '';
          this._hideAxisPointer();
          this._resetLastHover();
          this._showItemTooltipContent(dataModel, dataIndex, el.dataType, e);
        }
        api.dispatchAction({
          type: 'showTip',
          from: this.uid,
          dataIndex: el.dataIndex,
          seriesIndex: el.seriesIndex
        });
      } else if (el && el.tooltip) {
        var tooltipOpt = el.tooltip;
        if (typeof tooltipOpt === 'string') {
          var content = tooltipOpt;
          tooltipOpt = {
            content: content,
            formatter: content
          };
        }
        var subTooltipModel = new Model(tooltipOpt, tooltipModel);
        var defaultHtml = subTooltipModel.get('content');
        var asyncTicket = Math.random();
        this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, el, api);
      } else {
        if (globalTrigger === 'item') {
          this._hide();
        } else {
          this._showAxisTooltip(tooltipModel, ecModel, e);
        }
        if (tooltipModel.get('axisPointer.type') === 'cross') {
          api.dispatchAction({
            type: 'showTip',
            from: this.uid,
            x: e.offsetX,
            y: e.offsetY
          });
        }
      }
    },
    _showAxisTooltip: function(tooltipModel, ecModel, e) {
      var axisPointerModel = tooltipModel.getModel('axisPointer');
      var axisPointerType = axisPointerModel.get('type');
      if (axisPointerType === 'cross') {
        var el = e.target;
        if (el && el.dataIndex != null) {
          var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);
          var dataIndex = el.dataIndex;
          this._showItemTooltipContent(seriesModel, dataIndex, el.dataType, e);
        }
      }
      this._showAxisPointer();
      var allNotShow = true;
      zrUtil.each(this._seriesGroupByAxis, function(seriesCoordSysSameAxis) {
        var allCoordSys = seriesCoordSysSameAxis.coordSys;
        var coordSys = allCoordSys[0];
        var point = [e.offsetX, e.offsetY];
        if (!coordSys.containPoint(point)) {
          this._hideAxisPointer(coordSys.name);
          return;
        }
        allNotShow = false;
        var dimensions = coordSys.dimensions;
        var value = coordSys.pointToData(point, true);
        point = coordSys.dataToPoint(value);
        var baseAxis = coordSys.getBaseAxis();
        var axisType = axisPointerModel.get('axis');
        if (axisType === 'auto') {
          axisType = baseAxis.dim;
        }
        var contentNotChange = false;
        var lastHover = this._lastHover;
        if (axisPointerType === 'cross') {
          if (dataEqual(lastHover.data, value)) {
            contentNotChange = true;
          }
          lastHover.data = value;
        } else {
          var valIndex = zrUtil.indexOf(dimensions, axisType);
          if (lastHover.data === value[valIndex]) {
            contentNotChange = true;
          }
          lastHover.data = value[valIndex];
        }
        if (coordSys.type === 'cartesian2d' && !contentNotChange) {
          this._showCartesianPointer(axisPointerModel, coordSys, axisType, point);
        } else if (coordSys.type === 'polar' && !contentNotChange) {
          this._showPolarPointer(axisPointerModel, coordSys, axisType, point);
        } else if (coordSys.type === 'singleAxis' && !contentNotChange) {
          this._showSinglePointer(axisPointerModel, coordSys, axisType, point);
        }
        if (axisPointerType !== 'cross') {
          this._dispatchAndShowSeriesTooltipContent(coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange);
        }
      }, this);
      if (!this._tooltipModel.get('show')) {
        this._hideAxisPointer();
      }
      if (allNotShow) {
        this._hide();
      }
    },
    _showCartesianPointer: function(axisPointerModel, cartesian, axisType, point) {
      var self = this;
      var axisPointerType = axisPointerModel.get('type');
      var baseAxis = cartesian.getBaseAxis();
      var moveAnimation = axisPointerType !== 'cross' && baseAxis.type === 'category' && baseAxis.getBandWidth() > 20;
      if (axisPointerType === 'cross') {
        moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());
        moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());
        this._updateCrossText(cartesian, point, axisPointerModel);
      } else {
        var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');
        var otherExtent = otherAxis.getGlobalExtent();
        if (cartesian.type === 'cartesian2d') {
          (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(axisType, point, otherExtent);
        }
      }
      function moveGridLine(axisType, point, otherExtent) {
        var targetShape = axisType === 'x' ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1]) : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);
        var pointerEl = self._getPointerElement(cartesian, axisPointerModel, axisType, targetShape);
        graphic.subPixelOptimizeLine({
          shape: targetShape,
          style: pointerEl.style
        });
        moveAnimation ? graphic.updateProps(pointerEl, {shape: targetShape}, axisPointerModel) : pointerEl.attr({shape: targetShape});
      }
      function moveGridShadow(axisType, point, otherExtent) {
        var axis = cartesian.getAxis(axisType);
        var bandWidth = axis.getBandWidth();
        var span = otherExtent[1] - otherExtent[0];
        var targetShape = axisType === 'x' ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span) : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);
        var pointerEl = self._getPointerElement(cartesian, axisPointerModel, axisType, targetShape);
        moveAnimation ? graphic.updateProps(pointerEl, {shape: targetShape}, axisPointerModel) : pointerEl.attr({shape: targetShape});
      }
    },
    _showSinglePointer: function(axisPointerModel, single, axisType, point) {
      var self = this;
      var axisPointerType = axisPointerModel.get('type');
      var moveAnimation = axisPointerType !== 'cross' && single.getBaseAxis().type === 'category';
      var rect = single.getRect();
      var otherExtent = [rect.y, rect.y + rect.height];
      moveSingleLine(axisType, point, otherExtent);
      function moveSingleLine(axisType, point, otherExtent) {
        var axis = single.getAxis();
        var orient = axis.orient;
        var targetShape = orient === 'horizontal' ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1]) : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);
        var pointerEl = self._getPointerElement(single, axisPointerModel, axisType, targetShape);
        moveAnimation ? graphic.updateProps(pointerEl, {shape: targetShape}, axisPointerModel) : pointerEl.attr({shape: targetShape});
      }
    },
    _showPolarPointer: function(axisPointerModel, polar, axisType, point) {
      var self = this;
      var axisPointerType = axisPointerModel.get('type');
      var angleAxis = polar.getAngleAxis();
      var radiusAxis = polar.getRadiusAxis();
      var moveAnimation = axisPointerType !== 'cross' && polar.getBaseAxis().type === 'category';
      if (axisPointerType === 'cross') {
        movePolarLine('angle', point, radiusAxis.getExtent());
        movePolarLine('radius', point, angleAxis.getExtent());
        this._updateCrossText(polar, point, axisPointerModel);
      } else {
        var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');
        var otherExtent = otherAxis.getExtent();
        (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(axisType, point, otherExtent);
      }
      function movePolarLine(axisType, point, otherExtent) {
        var mouseCoord = polar.pointToCoord(point);
        var targetShape;
        if (axisType === 'angle') {
          var p1 = polar.coordToPoint([otherExtent[0], mouseCoord[1]]);
          var p2 = polar.coordToPoint([otherExtent[1], mouseCoord[1]]);
          targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);
        } else {
          targetShape = {
            cx: polar.cx,
            cy: polar.cy,
            r: mouseCoord[0]
          };
        }
        var pointerEl = self._getPointerElement(polar, axisPointerModel, axisType, targetShape);
        moveAnimation ? graphic.updateProps(pointerEl, {shape: targetShape}, axisPointerModel) : pointerEl.attr({shape: targetShape});
      }
      function movePolarShadow(axisType, point, otherExtent) {
        var axis = polar.getAxis(axisType);
        var bandWidth = axis.getBandWidth();
        var mouseCoord = polar.pointToCoord(point);
        var targetShape;
        var radian = Math.PI / 180;
        if (axisType === 'angle') {
          targetShape = makeSectorShape(polar.cx, polar.cy, otherExtent[0], otherExtent[1], (-mouseCoord[1] - bandWidth / 2) * radian, (-mouseCoord[1] + bandWidth / 2) * radian);
        } else {
          targetShape = makeSectorShape(polar.cx, polar.cy, mouseCoord[0] - bandWidth / 2, mouseCoord[0] + bandWidth / 2, 0, Math.PI * 2);
        }
        var pointerEl = self._getPointerElement(polar, axisPointerModel, axisType, targetShape);
        moveAnimation ? graphic.updateProps(pointerEl, {shape: targetShape}, axisPointerModel) : pointerEl.attr({shape: targetShape});
      }
    },
    _updateCrossText: function(coordSys, point, axisPointerModel) {
      var crossStyleModel = axisPointerModel.getModel('crossStyle');
      var textStyleModel = crossStyleModel.getModel('textStyle');
      var tooltipModel = this._tooltipModel;
      var text = this._crossText;
      if (!text) {
        text = this._crossText = new graphic.Text({style: {
            textAlign: 'left',
            textVerticalAlign: 'bottom'
          }});
        this.group.add(text);
      }
      var value = coordSys.pointToData(point);
      var dims = coordSys.dimensions;
      value = zrUtil.map(value, function(val, idx) {
        var axis = coordSys.getAxis(dims[idx]);
        if (axis.type === 'category' || axis.type === 'time') {
          val = axis.scale.getLabel(val);
        } else {
          val = formatUtil.addCommas(val.toFixed(axis.getPixelPrecision()));
        }
        return val;
      });
      text.setStyle({
        fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),
        textFont: textStyleModel.getFont(),
        text: value.join(', '),
        x: point[0] + 5,
        y: point[1] - 5
      });
      text.z = tooltipModel.get('z');
      text.zlevel = tooltipModel.get('zlevel');
    },
    _getPointerElement: function(coordSys, pointerModel, axisType, initShape) {
      var tooltipModel = this._tooltipModel;
      var z = tooltipModel.get('z');
      var zlevel = tooltipModel.get('zlevel');
      var axisPointers = this._axisPointers;
      var coordSysName = coordSys.name;
      axisPointers[coordSysName] = axisPointers[coordSysName] || {};
      if (axisPointers[coordSysName][axisType]) {
        return axisPointers[coordSysName][axisType];
      }
      var pointerType = pointerModel.get('type');
      var styleModel = pointerModel.getModel(pointerType + 'Style');
      var isShadow = pointerType === 'shadow';
      var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();
      var elementType = coordSys.type === 'polar' ? (isShadow ? 'Sector' : (axisType === 'radius' ? 'Circle' : 'Line')) : (isShadow ? 'Rect' : 'Line');
      isShadow ? (style.stroke = null) : (style.fill = null);
      var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({
        style: style,
        z: z,
        zlevel: zlevel,
        silent: true,
        shape: initShape
      });
      this.group.add(el);
      return el;
    },
    _dispatchAndShowSeriesTooltipContent: function(coordSys, seriesList, point, value, contentNotChange) {
      var rootTooltipModel = this._tooltipModel;
      var baseAxis = coordSys.getBaseAxis();
      var baseDimIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;
      var payloadBatch = zrUtil.map(seriesList, function(series) {
        return {
          seriesIndex: series.seriesIndex,
          dataIndex: series.getAxisTooltipDataIndex ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis) : series.getData().indexOfNearest(series.coordDimToDataDim(baseAxis.dim)[0], value[baseDimIndex], false, baseAxis.type === 'category' ? 0.5 : null)
        };
      });
      var lastHover = this._lastHover;
      var api = this._api;
      if (lastHover.payloadBatch && !contentNotChange) {
        api.dispatchAction({
          type: 'downplay',
          batch: lastHover.payloadBatch
        });
      }
      if (!contentNotChange) {
        api.dispatchAction({
          type: 'highlight',
          batch: payloadBatch
        });
        lastHover.payloadBatch = payloadBatch;
      }
      api.dispatchAction({
        type: 'showTip',
        dataIndex: payloadBatch[0].dataIndex,
        seriesIndex: payloadBatch[0].seriesIndex,
        from: this.uid
      });
      if (baseAxis && rootTooltipModel.get('showContent') && rootTooltipModel.get('show')) {
        var paramsList = zrUtil.map(seriesList, function(series, index) {
          return series.getDataParams(payloadBatch[index].dataIndex);
        });
        if (!contentNotChange) {
          var firstDataIndex = payloadBatch[0].dataIndex;
          var firstLine = baseAxis.type === 'time' ? baseAxis.scale.getLabel(value[baseDimIndex]) : seriesList[0].getData().getName(firstDataIndex);
          var defaultHtml = (firstLine ? firstLine + '<br />' : '') + zrUtil.map(seriesList, function(series, index) {
            return series.formatTooltip(payloadBatch[index].dataIndex, true);
          }).join('<br />');
          var asyncTicket = 'axis_' + coordSys.name + '_' + firstDataIndex;
          this._showTooltipContent(rootTooltipModel, defaultHtml, paramsList, asyncTicket, point[0], point[1], null, api);
        } else {
          updatePosition(rootTooltipModel.get('position'), point[0], point[1], this._tooltipContent, paramsList, null, api);
        }
      }
    },
    _showItemTooltipContent: function(seriesModel, dataIndex, dataType, e) {
      var api = this._api;
      var data = seriesModel.getData(dataType);
      var itemModel = data.getItemModel(dataIndex);
      var tooltipOpt = itemModel.get('tooltip', true);
      if (typeof tooltipOpt === 'string') {
        var tooltipContent = tooltipOpt;
        tooltipOpt = {formatter: tooltipContent};
      }
      var rootTooltipModel = this._tooltipModel;
      var seriesTooltipModel = seriesModel.getModel('tooltip', rootTooltipModel);
      var tooltipModel = new Model(tooltipOpt, seriesTooltipModel, seriesTooltipModel.ecModel);
      var params = seriesModel.getDataParams(dataIndex, dataType);
      var defaultHtml = seriesModel.formatTooltip(dataIndex, false, dataType);
      var asyncTicket = 'item_' + seriesModel.name + '_' + dataIndex;
      this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.target, api);
    },
    _showTooltipContent: function(tooltipModel, defaultHtml, params, asyncTicket, x, y, target, api) {
      this._ticket = '';
      if (tooltipModel.get('showContent') && tooltipModel.get('show')) {
        var tooltipContent = this._tooltipContent;
        var formatter = tooltipModel.get('formatter');
        var positionExpr = tooltipModel.get('position');
        var html = defaultHtml;
        if (formatter) {
          if (typeof formatter === 'string') {
            html = formatUtil.formatTpl(formatter, params);
          } else if (typeof formatter === 'function') {
            var self = this;
            var ticket = asyncTicket;
            var callback = function(cbTicket, html) {
              if (cbTicket === self._ticket) {
                tooltipContent.setContent(html);
                updatePosition(positionExpr, x, y, tooltipContent, params, target, api);
              }
            };
            self._ticket = ticket;
            html = formatter(params, ticket, callback);
          }
        }
        tooltipContent.show(tooltipModel);
        tooltipContent.setContent(html);
        updatePosition(positionExpr, x, y, tooltipContent, params, target, api);
      }
    },
    _showAxisPointer: function(coordSysName) {
      if (coordSysName) {
        var axisPointers = this._axisPointers[coordSysName];
        axisPointers && zrUtil.each(axisPointers, function(el) {
          el.show();
        });
      } else {
        this.group.eachChild(function(child) {
          child.show();
        });
        this.group.show();
      }
    },
    _resetLastHover: function() {
      var lastHover = this._lastHover;
      if (lastHover.payloadBatch) {
        this._api.dispatchAction({
          type: 'downplay',
          batch: lastHover.payloadBatch
        });
      }
      this._lastHover = {};
    },
    _hideAxisPointer: function(coordSysName) {
      if (coordSysName) {
        var axisPointers = this._axisPointers[coordSysName];
        axisPointers && zrUtil.each(axisPointers, function(el) {
          el.hide();
        });
      } else {
        if (this.group.children().length) {
          this.group.hide();
        }
      }
    },
    _hide: function() {
      clearTimeout(this._showTimeout);
      this._hideAxisPointer();
      this._resetLastHover();
      if (!this._alwaysShowContent) {
        this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
      }
      this._api.dispatchAction({
        type: 'hideTip',
        from: this.uid
      });
      this._lastX = this._lastY = null;
    },
    dispose: function(ecModel, api) {
      if (env.node) {
        return;
      }
      var zr = api.getZr();
      this._tooltipContent.hide();
      zr.off('click', this._tryShow);
      zr.off('mousemove', this._mousemove);
      zr.off('mouseout', this._hide);
      zr.off('globalout', this._hide);
      api.off('showTip', this._manuallyShowTip);
      api.off('hideTip', this._manuallyHideTip);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/tooltip.js", ["./tooltip/TooltipModel", "./tooltip/TooltipView", "../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./tooltip/TooltipModel');
  $__require('./tooltip/TooltipView');
  $__require('../echarts').registerAction({
    type: 'showTip',
    event: 'showTip',
    update: 'none'
  }, function() {});
  $__require('../echarts').registerAction({
    type: 'hideTip',
    event: 'hideTip',
    update: 'none'
  }, function() {});
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/axis/AngleAxisView.js", ["zrender/lib/core/util", "../../util/graphic", "../../model/Model", "../../echarts", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var Model = $__require('../../model/Model');
  var elementList = ['axisLine', 'axisLabel', 'axisTick', 'splitLine', 'splitArea'];
  function getAxisLineShape(polar, r0, r, angle) {
    var start = polar.coordToPoint([r0, angle]);
    var end = polar.coordToPoint([r, angle]);
    return {
      x1: start[0],
      y1: start[1],
      x2: end[0],
      y2: end[1]
    };
  }
  $__require('../../echarts').extendComponentView({
    type: 'angleAxis',
    render: function(angleAxisModel, ecModel) {
      this.group.removeAll();
      if (!angleAxisModel.get('show')) {
        return;
      }
      var polarModel = ecModel.getComponent('polar', angleAxisModel.get('polarIndex'));
      var angleAxis = angleAxisModel.axis;
      var polar = polarModel.coordinateSystem;
      var radiusExtent = polar.getRadiusAxis().getExtent();
      var ticksAngles = angleAxis.getTicksCoords();
      if (angleAxis.type !== 'category') {
        ticksAngles.pop();
      }
      zrUtil.each(elementList, function(name) {
        if (angleAxisModel.get(name + '.show')) {
          this['_' + name](angleAxisModel, polar, ticksAngles, radiusExtent);
        }
      }, this);
    },
    _axisLine: function(angleAxisModel, polar, ticksAngles, radiusExtent) {
      var lineStyleModel = angleAxisModel.getModel('axisLine.lineStyle');
      var circle = new graphic.Circle({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: radiusExtent[1]
        },
        style: lineStyleModel.getLineStyle(),
        z2: 1,
        silent: true
      });
      circle.style.fill = null;
      this.group.add(circle);
    },
    _axisTick: function(angleAxisModel, polar, ticksAngles, radiusExtent) {
      var tickModel = angleAxisModel.getModel('axisTick');
      var tickLen = (tickModel.get('inside') ? -1 : 1) * tickModel.get('length');
      var lines = zrUtil.map(ticksAngles, function(tickAngle) {
        return new graphic.Line({shape: getAxisLineShape(polar, radiusExtent[1], radiusExtent[1] + tickLen, tickAngle)});
      });
      this.group.add(graphic.mergePath(lines, {style: zrUtil.defaults(tickModel.getModel('lineStyle').getLineStyle(), {stroke: angleAxisModel.get('axisLine.lineStyle.color')})}));
    },
    _axisLabel: function(angleAxisModel, polar, ticksAngles, radiusExtent) {
      var axis = angleAxisModel.axis;
      var categoryData = angleAxisModel.get('data');
      var labelModel = angleAxisModel.getModel('axisLabel');
      var axisTextStyleModel = labelModel.getModel('textStyle');
      var labels = angleAxisModel.getFormattedLabels();
      var labelMargin = labelModel.get('margin');
      var labelsAngles = axis.getLabelsCoords();
      for (var i = 0; i < ticksAngles.length; i++) {
        var r = radiusExtent[1];
        var p = polar.coordToPoint([r + labelMargin, labelsAngles[i]]);
        var cx = polar.cx;
        var cy = polar.cy;
        var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? 'center' : (p[0] > cx ? 'left' : 'right');
        var labelTextBaseline = Math.abs(p[1] - cy) / r < 0.3 ? 'middle' : (p[1] > cy ? 'top' : 'bottom');
        var textStyleModel = axisTextStyleModel;
        if (categoryData && categoryData[i] && categoryData[i].textStyle) {
          textStyleModel = new Model(categoryData[i].textStyle, axisTextStyleModel);
        }
        this.group.add(new graphic.Text({
          style: {
            x: p[0],
            y: p[1],
            fill: textStyleModel.getTextColor() || angleAxisModel.get('axisLine.lineStyle.color'),
            text: labels[i],
            textAlign: labelTextAlign,
            textVerticalAlign: labelTextBaseline,
            textFont: textStyleModel.getFont()
          },
          silent: true
        }));
      }
    },
    _splitLine: function(angleAxisModel, polar, ticksAngles, radiusExtent) {
      var splitLineModel = angleAxisModel.getModel('splitLine');
      var lineStyleModel = splitLineModel.getModel('lineStyle');
      var lineColors = lineStyleModel.get('color');
      var lineCount = 0;
      lineColors = lineColors instanceof Array ? lineColors : [lineColors];
      var splitLines = [];
      for (var i = 0; i < ticksAngles.length; i++) {
        var colorIndex = (lineCount++) % lineColors.length;
        splitLines[colorIndex] = splitLines[colorIndex] || [];
        splitLines[colorIndex].push(new graphic.Line({shape: getAxisLineShape(polar, radiusExtent[0], radiusExtent[1], ticksAngles[i])}));
      }
      for (var i = 0; i < splitLines.length; i++) {
        this.group.add(graphic.mergePath(splitLines[i], {
          style: zrUtil.defaults({stroke: lineColors[i % lineColors.length]}, lineStyleModel.getLineStyle()),
          silent: true,
          z: angleAxisModel.get('z')
        }));
      }
    },
    _splitArea: function(angleAxisModel, polar, ticksAngles, radiusExtent) {
      var splitAreaModel = angleAxisModel.getModel('splitArea');
      var areaStyleModel = splitAreaModel.getModel('areaStyle');
      var areaColors = areaStyleModel.get('color');
      var lineCount = 0;
      areaColors = areaColors instanceof Array ? areaColors : [areaColors];
      var splitAreas = [];
      var RADIAN = Math.PI / 180;
      var prevAngle = -ticksAngles[0] * RADIAN;
      var r0 = Math.min(radiusExtent[0], radiusExtent[1]);
      var r1 = Math.max(radiusExtent[0], radiusExtent[1]);
      var clockwise = angleAxisModel.get('clockwise');
      for (var i = 1; i < ticksAngles.length; i++) {
        var colorIndex = (lineCount++) % areaColors.length;
        splitAreas[colorIndex] = splitAreas[colorIndex] || [];
        splitAreas[colorIndex].push(new graphic.Sector({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r0: r0,
            r: r1,
            startAngle: prevAngle,
            endAngle: -ticksAngles[i] * RADIAN,
            clockwise: clockwise
          },
          silent: true
        }));
        prevAngle = -ticksAngles[i] * RADIAN;
      }
      for (var i = 0; i < splitAreas.length; i++) {
        this.group.add(graphic.mergePath(splitAreas[i], {
          style: zrUtil.defaults({fill: areaColors[i % areaColors.length]}, areaStyleModel.getAreaStyle()),
          silent: true
        }));
      }
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/angleAxis.js", ["../coord/polar/polarCreator", "./axis/AngleAxisView", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../coord/polar/polarCreator');
  $__require('./axis/AngleAxisView');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/polar/RadiusAxis.js", ["zrender/lib/core/util", "../Axis", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Axis = $__require('../Axis');
  function RadiusAxis(scale, radiusExtent) {
    Axis.call(this, 'radius', scale, radiusExtent);
    this.type = 'category';
  }
  RadiusAxis.prototype = {
    constructor: RadiusAxis,
    dataToRadius: Axis.prototype.dataToCoord,
    radiusToData: Axis.prototype.coordToData
  };
  zrUtil.inherits(RadiusAxis, Axis);
  module.exports = RadiusAxis;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/polar/AngleAxis.js", ["zrender/lib/core/util", "../Axis", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Axis = $__require('../Axis');
  function AngleAxis(scale, angleExtent) {
    angleExtent = angleExtent || [0, 360];
    Axis.call(this, 'angle', scale, angleExtent);
    this.type = 'category';
  }
  AngleAxis.prototype = {
    constructor: AngleAxis,
    dataToAngle: Axis.prototype.dataToCoord,
    angleToData: Axis.prototype.coordToData
  };
  zrUtil.inherits(AngleAxis, Axis);
  module.exports = AngleAxis;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/polar/Polar.js", ["./RadiusAxis", "./AngleAxis", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var RadiusAxis = $__require('./RadiusAxis');
  var AngleAxis = $__require('./AngleAxis');
  var Polar = function(name) {
    this.name = name || '';
    this.cx = 0;
    this.cy = 0;
    this._radiusAxis = new RadiusAxis();
    this._angleAxis = new AngleAxis();
  };
  Polar.prototype = {
    constructor: Polar,
    type: 'polar',
    dimensions: ['radius', 'angle'],
    containPoint: function(point) {
      var coord = this.pointToCoord(point);
      return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
    },
    containData: function(data) {
      return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
    },
    getAxis: function(axisType) {
      return this['_' + axisType + 'Axis'];
    },
    getAxesByScale: function(scaleType) {
      var axes = [];
      var angleAxis = this._angleAxis;
      var radiusAxis = this._radiusAxis;
      angleAxis.scale.type === scaleType && axes.push(angleAxis);
      radiusAxis.scale.type === scaleType && axes.push(radiusAxis);
      return axes;
    },
    getAngleAxis: function() {
      return this._angleAxis;
    },
    getRadiusAxis: function() {
      return this._radiusAxis;
    },
    getOtherAxis: function(axis) {
      var angleAxis = this._angleAxis;
      return axis === angleAxis ? this._radiusAxis : angleAxis;
    },
    getBaseAxis: function() {
      return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAngleAxis();
    },
    dataToPoints: function(data) {
      return data.mapArray(this.dimensions, function(radius, angle) {
        return this.dataToPoint([radius, angle]);
      }, this);
    },
    dataToPoint: function(data, clamp) {
      return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp), this._angleAxis.dataToAngle(data[1], clamp)]);
    },
    pointToData: function(point, clamp) {
      var coord = this.pointToCoord(point);
      return [this._radiusAxis.radiusToData(coord[0], clamp), this._angleAxis.angleToData(coord[1], clamp)];
    },
    pointToCoord: function(point) {
      var dx = point[0] - this.cx;
      var dy = point[1] - this.cy;
      var angleAxis = this.getAngleAxis();
      var extent = angleAxis.getExtent();
      var minAngle = Math.min(extent[0], extent[1]);
      var maxAngle = Math.max(extent[0], extent[1]);
      angleAxis.inverse ? (minAngle = maxAngle - 360) : (maxAngle = minAngle + 360);
      var radius = Math.sqrt(dx * dx + dy * dy);
      dx /= radius;
      dy /= radius;
      var radian = Math.atan2(-dy, dx) / Math.PI * 180;
      var dir = radian < minAngle ? 1 : -1;
      while (radian < minAngle || radian > maxAngle) {
        radian += dir * 360;
      }
      return [radius, radian];
    },
    coordToPoint: function(coord) {
      var radius = coord[0];
      var radian = coord[1] / 180 * Math.PI;
      var x = Math.cos(radian) * radius + this.cx;
      var y = -Math.sin(radian) * radius + this.cy;
      return [x, y];
    }
  };
  module.exports = Polar;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/polar/AxisModel.js", ["zrender/lib/core/util", "../../model/Component", "../axisModelCreator", "../axisModelCommonMixin", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var ComponentModel = $__require('../../model/Component');
  var axisModelCreator = $__require('../axisModelCreator');
  var PolarAxisModel = ComponentModel.extend({
    type: 'polarAxis',
    axis: null
  });
  zrUtil.merge(PolarAxisModel.prototype, $__require('../axisModelCommonMixin'));
  var polarAxisDefaultExtendedOption = {
    angle: {
      polarIndex: 0,
      startAngle: 90,
      clockwise: true,
      splitNumber: 12,
      axisLabel: {rotate: false}
    },
    radius: {
      polarIndex: 0,
      splitNumber: 5
    }
  };
  function getAxisType(axisDim, option) {
    return option.type || (option.data ? 'category' : 'value');
  }
  axisModelCreator('angle', PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.angle);
  axisModelCreator('radius', PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.radius);
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/polar/PolarModel.js", ["./AxisModel", "../../echarts", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./AxisModel');
  $__require('../../echarts').extendComponentModel({
    type: 'polar',
    dependencies: ['polarAxis', 'angleAxis'],
    coordinateSystem: null,
    findAxisModel: function(axisType) {
      var angleAxisModel;
      var ecModel = this.ecModel;
      ecModel.eachComponent(axisType, function(axisModel) {
        if (ecModel.getComponent('polar', axisModel.getShallow('polarIndex')) === this) {
          angleAxisModel = axisModel;
        }
      }, this);
      return angleAxisModel;
    },
    defaultOption: {
      zlevel: 0,
      z: 0,
      center: ['50%', '50%'],
      radius: '80%'
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/polar/polarCreator.js", ["./Polar", "../../util/number", "../../coord/axisHelper", "./PolarModel", "../../CoordinateSystem", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var Polar = $__require('./Polar');
  var numberUtil = $__require('../../util/number');
  var axisHelper = $__require('../../coord/axisHelper');
  var niceScaleExtent = axisHelper.niceScaleExtent;
  $__require('./PolarModel');
  function resizePolar(polarModel, api) {
    var center = polarModel.get('center');
    var radius = polarModel.get('radius');
    var width = api.getWidth();
    var height = api.getHeight();
    var parsePercent = numberUtil.parsePercent;
    this.cx = parsePercent(center[0], width);
    this.cy = parsePercent(center[1], height);
    var radiusAxis = this.getRadiusAxis();
    var size = Math.min(width, height) / 2;
    radiusAxis.setExtent(0, parsePercent(radius, size));
  }
  function updatePolarScale(ecModel, api) {
    var polar = this;
    var angleAxis = polar.getAngleAxis();
    var radiusAxis = polar.getRadiusAxis();
    angleAxis.scale.setExtent(Infinity, -Infinity);
    radiusAxis.scale.setExtent(Infinity, -Infinity);
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.coordinateSystem === polar) {
        var data = seriesModel.getData();
        radiusAxis.scale.unionExtent(data.getDataExtent('radius', radiusAxis.type !== 'category'));
        angleAxis.scale.unionExtent(data.getDataExtent('angle', angleAxis.type !== 'category'));
      }
    });
    niceScaleExtent(angleAxis, angleAxis.model);
    niceScaleExtent(radiusAxis, radiusAxis.model);
    if (angleAxis.type === 'category' && !angleAxis.onBand) {
      var extent = angleAxis.getExtent();
      var diff = 360 / angleAxis.scale.count();
      angleAxis.inverse ? (extent[1] += diff) : (extent[1] -= diff);
      angleAxis.setExtent(extent[0], extent[1]);
    }
  }
  function setAxis(axis, axisModel) {
    axis.type = axisModel.get('type');
    axis.scale = axisHelper.createScaleByModel(axisModel);
    axis.onBand = axisModel.get('boundaryGap') && axis.type === 'category';
    if (axisModel.mainType === 'angleAxis') {
      var startAngle = axisModel.get('startAngle');
      axis.inverse = axisModel.get('inverse') ^ axisModel.get('clockwise');
      axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360));
    }
    axisModel.axis = axis;
    axis.model = axisModel;
  }
  var polarCreator = {
    dimensions: Polar.prototype.dimensions,
    create: function(ecModel, api) {
      var polarList = [];
      ecModel.eachComponent('polar', function(polarModel, idx) {
        var polar = new Polar(idx);
        polar.resize = resizePolar;
        polar.update = updatePolarScale;
        var radiusAxis = polar.getRadiusAxis();
        var angleAxis = polar.getAngleAxis();
        var radiusAxisModel = polarModel.findAxisModel('radiusAxis');
        var angleAxisModel = polarModel.findAxisModel('angleAxis');
        setAxis(radiusAxis, radiusAxisModel);
        setAxis(angleAxis, angleAxisModel);
        polar.resize(polarModel, api);
        polarList.push(polar);
        polarModel.coordinateSystem = polar;
      });
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.get('coordinateSystem') === 'polar') {
          seriesModel.coordinateSystem = polarList[seriesModel.get('polarIndex')];
        }
      });
      return polarList;
    }
  };
  $__require('../../CoordinateSystem').register('polar', polarCreator);
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/axis/RadiusAxisView.js", ["zrender/lib/core/util", "../../util/graphic", "./AxisBuilder", "../../echarts", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var AxisBuilder = $__require('./AxisBuilder');
  var axisBuilderAttrs = ['axisLine', 'axisLabel', 'axisTick', 'axisName'];
  var selfBuilderAttrs = ['splitLine', 'splitArea'];
  $__require('../../echarts').extendComponentView({
    type: 'radiusAxis',
    render: function(radiusAxisModel, ecModel) {
      this.group.removeAll();
      if (!radiusAxisModel.get('show')) {
        return;
      }
      var polarModel = ecModel.getComponent('polar', radiusAxisModel.get('polarIndex'));
      var angleAxis = polarModel.coordinateSystem.getAngleAxis();
      var radiusAxis = radiusAxisModel.axis;
      var polar = polarModel.coordinateSystem;
      var ticksCoords = radiusAxis.getTicksCoords();
      var axisAngle = angleAxis.getExtent()[0];
      var radiusExtent = radiusAxis.getExtent();
      var layout = layoutAxis(polar, radiusAxisModel, axisAngle);
      var axisBuilder = new AxisBuilder(radiusAxisModel, layout);
      zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
      this.group.add(axisBuilder.getGroup());
      zrUtil.each(selfBuilderAttrs, function(name) {
        if (radiusAxisModel.get(name + '.show')) {
          this['_' + name](radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords);
        }
      }, this);
    },
    _splitLine: function(radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
      var splitLineModel = radiusAxisModel.getModel('splitLine');
      var lineStyleModel = splitLineModel.getModel('lineStyle');
      var lineColors = lineStyleModel.get('color');
      var lineCount = 0;
      lineColors = lineColors instanceof Array ? lineColors : [lineColors];
      var splitLines = [];
      for (var i = 0; i < ticksCoords.length; i++) {
        var colorIndex = (lineCount++) % lineColors.length;
        splitLines[colorIndex] = splitLines[colorIndex] || [];
        splitLines[colorIndex].push(new graphic.Circle({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: ticksCoords[i]
          },
          silent: true
        }));
      }
      for (var i = 0; i < splitLines.length; i++) {
        this.group.add(graphic.mergePath(splitLines[i], {
          style: zrUtil.defaults({
            stroke: lineColors[i % lineColors.length],
            fill: null
          }, lineStyleModel.getLineStyle()),
          silent: true
        }));
      }
    },
    _splitArea: function(radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
      var splitAreaModel = radiusAxisModel.getModel('splitArea');
      var areaStyleModel = splitAreaModel.getModel('areaStyle');
      var areaColors = areaStyleModel.get('color');
      var lineCount = 0;
      areaColors = areaColors instanceof Array ? areaColors : [areaColors];
      var splitAreas = [];
      var prevRadius = ticksCoords[0];
      for (var i = 1; i < ticksCoords.length; i++) {
        var colorIndex = (lineCount++) % areaColors.length;
        splitAreas[colorIndex] = splitAreas[colorIndex] || [];
        splitAreas[colorIndex].push(new graphic.Sector({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r0: prevRadius,
            r: ticksCoords[i],
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: true
        }));
        prevRadius = ticksCoords[i];
      }
      for (var i = 0; i < splitAreas.length; i++) {
        this.group.add(graphic.mergePath(splitAreas[i], {
          style: zrUtil.defaults({fill: areaColors[i % areaColors.length]}, areaStyleModel.getAreaStyle()),
          silent: true
        }));
      }
    }
  });
  function layoutAxis(polar, radiusAxisModel, axisAngle) {
    return {
      position: [polar.cx, polar.cy],
      rotation: axisAngle / 180 * Math.PI,
      labelDirection: -1,
      tickDirection: -1,
      nameDirection: 1,
      labelRotation: radiusAxisModel.getModel('axisLabel').get('rotate'),
      z2: 1
    };
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/radiusAxis.js", ["../coord/polar/polarCreator", "./axis/RadiusAxisView", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../coord/polar/polarCreator');
  $__require('./axis/RadiusAxisView');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/polar.js", ["../coord/polar/polarCreator", "./angleAxis", "./radiusAxis", "../echarts", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../coord/polar/polarCreator');
  $__require('./angleAxis');
  $__require('./radiusAxis');
  $__require('../echarts').extendComponentView({type: 'polar'});
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/helper/selectableMixin.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  module.exports = {
    updateSelectedMap: function(targetList) {
      this._selectTargetMap = zrUtil.reduce(targetList || [], function(targetMap, target) {
        targetMap[target.name] = target;
        return targetMap;
      }, {});
    },
    select: function(name) {
      var targetMap = this._selectTargetMap;
      var target = targetMap[name];
      var selectedMode = this.get('selectedMode');
      if (selectedMode === 'single') {
        zrUtil.each(targetMap, function(target) {
          target.selected = false;
        });
      }
      target && (target.selected = true);
    },
    unSelect: function(name) {
      var target = this._selectTargetMap[name];
      target && (target.selected = false);
    },
    toggleSelected: function(name) {
      var target = this._selectTargetMap[name];
      if (target != null) {
        this[target.selected ? 'unSelect' : 'select'](name);
        return target.selected;
      }
    },
    isSelected: function(name) {
      var target = this._selectTargetMap[name];
      return target && target.selected;
    }
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/geo/GeoModel.js", ["../../util/model", "../../model/Component", "../../model/Model", "zrender/lib/core/util", "../../component/helper/selectableMixin", "./geoCreator", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var modelUtil = $__require('../../util/model');
  var ComponentModel = $__require('../../model/Component');
  var Model = $__require('../../model/Model');
  var zrUtil = $__require('zrender/lib/core/util');
  var selectableMixin = $__require('../../component/helper/selectableMixin');
  var geoCreator = $__require('./geoCreator');
  var GeoModel = ComponentModel.extend({
    type: 'geo',
    coordinateSystem: null,
    layoutMode: 'box',
    init: function(option) {
      ComponentModel.prototype.init.apply(this, arguments);
      modelUtil.defaultEmphasis(option.label, ['position', 'show', 'textStyle', 'distance', 'formatter']);
    },
    optionUpdated: function() {
      var option = this.option;
      var self = this;
      option.regions = geoCreator.getFilledRegions(option.regions, option.map);
      this._optionModelMap = zrUtil.reduce(option.regions || [], function(obj, regionOpt) {
        if (regionOpt.name) {
          obj[regionOpt.name] = new Model(regionOpt, self);
        }
        return obj;
      }, {});
      this.updateSelectedMap(option.regions);
    },
    defaultOption: {
      zlevel: 0,
      z: 0,
      show: true,
      left: 'center',
      top: 'center',
      aspectScale: 0.75,
      silent: false,
      map: '',
      center: null,
      zoom: 1,
      scaleLimit: null,
      label: {
        normal: {
          show: false,
          textStyle: {color: '#000'}
        },
        emphasis: {
          show: true,
          textStyle: {color: 'rgb(100,0,0)'}
        }
      },
      itemStyle: {
        normal: {
          borderWidth: 0.5,
          borderColor: '#444',
          color: '#eee'
        },
        emphasis: {color: 'rgba(255,215,0,0.8)'}
      },
      regions: []
    },
    getRegionModel: function(name) {
      return this._optionModelMap[name];
    },
    getFormattedLabel: function(name, status) {
      var formatter = this.get('label.' + status + '.formatter');
      var params = {name: name};
      if (typeof formatter === 'function') {
        params.status = status;
        return formatter(params);
      } else if (typeof formatter === 'string') {
        return formatter.replace('{a}', params.seriesName);
      }
    },
    setZoom: function(zoom) {
      this.option.zoom = zoom;
    },
    setCenter: function(center) {
      this.option.center = center;
    }
  });
  zrUtil.mixin(GeoModel, selectableMixin);
  module.exports = GeoModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/geo/parseGeoJson.js", ["zrender/lib/core/util", "./Region", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Region = $__require('./Region');
  function decode(json) {
    if (!json.UTF8Encoding) {
      return json;
    }
    var features = json.features;
    for (var f = 0; f < features.length; f++) {
      var feature = features[f];
      var geometry = feature.geometry;
      var coordinates = geometry.coordinates;
      var encodeOffsets = geometry.encodeOffsets;
      for (var c = 0; c < coordinates.length; c++) {
        var coordinate = coordinates[c];
        if (geometry.type === 'Polygon') {
          coordinates[c] = decodePolygon(coordinate, encodeOffsets[c]);
        } else if (geometry.type === 'MultiPolygon') {
          for (var c2 = 0; c2 < coordinate.length; c2++) {
            var polygon = coordinate[c2];
            coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2]);
          }
        }
      }
    }
    json.UTF8Encoding = false;
    return json;
  }
  function decodePolygon(coordinate, encodeOffsets) {
    var result = [];
    var prevX = encodeOffsets[0];
    var prevY = encodeOffsets[1];
    for (var i = 0; i < coordinate.length; i += 2) {
      var x = coordinate.charCodeAt(i) - 64;
      var y = coordinate.charCodeAt(i + 1) - 64;
      x = (x >> 1) ^ (-(x & 1));
      y = (y >> 1) ^ (-(y & 1));
      x += prevX;
      y += prevY;
      prevX = x;
      prevY = y;
      result.push([x / 1024, y / 1024]);
    }
    return result;
  }
  function flattern2D(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      for (var k = 0; k < array[i].length; k++) {
        ret.push(array[i][k]);
      }
    }
    return ret;
  }
  module.exports = function(geoJson) {
    decode(geoJson);
    return zrUtil.map(zrUtil.filter(geoJson.features, function(featureObj) {
      return featureObj.geometry && featureObj.properties;
    }), function(featureObj) {
      var properties = featureObj.properties;
      var geometry = featureObj.geometry;
      var coordinates = geometry.coordinates;
      if (geometry.type === 'MultiPolygon') {
        coordinates = flattern2D(coordinates);
      }
      return new Region(properties.name, coordinates, properties.cp);
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/View.js", ["zrender/lib/core/vector", "zrender/lib/core/matrix", "zrender/lib/mixin/Transformable", "zrender/lib/core/util", "zrender/lib/core/BoundingRect", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var vector = $__require('zrender/lib/core/vector');
  var matrix = $__require('zrender/lib/core/matrix');
  var Transformable = $__require('zrender/lib/mixin/Transformable');
  var zrUtil = $__require('zrender/lib/core/util');
  var BoundingRect = $__require('zrender/lib/core/BoundingRect');
  var v2ApplyTransform = vector.applyTransform;
  function TransformDummy() {
    Transformable.call(this);
  }
  zrUtil.mixin(TransformDummy, Transformable);
  function View(name) {
    this.name = name;
    this.zoomLimit;
    Transformable.call(this);
    this._roamTransform = new TransformDummy();
    this._viewTransform = new TransformDummy();
    this._center;
    this._zoom;
  }
  View.prototype = {
    constructor: View,
    type: 'view',
    dimensions: ['x', 'y'],
    setBoundingRect: function(x, y, width, height) {
      this._rect = new BoundingRect(x, y, width, height);
      return this._rect;
    },
    getBoundingRect: function() {
      return this._rect;
    },
    setViewRect: function(x, y, width, height) {
      width = width;
      height = height;
      this.transformTo(x, y, width, height);
      this._viewRect = new BoundingRect(x, y, width, height);
    },
    transformTo: function(x, y, width, height) {
      var rect = this.getBoundingRect();
      var viewTransform = this._viewTransform;
      viewTransform.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));
      viewTransform.decomposeTransform();
      this._updateTransform();
    },
    setCenter: function(centerCoord) {
      if (!centerCoord) {
        return;
      }
      this._center = centerCoord;
      this._updateCenterAndZoom();
    },
    setZoom: function(zoom) {
      zoom = zoom || 1;
      var zoomLimit = this.zoomLimit;
      if (zoomLimit) {
        if (zoomLimit.max != null) {
          zoom = Math.min(zoomLimit.max, zoom);
        }
        if (zoomLimit.min != null) {
          zoom = Math.max(zoomLimit.min, zoom);
        }
      }
      this._zoom = zoom;
      this._updateCenterAndZoom();
    },
    getDefaultCenter: function() {
      var rawRect = this.getBoundingRect();
      var cx = rawRect.x + rawRect.width / 2;
      var cy = rawRect.y + rawRect.height / 2;
      return [cx, cy];
    },
    getCenter: function() {
      return this._center || this.getDefaultCenter();
    },
    getZoom: function() {
      return this._zoom || 1;
    },
    getRoamTransform: function() {
      return this._roamTransform;
    },
    _updateCenterAndZoom: function() {
      var viewTransformMatrix = this._viewTransform.getLocalTransform();
      var roamTransform = this._roamTransform;
      var defaultCenter = this.getDefaultCenter();
      var center = this.getCenter();
      var zoom = this.getZoom();
      center = vector.applyTransform([], center, viewTransformMatrix);
      defaultCenter = vector.applyTransform([], defaultCenter, viewTransformMatrix);
      roamTransform.origin = center;
      roamTransform.position = [defaultCenter[0] - center[0], defaultCenter[1] - center[1]];
      roamTransform.scale = [zoom, zoom];
      this._updateTransform();
    },
    _updateTransform: function() {
      var roamTransform = this._roamTransform;
      var viewTransform = this._viewTransform;
      viewTransform.parent = roamTransform;
      roamTransform.updateTransform();
      viewTransform.updateTransform();
      viewTransform.transform && matrix.copy(this.transform || (this.transform = []), viewTransform.transform);
      if (this.transform) {
        this.invTransform = this.invTransform || [];
        matrix.invert(this.invTransform, this.transform);
      } else {
        this.invTransform = null;
      }
      this.decomposeTransform();
    },
    getViewRect: function() {
      return this._viewRect;
    },
    getViewRectAfterRoam: function() {
      var rect = this.getBoundingRect().clone();
      rect.applyTransform(this.transform);
      return rect;
    },
    dataToPoint: function(data) {
      var transform = this.transform;
      return transform ? v2ApplyTransform([], data, transform) : [data[0], data[1]];
    },
    pointToData: function(point) {
      var invTransform = this.invTransform;
      return invTransform ? v2ApplyTransform([], point, invTransform) : [point[0], point[1]];
    }
  };
  zrUtil.mixin(View, Transformable);
  module.exports = View;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/geo/Region.js", ["zrender/lib/contain/polygon", "zrender/lib/core/BoundingRect", "zrender/lib/core/bbox", "zrender/lib/core/vector", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var polygonContain = $__require('zrender/lib/contain/polygon');
  var BoundingRect = $__require('zrender/lib/core/BoundingRect');
  var bbox = $__require('zrender/lib/core/bbox');
  var vec2 = $__require('zrender/lib/core/vector');
  function Region(name, contours, cp) {
    this.name = name;
    this.contours = contours;
    if (!cp) {
      var rect = this.getBoundingRect();
      cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    } else {
      cp = [cp[0], cp[1]];
    }
    this.center = cp;
  }
  Region.prototype = {
    constructor: Region,
    getBoundingRect: function() {
      var rect = this._rect;
      if (rect) {
        return rect;
      }
      var MAX_NUMBER = Number.MAX_VALUE;
      var min = [MAX_NUMBER, MAX_NUMBER];
      var max = [-MAX_NUMBER, -MAX_NUMBER];
      var min2 = [];
      var max2 = [];
      var contours = this.contours;
      for (var i = 0; i < contours.length; i++) {
        bbox.fromPoints(contours[i], min2, max2);
        vec2.min(min, min, min2);
        vec2.max(max, max, max2);
      }
      if (i === 0) {
        min[0] = min[1] = max[0] = max[1] = 0;
      }
      return (this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]));
    },
    contain: function(coord) {
      var rect = this.getBoundingRect();
      var contours = this.contours;
      if (rect.contain(coord[0], coord[1])) {
        for (var i = 0,
            len = contours.length; i < len; i++) {
          if (polygonContain.contain(contours[i], coord[0], coord[1])) {
            return true;
          }
        }
      }
      return false;
    },
    transformTo: function(x, y, width, height) {
      var rect = this.getBoundingRect();
      var aspect = rect.width / rect.height;
      if (!width) {
        width = aspect * height;
      } else if (!height) {
        height = width / aspect;
      }
      var target = new BoundingRect(x, y, width, height);
      var transform = rect.calculateTransform(target);
      var contours = this.contours;
      for (var i = 0; i < contours.length; i++) {
        for (var p = 0; p < contours[i].length; p++) {
          vec2.applyTransform(contours[i][p], contours[i][p], transform);
        }
      }
      rect = this._rect;
      rect.copy(target);
      this.center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    }
  };
  module.exports = Region;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/geo/fix/nanhai.js", ["../Region", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var Region = $__require('../Region');
  var geoCoord = [126, 25];
  var points = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
  for (var i = 0; i < points.length; i++) {
    for (var k = 0; k < points[i].length; k++) {
      points[i][k][0] /= 10.5;
      points[i][k][1] /= -10.5 / 0.75;
      points[i][k][0] += geoCoord[0];
      points[i][k][1] += geoCoord[1];
    }
  }
  module.exports = function(geo) {
    if (geo.map === 'china') {
      geo.regions.push(new Region('', points, geoCoord));
    }
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/geo/fix/textCoord.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var coordsOffsetMap = {
    '': [32, 80],
    '': [0, -10],
    '': [10, 5],
    '': [-10, 10],
    '': [5, 5]
  };
  module.exports = function(geo) {
    zrUtil.each(geo.regions, function(region) {
      var coordFix = coordsOffsetMap[region.name];
      if (coordFix) {
        var cp = region.center;
        cp[0] += coordFix[0] / 10.5;
        cp[1] += -coordFix[1] / (10.5 / 0.75);
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/geo/fix/geoCoord.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var geoCoordMap = {
    'Russia': [100, 60],
    'United States of America': [-99, 38]
  };
  module.exports = function(geo) {
    zrUtil.each(geo.regions, function(region) {
      var geoCoord = geoCoordMap[region.name];
      if (geoCoord) {
        var cp = region.center;
        cp[0] = geoCoord[0];
        cp[1] = geoCoord[1];
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/geo/Geo.js", ["./parseGeoJson", "zrender/lib/core/util", "zrender/lib/core/BoundingRect", "../View", "./fix/nanhai", "./fix/textCoord", "./fix/geoCoord", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var parseGeoJson = $__require('./parseGeoJson');
  var zrUtil = $__require('zrender/lib/core/util');
  var BoundingRect = $__require('zrender/lib/core/BoundingRect');
  var View = $__require('../View');
  var geoFixFuncs = [$__require('./fix/nanhai'), $__require('./fix/textCoord'), $__require('./fix/geoCoord')];
  function Geo(name, map, geoJson, specialAreas, nameMap) {
    View.call(this, name);
    this.map = map;
    this._nameCoordMap = {};
    this.loadGeoJson(geoJson, specialAreas, nameMap);
  }
  Geo.prototype = {
    constructor: Geo,
    type: 'geo',
    dimensions: ['lng', 'lat'],
    containCoord: function(coord) {
      var regions = this.regions;
      for (var i = 0; i < regions.length; i++) {
        if (regions[i].contain(coord)) {
          return true;
        }
      }
      return false;
    },
    loadGeoJson: function(geoJson, specialAreas, nameMap) {
      try {
        this.regions = geoJson ? parseGeoJson(geoJson) : [];
      } catch (e) {
        throw 'Invalid geoJson format\n' + e;
      }
      specialAreas = specialAreas || {};
      nameMap = nameMap || {};
      var regions = this.regions;
      var regionsMap = {};
      for (var i = 0; i < regions.length; i++) {
        var regionName = regions[i].name;
        regionName = nameMap[regionName] || regionName;
        regions[i].name = regionName;
        regionsMap[regionName] = regions[i];
        this.addGeoCoord(regionName, regions[i].center);
        var specialArea = specialAreas[regionName];
        if (specialArea) {
          regions[i].transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
        }
      }
      this._regionsMap = regionsMap;
      this._rect = null;
      zrUtil.each(geoFixFuncs, function(fixFunc) {
        fixFunc(this);
      }, this);
    },
    transformTo: function(x, y, width, height) {
      var rect = this.getBoundingRect();
      rect = rect.clone();
      rect.y = -rect.y - rect.height;
      var viewTransform = this._viewTransform;
      viewTransform.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));
      viewTransform.decomposeTransform();
      var scale = viewTransform.scale;
      scale[1] = -scale[1];
      viewTransform.updateTransform();
      this._updateTransform();
    },
    getRegion: function(name) {
      return this._regionsMap[name];
    },
    getRegionByCoord: function(coord) {
      var regions = this.regions;
      for (var i = 0; i < regions.length; i++) {
        if (regions[i].contain(coord)) {
          return regions[i];
        }
      }
    },
    addGeoCoord: function(name, geoCoord) {
      this._nameCoordMap[name] = geoCoord;
    },
    getGeoCoord: function(name) {
      return this._nameCoordMap[name];
    },
    getBoundingRect: function() {
      if (this._rect) {
        return this._rect;
      }
      var rect;
      var regions = this.regions;
      for (var i = 0; i < regions.length; i++) {
        var regionRect = regions[i].getBoundingRect();
        rect = rect || regionRect.clone();
        rect.union(regionRect);
      }
      return (this._rect = rect || new BoundingRect(0, 0, 0, 0));
    },
    dataToPoints: function(data) {
      var item = [];
      return data.mapArray(['lng', 'lat'], function(lon, lat) {
        item[0] = lon;
        item[1] = lat;
        return this.dataToPoint(item);
      }, this);
    },
    dataToPoint: function(data) {
      if (typeof data === 'string') {
        data = this.getGeoCoord(data);
      }
      if (data) {
        return View.prototype.dataToPoint.call(this, data);
      }
    }
  };
  zrUtil.mixin(Geo, View);
  module.exports = Geo;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/geo/geoCreator.js", ["./Geo", "../../util/layout", "zrender/lib/core/util", "../../util/number", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var Geo = $__require('./Geo');
  var layout = $__require('../../util/layout');
  var zrUtil = $__require('zrender/lib/core/util');
  var numberUtil = $__require('../../util/number');
  var mapDataStores = {};
  function resizeGeo(geoModel, api) {
    var rect = this.getBoundingRect();
    var boxLayoutOption;
    var center = geoModel.get('layoutCenter');
    var size = geoModel.get('layoutSize');
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    var aspectScale = geoModel.get('aspectScale') || 0.75;
    var aspect = rect.width / rect.height * aspectScale;
    var useCenterAndSize = false;
    if (center && size) {
      center = [numberUtil.parsePercent(center[0], viewWidth), numberUtil.parsePercent(center[1], viewHeight)];
      size = numberUtil.parsePercent(size, Math.min(viewWidth, viewHeight));
      if (!isNaN(center[0]) && !isNaN(center[1]) && !isNaN(size)) {
        useCenterAndSize = true;
      } else {
        if (__DEV__) {
          console.warn('Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.');
        }
      }
    }
    var viewRect;
    if (useCenterAndSize) {
      var viewRect = {};
      if (aspect > 1) {
        viewRect.width = size;
        viewRect.height = size / aspect;
      } else {
        viewRect.height = size;
        viewRect.width = size * aspect;
      }
      viewRect.y = center[1] - viewRect.height / 2;
      viewRect.x = center[0] - viewRect.width / 2;
    } else {
      boxLayoutOption = geoModel.getBoxLayoutParams();
      boxLayoutOption.aspect = aspect;
      viewRect = layout.getLayoutRect(boxLayoutOption, {
        width: viewWidth,
        height: viewHeight
      });
    }
    this.setViewRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
    this.setCenter(geoModel.get('center'));
    this.setZoom(geoModel.get('zoom'));
  }
  function setGeoCoords(geo, model) {
    zrUtil.each(model.get('geoCoord'), function(geoCoord, name) {
      geo.addGeoCoord(name, geoCoord);
    });
  }
  if (__DEV__) {
    var mapNotExistsError = function(name) {
      console.error('Map ' + name + ' not exists. You can download map file on http://echarts.baidu.com/download-map.html');
    };
  }
  var geoCreator = {
    dimensions: Geo.prototype.dimensions,
    create: function(ecModel, api) {
      var geoList = [];
      ecModel.eachComponent('geo', function(geoModel, idx) {
        var name = geoModel.get('map');
        var mapData = mapDataStores[name];
        if (__DEV__) {
          if (!mapData) {
            mapNotExistsError(name);
          }
        }
        var geo = new Geo(name + idx, name, mapData && mapData.geoJson, mapData && mapData.specialAreas, geoModel.get('nameMap'));
        geo.zoomLimit = geoModel.get('scaleLimit');
        geoList.push(geo);
        setGeoCoords(geo, geoModel);
        geoModel.coordinateSystem = geo;
        geo.model = geoModel;
        geo.resize = resizeGeo;
        geo.resize(geoModel, api);
      });
      ecModel.eachSeries(function(seriesModel) {
        var coordSys = seriesModel.get('coordinateSystem');
        if (coordSys === 'geo') {
          var geoIndex = seriesModel.get('geoIndex') || 0;
          seriesModel.coordinateSystem = geoList[geoIndex];
        }
      });
      var mapModelGroupBySeries = {};
      ecModel.eachSeriesByType('map', function(seriesModel) {
        var mapType = seriesModel.get('map');
        mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
        mapModelGroupBySeries[mapType].push(seriesModel);
      });
      zrUtil.each(mapModelGroupBySeries, function(mapSeries, mapType) {
        var mapData = mapDataStores[mapType];
        if (__DEV__) {
          if (!mapData) {
            mapNotExistsError(mapSeries[0].get('map'));
          }
        }
        var nameMapList = zrUtil.map(mapSeries, function(singleMapSeries) {
          return singleMapSeries.get('nameMap');
        });
        var geo = new Geo(mapType, mapType, mapData && mapData.geoJson, mapData && mapData.specialAreas, zrUtil.mergeAll(nameMapList));
        geo.zoomLimit = zrUtil.retrieve.apply(null, zrUtil.map(mapSeries, function(singleMapSeries) {
          return singleMapSeries.get('scaleLimit');
        }));
        geoList.push(geo);
        geo.resize = resizeGeo;
        geo.resize(mapSeries[0], api);
        zrUtil.each(mapSeries, function(singleMapSeries) {
          singleMapSeries.coordinateSystem = geo;
          setGeoCoords(geo, singleMapSeries);
        });
      });
      return geoList;
    },
    registerMap: function(mapName, geoJson, specialAreas) {
      if (geoJson.geoJson && !geoJson.features) {
        specialAreas = geoJson.specialAreas;
        geoJson = geoJson.geoJson;
      }
      if (typeof geoJson === 'string') {
        geoJson = (typeof JSON !== 'undefined' && JSON.parse) ? JSON.parse(geoJson) : (new Function('return (' + geoJson + ');'))();
      }
      mapDataStores[mapName] = {
        geoJson: geoJson,
        specialAreas: specialAreas
      };
    },
    getMap: function(mapName) {
      return mapDataStores[mapName];
    },
    getFilledRegions: function(originRegionArr, mapName) {
      var regionsArr = (originRegionArr || []).slice();
      var map = geoCreator.getMap(mapName);
      var geoJson = map && map.geoJson;
      if (!geoJson) {
        if (__DEV__) {
          mapNotExistsError(mapName);
        }
        return originRegionArr;
      }
      var dataNameMap = {};
      var features = geoJson.features;
      for (var i = 0; i < regionsArr.length; i++) {
        dataNameMap[regionsArr[i].name] = regionsArr[i];
      }
      for (var i = 0; i < features.length; i++) {
        var name = features[i].properties.name;
        if (!dataNameMap[name]) {
          regionsArr.push({name: name});
        }
      }
      return regionsArr;
    }
  };
  var echarts = $__require('../../echarts');
  echarts.registerMap = geoCreator.registerMap;
  echarts.getMap = geoCreator.getMap;
  echarts.loadMap = function() {};
  echarts.registerCoordinateSystem('geo', geoCreator);
  module.exports = geoCreator;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/helper/MapDraw.js", ["./RoamController", "../../util/graphic", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var RoamController = $__require('./RoamController');
  var graphic = $__require('../../util/graphic');
  var zrUtil = $__require('zrender/lib/core/util');
  function getFixedItemStyle(model, scale) {
    var itemStyle = model.getItemStyle();
    var areaColor = model.get('areaColor');
    if (areaColor) {
      itemStyle.fill = areaColor;
    }
    return itemStyle;
  }
  function updateMapSelectHandler(mapOrGeoModel, group, api, fromView) {
    group.off('click');
    mapOrGeoModel.get('selectedMode') && group.on('click', function(e) {
      var el = e.target;
      while (!el.__region) {
        el = el.parent;
      }
      if (!el) {
        return;
      }
      var region = el.__region;
      var action = {
        type: (mapOrGeoModel.mainType === 'geo' ? 'geo' : 'map') + 'ToggleSelect',
        name: region.name,
        from: fromView.uid
      };
      action[mapOrGeoModel.mainType + 'Id'] = mapOrGeoModel.id;
      api.dispatchAction(action);
      updateMapSelected(mapOrGeoModel, group);
    });
  }
  function updateMapSelected(mapOrGeoModel, group) {
    group.eachChild(function(otherRegionEl) {
      if (otherRegionEl.__region) {
        otherRegionEl.trigger(mapOrGeoModel.isSelected(otherRegionEl.__region.name) ? 'emphasis' : 'normal');
      }
    });
  }
  function MapDraw(api, updateGroup) {
    var group = new graphic.Group();
    this._controller = new RoamController(api.getZr(), updateGroup ? group : null, null);
    this.group = group;
    this._updateGroup = updateGroup;
  }
  MapDraw.prototype = {
    constructor: MapDraw,
    draw: function(mapOrGeoModel, ecModel, api, fromView, payload) {
      var data = mapOrGeoModel.getData && mapOrGeoModel.getData();
      var geo = mapOrGeoModel.coordinateSystem;
      var group = this.group;
      var scale = geo.scale;
      var groupNewProp = {
        position: geo.position,
        scale: scale
      };
      if (!group.childAt(0) || payload) {
        group.attr(groupNewProp);
      } else {
        graphic.updateProps(group, groupNewProp, mapOrGeoModel);
      }
      group.removeAll();
      var itemStyleAccessPath = ['itemStyle', 'normal'];
      var hoverItemStyleAccessPath = ['itemStyle', 'emphasis'];
      var labelAccessPath = ['label', 'normal'];
      var hoverLabelAccessPath = ['label', 'emphasis'];
      zrUtil.each(geo.regions, function(region) {
        var regionGroup = new graphic.Group();
        var compoundPath = new graphic.CompoundPath({shape: {paths: []}});
        regionGroup.add(compoundPath);
        var regionModel = mapOrGeoModel.getRegionModel(region.name) || mapOrGeoModel;
        var itemStyleModel = regionModel.getModel(itemStyleAccessPath);
        var hoverItemStyleModel = regionModel.getModel(hoverItemStyleAccessPath);
        var itemStyle = getFixedItemStyle(itemStyleModel, scale);
        var hoverItemStyle = getFixedItemStyle(hoverItemStyleModel, scale);
        var labelModel = regionModel.getModel(labelAccessPath);
        var hoverLabelModel = regionModel.getModel(hoverLabelAccessPath);
        var dataIdx;
        if (data) {
          dataIdx = data.indexOfName(region.name);
          var visualColor = data.getItemVisual(dataIdx, 'color', true);
          if (visualColor) {
            itemStyle.fill = visualColor;
          }
        }
        var textStyleModel = labelModel.getModel('textStyle');
        var hoverTextStyleModel = hoverLabelModel.getModel('textStyle');
        zrUtil.each(region.contours, function(contour) {
          var polygon = new graphic.Polygon({shape: {points: contour}});
          compoundPath.shape.paths.push(polygon);
        });
        compoundPath.setStyle(itemStyle);
        compoundPath.style.strokeNoScale = true;
        compoundPath.culling = true;
        var showLabel = labelModel.get('show');
        var hoverShowLabel = hoverLabelModel.get('show');
        var isDataNaN = data && isNaN(data.get('value', dataIdx));
        var itemLayout = data && data.getItemLayout(dataIdx);
        if ((!data || isDataNaN && (showLabel || hoverShowLabel)) || (itemLayout && itemLayout.showLabel)) {
          var query = data ? dataIdx : region.name;
          var formattedStr = mapOrGeoModel.getFormattedLabel(query, 'normal');
          var hoverFormattedStr = mapOrGeoModel.getFormattedLabel(query, 'emphasis');
          var text = new graphic.Text({
            style: {
              text: showLabel ? (formattedStr || region.name) : '',
              fill: textStyleModel.getTextColor(),
              textFont: textStyleModel.getFont(),
              textAlign: 'center',
              textVerticalAlign: 'middle'
            },
            hoverStyle: {
              text: hoverShowLabel ? (hoverFormattedStr || region.name) : '',
              fill: hoverTextStyleModel.getTextColor(),
              textFont: hoverTextStyleModel.getFont()
            },
            position: region.center.slice(),
            scale: [1 / scale[0], 1 / scale[1]],
            z2: 10,
            silent: true
          });
          regionGroup.add(text);
        }
        if (data) {
          data.setItemGraphicEl(dataIdx, regionGroup);
        } else {
          var regionModel = mapOrGeoModel.getRegionModel(region.name);
          compoundPath.eventData = {
            componentType: 'geo',
            geoIndex: mapOrGeoModel.componentIndex,
            name: region.name,
            region: (regionModel && regionModel.option) || {}
          };
        }
        regionGroup.__region = region;
        graphic.setHoverStyle(regionGroup, hoverItemStyle);
        group.add(regionGroup);
      });
      this._updateController(mapOrGeoModel, ecModel, api);
      updateMapSelectHandler(mapOrGeoModel, group, api, fromView);
      updateMapSelected(mapOrGeoModel, group);
    },
    remove: function() {
      this.group.removeAll();
      this._controller.dispose();
    },
    _updateController: function(mapOrGeoModel, ecModel, api) {
      var geo = mapOrGeoModel.coordinateSystem;
      var controller = this._controller;
      controller.zoomLimit = mapOrGeoModel.get('scaleLimit');
      controller.zoom = geo.getZoom();
      controller.enable(mapOrGeoModel.get('roam') || false);
      var mainType = mapOrGeoModel.mainType;
      function makeActionBase() {
        var action = {
          type: 'geoRoam',
          componentType: mainType
        };
        action[mainType + 'Id'] = mapOrGeoModel.id;
        return action;
      }
      controller.off('pan').on('pan', function(dx, dy) {
        api.dispatchAction(zrUtil.extend(makeActionBase(), {
          dx: dx,
          dy: dy
        }));
      });
      controller.off('zoom').on('zoom', function(zoom, mouseX, mouseY) {
        api.dispatchAction(zrUtil.extend(makeActionBase(), {
          zoom: zoom,
          originX: mouseX,
          originY: mouseY
        }));
        if (this._updateGroup) {
          var group = this.group;
          var scale = group.scale;
          group.traverse(function(el) {
            if (el.type === 'text') {
              el.attr('scale', [1 / scale[0], 1 / scale[1]]);
            }
          });
        }
      }, this);
      controller.rectProvider = function() {
        return geo.getViewRectAfterRoam();
      };
    }
  };
  module.exports = MapDraw;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/geo/GeoView.js", ["../helper/MapDraw", "../../echarts", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var MapDraw = $__require('../helper/MapDraw');
  module.exports = $__require('../../echarts').extendComponentView({
    type: 'geo',
    init: function(ecModel, api) {
      var mapDraw = new MapDraw(api, true);
      this._mapDraw = mapDraw;
      this.group.add(mapDraw.group);
    },
    render: function(geoModel, ecModel, api, payload) {
      if (payload && payload.type === 'geoToggleSelect' && payload.from === this.uid) {
        return;
      }
      var mapDraw = this._mapDraw;
      if (geoModel.get('show')) {
        mapDraw.draw(geoModel, ecModel, api, this, payload);
      } else {
        this._mapDraw.group.removeAll();
      }
      this.group.silent = geoModel.get('silent');
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/action/roamHelper.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var roamHelper = {};
  roamHelper.updateCenterAndZoom = function(view, payload, zoomLimit) {
    var previousZoom = view.getZoom();
    var center = view.getCenter();
    var zoom = payload.zoom;
    var point = view.dataToPoint(center);
    if (payload.dx != null && payload.dy != null) {
      point[0] -= payload.dx;
      point[1] -= payload.dy;
      var center = view.pointToData(point);
      view.setCenter(center);
    }
    if (zoom != null) {
      if (zoomLimit) {
        var zoomMin = zoomLimit.min || 0;
        var zoomMax = zoomLimit.max || Infinity;
        zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;
      }
      view.scale[0] *= zoom;
      view.scale[1] *= zoom;
      var position = view.position;
      var fixX = (payload.originX - position[0]) * (zoom - 1);
      var fixY = (payload.originY - position[1]) * (zoom - 1);
      position[0] -= fixX;
      position[1] -= fixY;
      view.updateTransform();
      var center = view.pointToData(point);
      view.setCenter(center);
      view.setZoom(zoom * previousZoom);
    }
    return {
      center: view.getCenter(),
      zoom: view.getZoom()
    };
  };
  module.exports = roamHelper;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/action/geoRoam.js", ["zrender/lib/core/util", "./roamHelper", "../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var roamHelper = $__require('./roamHelper');
  var echarts = $__require('../echarts');
  echarts.registerAction({
    type: 'geoRoam',
    event: 'geoRoam',
    update: 'updateLayout'
  }, function(payload, ecModel) {
    var componentType = payload.componentType || 'series';
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function(componentModel) {
      var geo = componentModel.coordinateSystem;
      if (geo.type !== 'geo') {
        return;
      }
      var res = roamHelper.updateCenterAndZoom(geo, payload, componentModel.get('scaleLimit'));
      componentModel.setCenter && componentModel.setCenter(res.center);
      componentModel.setZoom && componentModel.setZoom(res.zoom);
      if (componentType === 'series') {
        zrUtil.each(componentModel.seriesGroup, function(seriesModel) {
          seriesModel.setCenter(res.center);
          seriesModel.setZoom(res.zoom);
        });
      }
    });
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/geo.js", ["../coord/geo/GeoModel", "../coord/geo/geoCreator", "./geo/GeoView", "../action/geoRoam", "../echarts", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../coord/geo/GeoModel');
  $__require('../coord/geo/geoCreator');
  $__require('./geo/GeoView');
  $__require('../action/geoRoam');
  var echarts = $__require('../echarts');
  var zrUtil = $__require('zrender/lib/core/util');
  function makeAction(method, actionInfo) {
    actionInfo.update = 'updateView';
    echarts.registerAction(actionInfo, function(payload, ecModel) {
      var selected = {};
      ecModel.eachComponent({
        mainType: 'geo',
        query: payload
      }, function(geoModel) {
        geoModel[method](payload.name);
        var geo = geoModel.coordinateSystem;
        zrUtil.each(geo.regions, function(region) {
          selected[region.name] = geoModel.isSelected(region.name) || false;
        });
      });
      return {
        selected: selected,
        name: payload.name
      };
    });
  }
  makeAction('toggleSelected', {
    type: 'geoToggleSelect',
    event: 'geoselectchanged'
  });
  makeAction('select', {
    type: 'geoSelect',
    event: 'geoselected'
  });
  makeAction('unSelect', {
    type: 'geoUnSelect',
    event: 'geounselected'
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/parallel/AxisModel.js", ["../../model/Component", "zrender/lib/core/util", "../../model/mixin/makeStyleMapper", "../axisModelCreator", "../../util/number", "../axisModelCommonMixin", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ComponentModel = $__require('../../model/Component');
  var zrUtil = $__require('zrender/lib/core/util');
  var makeStyleMapper = $__require('../../model/mixin/makeStyleMapper');
  var axisModelCreator = $__require('../axisModelCreator');
  var numberUtil = $__require('../../util/number');
  var AxisModel = ComponentModel.extend({
    type: 'baseParallelAxis',
    axis: null,
    activeIntervals: [],
    getAreaSelectStyle: function() {
      return makeStyleMapper([['fill', 'color'], ['lineWidth', 'borderWidth'], ['stroke', 'borderColor'], ['width', 'width'], ['opacity', 'opacity']]).call(this.getModel('areaSelectStyle'));
    },
    setActiveIntervals: function(intervals) {
      var activeIntervals = this.activeIntervals = zrUtil.clone(intervals);
      if (activeIntervals) {
        for (var i = activeIntervals.length - 1; i >= 0; i--) {
          numberUtil.asc(activeIntervals[i]);
        }
      }
    },
    getActiveState: function(value) {
      var activeIntervals = this.activeIntervals;
      if (!activeIntervals.length) {
        return 'normal';
      }
      if (value == null) {
        return 'inactive';
      }
      for (var i = 0,
          len = activeIntervals.length; i < len; i++) {
        if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
          return 'active';
        }
      }
      return 'inactive';
    }
  });
  var defaultOption = {
    type: 'value',
    dim: null,
    parallelIndex: null,
    areaSelectStyle: {
      width: 20,
      borderWidth: 1,
      borderColor: 'rgba(160,197,232)',
      color: 'rgba(160,197,232)',
      opacity: 0.3
    },
    realtime: true,
    z: 10
  };
  zrUtil.merge(AxisModel.prototype, $__require('../axisModelCommonMixin'));
  function getAxisType(axisName, option) {
    return option.type || (option.data ? 'category' : 'value');
  }
  axisModelCreator('parallel', AxisModel, getAxisType, defaultOption);
  module.exports = AxisModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/parallel/ParallelModel.js", ["zrender/lib/core/util", "../../model/Component", "./AxisModel", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Component = $__require('../../model/Component');
  $__require('./AxisModel');
  Component.extend({
    type: 'parallel',
    dependencies: ['parallelAxis'],
    coordinateSystem: null,
    dimensions: null,
    parallelAxisIndex: null,
    layoutMode: 'box',
    defaultOption: {
      zlevel: 0,
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      layout: 'horizontal',
      axisExpandable: false,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      parallelAxisDefault: null
    },
    init: function() {
      Component.prototype.init.apply(this, arguments);
      this.mergeOption({});
    },
    mergeOption: function(newOption) {
      var thisOption = this.option;
      newOption && zrUtil.merge(thisOption, newOption, true);
      this._initDimensions();
    },
    contains: function(model, ecModel) {
      var parallelIndex = model.get('parallelIndex');
      return parallelIndex != null && ecModel.getComponent('parallel', parallelIndex) === this;
    },
    setAxisExpand: function(opt) {
      zrUtil.each(['axisExpandable', 'axisExpandCenter', 'axisExpandCount', 'axisExpandWidth'], function(name) {
        if (opt.hasOwnProperty(name)) {
          this.option[name] = opt[name];
        }
      }, this);
    },
    _initDimensions: function() {
      var dimensions = this.dimensions = [];
      var parallelAxisIndex = this.parallelAxisIndex = [];
      var axisModels = zrUtil.filter(this.dependentModels.parallelAxis, function(axisModel) {
        return axisModel.get('parallelIndex') === this.componentIndex;
      });
      zrUtil.each(axisModels, function(axisModel) {
        dimensions.push('dim' + axisModel.get('dim'));
        parallelAxisIndex.push(axisModel.componentIndex);
      });
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/parallel/ParallelAxis.js", ["zrender/lib/core/util", "../Axis", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Axis = $__require('../Axis');
  var ParallelAxis = function(dim, scale, coordExtent, axisType, axisIndex) {
    Axis.call(this, dim, scale, coordExtent);
    this.type = axisType || 'value';
    this.axisIndex = axisIndex;
  };
  ParallelAxis.prototype = {
    constructor: ParallelAxis,
    model: null
  };
  zrUtil.inherits(ParallelAxis, Axis);
  module.exports = ParallelAxis;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/parallel/Parallel.js", ["../../util/layout", "../../coord/axisHelper", "zrender/lib/core/util", "./ParallelAxis", "../../util/graphic", "zrender/lib/core/matrix", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var layout = $__require('../../util/layout');
  var axisHelper = $__require('../../coord/axisHelper');
  var zrUtil = $__require('zrender/lib/core/util');
  var ParallelAxis = $__require('./ParallelAxis');
  var graphic = $__require('../../util/graphic');
  var matrix = $__require('zrender/lib/core/matrix');
  var each = zrUtil.each;
  var PI = Math.PI;
  function Parallel(parallelModel, ecModel, api) {
    this._axesMap = {};
    this._axesLayout = {};
    this.dimensions = parallelModel.dimensions;
    this._rect;
    this._model = parallelModel;
    this._init(parallelModel, ecModel, api);
  }
  Parallel.prototype = {
    type: 'parallel',
    constructor: Parallel,
    _init: function(parallelModel, ecModel, api) {
      var dimensions = parallelModel.dimensions;
      var parallelAxisIndex = parallelModel.parallelAxisIndex;
      each(dimensions, function(dim, idx) {
        var axisIndex = parallelAxisIndex[idx];
        var axisModel = ecModel.getComponent('parallelAxis', axisIndex);
        var axis = this._axesMap[dim] = new ParallelAxis(dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisIndex);
        var isCategory = axis.type === 'category';
        axis.onBand = isCategory && axisModel.get('boundaryGap');
        axis.inverse = axisModel.get('inverse');
        axisModel.axis = axis;
        axis.model = axisModel;
      }, this);
    },
    update: function(ecModel, api) {
      this._updateAxesFromSeries(this._model, ecModel);
    },
    _updateAxesFromSeries: function(parallelModel, ecModel) {
      ecModel.eachSeries(function(seriesModel) {
        if (!parallelModel.contains(seriesModel, ecModel)) {
          return;
        }
        var data = seriesModel.getData();
        each(this.dimensions, function(dim) {
          var axis = this._axesMap[dim];
          axis.scale.unionExtent(data.getDataExtent(dim));
          axisHelper.niceScaleExtent(axis, axis.model);
        }, this);
      }, this);
    },
    resize: function(parallelModel, api) {
      this._rect = layout.getLayoutRect(parallelModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
      this._layoutAxes(parallelModel);
    },
    getRect: function() {
      return this._rect;
    },
    _layoutAxes: function(parallelModel) {
      var rect = this._rect;
      var layout = parallelModel.get('layout');
      var axes = this._axesMap;
      var dimensions = this.dimensions;
      var size = [rect.width, rect.height];
      var sizeIdx = layout === 'horizontal' ? 0 : 1;
      var layoutLength = size[sizeIdx];
      var axisLength = size[1 - sizeIdx];
      var axisExtent = [0, axisLength];
      each(axes, function(axis) {
        var idx = axis.inverse ? 1 : 0;
        axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
      });
      var axisExpandable = parallelModel.get('axisExpandable');
      var axisExpandWidth = parallelModel.get('axisExpandWidth');
      var axisExpandCenter = parallelModel.get('axisExpandCenter');
      var axisExpandCount = parallelModel.get('axisExpandCount') || 0;
      var axisExpandWindow;
      if (axisExpandCenter != null) {
        var left = Math.max(0, Math.floor(axisExpandCenter - (axisExpandCount - 1) / 2));
        var right = left + axisExpandCount - 1;
        if (right >= dimensions.length) {
          right = dimensions.length - 1;
          left = Math.max(0, Math.floor(right - axisExpandCount + 1));
        }
        axisExpandWindow = [left, right];
      }
      var calcPos = (axisExpandable && axisExpandWindow && axisExpandWidth) ? function(axisIndex, layoutLength, axisCount) {
        var peekIntervalCount = axisExpandWindow[1] - axisExpandWindow[0];
        var otherWidth = (layoutLength - axisExpandWidth * peekIntervalCount) / (axisCount - 1 - peekIntervalCount);
        var position;
        if (axisIndex < axisExpandWindow[0]) {
          position = (axisIndex - 1) * otherWidth;
        } else if (axisIndex <= axisExpandWindow[1]) {
          position = axisExpandWindow[0] * otherWidth + (axisIndex - axisExpandWindow[0]) * axisExpandWidth;
        } else if (axisIndex === axisCount - 1) {
          position = layoutLength;
        } else {
          position = axisExpandWindow[0] * otherWidth + peekIntervalCount * axisExpandWidth + (axisIndex - axisExpandWindow[1]) * otherWidth;
        }
        return {
          position: position,
          axisNameAvailableWidth: (axisExpandWindow[0] < axisIndex && axisIndex < axisExpandWindow[1]) ? axisExpandWidth : otherWidth
        };
      } : function(axisIndex, layoutLength, axisCount) {
        var step = layoutLength / (axisCount - 1);
        return {
          position: step * axisIndex,
          axisNameAvailableWidth: step
        };
      };
      each(dimensions, function(dim, idx) {
        var posInfo = calcPos(idx, layoutLength, dimensions.length);
        var positionTable = {
          horizontal: {
            x: posInfo.position,
            y: axisLength
          },
          vertical: {
            x: 0,
            y: posInfo.position
          }
        };
        var rotationTable = {
          horizontal: PI / 2,
          vertical: 0
        };
        var position = [positionTable[layout].x + rect.x, positionTable[layout].y + rect.y];
        var rotation = rotationTable[layout];
        var transform = matrix.create();
        matrix.rotate(transform, transform, rotation);
        matrix.translate(transform, transform, position);
        this._axesLayout[dim] = {
          position: position,
          rotation: rotation,
          transform: transform,
          axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
          tickDirection: 1,
          labelDirection: 1,
          axisExpandWindow: axisExpandWindow
        };
      }, this);
    },
    getAxis: function(dim) {
      return this._axesMap[dim];
    },
    dataToPoint: function(value, dim) {
      return this.axisCoordToPoint(this._axesMap[dim].dataToCoord(value), dim);
    },
    eachActiveState: function(data, callback, context) {
      var dimensions = this.dimensions;
      var axesMap = this._axesMap;
      var hasActiveSet = this.hasAxisbrushed();
      for (var i = 0,
          len = data.count(); i < len; i++) {
        var values = data.getValues(dimensions, i);
        var activeState;
        if (!hasActiveSet) {
          activeState = 'normal';
        } else {
          activeState = 'active';
          for (var j = 0,
              lenj = dimensions.length; j < lenj; j++) {
            var dimName = dimensions[j];
            var state = axesMap[dimName].model.getActiveState(values[j], j);
            if (state === 'inactive') {
              activeState = 'inactive';
              break;
            }
          }
        }
        callback.call(context, activeState, i);
      }
    },
    hasAxisbrushed: function() {
      var dimensions = this.dimensions;
      var axesMap = this._axesMap;
      var hasActiveSet = false;
      for (var j = 0,
          lenj = dimensions.length; j < lenj; j++) {
        if (axesMap[dimensions[j]].model.getActiveState() !== 'normal') {
          hasActiveSet = true;
        }
      }
      return hasActiveSet;
    },
    axisCoordToPoint: function(coord, dim) {
      var axisLayout = this._axesLayout[dim];
      return graphic.applyTransform([coord, 0], axisLayout.transform);
    },
    getAxisLayout: function(dim) {
      return zrUtil.clone(this._axesLayout[dim]);
    },
    findClosestAxisDim: function(point) {
      var axisDim;
      var minDist = Infinity;
      zrUtil.each(this._axesLayout, function(axisLayout, dim) {
        var localPoint = graphic.applyTransform(point, axisLayout.transform, true);
        var extent = this._axesMap[dim].getExtent();
        if (localPoint[0] < extent[0] || localPoint[0] > extent[1]) {
          return;
        }
        var dist = Math.abs(localPoint[1]);
        if (dist < minDist) {
          minDist = dist;
          axisDim = dim;
        }
      }, this);
      return axisDim;
    }
  };
  module.exports = Parallel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/parallel/parallelCreator.js", ["./Parallel", "../../CoordinateSystem", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var Parallel = $__require('./Parallel');
  function create(ecModel, api) {
    var coordSysList = [];
    ecModel.eachComponent('parallel', function(parallelModel, idx) {
      var coordSys = new Parallel(parallelModel, ecModel, api);
      coordSys.name = 'parallel_' + idx;
      coordSys.resize(parallelModel, api);
      parallelModel.coordinateSystem = coordSys;
      coordSys.model = parallelModel;
      coordSysList.push(coordSys);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get('coordinateSystem') === 'parallel') {
        var parallelIndex = seriesModel.get('parallelIndex');
        seriesModel.coordinateSystem = coordSysList[parallelIndex];
      }
    });
    return coordSysList;
  }
  $__require('../../CoordinateSystem').register('parallel', {create: create});
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/axis/parallelAxisAction.js", ["../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../../echarts');
  var actionInfo = {
    type: 'axisAreaSelect',
    event: 'axisAreaSelected',
    update: 'updateVisual'
  };
  echarts.registerAction(actionInfo, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'parallelAxis',
      query: payload
    }, function(parallelAxisModel) {
      parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
    });
  });
  echarts.registerAction('parallelAxisExpand', function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'parallel',
      query: payload
    }, function(parallelModel) {
      parallelModel.setAxisExpand(payload);
    });
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/axis/ParallelAxisView.js", ["zrender/lib/core/util", "./AxisBuilder", "../helper/BrushController", "../../util/graphic", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var AxisBuilder = $__require('./AxisBuilder');
  var BrushController = $__require('../helper/BrushController');
  var graphic = $__require('../../util/graphic');
  var elementList = ['axisLine', 'axisLabel', 'axisTick', 'axisName'];
  var AxisView = $__require('../../echarts').extendComponentView({
    type: 'parallelAxis',
    init: function(ecModel, api) {
      AxisView.superApply(this, 'init', arguments);
      (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this));
    },
    render: function(axisModel, ecModel, api, payload) {
      if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
        return;
      }
      this.axisModel = axisModel;
      this.api = api;
      this.group.removeAll();
      var oldAxisGroup = this._axisGroup;
      this._axisGroup = new graphic.Group();
      this.group.add(this._axisGroup);
      if (!axisModel.get('show')) {
        return;
      }
      var coordSys = ecModel.getComponent('parallel', axisModel.get('parallelIndex')).coordinateSystem;
      var areaSelectStyle = axisModel.getAreaSelectStyle();
      var areaWidth = areaSelectStyle.width;
      var dim = axisModel.axis.dim;
      var axisLayout = coordSys.getAxisLayout(dim);
      var axisLabelShow;
      var axisIndex = zrUtil.indexOf(coordSys.dimensions, dim);
      var axisExpandWindow = axisLayout.axisExpandWindow;
      if (axisExpandWindow && (axisIndex <= axisExpandWindow[0] || axisIndex >= axisExpandWindow[1])) {
        axisLabelShow = false;
      }
      var builderOpt = zrUtil.extend({
        axisLabelShow: axisLabelShow,
        strokeContainThreshold: areaWidth
      }, axisLayout);
      var axisBuilder = new AxisBuilder(axisModel, builderOpt);
      zrUtil.each(elementList, axisBuilder.add, axisBuilder);
      this._axisGroup.add(axisBuilder.getGroup());
      this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, areaWidth);
      graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    },
    _refreshBrushController: function(builderOpt, areaSelectStyle, axisModel, areaWidth) {
      var axis = axisModel.axis;
      var coverInfoList = zrUtil.map(axisModel.activeIntervals, function(interval) {
        return {
          brushType: 'lineX',
          panelId: 'pl',
          range: [axis.dataToCoord(interval[0], true), axis.dataToCoord(interval[1], true)]
        };
      });
      var extent = axis.getExtent();
      var extra = 30;
      var rect = {
        x: extent[0] - extra,
        y: -areaWidth / 2,
        width: extent[1] - extent[0] + 2 * extra,
        height: areaWidth
      };
      this._brushController.mount({
        enableGlobalPan: true,
        rotation: builderOpt.rotation,
        position: builderOpt.position
      }).setPanels([{
        panelId: 'pl',
        rect: rect
      }]).enableBrush({
        brushType: 'lineX',
        brushStyle: areaSelectStyle,
        removeOnClick: true
      }).updateCovers(coverInfoList);
    },
    _onBrush: function(coverInfoList, opt) {
      var axisModel = this.axisModel;
      var axis = axisModel.axis;
      var intervals = zrUtil.map(coverInfoList, function(coverInfo) {
        return [axis.coordToData(coverInfo.range[0], true), axis.coordToData(coverInfo.range[1], true)];
      });
      if (!axisModel.option.realtime === opt.isEnd || opt.removeOnClick) {
        this.api.dispatchAction({
          type: 'axisAreaSelect',
          parallelAxisId: axisModel.id,
          intervals: intervals
        });
      }
    },
    dispose: function() {
      this._brushController.dispose();
    }
  });
  function fromAxisAreaSelect(axisModel, ecModel, payload) {
    return payload && payload.type === 'axisAreaSelect' && ecModel.findComponents({
      mainType: 'parallelAxis',
      query: payload
    })[0] === axisModel;
  }
  module.exports = AxisView;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/parallelAxis.js", ["../coord/parallel/parallelCreator", "./axis/parallelAxisAction", "./axis/ParallelAxisView", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../coord/parallel/parallelCreator');
  $__require('./axis/parallelAxisAction');
  $__require('./axis/ParallelAxisView');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/parallel/parallelPreprocessor.js", ["zrender/lib/core/util", "../../util/model", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var modelUtil = $__require('../../util/model');
  module.exports = function(option) {
    createParallelIfNeeded(option);
    mergeAxisOptionFromParallel(option);
  };
  function createParallelIfNeeded(option) {
    if (option.parallel) {
      return;
    }
    var hasParallelSeries = false;
    zrUtil.each(option.series, function(seriesOpt) {
      if (seriesOpt && seriesOpt.type === 'parallel') {
        hasParallelSeries = true;
      }
    });
    if (hasParallelSeries) {
      option.parallel = [{}];
    }
  }
  function mergeAxisOptionFromParallel(option) {
    var axes = modelUtil.normalizeToArray(option.parallelAxis);
    zrUtil.each(axes, function(axisOption) {
      if (!zrUtil.isObject(axisOption)) {
        return;
      }
      var parallelIndex = axisOption.parallelIndex || 0;
      var parallelOption = modelUtil.normalizeToArray(option.parallel)[parallelIndex];
      if (parallelOption && parallelOption.parallelAxisDefault) {
        zrUtil.merge(axisOption, parallelOption.parallelAxisDefault, false);
      }
    });
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/parallel.js", ["../coord/parallel/parallelCreator", "../coord/parallel/ParallelModel", "./parallelAxis", "../echarts", "zrender/lib/core/util", "../coord/parallel/parallelPreprocessor", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../coord/parallel/parallelCreator');
  $__require('../coord/parallel/ParallelModel');
  $__require('./parallelAxis');
  var echarts = $__require('../echarts');
  var zrUtil = $__require('zrender/lib/core/util');
  var CLICK_THRESHOLD = 5;
  echarts.extendComponentView({
    type: 'parallel',
    render: function(parallelModel, ecModel, api) {
      var zr = api.getZr();
      if (!this.__onMouseDown) {
        var mousedownPoint;
        zr.on('mousedown', this.__onMouseDown = function(e) {
          mousedownPoint = [e.offsetX, e.offsetY];
        });
        zr.on('mouseup', this.__onMouseUp = function(e) {
          var point = [e.offsetX, e.offsetY];
          var dist = Math.pow(mousedownPoint[0] - point[0], 2) + Math.pow(mousedownPoint[1] - point[1], 2);
          if (!parallelModel.get('axisExpandable') || dist > CLICK_THRESHOLD) {
            return;
          }
          var coordSys = parallelModel.coordinateSystem;
          var closestDim = coordSys.findClosestAxisDim(point);
          if (closestDim) {
            var axisIndex = zrUtil.indexOf(coordSys.dimensions, closestDim);
            api.dispatchAction({
              type: 'parallelAxisExpand',
              axisExpandCenter: axisIndex
            });
          }
        });
      }
    },
    dispose: function(ecModel, api) {
      api.getZr().off(this.__onMouseDown);
      api.getZr().off(this.__onMouseUp);
    }
  });
  echarts.registerPreprocessor($__require('../coord/parallel/parallelPreprocessor'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/single/SingleAxis.js", ["zrender/lib/core/util", "../Axis", "../axisHelper", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Axis = $__require('../Axis');
  var axisHelper = $__require('../axisHelper');
  var SingleAxis = function(dim, scale, coordExtent, axisType, position) {
    Axis.call(this, dim, scale, coordExtent);
    this.type = axisType || 'value';
    this.position = position || 'bottom';
    this.orient = null;
    this._labelInterval = null;
  };
  SingleAxis.prototype = {
    constructor: SingleAxis,
    model: null,
    isHorizontal: function() {
      var position = this.position;
      return position === 'top' || position === 'bottom';
    },
    getLabelInterval: function() {
      var labelInterval = this._labelInterval;
      if (!labelInterval) {
        var axisModel = this.model;
        var labelModel = axisModel.getModel('axisLabel');
        var interval = labelModel.get('interval');
        if (!(this.type === 'category' && interval === 'auto')) {
          labelInterval = this._labelInterval = interval === 'auto' ? 0 : interval;
          return labelInterval;
        }
        labelInterval = this._labelInterval = axisHelper.getAxisLabelInterval(zrUtil.map(this.scale.getTicks(), this.dataToCoord, this), axisModel.getFormattedLabels(), labelModel.getModel('textStyle').getFont(), this.isHorizontal());
      }
      return labelInterval;
    },
    toGlobalCoord: null,
    toLocalCoord: null
  };
  zrUtil.inherits(SingleAxis, Axis);
  module.exports = SingleAxis;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/single/Single.js", ["./SingleAxis", "../axisHelper", "../../util/layout", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SingleAxis = $__require('./SingleAxis');
  var axisHelper = $__require('../axisHelper');
  var layout = $__require('../../util/layout');
  function Single(axisModel, ecModel, api) {
    this.dimension = 'x';
    this.dimensions = ['x'];
    this._axis = null;
    this._rect;
    this._init(axisModel, ecModel, api);
    this._model = axisModel;
  }
  Single.prototype = {
    type: 'singleAxis',
    constructor: Single,
    _init: function(axisModel, ecModel, api) {
      var dim = this.dimension;
      var axis = new SingleAxis(dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisModel.get('position'));
      var isCategory = axis.type === 'category';
      axis.onBand = isCategory && axisModel.get('boundaryGap');
      axis.inverse = axisModel.get('inverse');
      axis.orient = axisModel.get('orient');
      axisModel.axis = axis;
      axis.model = axisModel;
      this._axis = axis;
    },
    update: function(ecModel, api) {
      this._updateAxisFromSeries(ecModel);
    },
    _updateAxisFromSeries: function(ecModel) {
      ecModel.eachSeries(function(seriesModel) {
        var data = seriesModel.getData();
        var dim = this.dimension;
        this._axis.scale.unionExtent(data.getDataExtent(seriesModel.coordDimToDataDim(dim)));
        axisHelper.niceScaleExtent(this._axis, this._axis.model);
      }, this);
    },
    resize: function(axisModel, api) {
      this._rect = layout.getLayoutRect({
        left: axisModel.get('left'),
        top: axisModel.get('top'),
        right: axisModel.get('right'),
        bottom: axisModel.get('bottom'),
        width: axisModel.get('width'),
        height: axisModel.get('height')
      }, {
        width: api.getWidth(),
        height: api.getHeight()
      });
      this._adjustAxis();
    },
    getRect: function() {
      return this._rect;
    },
    _adjustAxis: function() {
      var rect = this._rect;
      var axis = this._axis;
      var isHorizontal = axis.isHorizontal();
      var extent = isHorizontal ? [0, rect.width] : [0, rect.height];
      var idx = axis.reverse ? 1 : 0;
      axis.setExtent(extent[idx], extent[1 - idx]);
      this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y);
    },
    _updateAxisTransform: function(axis, coordBase) {
      var axisExtent = axis.getExtent();
      var extentSum = axisExtent[0] + axisExtent[1];
      var isHorizontal = axis.isHorizontal();
      axis.toGlobalCoord = isHorizontal ? function(coord) {
        return coord + coordBase;
      } : function(coord) {
        return extentSum - coord + coordBase;
      };
      axis.toLocalCoord = isHorizontal ? function(coord) {
        return coord - coordBase;
      } : function(coord) {
        return extentSum - coord + coordBase;
      };
    },
    getAxis: function() {
      return this._axis;
    },
    getBaseAxis: function() {
      return this._axis;
    },
    containPoint: function(point) {
      var rect = this.getRect();
      var axis = this.getAxis();
      var orient = axis.orient;
      if (orient === 'horizontal') {
        return axis.contain(axis.toLocalCoord(point[0])) && (point[1] >= rect.y && point[1] <= (rect.y + rect.height));
      } else {
        return axis.contain(axis.toLocalCoord(point[1])) && (point[0] >= rect.y && point[0] <= (rect.y + rect.height));
      }
    },
    pointToData: function(point) {
      var axis = this.getAxis();
      return [axis.coordToData(axis.toLocalCoord(point[axis.orient === 'horizontal' ? 0 : 1]))];
    },
    dataToPoint: function(val) {
      var axis = this.getAxis();
      var rect = this.getRect();
      var pt = [];
      var idx = axis.orient === 'horizontal' ? 0 : 1;
      pt[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));
      pt[1 - idx] = idx === 0 ? (rect.y + rect.height / 2) : (rect.x + rect.width / 2);
      return pt;
    }
  };
  module.exports = Single;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/single/singleCreator.js", ["./Single", "../../CoordinateSystem", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var Single = $__require('./Single');
  function create(ecModel, api) {
    var singles = [];
    ecModel.eachComponent('singleAxis', function(axisModel, idx) {
      var single = new Single(axisModel, ecModel, api);
      single.name = 'single_' + idx;
      single.resize(axisModel, api);
      axisModel.coordinateSystem = single;
      singles.push(single);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get('coordinateSystem') === 'singleAxis') {
        var singleAxisIndex = seriesModel.get('singleAxisIndex') || 0;
        var axisModel = ecModel.getComponent('singleAxis', singleAxisIndex);
        seriesModel.coordinateSystem = axisModel.coordinateSystem;
      }
    });
    return singles;
  }
  $__require('../../CoordinateSystem').register('single', {
    create: create,
    dimensions: Single.prototype.dimensions
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/axis/AxisBuilder.js", ["zrender/lib/core/util", "../../util/format", "../../util/graphic", "../../model/Model", "../../util/number", "zrender/lib/core/vector", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var formatUtil = $__require('../../util/format');
  var graphic = $__require('../../util/graphic');
  var Model = $__require('../../model/Model');
  var numberUtil = $__require('../../util/number');
  var remRadian = numberUtil.remRadian;
  var isRadianAroundZero = numberUtil.isRadianAroundZero;
  var vec2 = $__require('zrender/lib/core/vector');
  var v2ApplyTransform = vec2.applyTransform;
  var retrieve = zrUtil.retrieve;
  var PI = Math.PI;
  function makeAxisEventDataBase(axisModel) {
    var eventData = {componentType: axisModel.mainType};
    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
    return eventData;
  }
  var AxisBuilder = function(axisModel, opt) {
    this.opt = opt;
    this.axisModel = axisModel;
    zrUtil.defaults(opt, {
      labelOffset: 0,
      nameDirection: 1,
      tickDirection: 1,
      labelDirection: 1,
      silent: true
    });
    this.group = new graphic.Group();
    var dumbGroup = new graphic.Group({
      position: opt.position.slice(),
      rotation: opt.rotation
    });
    dumbGroup.updateTransform();
    this._transform = dumbGroup.transform;
    this._dumbGroup = dumbGroup;
  };
  AxisBuilder.prototype = {
    constructor: AxisBuilder,
    hasBuilder: function(name) {
      return !!builders[name];
    },
    add: function(name) {
      builders[name].call(this);
    },
    getGroup: function() {
      return this.group;
    }
  };
  var builders = {
    axisLine: function() {
      var opt = this.opt;
      var axisModel = this.axisModel;
      if (!axisModel.get('axisLine.show')) {
        return;
      }
      var extent = this.axisModel.axis.getExtent();
      var matrix = this._transform;
      var pt1 = [extent[0], 0];
      var pt2 = [extent[1], 0];
      if (matrix) {
        v2ApplyTransform(pt1, pt1, matrix);
        v2ApplyTransform(pt2, pt2, matrix);
      }
      this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({
        anid: 'line',
        shape: {
          x1: pt1[0],
          y1: pt1[1],
          x2: pt2[0],
          y2: pt2[1]
        },
        style: zrUtil.extend({lineCap: 'round'}, axisModel.getModel('axisLine.lineStyle').getLineStyle()),
        strokeContainThreshold: opt.strokeContainThreshold || 5,
        silent: true,
        z2: 1
      })));
    },
    axisTick: function() {
      var axisModel = this.axisModel;
      if (!axisModel.get('axisTick.show')) {
        return;
      }
      var axis = axisModel.axis;
      var tickModel = axisModel.getModel('axisTick');
      var opt = this.opt;
      var lineStyleModel = tickModel.getModel('lineStyle');
      var tickLen = tickModel.get('length');
      var tickInterval = getInterval(tickModel, opt.labelInterval);
      var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));
      var ticks = axis.scale.getTicks();
      var pt1 = [];
      var pt2 = [];
      var matrix = this._transform;
      for (var i = 0; i < ticksCoords.length; i++) {
        if (ifIgnoreOnTick(axis, i, tickInterval)) {
          continue;
        }
        var tickCoord = ticksCoords[i];
        pt1[0] = tickCoord;
        pt1[1] = 0;
        pt2[0] = tickCoord;
        pt2[1] = opt.tickDirection * tickLen;
        if (matrix) {
          v2ApplyTransform(pt1, pt1, matrix);
          v2ApplyTransform(pt2, pt2, matrix);
        }
        this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({
          anid: 'tick_' + ticks[i],
          shape: {
            x1: pt1[0],
            y1: pt1[1],
            x2: pt2[0],
            y2: pt2[1]
          },
          style: zrUtil.defaults(lineStyleModel.getLineStyle(), {stroke: axisModel.get('axisLine.lineStyle.color')}),
          z2: 2,
          silent: true
        })));
      }
    },
    axisLabel: function() {
      var opt = this.opt;
      var axisModel = this.axisModel;
      var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));
      if (!show) {
        return;
      }
      var axis = axisModel.axis;
      var labelModel = axisModel.getModel('axisLabel');
      var textStyleModel = labelModel.getModel('textStyle');
      var labelMargin = labelModel.get('margin');
      var ticks = axis.scale.getTicks();
      var labels = axisModel.getFormattedLabels();
      var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;
      labelRotation = labelRotation * PI / 180;
      var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);
      var categoryData = axisModel.get('data');
      var textEls = [];
      var silent = isSilent(axisModel);
      var triggerEvent = axisModel.get('triggerEvent');
      for (var i = 0; i < ticks.length; i++) {
        if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {
          continue;
        }
        var itemTextStyleModel = textStyleModel;
        if (categoryData && categoryData[i] && categoryData[i].textStyle) {
          itemTextStyleModel = new Model(categoryData[i].textStyle, textStyleModel, axisModel.ecModel);
        }
        var textColor = itemTextStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');
        var tickCoord = axis.dataToCoord(ticks[i]);
        var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];
        var labelBeforeFormat = axis.scale.getLabel(ticks[i]);
        var textEl = new graphic.Text({
          anid: 'label_' + ticks[i],
          style: {
            text: labels[i],
            textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,
            textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,
            textFont: itemTextStyleModel.getFont(),
            fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor
          },
          position: pos,
          rotation: labelLayout.rotation,
          silent: silent,
          z2: 10
        });
        if (triggerEvent) {
          textEl.eventData = makeAxisEventDataBase(axisModel);
          textEl.eventData.targetType = 'axisLabel';
          textEl.eventData.value = labelBeforeFormat;
        }
        this._dumbGroup.add(textEl);
        textEl.updateTransform();
        textEls.push(textEl);
        this.group.add(textEl);
        textEl.decomposeTransform();
      }
      function isTwoLabelOverlapped(current, next) {
        var firstRect = current && current.getBoundingRect().clone();
        var nextRect = next && next.getBoundingRect().clone();
        if (firstRect && nextRect) {
          firstRect.applyTransform(current.getLocalTransform());
          nextRect.applyTransform(next.getLocalTransform());
          return firstRect.intersect(nextRect);
        }
      }
      if (axis.type !== 'category') {
        if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {
          var firstLabel = textEls[0];
          var nextLabel = textEls[1];
          if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
            firstLabel.ignore = true;
          }
        }
        if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {
          var lastLabel = textEls[textEls.length - 1];
          var prevLabel = textEls[textEls.length - 2];
          if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
            lastLabel.ignore = true;
          }
        }
      }
    },
    axisName: function() {
      var opt = this.opt;
      var axisModel = this.axisModel;
      var name = retrieve(opt.axisName, axisModel.get('name'));
      if (!name) {
        return;
      }
      var nameLocation = axisModel.get('nameLocation');
      var nameDirection = opt.nameDirection;
      var textStyleModel = axisModel.getModel('nameTextStyle');
      var gap = axisModel.get('nameGap') || 0;
      var extent = this.axisModel.axis.getExtent();
      var gapSignal = extent[0] > extent[1] ? -1 : 1;
      var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0];
      var labelLayout;
      var nameRotation = axisModel.get('nameRotate');
      if (nameRotation != null) {
        nameRotation = nameRotation * PI / 180;
      }
      var axisNameAvailableWidth;
      if (nameLocation === 'middle') {
        labelLayout = innerTextLayout(opt, nameRotation != null ? nameRotation : opt.rotation, nameDirection);
      } else {
        labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);
        axisNameAvailableWidth = opt.axisNameAvailableWidth;
        if (axisNameAvailableWidth != null) {
          axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
          !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
        }
      }
      var textFont = textStyleModel.getFont();
      var truncateOpt = axisModel.get('nameTruncate', true) || {};
      var ellipsis = truncateOpt.ellipsis;
      var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);
      var truncatedText = (ellipsis != null && maxWidth != null) ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {
        minChar: 2,
        placeholder: truncateOpt.placeholder
      }) : name;
      var tooltipOpt = axisModel.get('tooltip', true);
      var mainType = axisModel.mainType;
      var formatterParams = {
        componentType: mainType,
        name: name,
        $vars: ['name']
      };
      formatterParams[mainType + 'Index'] = axisModel.componentIndex;
      var textEl = new graphic.Text({
        anid: 'name',
        __fullText: name,
        __truncatedText: truncatedText,
        style: {
          text: truncatedText,
          textFont: textFont,
          fill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),
          textAlign: labelLayout.textAlign,
          textVerticalAlign: labelLayout.verticalAlign
        },
        position: pos,
        rotation: labelLayout.rotation,
        silent: isSilent(axisModel),
        z2: 1,
        tooltip: (tooltipOpt && tooltipOpt.show) ? zrUtil.extend({
          content: name,
          formatter: function() {
            return name;
          },
          formatterParams: formatterParams
        }, tooltipOpt) : null
      });
      if (axisModel.get('triggerEvent')) {
        textEl.eventData = makeAxisEventDataBase(axisModel);
        textEl.eventData.targetType = 'axisName';
        textEl.eventData.name = name;
      }
      this._dumbGroup.add(textEl);
      textEl.updateTransform();
      this.group.add(textEl);
      textEl.decomposeTransform();
    }
  };
  function innerTextLayout(opt, textRotation, direction) {
    var rotationDiff = remRadian(textRotation - opt.rotation);
    var textAlign;
    var verticalAlign;
    if (isRadianAroundZero(rotationDiff)) {
      verticalAlign = direction > 0 ? 'top' : 'bottom';
      textAlign = 'center';
    } else if (isRadianAroundZero(rotationDiff - PI)) {
      verticalAlign = direction > 0 ? 'bottom' : 'top';
      textAlign = 'center';
    } else {
      verticalAlign = 'middle';
      if (rotationDiff > 0 && rotationDiff < PI) {
        textAlign = direction > 0 ? 'right' : 'left';
      } else {
        textAlign = direction > 0 ? 'left' : 'right';
      }
    }
    return {
      rotation: rotationDiff,
      textAlign: textAlign,
      verticalAlign: verticalAlign
    };
  }
  function endTextLayout(opt, textPosition, textRotate, extent) {
    var rotationDiff = remRadian(textRotate - opt.rotation);
    var textAlign;
    var verticalAlign;
    var inverse = extent[0] > extent[1];
    var onLeft = (textPosition === 'start' && !inverse) || (textPosition !== 'start' && inverse);
    if (isRadianAroundZero(rotationDiff - PI / 2)) {
      verticalAlign = onLeft ? 'bottom' : 'top';
      textAlign = 'center';
    } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
      verticalAlign = onLeft ? 'top' : 'bottom';
      textAlign = 'center';
    } else {
      verticalAlign = 'middle';
      if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
        textAlign = onLeft ? 'left' : 'right';
      } else {
        textAlign = onLeft ? 'right' : 'left';
      }
    }
    return {
      rotation: rotationDiff,
      textAlign: textAlign,
      verticalAlign: verticalAlign
    };
  }
  function isSilent(axisModel) {
    var tooltipOpt = axisModel.get('tooltip');
    return axisModel.get('silent') || !(axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show));
  }
  var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function(axis, i, interval) {
    var rawTick;
    var scale = axis.scale;
    return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));
  };
  var getInterval = AxisBuilder.getInterval = function(model, labelInterval) {
    var interval = model.get('interval');
    if (interval == null || interval == 'auto') {
      interval = labelInterval;
    }
    return interval;
  };
  module.exports = AxisBuilder;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/axis/SingleAxisView.js", ["./AxisBuilder", "zrender/lib/core/util", "../../util/graphic", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var AxisBuilder = $__require('./AxisBuilder');
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var getInterval = AxisBuilder.getInterval;
  var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;
  var axisBuilderAttrs = ['axisLine', 'axisLabel', 'axisTick', 'axisName'];
  var selfBuilderAttr = 'splitLine';
  var AxisView = $__require('../../echarts').extendComponentView({
    type: 'singleAxis',
    render: function(axisModel, ecModel) {
      var group = this.group;
      group.removeAll();
      var layout = axisLayout(axisModel);
      var axisBuilder = new AxisBuilder(axisModel, layout);
      zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
      group.add(axisBuilder.getGroup());
      if (axisModel.get(selfBuilderAttr + '.show')) {
        this['_' + selfBuilderAttr](axisModel, layout.labelInterval);
      }
    },
    _splitLine: function(axisModel, labelInterval) {
      var axis = axisModel.axis;
      var splitLineModel = axisModel.getModel('splitLine');
      var lineStyleModel = splitLineModel.getModel('lineStyle');
      var lineWidth = lineStyleModel.get('width');
      var lineColors = lineStyleModel.get('color');
      var lineInterval = getInterval(splitLineModel, labelInterval);
      lineColors = lineColors instanceof Array ? lineColors : [lineColors];
      var gridRect = axisModel.coordinateSystem.getRect();
      var isHorizontal = axis.isHorizontal();
      var splitLines = [];
      var lineCount = 0;
      var ticksCoords = axis.getTicksCoords();
      var p1 = [];
      var p2 = [];
      for (var i = 0; i < ticksCoords.length; ++i) {
        if (ifIgnoreOnTick(axis, i, lineInterval)) {
          continue;
        }
        var tickCoord = axis.toGlobalCoord(ticksCoords[i]);
        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }
        var colorIndex = (lineCount++) % lineColors.length;
        splitLines[colorIndex] = splitLines[colorIndex] || [];
        splitLines[colorIndex].push(new graphic.Line(graphic.subPixelOptimizeLine({
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: {lineWidth: lineWidth},
          silent: true
        })));
      }
      for (var i = 0; i < splitLines.length; ++i) {
        this.group.add(graphic.mergePath(splitLines[i], {
          style: {
            stroke: lineColors[i % lineColors.length],
            lineDash: lineStyleModel.getLineDash(),
            lineWidth: lineWidth
          },
          silent: true
        }));
      }
    }
  });
  function axisLayout(axisModel) {
    var single = axisModel.coordinateSystem;
    var axis = axisModel.axis;
    var layout = {};
    var axisPosition = axis.position;
    var orient = axis.orient;
    var rect = single.getRect();
    var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
    var positionMap = {
      horizontal: {
        top: rectBound[2],
        bottom: rectBound[3]
      },
      vertical: {
        left: rectBound[0],
        right: rectBound[1]
      }
    };
    layout.position = [orient === 'vertical' ? positionMap.vertical[axisPosition] : rectBound[0], orient === 'horizontal' ? positionMap.horizontal[axisPosition] : rectBound[3]];
    var r = {
      horizontal: 0,
      vertical: 1
    };
    layout.rotation = Math.PI / 2 * r[orient];
    var directionMap = {
      top: -1,
      bottom: 1,
      right: 1,
      left: -1
    };
    layout.labelDirection = layout.tickDirection = layout.nameDirection = directionMap[axisPosition];
    if (axisModel.getModel('axisTick').get('inside')) {
      layout.tickDirection = -layout.tickDirection;
    }
    if (axisModel.getModel('axisLabel').get('inside')) {
      layout.labelDirection = -layout.labelDirection;
    }
    var labelRotation = axisModel.getModel('axisLabel').get('rotate');
    layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;
    layout.labelInterval = axis.getLabelInterval();
    layout.z2 = 1;
    return layout;
  }
  module.exports = AxisView;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/axisDefault.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var defaultOption = {
    show: true,
    zlevel: 0,
    z: 0,
    inverse: false,
    name: '',
    nameLocation: 'end',
    nameRotate: null,
    nameTruncate: {
      maxWidth: null,
      ellipsis: '...',
      placeholder: '.'
    },
    nameTextStyle: {},
    nameGap: 15,
    silent: false,
    triggerEvent: false,
    tooltip: {show: false},
    axisLine: {
      show: true,
      onZero: true,
      lineStyle: {
        color: '#333',
        width: 1,
        type: 'solid'
      }
    },
    axisTick: {
      show: true,
      inside: false,
      length: 5,
      lineStyle: {width: 1}
    },
    axisLabel: {
      show: true,
      inside: false,
      rotate: 0,
      margin: 8,
      textStyle: {fontSize: 12}
    },
    splitLine: {
      show: true,
      lineStyle: {
        color: ['#ccc'],
        width: 1,
        type: 'solid'
      }
    },
    splitArea: {
      show: false,
      areaStyle: {color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']}
    }
  };
  var categoryAxis = zrUtil.merge({
    boundaryGap: true,
    splitLine: {show: false},
    axisTick: {
      alignWithLabel: false,
      interval: 'auto'
    },
    axisLabel: {interval: 'auto'}
  }, defaultOption);
  var valueAxis = zrUtil.merge({
    boundaryGap: [0, 0],
    splitNumber: 5
  }, defaultOption);
  var timeAxis = zrUtil.defaults({
    scale: true,
    min: 'dataMin',
    max: 'dataMax'
  }, valueAxis);
  var logAxis = zrUtil.defaults({}, valueAxis);
  logAxis.scale = true;
  module.exports = {
    categoryAxis: categoryAxis,
    valueAxis: valueAxis,
    timeAxis: timeAxis,
    logAxis: logAxis
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/axisModelCreator.js", ["./axisDefault", "zrender/lib/core/util", "../model/Component", "../util/layout", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var axisDefault = $__require('./axisDefault');
  var zrUtil = $__require('zrender/lib/core/util');
  var ComponentModel = $__require('../model/Component');
  var layout = $__require('../util/layout');
  var AXIS_TYPES = ['value', 'category', 'time', 'log'];
  module.exports = function(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
    zrUtil.each(AXIS_TYPES, function(axisType) {
      BaseAxisModelClass.extend({
        type: axisName + 'Axis.' + axisType,
        mergeDefaultAndTheme: function(option, ecModel) {
          var layoutMode = this.layoutMode;
          var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};
          var themeModel = ecModel.getTheme();
          zrUtil.merge(option, themeModel.get(axisType + 'Axis'));
          zrUtil.merge(option, this.getDefaultOption());
          option.type = axisTypeDefaulter(axisName, option);
          if (layoutMode) {
            layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
          }
        },
        defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)
      });
    });
    ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/axisModelCommonMixin.js", ["zrender/lib/core/util", "./axisHelper", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var axisHelper = $__require('./axisHelper');
  function getName(obj) {
    if (zrUtil.isObject(obj) && obj.value != null) {
      return obj.value;
    } else {
      return obj;
    }
  }
  function getCategories() {
    return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);
  }
  function getFormattedLabels() {
    return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));
  }
  module.exports = {
    getFormattedLabels: getFormattedLabels,
    getCategories: getCategories
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/single/AxisModel.js", ["../../model/Component", "../axisModelCreator", "zrender/lib/core/util", "../axisModelCommonMixin", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ComponentModel = $__require('../../model/Component');
  var axisModelCreator = $__require('../axisModelCreator');
  var zrUtil = $__require('zrender/lib/core/util');
  var AxisModel = ComponentModel.extend({
    type: 'singleAxis',
    layoutMode: 'box',
    axis: null,
    coordinateSystem: null
  });
  var defaultOption = {
    left: '5%',
    top: '5%',
    right: '5%',
    bottom: '5%',
    type: 'value',
    position: 'bottom',
    orient: 'horizontal',
    axisLine: {
      show: true,
      lineStyle: {
        width: 2,
        type: 'solid'
      }
    },
    axisTick: {
      show: true,
      length: 6,
      lineStyle: {width: 2}
    },
    axisLabel: {
      show: true,
      interval: 'auto'
    },
    splitLine: {
      show: true,
      lineStyle: {
        type: 'dashed',
        opacity: 0.2
      }
    }
  };
  function getAxisType(axisName, option) {
    return option.type || (option.data ? 'category' : 'value');
  }
  zrUtil.merge(AxisModel.prototype, $__require('../axisModelCommonMixin'));
  axisModelCreator('single', AxisModel, getAxisType, defaultOption);
  module.exports = AxisModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/singleAxis.js", ["../coord/single/singleCreator", "./axis/SingleAxisView", "../coord/single/AxisModel", "../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../coord/single/singleCreator');
  $__require('./axis/SingleAxisView');
  $__require('../coord/single/AxisModel');
  var echarts = $__require('../echarts');
  echarts.extendComponentView({type: 'single'});
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/brush/preprocessor.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var DEFAULT_TOOLBOX_BTNS = ['rect', 'polygon', 'keep', 'clear'];
  module.exports = function(option, isNew) {
    var brushComponents = option && option.brush;
    if (!zrUtil.isArray(brushComponents)) {
      brushComponents = brushComponents ? [brushComponents] : [];
    }
    if (!brushComponents.length) {
      return;
    }
    var brushComponentSpecifiedBtns = [];
    zrUtil.each(brushComponents, function(brushOpt) {
      var tbs = brushOpt.hasOwnProperty('toolbox') ? brushOpt.toolbox : [];
      if (tbs instanceof Array) {
        brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);
      }
    });
    var toolbox = option && option.toolbox;
    if (zrUtil.isArray(toolbox)) {
      toolbox = toolbox[0];
    }
    if (!toolbox) {
      toolbox = {feature: {}};
      option.toolbox = [toolbox];
    }
    var toolboxFeature = (toolbox.feature || (toolbox.feature = {}));
    var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});
    var brushTypes = toolboxBrush.type || (toolboxBrush.type = []);
    brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);
    removeDuplicate(brushTypes);
    if (isNew && !brushTypes.length) {
      brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);
    }
  };
  function removeDuplicate(arr) {
    var map = {};
    zrUtil.each(arr, function(val) {
      map[val] = 1;
    });
    arr.length = 0;
    zrUtil.each(map, function(flag, val) {
      arr.push(val);
    });
  }
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/contain/polygon.js", ["./windingLine"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var windingLine = $__require('./windingLine');
  var EPSILON = 1e-8;
  function isAroundEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
  }
  function contain(points, x, y) {
    var w = 0;
    var p = points[0];
    if (!p) {
      return false;
    }
    for (var i = 1; i < points.length; i++) {
      var p2 = points[i];
      w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
      p = p2;
    }
    var p0 = points[0];
    if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {
      w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
    }
    return w !== 0;
  }
  module.exports = {contain: contain};
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/brush/selector.js", ["zrender/lib/contain/polygon", "zrender/lib/core/BoundingRect", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var polygonContain = $__require('zrender/lib/contain/polygon').contain;
  var BoundingRect = $__require('zrender/lib/core/BoundingRect');
  var selector = {
    lineX: getLineSelectors(0),
    lineY: getLineSelectors(1),
    rect: {
      point: function(itemLayout, selectors, area) {
        return area.boundingRect.contain(itemLayout[0], itemLayout[1]);
      },
      rect: function(itemLayout, selectors, area) {
        return area.boundingRect.intersect(makeBoundingRect(itemLayout));
      }
    },
    polygon: {
      point: function(itemLayout, selectors, area) {
        return area.boundingRect.contain(itemLayout[0], itemLayout[1]) && polygonContain(area.range, itemLayout[0], itemLayout[1]);
      },
      rect: function(itemLayout, selectors, area) {
        var points = area.range;
        if (points.length <= 1) {
          return false;
        }
        var x = itemLayout.x;
        var y = itemLayout.y;
        var width = itemLayout.width;
        var height = itemLayout.height;
        var p = points[0];
        if (polygonContain(points, x, y) || polygonContain(points, x + width, y) || polygonContain(points, x, y + height) || polygonContain(points, x + width, y + height) || makeBoundingRect(itemLayout).contain(p[0], p[1]) || lineIntersectPolygon(x, y, x + width, y, points) || lineIntersectPolygon(x, y, x, y + height, points) || lineIntersectPolygon(x + width, y, x + width, y + height, points) || lineIntersectPolygon(x, y + height, x + width, y + height, points)) {
          return true;
        }
      }
    }
  };
  function getLineSelectors(xyIndex) {
    var xy = ['x', 'y'];
    var wh = ['width', 'height'];
    return {
      point: function(itemLayout, selectors, area) {
        var range = area.range;
        var p = itemLayout[xyIndex];
        return inLineRange(p, range);
      },
      rect: function(itemLayout, selectors, area) {
        var range = area.range;
        return inLineRange(itemLayout[xy[xyIndex]], range) || inLineRange(itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]], range);
      }
    };
  }
  function inLineRange(p, range) {
    return range[0] <= p && p <= range[1];
  }
  function lineIntersectPolygon(lx, ly, l2x, l2y, points) {
    for (var i = 0,
        p2 = points[points.length - 1]; i < points.length; i++) {
      var p = points[i];
      if (lineIntersect(lx, ly, l2x, l2y, p[0], p[1], p2[0], p2[1])) {
        return true;
      }
      p2 = p;
    }
  }
  function lineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
    var delta = determinant(a2x - a1x, b1x - b2x, a2y - a1y, b1y - b2y);
    if (nearZero(delta)) {
      return false;
    }
    var namenda = determinant(b1x - a1x, b1x - b2x, b1y - a1y, b1y - b2y) / delta;
    if (namenda < 0 || namenda > 1) {
      return false;
    }
    var miu = determinant(a2x - a1x, b1x - a1x, a2y - a1y, b1y - a1y) / delta;
    if (miu < 0 || miu > 1) {
      return false;
    }
    return true;
  }
  function nearZero(val) {
    return val <= (1e-6) && val >= -(1e-6);
  }
  function determinant(v1, v2, v3, v4) {
    return v1 * v4 - v2 * v3;
  }
  function makeBoundingRect(itemLayout) {
    var x = itemLayout.x;
    var y = itemLayout.y;
    var width = itemLayout.width;
    var height = itemLayout.height;
    if (width < 0) {
      x = x + width;
      width = -width;
    }
    if (height < 0) {
      y = y + height;
      height = -height;
    }
    return new BoundingRect(x, y, width, height);
  }
  module.exports = selector;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/brush/visualEncoding.js", ["../../echarts", "../../visual/visualSolution", "zrender/lib/core/util", "zrender/lib/core/BoundingRect", "./selector", "../../util/throttle", "../helper/brushHelper", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../../echarts');
  var visualSolution = $__require('../../visual/visualSolution');
  var zrUtil = $__require('zrender/lib/core/util');
  var BoundingRect = $__require('zrender/lib/core/BoundingRect');
  var selector = $__require('./selector');
  var throttle = $__require('../../util/throttle');
  var brushHelper = $__require('../helper/brushHelper');
  var STATE_LIST = ['inBrush', 'outOfBrush'];
  var DISPATCH_METHOD = '__ecBrushSelect';
  var DISPATCH_FLAG = '__ecInBrushSelectEvent';
  var PRIORITY_BRUSH = echarts.PRIORITY.VISUAL.BRUSH;
  echarts.registerLayout(PRIORITY_BRUSH, function(ecModel, api, payload) {
    ecModel.eachComponent({mainType: 'brush'}, function(brushModel) {
      payload && payload.type === 'takeGlobalCursor' && brushModel.setBrushOption(payload.key === 'brush' ? payload.brushOption : {brushType: false});
      brushModel.coordInfoList = brushHelper.makeCoordInfoList(brushModel.option, ecModel);
      brushHelper.parseInputRanges(brushModel, ecModel);
    });
  });
  echarts.registerVisual(PRIORITY_BRUSH, function(ecModel, api, payload) {
    var brushSelected = [];
    var throttleType;
    var throttleDelay;
    ecModel.eachComponent({mainType: 'brush'}, function(brushModel, brushIndex) {
      var thisBrushSelected = {
        brushId: brushModel.id,
        brushIndex: brushIndex,
        brushName: brushModel.name,
        areas: zrUtil.clone(brushModel.areas),
        selected: []
      };
      brushSelected.push(thisBrushSelected);
      var brushOption = brushModel.option;
      var brushLink = brushOption.brushLink;
      var linkedSeriesMap = [];
      var selectedDataIndexForLink = [];
      var rangeInfoBySeries = [];
      var hasBrushExists = 0;
      if (!brushIndex) {
        throttleType = brushOption.throttleType;
        throttleDelay = brushOption.throttleDelay;
      }
      var areas = zrUtil.map(brushModel.areas, function(area) {
        return bindSelector(zrUtil.defaults({boundingRect: boundingRectBuilders[area.brushType](area)}, area));
      });
      var visualMappings = visualSolution.createVisualMappings(brushModel.option, STATE_LIST, function(mappingOption) {
        mappingOption.mappingMethod = 'fixed';
      });
      zrUtil.isArray(brushLink) && zrUtil.each(brushLink, function(seriesIndex) {
        linkedSeriesMap[seriesIndex] = 1;
      });
      function linkOthers(seriesIndex) {
        return brushLink === 'all' || linkedSeriesMap[seriesIndex];
      }
      function brushed(rangeInfoList) {
        return !!rangeInfoList.length;
      }
      ecModel.eachSeries(function(seriesModel, seriesIndex) {
        var rangeInfoList = rangeInfoBySeries[seriesIndex] = [];
        seriesModel.subType === 'parallel' ? stepAParallel(seriesModel, seriesIndex, rangeInfoList) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);
      });
      function stepAParallel(seriesModel, seriesIndex) {
        var coordSys = seriesModel.coordinateSystem;
        hasBrushExists |= coordSys.hasAxisbrushed();
        linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function(activeState, dataIndex) {
          activeState === 'active' && (selectedDataIndexForLink[dataIndex] = 1);
        });
      }
      function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {
        var selectorsByBrushType = getSelectorsByBrushType(seriesModel);
        if (!selectorsByBrushType || brushModelNotControll(brushModel, seriesIndex)) {
          return;
        }
        zrUtil.each(areas, function(area) {
          selectorsByBrushType[area.brushType] && brushHelper.controlSeries(area, brushModel, seriesModel) && rangeInfoList.push(area);
          hasBrushExists |= brushed(rangeInfoList);
        });
        if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {
          var data = seriesModel.getData();
          data.each(function(dataIndex) {
            if (checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex)) {
              selectedDataIndexForLink[dataIndex] = 1;
            }
          });
        }
      }
      ecModel.eachSeries(function(seriesModel, seriesIndex) {
        var seriesBrushSelected = {
          seriesId: seriesModel.id,
          seriesIndex: seriesIndex,
          seriesName: seriesModel.name,
          dataIndex: []
        };
        thisBrushSelected.selected.push(seriesBrushSelected);
        var selectorsByBrushType = getSelectorsByBrushType(seriesModel);
        var rangeInfoList = rangeInfoBySeries[seriesIndex];
        var data = seriesModel.getData();
        var getValueState = linkOthers(seriesIndex) ? function(dataIndex) {
          return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush';
        } : function(dataIndex) {
          return checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush';
        };
        (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && visualSolution.applyVisual(STATE_LIST, visualMappings, data, getValueState);
      });
    });
    dispatchAction(api, throttleType, throttleDelay, brushSelected, payload);
  });
  function dispatchAction(api, throttleType, throttleDelay, brushSelected, payload) {
    if (!payload) {
      return;
    }
    var zr = api.getZr();
    if (zr[DISPATCH_FLAG]) {
      return;
    }
    if (!zr[DISPATCH_METHOD]) {
      zr[DISPATCH_METHOD] = doDispatch;
    }
    var fn = throttle.createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType);
    fn(api, brushSelected);
  }
  function doDispatch(api, brushSelected) {
    if (!api.isDisposed()) {
      var zr = api.getZr();
      zr[DISPATCH_FLAG] = true;
      api.dispatchAction({
        type: 'brushSelect',
        batch: brushSelected
      });
      zr[DISPATCH_FLAG] = false;
    }
  }
  function checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex) {
    var itemLayout = data.getItemLayout(dataIndex);
    for (var i = 0,
        len = rangeInfoList.length; i < len; i++) {
      var area = rangeInfoList[i];
      if (selectorsByBrushType[area.brushType](itemLayout, area.selectors, area)) {
        return true;
      }
    }
  }
  function getSelectorsByBrushType(seriesModel) {
    var brushSelector = seriesModel.brushSelector;
    if (zrUtil.isString(brushSelector)) {
      var sels = [];
      zrUtil.each(selector, function(selectorsByElementType, brushType) {
        sels[brushType] = selectorsByElementType[brushSelector];
      });
      return sels;
    } else if (zrUtil.isFunction(brushSelector)) {
      var bSelector = {};
      zrUtil.each(selector, function(sel, brushType) {
        bSelector[brushType] = brushSelector;
      });
      return bSelector;
    }
    return brushSelector;
  }
  function brushModelNotControll(brushModel, seriesIndex) {
    var seriesIndices = brushModel.option.seriesIndex;
    return seriesIndices != null && seriesIndices !== 'all' && (zrUtil.isArray(seriesIndices) ? zrUtil.indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);
  }
  function bindSelector(area) {
    var selectors = area.selectors = {};
    zrUtil.each(selector[area.brushType], function(selFn, elType) {
      selectors[elType] = function(itemLayout) {
        return selFn(itemLayout, selectors, area);
      };
    });
    return area;
  }
  var boundingRectBuilders = {
    lineX: zrUtil.noop,
    lineY: zrUtil.noop,
    rect: function(area) {
      return getBoundingRectFromMinMax(area.range);
    },
    polygon: function(area) {
      var minMax;
      var range = area.range;
      for (var i = 0,
          len = range.length; i < len; i++) {
        minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];
        var rg = range[i];
        rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);
        rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);
        rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);
        rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);
      }
      return minMax && getBoundingRectFromMinMax(minMax);
    }
  };
  function getBoundingRectFromMinMax(minMax) {
    return new BoundingRect(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/brush/BrushModel.js", ["../../echarts", "zrender/lib/core/util", "../../visual/visualSolution", "../../model/Model", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../../echarts');
  var zrUtil = $__require('zrender/lib/core/util');
  var visualSolution = $__require('../../visual/visualSolution');
  var Model = $__require('../../model/Model');
  var DEFAULT_OUT_OF_BRUSH_COLOR = ['#ddd'];
  var BrushModel = echarts.extendComponentModel({
    type: 'brush',
    dependencies: ['geo', 'grid', 'xAxis', 'yAxis', 'parallel', 'series'],
    defaultOption: {
      toolbox: null,
      brushLink: null,
      seriesIndex: 'all',
      geoIndex: null,
      xAxisIndex: null,
      yAxisIndex: null,
      brushType: 'rect',
      brushMode: 'single',
      transformable: true,
      brushStyle: {
        borderWidth: 1,
        color: 'rgba(120,140,180,0.3)',
        borderColor: 'rgba(120,140,180,0.8)',
        width: null
      },
      throttleType: 'fixRate',
      throttleDelay: 0,
      removeOnClick: true
    },
    areas: [],
    brushType: null,
    brushOption: {},
    coordInfoList: [],
    optionUpdated: function(newOption, isInit) {
      var thisOption = this.option;
      !isInit && visualSolution.replaceVisualOption(thisOption, newOption, ['inBrush', 'outOfBrush']);
      thisOption.inBrush = thisOption.inBrush || {};
      thisOption.outOfBrush = thisOption.outOfBrush || {color: DEFAULT_OUT_OF_BRUSH_COLOR};
    },
    setAreas: function(areas) {
      if (__DEV__) {
        zrUtil.assert(zrUtil.isArray(areas));
        zrUtil.each(areas, function(area) {
          zrUtil.assert(area.brushType, 'Illegal areas');
        });
      }
      if (!areas) {
        return;
      }
      this.areas = zrUtil.map(areas, function(area) {
        return this._mergeBrushOption(area);
      }, this);
    },
    setBrushOption: function(brushOption) {
      this.brushOption = this._mergeBrushOption(brushOption);
      this.brushType = this.brushOption.brushType;
    },
    _mergeBrushOption: function(brushOption) {
      var option = this.option;
      return zrUtil.merge({
        brushType: option.brushType,
        brushMode: option.brushMode,
        transformable: option.transformable,
        brushStyle: new Model(option.brushStyle).getItemStyle(),
        removeOnClick: option.removeOnClick
      }, brushOption, true);
    }
  });
  module.exports = BrushModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/brush/BrushView.js", ["zrender/lib/core/util", "../helper/BrushController", "../../echarts", "../helper/brushHelper", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var BrushController = $__require('../helper/BrushController');
  var echarts = $__require('../../echarts');
  var brushHelper = $__require('../helper/brushHelper');
  module.exports = echarts.extendComponentView({
    type: 'brush',
    init: function(ecModel, api) {
      this.ecModel = ecModel;
      this.api = api;
      this.model;
      (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this)).mount();
    },
    render: function(brushModel) {
      this.model = brushModel;
      return updateController.apply(this, arguments);
    },
    updateView: updateController,
    updateLayout: updateController,
    updateVisual: updateController,
    dispose: function() {
      this._brushController.dispose();
    },
    _onBrush: function(areas, opt) {
      var modelId = this.model.id;
      brushHelper.parseOutputRanges(areas, this.model.coordInfoList, this.ecModel);
      (!opt.isEnd || opt.removeOnClick) && this.api.dispatchAction({
        type: 'brush',
        brushId: modelId,
        areas: zrUtil.clone(areas),
        $from: modelId
      });
    }
  });
  function updateController(brushModel, ecModel, api, payload) {
    (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushHelper.makePanelOpts(brushModel.coordInfoList)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/brush/brushAction.js", ["../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../../echarts');
  echarts.registerAction({
    type: 'brush',
    event: 'brush',
    update: 'updateView'
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'brush',
      query: payload
    }, function(brushModel) {
      brushModel.setAreas(payload.areas);
    });
  });
  echarts.registerAction({
    type: 'brushSelect',
    event: 'brushSelected',
    update: 'none'
  }, function() {});
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/toolbox/feature/Brush.js", ["../featureManager", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var featureManager = $__require('../featureManager');
  var zrUtil = $__require('zrender/lib/core/util');
  function Brush(model, ecModel, api) {
    this.model = model;
    this.ecModel = ecModel;
    this.api = api;
    this._brushType;
    this._brushMode;
  }
  Brush.defaultOption = {
    show: true,
    type: ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear'],
    icon: {
      rect: 'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13',
      polygon: 'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2',
      lineX: 'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4',
      lineY: 'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4',
      keep: 'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z',
      clear: 'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2'
    },
    title: {
      rect: '',
      polygon: '',
      lineX: '',
      lineY: '',
      keep: '',
      clear: ''
    }
  };
  var proto = Brush.prototype;
  proto.render = proto.updateView = proto.updateLayout = function(featureModel, ecModel, api) {
    var brushType;
    var brushMode;
    var isBrushed;
    ecModel.eachComponent({mainType: 'brush'}, function(brushModel) {
      brushType = brushModel.brushType;
      brushMode = brushModel.brushOption.brushMode || 'single';
      isBrushed |= brushModel.areas.length;
    });
    this._brushType = brushType;
    this._brushMode = brushMode;
    zrUtil.each(featureModel.get('type', true), function(type) {
      featureModel.setIconStatus(type, (type === 'keep' ? brushMode === 'multiple' : type === 'clear' ? isBrushed : type === brushType) ? 'emphasis' : 'normal');
    });
  };
  proto.getIcons = function() {
    var model = this.model;
    var availableIcons = model.get('icon', true);
    var icons = {};
    zrUtil.each(model.get('type', true), function(type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  };
  proto.onclick = function(ecModel, api, type) {
    var api = this.api;
    var brushType = this._brushType;
    var brushMode = this._brushMode;
    if (type === 'clear') {
      api.dispatchAction({
        type: 'brush',
        areas: []
      });
    } else {
      api.dispatchAction({
        type: 'takeGlobalCursor',
        key: 'brush',
        brushOption: {
          brushType: type === 'keep' ? brushType : (brushType === type ? false : type),
          brushMode: type === 'keep' ? (brushMode === 'multiple' ? 'single' : 'multiple') : brushMode
        }
      });
    }
  };
  featureManager.register('brush', Brush);
  module.exports = Brush;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/brush.js", ["../echarts", "./brush/preprocessor", "./brush/visualEncoding", "./brush/BrushModel", "./brush/BrushView", "./brush/brushAction", "./toolbox/feature/Brush", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../echarts').registerPreprocessor($__require('./brush/preprocessor'));
  $__require('./brush/visualEncoding');
  $__require('./brush/BrushModel');
  $__require('./brush/BrushView');
  $__require('./brush/brushAction');
  $__require('./toolbox/feature/Brush');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/title.js", ["../echarts", "../util/graphic", "../util/layout", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../echarts');
  var graphic = $__require('../util/graphic');
  var layout = $__require('../util/layout');
  echarts.extendComponentModel({
    type: 'title',
    layoutMode: {
      type: 'box',
      ignoreSize: true
    },
    defaultOption: {
      zlevel: 0,
      z: 6,
      show: true,
      text: '',
      target: 'blank',
      subtext: '',
      subtarget: 'blank',
      left: 0,
      top: 0,
      backgroundColor: 'rgba(0,0,0,0)',
      borderColor: '#ccc',
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: 'bolder',
        color: '#333'
      },
      subtextStyle: {color: '#aaa'}
    }
  });
  echarts.extendComponentView({
    type: 'title',
    render: function(titleModel, ecModel, api) {
      this.group.removeAll();
      if (!titleModel.get('show')) {
        return;
      }
      var group = this.group;
      var textStyleModel = titleModel.getModel('textStyle');
      var subtextStyleModel = titleModel.getModel('subtextStyle');
      var textAlign = titleModel.get('textAlign');
      var textBaseline = titleModel.get('textBaseline');
      var textEl = new graphic.Text({
        style: {
          text: titleModel.get('text'),
          textFont: textStyleModel.getFont(),
          fill: textStyleModel.getTextColor()
        },
        z2: 10
      });
      var textRect = textEl.getBoundingRect();
      var subText = titleModel.get('subtext');
      var subTextEl = new graphic.Text({
        style: {
          text: subText,
          textFont: subtextStyleModel.getFont(),
          fill: subtextStyleModel.getTextColor(),
          y: textRect.height + titleModel.get('itemGap'),
          textBaseline: 'top'
        },
        z2: 10
      });
      var link = titleModel.get('link');
      var sublink = titleModel.get('sublink');
      textEl.silent = !link;
      subTextEl.silent = !sublink;
      if (link) {
        textEl.on('click', function() {
          window.open(link, '_' + titleModel.get('target'));
        });
      }
      if (sublink) {
        subTextEl.on('click', function() {
          window.open(sublink, '_' + titleModel.get('subtarget'));
        });
      }
      group.add(textEl);
      subText && group.add(subTextEl);
      var groupRect = group.getBoundingRect();
      var layoutOption = titleModel.getBoxLayoutParams();
      layoutOption.width = groupRect.width;
      layoutOption.height = groupRect.height;
      var layoutRect = layout.getLayoutRect(layoutOption, {
        width: api.getWidth(),
        height: api.getHeight()
      }, titleModel.get('padding'));
      if (!textAlign) {
        textAlign = titleModel.get('left') || titleModel.get('right');
        if (textAlign === 'middle') {
          textAlign = 'center';
        }
        if (textAlign === 'right') {
          layoutRect.x += layoutRect.width;
        } else if (textAlign === 'center') {
          layoutRect.x += layoutRect.width / 2;
        }
      }
      if (!textBaseline) {
        textBaseline = titleModel.get('top') || titleModel.get('bottom');
        if (textBaseline === 'center') {
          textBaseline = 'middle';
        }
        if (textBaseline === 'bottom') {
          layoutRect.y += layoutRect.height;
        } else if (textBaseline === 'middle') {
          layoutRect.y += layoutRect.height / 2;
        }
        textBaseline = textBaseline || 'top';
      }
      group.attr('position', [layoutRect.x, layoutRect.y]);
      var alignStyle = {
        textAlign: textAlign,
        textVerticalAlign: textBaseline
      };
      textEl.setStyle(alignStyle);
      subTextEl.setStyle(alignStyle);
      groupRect = group.getBoundingRect();
      var padding = layoutRect.margin;
      var style = titleModel.getItemStyle(['color', 'opacity']);
      style.fill = titleModel.get('backgroundColor');
      var rect = new graphic.Rect({
        shape: {
          x: groupRect.x - padding[3],
          y: groupRect.y - padding[0],
          width: groupRect.width + padding[1] + padding[3],
          height: groupRect.height + padding[0] + padding[2]
        },
        style: style,
        silent: true
      });
      graphic.subPixelOptimizeRect(rect);
      group.add(rect);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/SliderZoomModel.js", ["./DataZoomModel", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var DataZoomModel = $__require('./DataZoomModel');
  var SliderZoomModel = DataZoomModel.extend({
    type: 'dataZoom.slider',
    layoutMode: 'box',
    defaultOption: {
      show: true,
      right: 'ph',
      top: 'ph',
      width: 'ph',
      height: 'ph',
      left: null,
      bottom: null,
      backgroundColor: 'rgba(47,69,84,0)',
      dataBackground: {
        lineStyle: {
          color: '#2f4554',
          width: 0.5,
          opacity: 0.3
        },
        areaStyle: {
          color: 'rgba(47,69,84,0.3)',
          opacity: 0.3
        }
      },
      borderColor: '#ddd',
      fillerColor: 'rgba(167,183,204,0.4)',
      handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',
      handleSize: '100%',
      handleStyle: {color: '#a7b7cc'},
      labelPrecision: null,
      labelFormatter: null,
      showDetail: true,
      showDataShadow: 'auto',
      realtime: true,
      zoomLock: false,
      textStyle: {color: '#333'}
    }
  });
  module.exports = SliderZoomModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/SliderZoomView.js", ["zrender/lib/core/util", "../../util/graphic", "../../util/throttle", "./DataZoomView", "../../util/number", "../../util/layout", "../helper/sliderMove", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var throttle = $__require('../../util/throttle');
  var DataZoomView = $__require('./DataZoomView');
  var Rect = graphic.Rect;
  var numberUtil = $__require('../../util/number');
  var linearMap = numberUtil.linearMap;
  var layout = $__require('../../util/layout');
  var sliderMove = $__require('../helper/sliderMove');
  var asc = numberUtil.asc;
  var bind = zrUtil.bind;
  var each = zrUtil.each;
  var DEFAULT_LOCATION_EDGE_GAP = 7;
  var DEFAULT_FRAME_BORDER_WIDTH = 1;
  var DEFAULT_FILLER_SIZE = 30;
  var HORIZONTAL = 'horizontal';
  var VERTICAL = 'vertical';
  var LABEL_GAP = 5;
  var SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];
  var SliderZoomView = DataZoomView.extend({
    type: 'dataZoom.slider',
    init: function(ecModel, api) {
      this._displayables = {};
      this._orient;
      this._range;
      this._handleEnds;
      this._size;
      this._handleWidth;
      this._handleHeight;
      this._location;
      this._dragging;
      this._dataShadowInfo;
      this.api = api;
    },
    render: function(dataZoomModel, ecModel, api, payload) {
      SliderZoomView.superApply(this, 'render', arguments);
      throttle.createOrUpdate(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate');
      this._orient = dataZoomModel.get('orient');
      if (this.dataZoomModel.get('show') === false) {
        this.group.removeAll();
        return;
      }
      if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {
        this._buildView();
      }
      this._updateView();
    },
    remove: function() {
      SliderZoomView.superApply(this, 'remove', arguments);
      throttle.clear(this, '_dispatchZoomAction');
    },
    dispose: function() {
      SliderZoomView.superApply(this, 'dispose', arguments);
      throttle.clear(this, '_dispatchZoomAction');
    },
    _buildView: function() {
      var thisGroup = this.group;
      thisGroup.removeAll();
      this._resetLocation();
      this._resetInterval();
      var barGroup = this._displayables.barGroup = new graphic.Group();
      this._renderBackground();
      this._renderHandle();
      this._renderDataShadow();
      thisGroup.add(barGroup);
      this._positionGroup();
    },
    _resetLocation: function() {
      var dataZoomModel = this.dataZoomModel;
      var api = this.api;
      var coordRect = this._findCoordRect();
      var ecSize = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var positionInfo = this._orient === HORIZONTAL ? {
        right: ecSize.width - coordRect.x - coordRect.width,
        top: (ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP),
        width: coordRect.width,
        height: DEFAULT_FILLER_SIZE
      } : {
        right: DEFAULT_LOCATION_EDGE_GAP,
        top: coordRect.y,
        width: DEFAULT_FILLER_SIZE,
        height: coordRect.height
      };
      var layoutParams = layout.getLayoutParams(dataZoomModel.option);
      zrUtil.each(['right', 'top', 'width', 'height'], function(name) {
        if (layoutParams[name] === 'ph') {
          layoutParams[name] = positionInfo[name];
        }
      });
      var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);
      this._location = {
        x: layoutRect.x,
        y: layoutRect.y
      };
      this._size = [layoutRect.width, layoutRect.height];
      this._orient === VERTICAL && this._size.reverse();
    },
    _positionGroup: function() {
      var thisGroup = this.group;
      var location = this._location;
      var orient = this._orient;
      var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
      var inverse = targetAxisModel && targetAxisModel.get('inverse');
      var barGroup = this._displayables.barGroup;
      var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
      barGroup.attr((orient === HORIZONTAL && !inverse) ? {scale: otherAxisInverse ? [1, 1] : [1, -1]} : (orient === HORIZONTAL && inverse) ? {scale: otherAxisInverse ? [-1, 1] : [-1, -1]} : (orient === VERTICAL && !inverse) ? {
        scale: otherAxisInverse ? [1, -1] : [1, 1],
        rotation: Math.PI / 2
      } : {
        scale: otherAxisInverse ? [-1, -1] : [-1, 1],
        rotation: Math.PI / 2
      });
      var rect = thisGroup.getBoundingRect([barGroup]);
      thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);
    },
    _getViewExtent: function() {
      return [0, this._size[0]];
    },
    _renderBackground: function() {
      var dataZoomModel = this.dataZoomModel;
      var size = this._size;
      this._displayables.barGroup.add(new Rect({
        silent: true,
        shape: {
          x: 0,
          y: 0,
          width: size[0],
          height: size[1]
        },
        style: {fill: dataZoomModel.get('backgroundColor')},
        z2: -40
      }));
    },
    _renderDataShadow: function() {
      var info = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (!info) {
        return;
      }
      var size = this._size;
      var seriesModel = info.series;
      var data = seriesModel.getRawData();
      var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() : info.otherDim;
      var otherDataExtent = data.getDataExtent(otherDim);
      var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;
      otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];
      var otherShadowExtent = [0, size[1]];
      var thisShadowExtent = [0, size[0]];
      var areaPoints = [[size[0], 0], [0, 0]];
      var linePoints = [];
      var step = thisShadowExtent[1] / (data.count() - 1);
      var thisCoord = 0;
      var stride = Math.round(data.count() / size[0]);
      data.each([otherDim], function(value, index) {
        if (stride > 0 && (index % stride)) {
          thisCoord += step;
          return;
        }
        var otherCoord = (value == null || isNaN(value) || value === '') ? null : linearMap(value, otherDataExtent, otherShadowExtent, true);
        if (otherCoord != null) {
          areaPoints.push([thisCoord, otherCoord]);
          linePoints.push([thisCoord, otherCoord]);
        }
        thisCoord += step;
      });
      var dataZoomModel = this.dataZoomModel;
      this._displayables.barGroup.add(new graphic.Polygon({
        shape: {points: areaPoints},
        style: zrUtil.defaults({fill: dataZoomModel.get('dataBackgroundColor')}, dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()),
        silent: true,
        z2: -20
      }));
      this._displayables.barGroup.add(new graphic.Polyline({
        shape: {points: linePoints},
        style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),
        silent: true,
        z2: -19
      }));
    },
    _prepareDataShadowInfo: function() {
      var dataZoomModel = this.dataZoomModel;
      var showDataShadow = dataZoomModel.get('showDataShadow');
      if (showDataShadow === false) {
        return;
      }
      var result;
      var ecModel = this.ecModel;
      dataZoomModel.eachTargetAxis(function(dimNames, axisIndex) {
        var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();
        zrUtil.each(seriesModels, function(seriesModel) {
          if (result) {
            return;
          }
          if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {
            return;
          }
          var otherDim = getOtherDim(dimNames.name);
          var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;
          result = {
            thisAxis: thisAxis,
            series: seriesModel,
            thisDim: dimNames.name,
            otherDim: otherDim,
            otherAxisInverse: seriesModel.coordinateSystem.getOtherAxis(thisAxis).inverse
          };
        }, this);
      }, this);
      return result;
    },
    _renderHandle: function() {
      var displaybles = this._displayables;
      var handles = displaybles.handles = [];
      var handleLabels = displaybles.handleLabels = [];
      var barGroup = this._displayables.barGroup;
      var size = this._size;
      var dataZoomModel = this.dataZoomModel;
      barGroup.add(displaybles.filler = new Rect({
        draggable: true,
        cursor: 'move',
        drift: bind(this._onDragMove, this, 'all'),
        ondragstart: bind(this._showDataInfo, this, true),
        ondragend: bind(this._onDragEnd, this),
        onmouseover: bind(this._showDataInfo, this, true),
        onmouseout: bind(this._showDataInfo, this, false),
        style: {
          fill: dataZoomModel.get('fillerColor'),
          textPosition: 'inside'
        }
      }));
      barGroup.add(new Rect(graphic.subPixelOptimizeRect({
        silent: true,
        shape: {
          x: 0,
          y: 0,
          width: size[0],
          height: size[1]
        },
        style: {
          stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),
          lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
          fill: 'rgba(0,0,0,0)'
        }
      })));
      var iconStr = dataZoomModel.get('handleIcon');
      each([0, 1], function(handleIndex) {
        var path = graphic.makePath(iconStr, {
          style: {strokeNoScale: true},
          rectHover: true,
          cursor: this._orient === 'vertical' ? 'ns-resize' : 'ew-resize',
          draggable: true,
          drift: bind(this._onDragMove, this, handleIndex),
          ondragend: bind(this._onDragEnd, this),
          onmouseover: bind(this._showDataInfo, this, true),
          onmouseout: bind(this._showDataInfo, this, false)
        }, {
          x: -0.5,
          y: 0,
          width: 1,
          height: 1
        }, 'center');
        var bRect = path.getBoundingRect();
        this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);
        this._handleWidth = bRect.width / bRect.height * this._handleHeight;
        path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());
        var handleColor = dataZoomModel.get('handleColor');
        if (handleColor != null) {
          path.style.fill = handleColor;
        }
        barGroup.add(handles[handleIndex] = path);
        var textStyleModel = dataZoomModel.textStyleModel;
        this.group.add(handleLabels[handleIndex] = new graphic.Text({
          silent: true,
          invisible: true,
          style: {
            x: 0,
            y: 0,
            text: '',
            textVerticalAlign: 'middle',
            textAlign: 'center',
            fill: textStyleModel.getTextColor(),
            textFont: textStyleModel.getFont()
          },
          z2: 10
        }));
      }, this);
    },
    _resetInterval: function() {
      var range = this._range = this.dataZoomModel.getPercentRange();
      var viewExtent = this._getViewExtent();
      this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];
    },
    _updateInterval: function(handleIndex, delta) {
      var handleEnds = this._handleEnds;
      var viewExtend = this._getViewExtent();
      sliderMove(delta, handleEnds, viewExtend, (handleIndex === 'all' || this.dataZoomModel.get('zoomLock')) ? 'rigid' : 'cross', handleIndex);
      this._range = asc([linearMap(handleEnds[0], viewExtend, [0, 100], true), linearMap(handleEnds[1], viewExtend, [0, 100], true)]);
    },
    _updateView: function() {
      var displaybles = this._displayables;
      var handleEnds = this._handleEnds;
      var handleInterval = asc(handleEnds.slice());
      var size = this._size;
      each([0, 1], function(handleIndex) {
        var handle = displaybles.handles[handleIndex];
        var handleHeight = this._handleHeight;
        handle.attr({
          scale: [handleHeight, handleHeight],
          position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]
        });
      }, this);
      displaybles.filler.setShape({
        x: handleInterval[0],
        y: 0,
        width: handleInterval[1] - handleInterval[0],
        height: size[1]
      });
      this._updateDataInfo();
    },
    _updateDataInfo: function() {
      var dataZoomModel = this.dataZoomModel;
      var displaybles = this._displayables;
      var handleLabels = displaybles.handleLabels;
      var orient = this._orient;
      var labelTexts = ['', ''];
      if (dataZoomModel.get('showDetail')) {
        var dataInterval;
        var axis;
        dataZoomModel.eachTargetAxis(function(dimNames, axisIndex) {
          if (!dataInterval) {
            dataInterval = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getDataValueWindow();
            axis = this.ecModel.getComponent(dimNames.axis, axisIndex).axis;
          }
        }, this);
        if (dataInterval) {
          labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
        }
      }
      var orderedHandleEnds = asc(this._handleEnds.slice());
      setLabel.call(this, 0);
      setLabel.call(this, 1);
      function setLabel(handleIndex) {
        var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);
        var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);
        var offset = this._handleWidth / 2 + LABEL_GAP;
        var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
        handleLabels[handleIndex].setStyle({
          x: textPoint[0],
          y: textPoint[1],
          textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,
          textAlign: orient === HORIZONTAL ? direction : 'center',
          text: labelTexts[handleIndex]
        });
      }
    },
    _formatLabel: function(value, axis) {
      var dataZoomModel = this.dataZoomModel;
      var labelFormatter = dataZoomModel.get('labelFormatter');
      if (zrUtil.isFunction(labelFormatter)) {
        return labelFormatter(value);
      }
      var labelPrecision = dataZoomModel.get('labelPrecision');
      if (labelPrecision == null || labelPrecision === 'auto') {
        labelPrecision = axis.getPixelPrecision();
      }
      value = (value == null && isNaN(value)) ? '' : (axis.type === 'category' || axis.type === 'time') ? axis.scale.getLabel(Math.round(value)) : value.toFixed(Math.min(labelPrecision, 20));
      if (zrUtil.isString(labelFormatter)) {
        value = labelFormatter.replace('{value}', value);
      }
      return value;
    },
    _showDataInfo: function(showOrHide) {
      showOrHide = this._dragging || showOrHide;
      var handleLabels = this._displayables.handleLabels;
      handleLabels[0].attr('invisible', !showOrHide);
      handleLabels[1].attr('invisible', !showOrHide);
    },
    _onDragMove: function(handleIndex, dx, dy) {
      this._dragging = true;
      var vertex = this._applyBarTransform([dx, dy], true);
      this._updateInterval(handleIndex, vertex[0]);
      this._updateView();
      if (this.dataZoomModel.get('realtime')) {
        this._dispatchZoomAction();
      }
    },
    _onDragEnd: function() {
      this._dragging = false;
      this._showDataInfo(false);
      this._dispatchZoomAction();
    },
    _dispatchZoomAction: function() {
      var range = this._range;
      this.api.dispatchAction({
        type: 'dataZoom',
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        start: range[0],
        end: range[1]
      });
    },
    _applyBarTransform: function(vertex, inverse) {
      var barTransform = this._displayables.barGroup.getLocalTransform();
      return graphic.applyTransform(vertex, barTransform, inverse);
    },
    _findCoordRect: function() {
      var targetInfo = this.getTargetInfo();
      var rect;
      if (targetInfo.cartesians.length) {
        rect = targetInfo.cartesians[0].model.coordinateSystem.getRect();
      } else {
        var width = this.api.getWidth();
        var height = this.api.getHeight();
        rect = {
          x: width * 0.2,
          y: height * 0.2,
          width: width * 0.6,
          height: height * 0.6
        };
      }
      return rect;
    }
  });
  function getOtherDim(thisDim) {
    return thisDim === 'x' ? 'y' : 'x';
  }
  module.exports = SliderZoomView;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/InsideZoomModel.js", ["./DataZoomModel", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./DataZoomModel').extend({
    type: 'dataZoom.inside',
    defaultOption: {zoomLock: false}
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/helper/RoamController.js", ["zrender/lib/mixin/Eventful", "zrender/lib/core/util", "zrender/lib/core/event", "./interactionMutex", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var Eventful = $__require('zrender/lib/mixin/Eventful');
  var zrUtil = $__require('zrender/lib/core/util');
  var eventTool = $__require('zrender/lib/core/event');
  var interactionMutex = $__require('./interactionMutex');
  function mousedown(e) {
    if (e.target && e.target.draggable) {
      return;
    }
    var x = e.offsetX;
    var y = e.offsetY;
    var rect = this.rectProvider && this.rectProvider();
    if (rect && rect.contain(x, y)) {
      this._x = x;
      this._y = y;
      this._dragging = true;
    }
  }
  function mousemove(e) {
    if (!this._dragging) {
      return;
    }
    eventTool.stop(e.event);
    if (e.gestureEvent !== 'pinch') {
      if (interactionMutex.isTaken(this._zr, 'globalPan')) {
        return;
      }
      var x = e.offsetX;
      var y = e.offsetY;
      var dx = x - this._x;
      var dy = y - this._y;
      this._x = x;
      this._y = y;
      var target = this.target;
      if (target) {
        var pos = target.position;
        pos[0] += dx;
        pos[1] += dy;
        target.dirty();
      }
      eventTool.stop(e.event);
      this.trigger('pan', dx, dy);
    }
  }
  function mouseup(e) {
    this._dragging = false;
  }
  function mousewheel(e) {
    var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;
    zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);
  }
  function pinch(e) {
    if (interactionMutex.isTaken(this._zr, 'globalPan')) {
      return;
    }
    var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
    zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);
  }
  function zoom(e, zoomDelta, zoomX, zoomY) {
    var rect = this.rectProvider && this.rectProvider();
    if (rect && rect.contain(zoomX, zoomY)) {
      eventTool.stop(e.event);
      var target = this.target;
      var zoomLimit = this.zoomLimit;
      if (target) {
        var pos = target.position;
        var scale = target.scale;
        var newZoom = this.zoom = this.zoom || 1;
        newZoom *= zoomDelta;
        if (zoomLimit) {
          var zoomMin = zoomLimit.min || 0;
          var zoomMax = zoomLimit.max || Infinity;
          newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
        }
        var zoomScale = newZoom / this.zoom;
        this.zoom = newZoom;
        pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);
        pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);
        scale[0] *= zoomScale;
        scale[1] *= zoomScale;
        target.dirty();
      }
      this.trigger('zoom', zoomDelta, zoomX, zoomY);
    }
  }
  function RoamController(zr, target, rectProvider) {
    this.target = target;
    this.rectProvider = rectProvider;
    this.zoomLimit;
    this.zoom;
    this._zr = zr;
    var bind = zrUtil.bind;
    var mousedownHandler = bind(mousedown, this);
    var mousemoveHandler = bind(mousemove, this);
    var mouseupHandler = bind(mouseup, this);
    var mousewheelHandler = bind(mousewheel, this);
    var pinchHandler = bind(pinch, this);
    Eventful.call(this);
    this.enable = function(controlType) {
      this.disable();
      if (controlType == null) {
        controlType = true;
      }
      if (controlType === true || (controlType === 'move' || controlType === 'pan')) {
        zr.on('mousedown', mousedownHandler);
        zr.on('mousemove', mousemoveHandler);
        zr.on('mouseup', mouseupHandler);
      }
      if (controlType === true || (controlType === 'scale' || controlType === 'zoom')) {
        zr.on('mousewheel', mousewheelHandler);
        zr.on('pinch', pinchHandler);
      }
    };
    this.disable = function() {
      zr.off('mousedown', mousedownHandler);
      zr.off('mousemove', mousemoveHandler);
      zr.off('mouseup', mouseupHandler);
      zr.off('mousewheel', mousewheelHandler);
      zr.off('pinch', pinchHandler);
    };
    this.dispose = this.disable;
    this.isDragging = function() {
      return this._dragging;
    };
    this.isPinching = function() {
      return this._pinching;
    };
  }
  zrUtil.mixin(RoamController, Eventful);
  module.exports = RoamController;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/util/throttle.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var lib = {};
  var ORIGIN_METHOD = '\0__throttleOriginMethod';
  var RATE = '\0__throttleRate';
  var THROTTLE_TYPE = '\0__throttleType';
  lib.throttle = function(fn, delay, debounce) {
    var currCall;
    var lastCall = 0;
    var lastExec = 0;
    var timer = null;
    var diff;
    var scope;
    var args;
    delay = delay || 0;
    function exec() {
      lastExec = (new Date()).getTime();
      timer = null;
      fn.apply(scope, args || []);
    }
    var cb = function() {
      currCall = (new Date()).getTime();
      scope = this;
      args = arguments;
      diff = currCall - (debounce ? lastCall : lastExec) - delay;
      clearTimeout(timer);
      if (debounce) {
        timer = setTimeout(exec, delay);
      } else {
        if (diff >= 0) {
          exec();
        } else {
          timer = setTimeout(exec, -diff);
        }
      }
      lastCall = currCall;
    };
    cb.clear = function() {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
    return cb;
  };
  lib.createOrUpdate = function(obj, fnAttr, rate, throttleType) {
    var fn = obj[fnAttr];
    if (!fn) {
      return;
    }
    var originFn = fn[ORIGIN_METHOD] || fn;
    var lastThrottleType = fn[THROTTLE_TYPE];
    var lastRate = fn[RATE];
    if (lastRate !== rate || lastThrottleType !== throttleType) {
      if (rate == null || !throttleType) {
        return (obj[fnAttr] = originFn);
      }
      fn = obj[fnAttr] = lib.throttle(originFn, rate, throttleType === 'debounce');
      fn[ORIGIN_METHOD] = originFn;
      fn[THROTTLE_TYPE] = throttleType;
      fn[RATE] = rate;
    }
    return fn;
  };
  lib.clear = function(obj, fnAttr) {
    var fn = obj[fnAttr];
    if (fn && fn[ORIGIN_METHOD]) {
      obj[fnAttr] = fn[ORIGIN_METHOD];
    }
  };
  module.exports = lib;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/roams.js", ["zrender/lib/core/util", "../../component/helper/RoamController", "../../util/throttle", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var RoamController = $__require('../../component/helper/RoamController');
  var throttle = $__require('../../util/throttle');
  var curry = zrUtil.curry;
  var ATTR = '\0_ec_dataZoom_roams';
  var roams = {
    register: function(api, dataZoomInfo) {
      var store = giveStore(api);
      var theDataZoomId = dataZoomInfo.dataZoomId;
      var theCoordId = dataZoomInfo.coordId;
      zrUtil.each(store, function(record, coordId) {
        var dataZoomInfos = record.dataZoomInfos;
        if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {
          delete dataZoomInfos[theDataZoomId];
          record.count--;
        }
      });
      cleanStore(store);
      var record = store[theCoordId];
      if (!record) {
        record = store[theCoordId] = {
          coordId: theCoordId,
          dataZoomInfos: {},
          count: 0
        };
        record.controller = createController(api, dataZoomInfo, record);
        record.dispatchAction = zrUtil.curry(dispatchAction, api);
      }
      var rect = dataZoomInfo.coordinateSystem.getRect().clone();
      record.controller.rectProvider = function() {
        return rect;
      };
      throttle.createOrUpdate(record, 'dispatchAction', dataZoomInfo.throttleRate, 'fixRate');
      !(record.dataZoomInfos[theDataZoomId]) && record.count++;
      record.dataZoomInfos[theDataZoomId] = dataZoomInfo;
    },
    unregister: function(api, dataZoomId) {
      var store = giveStore(api);
      zrUtil.each(store, function(record) {
        var dataZoomInfos = record.dataZoomInfos;
        if (dataZoomInfos[dataZoomId]) {
          delete dataZoomInfos[dataZoomId];
          record.count--;
        }
      });
      cleanStore(store);
    },
    shouldRecordRange: function(payload, dataZoomId) {
      if (payload && payload.type === 'dataZoom' && payload.batch) {
        for (var i = 0,
            len = payload.batch.length; i < len; i++) {
          if (payload.batch[i].dataZoomId === dataZoomId) {
            return false;
          }
        }
      }
      return true;
    },
    generateCoordId: function(coordModel) {
      return coordModel.type + '\0_' + coordModel.id;
    }
  };
  function giveStore(api) {
    var zr = api.getZr();
    return zr[ATTR] || (zr[ATTR] = {});
  }
  function createController(api, dataZoomInfo, newRecord) {
    var controller = new RoamController(api.getZr());
    controller.enable();
    controller.on('pan', curry(onPan, newRecord));
    controller.on('zoom', curry(onZoom, newRecord));
    return controller;
  }
  function cleanStore(store) {
    zrUtil.each(store, function(record, coordId) {
      if (!record.count) {
        record.controller.off('pan').off('zoom');
        delete store[coordId];
      }
    });
  }
  function onPan(record, dx, dy) {
    wrapAndDispatch(record, function(info) {
      return info.panGetRange(record.controller, dx, dy);
    });
  }
  function onZoom(record, scale, mouseX, mouseY) {
    wrapAndDispatch(record, function(info) {
      return info.zoomGetRange(record.controller, scale, mouseX, mouseY);
    });
  }
  function wrapAndDispatch(record, getRange) {
    var batch = [];
    zrUtil.each(record.dataZoomInfos, function(info) {
      var range = getRange(info);
      range && batch.push({
        dataZoomId: info.dataZoomId,
        start: range[0],
        end: range[1]
      });
    });
    record.dispatchAction(batch);
  }
  function dispatchAction(api, batch) {
    api.dispatchAction({
      type: 'dataZoom',
      batch: batch
    });
  }
  module.exports = roams;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/InsideZoomView.js", ["./DataZoomView", "zrender/lib/core/util", "../helper/sliderMove", "./roams", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var DataZoomView = $__require('./DataZoomView');
  var zrUtil = $__require('zrender/lib/core/util');
  var sliderMove = $__require('../helper/sliderMove');
  var roams = $__require('./roams');
  var bind = zrUtil.bind;
  var InsideZoomView = DataZoomView.extend({
    type: 'dataZoom.inside',
    init: function(ecModel, api) {
      this._range;
    },
    render: function(dataZoomModel, ecModel, api, payload) {
      InsideZoomView.superApply(this, 'render', arguments);
      if (roams.shouldRecordRange(payload, dataZoomModel.id)) {
        this._range = dataZoomModel.getPercentRange();
      }
      var coordInfoList = this.getTargetInfo().cartesians;
      var allCoordIds = zrUtil.map(coordInfoList, function(coordInfo) {
        return roams.generateCoordId(coordInfo.model);
      });
      zrUtil.each(coordInfoList, function(coordInfo) {
        var coordModel = coordInfo.model;
        roams.register(api, {
          coordId: roams.generateCoordId(coordModel),
          allCoordIds: allCoordIds,
          coordinateSystem: coordModel.coordinateSystem,
          dataZoomId: dataZoomModel.id,
          throttleRate: dataZoomModel.get('throttle', true),
          panGetRange: bind(this._onPan, this, coordInfo),
          zoomGetRange: bind(this._onZoom, this, coordInfo)
        });
      }, this);
    },
    dispose: function() {
      roams.unregister(this.api, this.dataZoomModel.id);
      InsideZoomView.superApply(this, 'dispose', arguments);
      this._range = null;
    },
    _onPan: function(coordInfo, controller, dx, dy) {
      return (this._range = panCartesian([dx, dy], this._range, controller, coordInfo));
    },
    _onZoom: function(coordInfo, controller, scale, mouseX, mouseY) {
      var dataZoomModel = this.dataZoomModel;
      if (dataZoomModel.option.zoomLock) {
        return this._range;
      }
      return (this._range = scaleCartesian(1 / scale, [mouseX, mouseY], this._range, controller, coordInfo, dataZoomModel));
    }
  });
  function panCartesian(pixelDeltas, range, controller, coordInfo) {
    range = range.slice();
    var axisModel = coordInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    var directionInfo = getDirectionInfo(pixelDeltas, axisModel, controller);
    var percentDelta = directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
    sliderMove(percentDelta, range, [0, 100], 'rigid');
    return range;
  }
  function scaleCartesian(scale, mousePoint, range, controller, coordInfo, dataZoomModel) {
    range = range.slice();
    var axisModel = coordInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    var directionInfo = getDirectionInfo(mousePoint, axisModel, controller);
    var mouse = directionInfo.pixel - directionInfo.pixelStart;
    var percentPoint = mouse / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
    scale = Math.max(scale, 0);
    range[0] = (range[0] - percentPoint) * scale + percentPoint;
    range[1] = (range[1] - percentPoint) * scale + percentPoint;
    return fixRange(range);
  }
  function getDirectionInfo(xy, axisModel, controller) {
    var axis = axisModel.axis;
    var rect = controller.rectProvider();
    var ret = {};
    if (axis.dim === 'x') {
      ret.pixel = xy[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = xy[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  }
  function fixRange(range) {
    var bound = [0, 100];
    !(range[0] <= bound[1]) && (range[0] = bound[1]);
    !(range[1] <= bound[1]) && (range[1] = bound[1]);
    !(range[0] >= bound[0]) && (range[0] = bound[0]);
    !(range[1] >= bound[0]) && (range[1] = bound[0]);
    return range;
  }
  module.exports = InsideZoomView;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom.js", ["./dataZoom/typeDefaulter", "./dataZoom/DataZoomModel", "./dataZoom/DataZoomView", "./dataZoom/SliderZoomModel", "./dataZoom/SliderZoomView", "./dataZoom/InsideZoomModel", "./dataZoom/InsideZoomView", "./dataZoom/dataZoomProcessor", "./dataZoom/dataZoomAction", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./dataZoom/typeDefaulter');
  $__require('./dataZoom/DataZoomModel');
  $__require('./dataZoom/DataZoomView');
  $__require('./dataZoom/SliderZoomModel');
  $__require('./dataZoom/SliderZoomView');
  $__require('./dataZoom/InsideZoomModel');
  $__require('./dataZoom/InsideZoomView');
  $__require('./dataZoom/dataZoomProcessor');
  $__require('./dataZoom/dataZoomAction');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMap/ContinuousModel.js", ["./VisualMapModel", "zrender/lib/core/util", "../../util/number", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var VisualMapModel = $__require('./VisualMapModel');
  var zrUtil = $__require('zrender/lib/core/util');
  var numberUtil = $__require('../../util/number');
  var DEFAULT_BAR_BOUND = [20, 140];
  var ContinuousModel = VisualMapModel.extend({
    type: 'visualMap.continuous',
    defaultOption: {
      align: 'auto',
      calculable: false,
      range: null,
      realtime: true,
      itemHeight: null,
      itemWidth: null,
      hoverLink: true,
      hoverLinkDataSize: null,
      hoverLinkOnHandle: true
    },
    optionUpdated: function(newOption, isInit) {
      ContinuousModel.superApply(this, 'optionUpdated', arguments);
      this.resetTargetSeries();
      this.resetExtent();
      this.resetVisual(function(mappingOption) {
        mappingOption.mappingMethod = 'linear';
        mappingOption.dataExtent = this.getExtent();
      });
      this._resetRange();
    },
    resetItemSize: function() {
      ContinuousModel.superApply(this, 'resetItemSize', arguments);
      var itemSize = this.itemSize;
      this._orient === 'horizontal' && itemSize.reverse();
      (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
      (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
    },
    _resetRange: function() {
      var dataExtent = this.getExtent();
      var range = this.option.range;
      if (!range || range.auto) {
        dataExtent.auto = 1;
        this.option.range = dataExtent;
      } else if (zrUtil.isArray(range)) {
        if (range[0] > range[1]) {
          range.reverse();
        }
        range[0] = Math.max(range[0], dataExtent[0]);
        range[1] = Math.min(range[1], dataExtent[1]);
      }
    },
    completeVisualOption: function() {
      VisualMapModel.prototype.completeVisualOption.apply(this, arguments);
      zrUtil.each(this.stateList, function(state) {
        var symbolSize = this.option.controller[state].symbolSize;
        if (symbolSize && symbolSize[0] !== symbolSize[1]) {
          symbolSize[0] = 0;
        }
      }, this);
    },
    setSelected: function(selected) {
      this.option.range = selected.slice();
      this._resetRange();
    },
    getSelected: function() {
      var dataExtent = this.getExtent();
      var dataInterval = numberUtil.asc((this.get('range') || []).slice());
      dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
      dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
      dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
      dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
      return dataInterval;
    },
    getValueState: function(value) {
      var range = this.option.range;
      var dataExtent = this.getExtent();
      return ((range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1])) ? 'inRange' : 'outOfRange';
    },
    findTargetDataIndices: function(range) {
      var result = [];
      this.eachTargetSeries(function(seriesModel) {
        var dataIndices = [];
        var data = seriesModel.getData();
        data.each(this.getDataDimension(data), function(value, dataIndex) {
          range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
        }, true, this);
        result.push({
          seriesId: seriesModel.id,
          dataIndex: dataIndices
        });
      }, this);
      return result;
    },
    getStops: function(seriesModel, getColorVisual) {
      var result = [];
      insertStopList(this, 'outOfRange', this.getExtent(), result);
      insertStopList(this, 'inRange', this.option.range.slice(), result);
      zrUtil.each(result, function(item) {
        item.color = getColorVisual(this, item.value, item.valueState);
      }, this);
      return result;
    }
  });
  function getColorStopValues(visualMapModel, valueState, dataExtent) {
    var mapping = visualMapModel.targetVisuals[valueState].color;
    if (!mapping) {
      return dataExtent.slice();
    }
    var count = mapping.option.visual.length;
    if (count <= 1 || dataExtent[0] === dataExtent[1]) {
      return dataExtent.slice();
    }
    var step = (dataExtent[1] - dataExtent[0]) / (count - 1);
    var value = dataExtent[0];
    var stopValues = [];
    for (var i = 0; i < count && value < dataExtent[1]; i++) {
      stopValues.push(value);
      value += step;
    }
    stopValues.push(dataExtent[1]);
    return stopValues;
  }
  function insertStopList(visualMapModel, valueState, dataExtent, result) {
    var stops = getColorStopValues(visualMapModel, valueState, dataExtent);
    zrUtil.each(stops, function(val) {
      var stop = {
        value: val,
        valueState: valueState
      };
      var inRange = 0;
      for (var i = 0; i < result.length; i++) {
        inRange |= result[i].valueState === 'inRange';
        if (val < result[i].value) {
          result.splice(i, 0, stop);
          return;
        }
        inRange && (result[i].valueState = 'inRange');
      }
      result.push(stop);
    });
  }
  module.exports = ContinuousModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/helper/sliderMove.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(delta, handleEnds, extent, mode, handleIndex) {
    if (!delta) {
      return handleEnds;
    }
    if (mode === 'rigid') {
      delta = getRealDelta(delta, handleEnds, extent);
      handleEnds[0] += delta;
      handleEnds[1] += delta;
    } else {
      delta = getRealDelta(delta, handleEnds[handleIndex], extent);
      handleEnds[handleIndex] += delta;
      if (mode === 'push' && handleEnds[0] > handleEnds[1]) {
        handleEnds[1 - handleIndex] = handleEnds[handleIndex];
      }
    }
    return handleEnds;
    function getRealDelta(delta, handleEnds, extent) {
      var handleMinMax = !handleEnds.length ? [handleEnds, handleEnds] : handleEnds.slice();
      handleEnds[0] > handleEnds[1] && handleMinMax.reverse();
      if (delta < 0 && handleMinMax[0] + delta < extent[0]) {
        delta = extent[0] - handleMinMax[0];
      }
      if (delta > 0 && handleMinMax[1] + delta > extent[1]) {
        delta = extent[1] - handleMinMax[1];
      }
      return delta;
    }
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMap/ContinuousView.js", ["./VisualMapView", "../../util/graphic", "zrender/lib/core/util", "../../util/number", "../helper/sliderMove", "zrender/lib/graphic/LinearGradient", "./helper", "../../util/model", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var VisualMapView = $__require('./VisualMapView');
  var graphic = $__require('../../util/graphic');
  var zrUtil = $__require('zrender/lib/core/util');
  var numberUtil = $__require('../../util/number');
  var sliderMove = $__require('../helper/sliderMove');
  var LinearGradient = $__require('zrender/lib/graphic/LinearGradient');
  var helper = $__require('./helper');
  var modelUtil = $__require('../../util/model');
  var linearMap = numberUtil.linearMap;
  var each = zrUtil.each;
  var mathMin = Math.min;
  var mathMax = Math.max;
  var HOVER_LINK_SIZE = 12;
  var HOVER_LINK_OUT = 6;
  var ContinuousView = VisualMapView.extend({
    type: 'visualMap.continuous',
    init: function() {
      ContinuousView.superApply(this, 'init', arguments);
      this._shapes = {};
      this._dataInterval = [];
      this._handleEnds = [];
      this._orient;
      this._useHandle;
      this._hoverLinkDataIndices = [];
      this._dragging;
      this._hovering;
    },
    doRender: function(visualMapModel, ecModel, api, payload) {
      if (!payload || payload.type !== 'selectDataRange' || payload.from !== this.uid) {
        this._buildView();
      }
    },
    _buildView: function() {
      this.group.removeAll();
      var visualMapModel = this.visualMapModel;
      var thisGroup = this.group;
      this._orient = visualMapModel.get('orient');
      this._useHandle = visualMapModel.get('calculable');
      this._resetInterval();
      this._renderBar(thisGroup);
      var dataRangeText = visualMapModel.get('text');
      this._renderEndsText(thisGroup, dataRangeText, 0);
      this._renderEndsText(thisGroup, dataRangeText, 1);
      this._updateView(true);
      this.renderBackground(thisGroup);
      this._updateView();
      this._enableHoverLinkToSeries();
      this._enableHoverLinkFromSeries();
      this.positionGroup(thisGroup);
    },
    _renderEndsText: function(group, dataRangeText, endsIndex) {
      if (!dataRangeText) {
        return;
      }
      var text = dataRangeText[1 - endsIndex];
      text = text != null ? text + '' : '';
      var visualMapModel = this.visualMapModel;
      var textGap = visualMapModel.get('textGap');
      var itemSize = visualMapModel.itemSize;
      var barGroup = this._shapes.barGroup;
      var position = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);
      var align = this._applyTransform(endsIndex === 0 ? 'bottom' : 'top', barGroup);
      var orient = this._orient;
      var textStyleModel = this.visualMapModel.textStyleModel;
      this.group.add(new graphic.Text({style: {
          x: position[0],
          y: position[1],
          textVerticalAlign: orient === 'horizontal' ? 'middle' : align,
          textAlign: orient === 'horizontal' ? align : 'center',
          text: text,
          textFont: textStyleModel.getFont(),
          fill: textStyleModel.getTextColor()
        }}));
    },
    _renderBar: function(targetGroup) {
      var visualMapModel = this.visualMapModel;
      var shapes = this._shapes;
      var itemSize = visualMapModel.itemSize;
      var orient = this._orient;
      var useHandle = this._useHandle;
      var itemAlign = helper.getItemAlign(visualMapModel, this.api, itemSize);
      var barGroup = shapes.barGroup = this._createBarGroup(itemAlign);
      barGroup.add(shapes.outOfRange = createPolygon());
      barGroup.add(shapes.inRange = createPolygon(null, useHandle ? 'move' : null, zrUtil.bind(this._dragHandle, this, 'all', false), zrUtil.bind(this._dragHandle, this, 'all', true)));
      var textRect = visualMapModel.textStyleModel.getTextRect('');
      var textSize = mathMax(textRect.width, textRect.height);
      if (useHandle) {
        shapes.handleThumbs = [];
        shapes.handleLabels = [];
        shapes.handleLabelPoints = [];
        this._createHandle(barGroup, 0, itemSize, textSize, orient, itemAlign);
        this._createHandle(barGroup, 1, itemSize, textSize, orient, itemAlign);
      }
      this._createIndicator(barGroup, itemSize, textSize, orient);
      targetGroup.add(barGroup);
    },
    _createHandle: function(barGroup, handleIndex, itemSize, textSize, orient) {
      var onDrift = zrUtil.bind(this._dragHandle, this, handleIndex, false);
      var onDragEnd = zrUtil.bind(this._dragHandle, this, handleIndex, true);
      var handleThumb = createPolygon(createHandlePoints(handleIndex, textSize), 'move', onDrift, onDragEnd);
      handleThumb.position[0] = itemSize[0];
      barGroup.add(handleThumb);
      var textStyleModel = this.visualMapModel.textStyleModel;
      var handleLabel = new graphic.Text({
        draggable: true,
        drift: onDrift,
        ondragend: onDragEnd,
        style: {
          x: 0,
          y: 0,
          text: '',
          textFont: textStyleModel.getFont(),
          fill: textStyleModel.getTextColor()
        }
      });
      this.group.add(handleLabel);
      var handleLabelPoint = [orient === 'horizontal' ? textSize / 2 : textSize * 1.5, orient === 'horizontal' ? (handleIndex === 0 ? -(textSize * 1.5) : (textSize * 1.5)) : (handleIndex === 0 ? -textSize / 2 : textSize / 2)];
      var shapes = this._shapes;
      shapes.handleThumbs[handleIndex] = handleThumb;
      shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
      shapes.handleLabels[handleIndex] = handleLabel;
    },
    _createIndicator: function(barGroup, itemSize, textSize, orient) {
      var indicator = createPolygon([[0, 0]], 'move');
      indicator.position[0] = itemSize[0];
      indicator.attr({
        invisible: true,
        silent: true
      });
      barGroup.add(indicator);
      var textStyleModel = this.visualMapModel.textStyleModel;
      var indicatorLabel = new graphic.Text({
        silent: true,
        invisible: true,
        style: {
          x: 0,
          y: 0,
          text: '',
          textFont: textStyleModel.getFont(),
          fill: textStyleModel.getTextColor()
        }
      });
      this.group.add(indicatorLabel);
      var indicatorLabelPoint = [orient === 'horizontal' ? textSize / 2 : HOVER_LINK_OUT + 3, 0];
      var shapes = this._shapes;
      shapes.indicator = indicator;
      shapes.indicatorLabel = indicatorLabel;
      shapes.indicatorLabelPoint = indicatorLabelPoint;
    },
    _dragHandle: function(handleIndex, isEnd, dx, dy) {
      if (!this._useHandle) {
        return;
      }
      this._dragging = !isEnd;
      if (!isEnd) {
        var vertex = this._applyTransform([dx, dy], this._shapes.barGroup, true);
        this._updateInterval(handleIndex, vertex[1]);
        this._updateView();
      }
      if (isEnd === !this.visualMapModel.get('realtime')) {
        this.api.dispatchAction({
          type: 'selectDataRange',
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        });
      }
      if (isEnd) {
        !this._hovering && this._clearHoverLinkToSeries();
      } else if (useHoverLinkOnHandle(this.visualMapModel)) {
        this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
      }
    },
    _resetInterval: function() {
      var visualMapModel = this.visualMapModel;
      var dataInterval = this._dataInterval = visualMapModel.getSelected();
      var dataExtent = visualMapModel.getExtent();
      var sizeExtent = [0, visualMapModel.itemSize[1]];
      this._handleEnds = [linearMap(dataInterval[0], dataExtent, sizeExtent, true), linearMap(dataInterval[1], dataExtent, sizeExtent, true)];
    },
    _updateInterval: function(handleIndex, delta) {
      delta = delta || 0;
      var visualMapModel = this.visualMapModel;
      var handleEnds = this._handleEnds;
      sliderMove(delta, handleEnds, [0, visualMapModel.itemSize[1]], handleIndex === 'all' ? 'rigid' : 'push', handleIndex);
      var dataExtent = visualMapModel.getExtent();
      var sizeExtent = [0, visualMapModel.itemSize[1]];
      this._dataInterval = [linearMap(handleEnds[0], sizeExtent, dataExtent, true), linearMap(handleEnds[1], sizeExtent, dataExtent, true)];
    },
    _updateView: function(forSketch) {
      var visualMapModel = this.visualMapModel;
      var dataExtent = visualMapModel.getExtent();
      var shapes = this._shapes;
      var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
      var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;
      var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, 'inRange');
      var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, 'outOfRange');
      shapes.inRange.setStyle({
        fill: visualInRange.barColor,
        opacity: visualInRange.opacity
      }).setShape('points', visualInRange.barPoints);
      shapes.outOfRange.setStyle({
        fill: visualOutOfRange.barColor,
        opacity: visualOutOfRange.opacity
      }).setShape('points', visualOutOfRange.barPoints);
      this._updateHandle(inRangeHandleEnds, visualInRange);
    },
    _createBarVisual: function(dataInterval, dataExtent, handleEnds, forceState) {
      var opts = {
        forceState: forceState,
        convertOpacityToAlpha: true
      };
      var colorStops = this._makeColorGradient(dataInterval, opts);
      var symbolSizes = [this.getControllerVisual(dataInterval[0], 'symbolSize', opts), this.getControllerVisual(dataInterval[1], 'symbolSize', opts)];
      var barPoints = this._createBarPoints(handleEnds, symbolSizes);
      return {
        barColor: new LinearGradient(0, 0, 1, 1, colorStops),
        barPoints: barPoints,
        handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]
      };
    },
    _makeColorGradient: function(dataInterval, opts) {
      var sampleNumber = 100;
      var colorStops = [];
      var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
      colorStops.push({
        color: this.getControllerVisual(dataInterval[0], 'color', opts),
        offset: 0
      });
      for (var i = 1; i < sampleNumber; i++) {
        var currValue = dataInterval[0] + step * i;
        if (currValue > dataInterval[1]) {
          break;
        }
        colorStops.push({
          color: this.getControllerVisual(currValue, 'color', opts),
          offset: i / sampleNumber
        });
      }
      colorStops.push({
        color: this.getControllerVisual(dataInterval[1], 'color', opts),
        offset: 1
      });
      return colorStops;
    },
    _createBarPoints: function(handleEnds, symbolSizes) {
      var itemSize = this.visualMapModel.itemSize;
      return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]];
    },
    _createBarGroup: function(itemAlign) {
      var orient = this._orient;
      var inverse = this.visualMapModel.get('inverse');
      return new graphic.Group((orient === 'horizontal' && !inverse) ? {
        scale: itemAlign === 'bottom' ? [1, 1] : [-1, 1],
        rotation: Math.PI / 2
      } : (orient === 'horizontal' && inverse) ? {
        scale: itemAlign === 'bottom' ? [-1, 1] : [1, 1],
        rotation: -Math.PI / 2
      } : (orient === 'vertical' && !inverse) ? {scale: itemAlign === 'left' ? [1, -1] : [-1, -1]} : {scale: itemAlign === 'left' ? [1, 1] : [-1, 1]});
    },
    _updateHandle: function(handleEnds, visualInRange) {
      if (!this._useHandle) {
        return;
      }
      var shapes = this._shapes;
      var visualMapModel = this.visualMapModel;
      var handleThumbs = shapes.handleThumbs;
      var handleLabels = shapes.handleLabels;
      each([0, 1], function(handleIndex) {
        var handleThumb = handleThumbs[handleIndex];
        handleThumb.setStyle('fill', visualInRange.handlesColor[handleIndex]);
        handleThumb.position[1] = handleEnds[handleIndex];
        var textPoint = graphic.applyTransform(shapes.handleLabelPoints[handleIndex], graphic.getTransform(handleThumb, this.group));
        handleLabels[handleIndex].setStyle({
          x: textPoint[0],
          y: textPoint[1],
          text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
          textVerticalAlign: 'middle',
          textAlign: this._applyTransform(this._orient === 'horizontal' ? (handleIndex === 0 ? 'bottom' : 'top') : 'left', shapes.barGroup)
        });
      }, this);
    },
    _showIndicator: function(cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
      var visualMapModel = this.visualMapModel;
      var dataExtent = visualMapModel.getExtent();
      var itemSize = visualMapModel.itemSize;
      var sizeExtent = [0, itemSize[1]];
      var pos = linearMap(cursorValue, dataExtent, sizeExtent, true);
      var shapes = this._shapes;
      var indicator = shapes.indicator;
      if (!indicator) {
        return;
      }
      indicator.position[1] = pos;
      indicator.attr('invisible', false);
      indicator.setShape('points', createIndicatorPoints(!!rangeSymbol, halfHoverLinkSize, pos, itemSize[1]));
      var opts = {convertOpacityToAlpha: true};
      var color = this.getControllerVisual(cursorValue, 'color', opts);
      indicator.setStyle('fill', color);
      var textPoint = graphic.applyTransform(shapes.indicatorLabelPoint, graphic.getTransform(indicator, this.group));
      var indicatorLabel = shapes.indicatorLabel;
      indicatorLabel.attr('invisible', false);
      var align = this._applyTransform('left', shapes.barGroup);
      var orient = this._orient;
      indicatorLabel.setStyle({
        text: (rangeSymbol ? rangeSymbol : '') + visualMapModel.formatValueText(textValue),
        textVerticalAlign: orient === 'horizontal' ? align : 'middle',
        textAlign: orient === 'horizontal' ? 'center' : align,
        x: textPoint[0],
        y: textPoint[1]
      });
    },
    _enableHoverLinkToSeries: function() {
      var self = this;
      this._shapes.barGroup.on('mousemove', function(e) {
        self._hovering = true;
        if (!self._dragging) {
          var itemSize = self.visualMapModel.itemSize;
          var pos = self._applyTransform([e.offsetX, e.offsetY], self._shapes.barGroup, true, true);
          pos[1] = mathMin(mathMax(0, pos[1]), itemSize[1]);
          self._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
        }
      }).on('mouseout', function() {
        self._hovering = false;
        !self._dragging && self._clearHoverLinkToSeries();
      });
    },
    _enableHoverLinkFromSeries: function() {
      var zr = this.api.getZr();
      if (this.visualMapModel.option.hoverLink) {
        zr.on('mouseover', this._hoverLinkFromSeriesMouseOver, this);
        zr.on('mouseout', this._hideIndicator, this);
      } else {
        this._clearHoverLinkFromSeries();
      }
    },
    _doHoverLinkToSeries: function(cursorPos, hoverOnBar) {
      var visualMapModel = this.visualMapModel;
      var itemSize = visualMapModel.itemSize;
      if (!visualMapModel.option.hoverLink) {
        return;
      }
      var sizeExtent = [0, itemSize[1]];
      var dataExtent = visualMapModel.getExtent();
      cursorPos = mathMin(mathMax(sizeExtent[0], cursorPos), sizeExtent[1]);
      var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
      var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
      var cursorValue = linearMap(cursorPos, sizeExtent, dataExtent, true);
      var valueRange = [linearMap(hoverRange[0], sizeExtent, dataExtent, true), linearMap(hoverRange[1], sizeExtent, dataExtent, true)];
      hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
      hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);
      if (hoverOnBar) {
        if (valueRange[0] === -Infinity) {
          this._showIndicator(cursorValue, valueRange[1], '< ', halfHoverLinkSize);
        } else if (valueRange[1] === Infinity) {
          this._showIndicator(cursorValue, valueRange[0], '> ', halfHoverLinkSize);
        } else {
          this._showIndicator(cursorValue, cursorValue, ' ', halfHoverLinkSize);
        }
      }
      var oldBatch = this._hoverLinkDataIndices;
      var newBatch = [];
      if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
        newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
      }
      var resultBatches = modelUtil.compressBatches(oldBatch, newBatch);
      this._dispatchHighDown('downplay', resultBatches[0]);
      this._dispatchHighDown('highlight', resultBatches[1]);
    },
    _hoverLinkFromSeriesMouseOver: function(e) {
      var el = e.target;
      if (!el || el.dataIndex == null) {
        return;
      }
      var dataModel = el.dataModel || this.ecModel.getSeriesByIndex(el.seriesIndex);
      var data = dataModel.getData(el.dataType);
      var dim = data.getDimension(this.visualMapModel.getDataDimension(data));
      var value = data.get(dim, el.dataIndex, true);
      if (!isNaN(value)) {
        this._showIndicator(value, value);
      }
    },
    _hideIndicator: function() {
      var shapes = this._shapes;
      shapes.indicator && shapes.indicator.attr('invisible', true);
      shapes.indicatorLabel && shapes.indicatorLabel.attr('invisible', true);
    },
    _clearHoverLinkToSeries: function() {
      this._hideIndicator();
      var indices = this._hoverLinkDataIndices;
      this._dispatchHighDown('downplay', indices);
      indices.length = 0;
    },
    _clearHoverLinkFromSeries: function() {
      this._hideIndicator();
      var zr = this.api.getZr();
      zr.off('mouseover', this._hoverLinkFromSeriesMouseOver);
      zr.off('mouseout', this._hideIndicator);
    },
    _applyTransform: function(vertex, element, inverse, global) {
      var transform = graphic.getTransform(element, global ? null : this.group);
      return graphic[zrUtil.isArray(vertex) ? 'applyTransform' : 'transformDirection'](vertex, transform, inverse);
    },
    _dispatchHighDown: function(type, batch) {
      batch && batch.length && this.api.dispatchAction({
        type: type,
        batch: batch
      });
    },
    dispose: function() {
      this._clearHoverLinkFromSeries();
      this._clearHoverLinkToSeries();
    },
    remove: function() {
      this._clearHoverLinkFromSeries();
      this._clearHoverLinkToSeries();
    }
  });
  function createPolygon(points, cursor, onDrift, onDragEnd) {
    return new graphic.Polygon({
      shape: {points: points},
      draggable: !!onDrift,
      cursor: cursor,
      drift: onDrift,
      ondragend: onDragEnd
    });
  }
  function createHandlePoints(handleIndex, textSize) {
    return handleIndex === 0 ? [[0, 0], [textSize, 0], [textSize, -textSize]] : [[0, 0], [textSize, 0], [textSize, textSize]];
  }
  function createIndicatorPoints(isRange, halfHoverLinkSize, pos, extentMax) {
    return isRange ? [[0, -mathMin(halfHoverLinkSize, mathMax(pos, 0))], [HOVER_LINK_OUT, 0], [0, mathMin(halfHoverLinkSize, mathMax(extentMax - pos, 0))]] : [[0, 0], [5, -5], [5, 5]];
  }
  function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
    var halfHoverLinkSize = HOVER_LINK_SIZE / 2;
    var hoverLinkDataSize = visualMapModel.get('hoverLinkDataSize');
    if (hoverLinkDataSize) {
      halfHoverLinkSize = linearMap(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
    }
    return halfHoverLinkSize;
  }
  function useHoverLinkOnHandle(visualMapModel) {
    return !visualMapModel.get('realtime') && visualMapModel.get('hoverLinkOnHandle');
  }
  module.exports = ContinuousView;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMapContinuous.js", ["../echarts", "./visualMap/preprocessor", "./visualMap/typeDefaulter", "./visualMap/visualEncoding", "./visualMap/ContinuousModel", "./visualMap/ContinuousView", "./visualMap/visualMapAction", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../echarts').registerPreprocessor($__require('./visualMap/preprocessor'));
  $__require('./visualMap/typeDefaulter');
  $__require('./visualMap/visualEncoding');
  $__require('./visualMap/ContinuousModel');
  $__require('./visualMap/ContinuousView');
  $__require('./visualMap/visualMapAction');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMap/preprocessor.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var each = zrUtil.each;
  module.exports = function(option) {
    var visualMap = option && option.visualMap;
    if (!zrUtil.isArray(visualMap)) {
      visualMap = visualMap ? [visualMap] : [];
    }
    each(visualMap, function(opt) {
      if (!opt) {
        return;
      }
      if (has(opt, 'splitList') && !has(opt, 'pieces')) {
        opt.pieces = opt.splitList;
        delete opt.splitList;
      }
      var pieces = opt.pieces;
      if (pieces && zrUtil.isArray(pieces)) {
        each(pieces, function(piece) {
          if (zrUtil.isObject(piece)) {
            if (has(piece, 'start') && !has(piece, 'min')) {
              piece.min = piece.start;
            }
            if (has(piece, 'end') && !has(piece, 'max')) {
              piece.max = piece.end;
            }
          }
        });
      }
    });
  };
  function has(obj, name) {
    return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMap/typeDefaulter.js", ["../../model/Component", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../../model/Component').registerSubTypeDefaulter('visualMap', function(option) {
    return (!option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable)) ? 'continuous' : 'piecewise';
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMap/visualEncoding.js", ["../../echarts", "../../visual/visualSolution", "../../visual/VisualMapping", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../../echarts');
  var visualSolution = $__require('../../visual/visualSolution');
  var VisualMapping = $__require('../../visual/VisualMapping');
  echarts.registerVisual(echarts.PRIORITY.VISUAL.COMPONENT, function(ecModel) {
    ecModel.eachComponent('visualMap', function(visualMapModel) {
      processSingleVisualMap(visualMapModel, ecModel);
    });
    prepareVisualMeta(ecModel);
  });
  function processSingleVisualMap(visualMapModel, ecModel) {
    visualMapModel.eachTargetSeries(function(seriesModel) {
      var data = seriesModel.getData();
      visualSolution.applyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, data, visualMapModel.getValueState, visualMapModel, visualMapModel.getDataDimension(data));
    });
  }
  function prepareVisualMeta(ecModel) {
    ecModel.eachSeries(function(seriesModel) {
      var data = seriesModel.getData();
      var visualMetaList = [];
      ecModel.eachComponent('visualMap', function(visualMapModel) {
        if (visualMapModel.isTargetSeries(seriesModel)) {
          var visualMeta = {};
          visualMetaList.push(visualMeta);
          visualMeta.stops = visualMapModel.getStops(seriesModel, getColorVisual);
          visualMeta.dimension = visualMapModel.getDataDimension(data);
        }
      });
      seriesModel.getData().setVisual('visualMeta', visualMetaList);
    });
  }
  function getColorVisual(visualMapModel, value, valueState) {
    var mappings = visualMapModel.targetVisuals[valueState];
    var visualTypes = VisualMapping.prepareVisualTypes(mappings);
    var resultVisual = {};
    for (var i = 0,
        len = visualTypes.length; i < len; i++) {
      var type = visualTypes[i];
      var mapping = mappings[type === 'colorAlpha' ? '__alphaForOpacity' : type];
      mapping && mapping.applyVisual(value, getVisual, setVisual);
    }
    return resultVisual.color;
    function getVisual(key) {
      return resultVisual[key];
    }
    function setVisual(key, value) {
      resultVisual[key] = value;
    }
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/visual/visualDefault.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var visualDefault = {get: function(visualType, key, isCategory) {
      var value = zrUtil.clone((defaultOption[visualType] || {})[key]);
      return isCategory ? (zrUtil.isArray(value) ? value[value.length - 1] : value) : value;
    }};
  var defaultOption = {
    color: {
      active: ['#006edd', '#e0ffff'],
      inactive: ['rgba(0,0,0,0)']
    },
    colorHue: {
      active: [0, 360],
      inactive: [0, 0]
    },
    colorSaturation: {
      active: [0.3, 1],
      inactive: [0, 0]
    },
    colorLightness: {
      active: [0.9, 0.5],
      inactive: [0, 0]
    },
    colorAlpha: {
      active: [0.3, 1],
      inactive: [0, 0]
    },
    opacity: {
      active: [0.3, 1],
      inactive: [0, 0]
    },
    symbol: {
      active: ['circle', 'roundRect', 'diamond'],
      inactive: ['none']
    },
    symbolSize: {
      active: [10, 50],
      inactive: [0, 0]
    }
  };
  module.exports = visualDefault;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/visual/visualSolution.js", ["zrender/lib/core/util", "./VisualMapping", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var VisualMapping = $__require('./VisualMapping');
  var each = zrUtil.each;
  function hasKeys(obj) {
    if (obj) {
      for (var name in obj) {
        if (obj.hasOwnProperty(name)) {
          return true;
        }
      }
    }
  }
  var visualSolution = {
    createVisualMappings: function(option, stateList, supplementVisualOption) {
      var visualMappings = {};
      each(stateList, function(state) {
        var mappings = visualMappings[state] = createMappings();
        each(option[state], function(visualData, visualType) {
          if (!VisualMapping.isValidType(visualType)) {
            return;
          }
          var mappingOption = {
            type: visualType,
            visual: visualData
          };
          supplementVisualOption && supplementVisualOption(mappingOption, state);
          mappings[visualType] = new VisualMapping(mappingOption);
          if (visualType === 'opacity') {
            mappingOption = zrUtil.clone(mappingOption);
            mappingOption.type = 'colorAlpha';
            mappings.__hidden.__alphaForOpacity = new VisualMapping(mappingOption);
          }
        });
      });
      return visualMappings;
      function createMappings() {
        var Creater = function() {};
        Creater.prototype.__hidden = Creater.prototype;
        var obj = new Creater();
        return obj;
      }
    },
    replaceVisualOption: function(thisOption, newOption, keys) {
      var has;
      zrUtil.each(keys, function(key) {
        if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
          has = true;
        }
      });
      has && zrUtil.each(keys, function(key) {
        if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
          thisOption[key] = zrUtil.clone(newOption[key]);
        } else {
          delete thisOption[key];
        }
      });
    },
    applyVisual: function(stateList, visualMappings, data, getValueState, scope, dimension) {
      var visualTypesMap = {};
      zrUtil.each(stateList, function(state) {
        var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);
        visualTypesMap[state] = visualTypes;
      });
      var dataIndex;
      function getVisual(key) {
        return data.getItemVisual(dataIndex, key);
      }
      function setVisual(key, value) {
        data.setItemVisual(dataIndex, key, value);
      }
      if (dimension == null) {
        data.each(eachItem, true);
      } else {
        data.each([dimension], eachItem, true);
      }
      function eachItem(valueOrIndex, index) {
        dataIndex = dimension == null ? valueOrIndex : index;
        var valueState = getValueState.call(scope, valueOrIndex);
        var mappings = visualMappings[valueState];
        var visualTypes = visualTypesMap[valueState];
        for (var i = 0,
            len = visualTypes.length; i < len; i++) {
          var type = visualTypes[i];
          mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);
        }
      }
    }
  };
  module.exports = visualSolution;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMap/VisualMapModel.js", ["../../echarts", "zrender/lib/core/util", "zrender/lib/core/env", "../../visual/visualDefault", "../../visual/VisualMapping", "../../visual/visualSolution", "../../util/model", "../../util/number", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../../echarts');
  var zrUtil = $__require('zrender/lib/core/util');
  var env = $__require('zrender/lib/core/env');
  var visualDefault = $__require('../../visual/visualDefault');
  var VisualMapping = $__require('../../visual/VisualMapping');
  var visualSolution = $__require('../../visual/visualSolution');
  var mapVisual = VisualMapping.mapVisual;
  var modelUtil = $__require('../../util/model');
  var eachVisual = VisualMapping.eachVisual;
  var numberUtil = $__require('../../util/number');
  var isArray = zrUtil.isArray;
  var each = zrUtil.each;
  var asc = numberUtil.asc;
  var linearMap = numberUtil.linearMap;
  var noop = zrUtil.noop;
  var DEFAULT_COLOR = ['#f6efa6', '#d88273', '#bf444c'];
  var VisualMapModel = echarts.extendComponentModel({
    type: 'visualMap',
    dependencies: ['series'],
    stateList: ['inRange', 'outOfRange'],
    replacableOptionKeys: ['inRange', 'outOfRange', 'target', 'controller', 'color'],
    dataBound: [-Infinity, Infinity],
    layoutMode: {
      type: 'box',
      ignoreSize: true
    },
    defaultOption: {
      show: true,
      zlevel: 0,
      z: 4,
      seriesIndex: null,
      min: 0,
      max: 200,
      dimension: null,
      inRange: null,
      outOfRange: null,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: false,
      orient: 'vertical',
      backgroundColor: 'rgba(0,0,0,0)',
      borderColor: '#ccc',
      contentColor: '#5793f3',
      inactiveColor: '#aaa',
      borderWidth: 0,
      padding: 5,
      textGap: 10,
      precision: 0,
      color: null,
      formatter: null,
      text: null,
      textStyle: {color: '#333'}
    },
    init: function(option, parentModel, ecModel) {
      this._dataExtent;
      this.targetVisuals = {};
      this.controllerVisuals = {};
      this.textStyleModel;
      this.itemSize;
      this.mergeDefaultAndTheme(option, ecModel);
    },
    optionUpdated: function(newOption, isInit) {
      var thisOption = this.option;
      if (!env.canvasSupported) {
        thisOption.realtime = false;
      }
      !isInit && visualSolution.replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
      this.textStyleModel = this.getModel('textStyle');
      this.resetItemSize();
      this.completeVisualOption();
    },
    resetVisual: function(supplementVisualOption) {
      var stateList = this.stateList;
      supplementVisualOption = zrUtil.bind(supplementVisualOption, this);
      this.controllerVisuals = visualSolution.createVisualMappings(this.option.controller, stateList, supplementVisualOption);
      this.targetVisuals = visualSolution.createVisualMappings(this.option.target, stateList, supplementVisualOption);
    },
    resetTargetSeries: function() {
      var thisOption = this.option;
      var allSeriesIndex = thisOption.seriesIndex == null;
      thisOption.seriesIndex = allSeriesIndex ? [] : modelUtil.normalizeToArray(thisOption.seriesIndex);
      allSeriesIndex && this.ecModel.eachSeries(function(seriesModel, index) {
        thisOption.seriesIndex.push(index);
      });
    },
    eachTargetSeries: function(callback, context) {
      zrUtil.each(this.option.seriesIndex, function(seriesIndex) {
        callback.call(context, this.ecModel.getSeriesByIndex(seriesIndex));
      }, this);
    },
    isTargetSeries: function(seriesModel) {
      var is = false;
      this.eachTargetSeries(function(model) {
        model === seriesModel && (is = true);
      });
      return is;
    },
    formatValueText: function(value, isCategory, edgeSymbols) {
      var option = this.option;
      var precision = option.precision;
      var dataBound = this.dataBound;
      var formatter = option.formatter;
      var isMinMax;
      var textValue;
      edgeSymbols = edgeSymbols || ['<', '>'];
      if (zrUtil.isArray(value)) {
        value = value.slice();
        isMinMax = true;
      }
      textValue = isCategory ? value : (isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value));
      if (zrUtil.isString(formatter)) {
        return formatter.replace('{value}', isMinMax ? textValue[0] : textValue).replace('{value2}', isMinMax ? textValue[1] : textValue);
      } else if (zrUtil.isFunction(formatter)) {
        return isMinMax ? formatter(value[0], value[1]) : formatter(value);
      }
      if (isMinMax) {
        if (value[0] === dataBound[0]) {
          return edgeSymbols[0] + ' ' + textValue[1];
        } else if (value[1] === dataBound[1]) {
          return edgeSymbols[1] + ' ' + textValue[0];
        } else {
          return textValue[0] + ' - ' + textValue[1];
        }
      } else {
        return textValue;
      }
      function toFixed(val) {
        return val === dataBound[0] ? 'min' : val === dataBound[1] ? 'max' : (+val).toFixed(precision);
      }
    },
    resetExtent: function() {
      var thisOption = this.option;
      var extent = asc([thisOption.min, thisOption.max]);
      this._dataExtent = extent;
    },
    getDataDimension: function(list) {
      var optDim = this.option.dimension;
      return optDim != null ? optDim : list.dimensions.length - 1;
    },
    getExtent: function() {
      return this._dataExtent.slice();
    },
    completeVisualOption: function() {
      var thisOption = this.option;
      var base = {
        inRange: thisOption.inRange,
        outOfRange: thisOption.outOfRange
      };
      var target = thisOption.target || (thisOption.target = {});
      var controller = thisOption.controller || (thisOption.controller = {});
      zrUtil.merge(target, base);
      zrUtil.merge(controller, base);
      var isCategory = this.isCategory();
      completeSingle.call(this, target);
      completeSingle.call(this, controller);
      completeInactive.call(this, target, 'inRange', 'outOfRange');
      completeController.call(this, controller);
      function completeSingle(base) {
        if (isArray(thisOption.color) && !base.inRange) {
          base.inRange = {color: thisOption.color.slice().reverse()};
        }
        base.inRange = base.inRange || {color: DEFAULT_COLOR};
        each(this.stateList, function(state) {
          var visualType = base[state];
          if (zrUtil.isString(visualType)) {
            var defa = visualDefault.get(visualType, 'active', isCategory);
            if (defa) {
              base[state] = {};
              base[state][visualType] = defa;
            } else {
              delete base[state];
            }
          }
        }, this);
      }
      function completeInactive(base, stateExist, stateAbsent) {
        var optExist = base[stateExist];
        var optAbsent = base[stateAbsent];
        if (optExist && !optAbsent) {
          optAbsent = base[stateAbsent] = {};
          each(optExist, function(visualData, visualType) {
            if (!VisualMapping.isValidType(visualType)) {
              return;
            }
            var defa = visualDefault.get(visualType, 'inactive', isCategory);
            if (defa != null) {
              optAbsent[visualType] = defa;
              if (visualType === 'color' && !optAbsent.hasOwnProperty('opacity') && !optAbsent.hasOwnProperty('colorAlpha')) {
                optAbsent.opacity = [0, 0];
              }
            }
          });
        }
      }
      function completeController(controller) {
        var symbolExists = (controller.inRange || {}).symbol || (controller.outOfRange || {}).symbol;
        var symbolSizeExists = (controller.inRange || {}).symbolSize || (controller.outOfRange || {}).symbolSize;
        var inactiveColor = this.get('inactiveColor');
        each(this.stateList, function(state) {
          var itemSize = this.itemSize;
          var visuals = controller[state];
          if (!visuals) {
            visuals = controller[state] = {color: isCategory ? inactiveColor : [inactiveColor]};
          }
          if (visuals.symbol == null) {
            visuals.symbol = symbolExists && zrUtil.clone(symbolExists) || (isCategory ? 'roundRect' : ['roundRect']);
          }
          if (visuals.symbolSize == null) {
            visuals.symbolSize = symbolSizeExists && zrUtil.clone(symbolSizeExists) || (isCategory ? itemSize[0] : [itemSize[0], itemSize[0]]);
          }
          visuals.symbol = mapVisual(visuals.symbol, function(symbol) {
            return (symbol === 'none' || symbol === 'square') ? 'roundRect' : symbol;
          });
          var symbolSize = visuals.symbolSize;
          if (symbolSize != null) {
            var max = -Infinity;
            eachVisual(symbolSize, function(value) {
              value > max && (max = value);
            });
            visuals.symbolSize = mapVisual(symbolSize, function(value) {
              return linearMap(value, [0, max], [0, itemSize[0]], true);
            });
          }
        }, this);
      }
    },
    resetItemSize: function() {
      this.itemSize = [parseFloat(this.get('itemWidth')), parseFloat(this.get('itemHeight'))];
    },
    isCategory: function() {
      return !!this.option.categories;
    },
    setSelected: noop,
    getValueState: noop
  });
  module.exports = VisualMapModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMap/PiecewiseModel.js", ["./VisualMapModel", "zrender/lib/core/util", "../../visual/VisualMapping", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var VisualMapModel = $__require('./VisualMapModel');
  var zrUtil = $__require('zrender/lib/core/util');
  var VisualMapping = $__require('../../visual/VisualMapping');
  var PiecewiseModel = VisualMapModel.extend({
    type: 'visualMap.piecewise',
    defaultOption: {
      selected: null,
      align: 'auto',
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: 'roundRect',
      pieceList: null,
      categories: null,
      splitNumber: 5,
      selectedMode: 'multiple',
      itemGap: 10,
      hoverLink: true
    },
    optionUpdated: function(newOption, isInit) {
      PiecewiseModel.superApply(this, 'optionUpdated', arguments);
      this._pieceList = [];
      this.resetTargetSeries();
      this.resetExtent();
      var mode = this._mode = this._determineMode();
      resetMethods[this._mode].call(this);
      this._resetSelected(newOption, isInit);
      var categories = this.option.categories;
      this.resetVisual(function(mappingOption, state) {
        if (mode === 'categories') {
          mappingOption.mappingMethod = 'category';
          mappingOption.categories = zrUtil.clone(categories);
        } else {
          mappingOption.dataExtent = this.getExtent();
          mappingOption.mappingMethod = 'piecewise';
          mappingOption.pieceList = zrUtil.map(this._pieceList, function(piece) {
            var piece = zrUtil.clone(piece);
            if (state !== 'inRange') {
              piece.visual = null;
            }
            return piece;
          });
        }
      });
    },
    _resetSelected: function(newOption, isInit) {
      var thisOption = this.option;
      var pieceList = this._pieceList;
      var selected = (isInit ? thisOption : newOption).selected || {};
      thisOption.selected = selected;
      zrUtil.each(pieceList, function(piece, index) {
        var key = this.getSelectedMapKey(piece);
        if (!(key in selected)) {
          selected[key] = true;
        }
      }, this);
      if (thisOption.selectedMode === 'single') {
        var hasSel = false;
        zrUtil.each(pieceList, function(piece, index) {
          var key = this.getSelectedMapKey(piece);
          if (selected[key]) {
            hasSel ? (selected[key] = false) : (hasSel = true);
          }
        }, this);
      }
    },
    getSelectedMapKey: function(piece) {
      return this._mode === 'categories' ? piece.value + '' : piece.index + '';
    },
    getPieceList: function() {
      return this._pieceList;
    },
    _determineMode: function() {
      var option = this.option;
      return option.pieces && option.pieces.length > 0 ? 'pieces' : this.option.categories ? 'categories' : 'splitNumber';
    },
    setSelected: function(selected) {
      this.option.selected = zrUtil.clone(selected);
    },
    getValueState: function(value) {
      var index = VisualMapping.findPieceIndex(value, this._pieceList);
      return index != null ? (this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? 'inRange' : 'outOfRange') : 'outOfRange';
    },
    findTargetDataIndices: function(pieceIndex) {
      var result = [];
      this.eachTargetSeries(function(seriesModel) {
        var dataIndices = [];
        var data = seriesModel.getData();
        data.each(this.getDataDimension(data), function(value, dataIndex) {
          var pIdx = VisualMapping.findPieceIndex(value, this._pieceList);
          pIdx === pieceIndex && dataIndices.push(dataIndex);
        }, true, this);
        result.push({
          seriesId: seriesModel.id,
          dataIndex: dataIndices
        });
      }, this);
      return result;
    },
    getRepresentValue: function(piece) {
      var representValue;
      if (this.isCategory()) {
        representValue = piece.value;
      } else {
        if (piece.value != null) {
          representValue = piece.value;
        } else {
          var pieceInterval = piece.interval || [];
          representValue = (pieceInterval[0] + pieceInterval[1]) / 2;
        }
      }
      return representValue;
    },
    getStops: function(seriesModel, getColorVisual) {
      var result = [];
      var model = this;
      var curr = -Infinity;
      zrUtil.each(this._pieceList, function(piece) {
        var interval = piece.interval;
        if (interval) {
          interval[0] > curr && setPiece({
            interval: [curr, interval[0]],
            valueState: 'outOfRange'
          });
          setPiece({
            interval: interval.slice(),
            valueState: this.getValueState((interval[0] + interval[1]) / 2)
          });
          curr = interval[1];
        }
      }, this);
      return result;
      function setPiece(piece) {
        result.push(piece);
        piece.color = getColorVisual(model, model.getRepresentValue(piece), piece.valueState);
      }
    }
  });
  var resetMethods = {
    splitNumber: function() {
      var thisOption = this.option;
      var pieceList = this._pieceList;
      var precision = thisOption.precision;
      var dataExtent = this.getExtent();
      var splitNumber = thisOption.splitNumber;
      splitNumber = Math.max(parseInt(splitNumber, 10), 1);
      thisOption.splitNumber = splitNumber;
      var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;
      while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
        precision++;
      }
      thisOption.precision = precision;
      splitStep = +splitStep.toFixed(precision);
      for (var i = 0,
          curr = dataExtent[0]; i < splitNumber; i++, curr += splitStep) {
        var max = i === splitNumber - 1 ? dataExtent[1] : (curr + splitStep);
        pieceList.push({
          index: i,
          interval: [curr, max],
          close: [1, 1]
        });
      }
      normalizePieces(pieceList);
      zrUtil.each(pieceList, function(piece) {
        piece.text = this.formatValueText(piece.interval);
      }, this);
    },
    categories: function() {
      var thisOption = this.option;
      zrUtil.each(thisOption.categories, function(cate) {
        this._pieceList.push({
          text: this.formatValueText(cate, true),
          value: cate
        });
      }, this);
      normalizeReverse(thisOption, this._pieceList);
    },
    pieces: function() {
      var thisOption = this.option;
      var pieceList = this._pieceList;
      zrUtil.each(thisOption.pieces, function(pieceListItem, index) {
        if (!zrUtil.isObject(pieceListItem)) {
          pieceListItem = {value: pieceListItem};
        }
        var item = {
          text: '',
          index: index
        };
        if (pieceListItem.label != null) {
          item.text = pieceListItem.label;
        }
        if (pieceListItem.hasOwnProperty('value')) {
          var value = item.value = pieceListItem.value;
          item.interval = [value, value];
          item.close = [1, 1];
        } else {
          var interval = item.interval = [];
          var close = item.close = [0, 0];
          var closeList = [1, 0, 1];
          var infinityList = [-Infinity, Infinity];
          var useMinMax = [];
          for (var lg = 0; lg < 2; lg++) {
            var names = [['gte', 'gt', 'min'], ['lte', 'lt', 'max']][lg];
            for (var i = 0; i < 3 && interval[lg] == null; i++) {
              interval[lg] = pieceListItem[names[i]];
              close[lg] = closeList[i];
              useMinMax[lg] = i === 2;
            }
            interval[lg] == null && (interval[lg] = infinityList[lg]);
          }
          useMinMax[0] && interval[1] === Infinity && (close[0] = 0);
          useMinMax[1] && interval[0] === -Infinity && (close[1] = 0);
          if (__DEV__) {
            if (interval[0] > interval[1]) {
              console.warn('Piece ' + index + 'is illegal: ' + interval + ' lower bound should not greater then uppper bound.');
            }
          }
          if (interval[0] === interval[1] && close[0] && close[1]) {
            item.value = interval[0];
          }
        }
        item.visual = VisualMapping.retrieveVisuals(pieceListItem);
        pieceList.push(item);
      }, this);
      normalizeReverse(thisOption, pieceList);
      normalizePieces(pieceList);
      zrUtil.each(pieceList, function(piece) {
        var close = piece.close;
        var edgeSymbols = [['<', ''][close[1]], ['>', ''][close[0]]];
        piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
      }, this);
    }
  };
  function normalizeReverse(thisOption, pieceList) {
    var inverse = thisOption.inverse;
    if (thisOption.orient === 'vertical' ? !inverse : inverse) {
      pieceList.reverse();
    }
  }
  function normalizePieces(pieceList) {
    pieceList.sort(function(a, b) {
      return littleThan(a, b) ? -1 : 1;
    });
    var curr = -Infinity;
    for (var i = 0; i < pieceList.length; i++) {
      var interval = pieceList[i].interval;
      var close = pieceList[i].close;
      for (var lg = 0; lg < 2; lg++) {
        if (interval[lg] < curr) {
          interval[lg] = curr;
          close[lg] = 1 - lg;
        }
        curr = interval[lg];
      }
    }
    function littleThan(piece, standard, lg) {
      lg = lg || 0;
      return piece.interval[lg] < standard.interval[lg] || (piece.interval[lg] === standard.interval[lg] && (+piece.close[lg] > standard.close[lg] || littleThan(piece, standard, 1)));
    }
  }
  module.exports = PiecewiseModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/visual/VisualMapping.js", ["zrender/lib/core/util", "zrender/lib/tool/color", "../util/number", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var zrColor = $__require('zrender/lib/tool/color');
  var linearMap = $__require('../util/number').linearMap;
  var each = zrUtil.each;
  var isObject = zrUtil.isObject;
  var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
  var VisualMapping = function(option) {
    var mappingMethod = option.mappingMethod;
    var visualType = option.type;
    var thisOption = this.option = zrUtil.clone(option);
    this.type = visualType;
    this.mappingMethod = mappingMethod;
    this._normalizeData = normalizers[mappingMethod];
    var visualHandler = visualHandlers[visualType];
    this.applyVisual = visualHandler.applyVisual;
    this.getColorMapper = visualHandler.getColorMapper;
    this._doMap = visualHandler._doMap[mappingMethod];
    if (mappingMethod === 'piecewise') {
      normalizeVisualRange(thisOption);
      preprocessForPiecewise(thisOption);
    } else if (mappingMethod === 'category') {
      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) : normalizeVisualRange(thisOption, true);
    } else {
      zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);
      normalizeVisualRange(thisOption);
    }
  };
  VisualMapping.prototype = {
    constructor: VisualMapping,
    mapValueToVisual: function(value) {
      var normalized = this._normalizeData(value);
      return this._doMap(normalized, value);
    },
    getNormalizer: function() {
      return zrUtil.bind(this._normalizeData, this);
    }
  };
  var visualHandlers = VisualMapping.visualHandlers = {
    color: {
      applyVisual: makeApplyVisual('color'),
      getColorMapper: function() {
        var thisOption = this.option;
        var parsedVisual = zrUtil.map(thisOption.visual, zrColor.parse);
        return zrUtil.bind(thisOption.mappingMethod === 'category' ? function(value, isNormalized) {
          !isNormalized && (value = this._normalizeData(value));
          return doMapCategory(this, value);
        } : function(value, isNormalized, out) {
          var returnRGBArray = !!out;
          !isNormalized && (value = this._normalizeData(value));
          out = zrColor.fastMapToColor(value, parsedVisual, out);
          return returnRGBArray ? out : zrUtil.stringify(out, 'rgba');
        }, this);
      },
      _doMap: {
        linear: function(normalized) {
          return zrColor.mapToColor(normalized, this.option.visual);
        },
        category: doMapCategory,
        piecewise: function(normalized, value) {
          var result = getSpecifiedVisual.call(this, value);
          if (result == null) {
            result = zrColor.mapToColor(normalized, this.option.visual);
          }
          return result;
        },
        fixed: doMapFixed
      }
    },
    colorHue: makePartialColorVisualHandler(function(color, value) {
      return zrColor.modifyHSL(color, value);
    }),
    colorSaturation: makePartialColorVisualHandler(function(color, value) {
      return zrColor.modifyHSL(color, null, value);
    }),
    colorLightness: makePartialColorVisualHandler(function(color, value) {
      return zrColor.modifyHSL(color, null, null, value);
    }),
    colorAlpha: makePartialColorVisualHandler(function(color, value) {
      return zrColor.modifyAlpha(color, value);
    }),
    opacity: {
      applyVisual: makeApplyVisual('opacity'),
      _doMap: makeDoMap([0, 1])
    },
    symbol: {
      applyVisual: function(value, getter, setter) {
        var symbolCfg = this.mapValueToVisual(value);
        if (zrUtil.isString(symbolCfg)) {
          setter('symbol', symbolCfg);
        } else if (isObject(symbolCfg)) {
          for (var name in symbolCfg) {
            if (symbolCfg.hasOwnProperty(name)) {
              setter(name, symbolCfg[name]);
            }
          }
        }
      },
      _doMap: {
        linear: doMapToArray,
        category: doMapCategory,
        piecewise: function(normalized, value) {
          var result = getSpecifiedVisual.call(this, value);
          if (result == null) {
            result = doMapToArray.call(this, normalized);
          }
          return result;
        },
        fixed: doMapFixed
      }
    },
    symbolSize: {
      applyVisual: makeApplyVisual('symbolSize'),
      _doMap: makeDoMap([0, 1])
    }
  };
  function preprocessForPiecewise(thisOption) {
    var pieceList = thisOption.pieceList;
    thisOption.hasSpecialVisual = false;
    zrUtil.each(pieceList, function(piece, index) {
      piece.originIndex = index;
      if (piece.visual != null) {
        thisOption.hasSpecialVisual = true;
      }
    });
  }
  function preprocessForSpecifiedCategory(thisOption) {
    var categories = thisOption.categories;
    var visual = thisOption.visual;
    var categoryMap = thisOption.categoryMap = {};
    each(categories, function(cate, index) {
      categoryMap[cate] = index;
    });
    if (!zrUtil.isArray(visual)) {
      var visualArr = [];
      if (zrUtil.isObject(visual)) {
        each(visual, function(v, cate) {
          var index = categoryMap[cate];
          visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
        });
      } else {
        visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
      }
      visual = thisOption.visual = visualArr;
    }
    for (var i = categories.length - 1; i >= 0; i--) {
      if (visual[i] == null) {
        delete categoryMap[categories[i]];
        categories.pop();
      }
    }
  }
  function normalizeVisualRange(thisOption, isCategory) {
    var visual = thisOption.visual;
    var visualArr = [];
    if (zrUtil.isObject(visual)) {
      each(visual, function(v) {
        visualArr.push(v);
      });
    } else if (visual != null) {
      visualArr.push(visual);
    }
    var doNotNeedPair = {
      color: 1,
      symbol: 1
    };
    if (!isCategory && visualArr.length === 1 && !(thisOption.type in doNotNeedPair)) {
      visualArr[1] = visualArr[0];
    }
    thisOption.visual = visualArr;
  }
  function makePartialColorVisualHandler(applyValue) {
    return {
      applyVisual: function(value, getter, setter) {
        value = this.mapValueToVisual(value);
        setter('color', applyValue(getter('color'), value));
      },
      _doMap: makeDoMap([0, 1])
    };
  }
  function doMapToArray(arr, normalized) {
    var visual = this.option.visual;
    return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};
  }
  function makeApplyVisual(visualType) {
    return function(value, getter, setter) {
      setter(visualType, this.mapValueToVisual(value));
    };
  }
  function doMapCategory(normalized) {
    var visual = this.option.visual;
    return visual[(this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX) ? normalized % visual.length : normalized];
  }
  function doMapFixed() {
    return this.option.visual[0];
  }
  function makeDoMap(sourceExtent) {
    return {
      linear: function(normalized) {
        return linearMap(normalized, sourceExtent, this.option.visual, true);
      },
      category: doMapCategory,
      piecewise: function(normalized, value) {
        var result = getSpecifiedVisual.call(this, value);
        if (result == null) {
          result = linearMap(normalized, sourceExtent, this.option.visual, true);
        }
        return result;
      },
      fixed: doMapFixed
    };
  }
  function getSpecifiedVisual(value) {
    var thisOption = this.option;
    var pieceList = thisOption.pieceList;
    if (thisOption.hasSpecialVisual) {
      var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
      var piece = pieceList[pieceIndex];
      if (piece && piece.visual) {
        return piece.visual[this.type];
      }
    }
  }
  var normalizers = {
    linear: function(value) {
      return linearMap(value, this.option.dataExtent, [0, 1], true);
    },
    piecewise: function(value) {
      var pieceList = this.option.pieceList;
      var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);
      if (pieceIndex != null) {
        return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
      }
    },
    category: function(value) {
      var index = this.option.categories ? this.option.categoryMap[value] : value;
      return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
    },
    fixed: zrUtil.noop
  };
  VisualMapping.addVisualHandler = function(name, handler) {
    visualHandlers[name] = handler;
  };
  VisualMapping.isValidType = function(visualType) {
    return visualHandlers.hasOwnProperty(visualType);
  };
  VisualMapping.eachVisual = function(visual, callback, context) {
    if (zrUtil.isObject(visual)) {
      zrUtil.each(visual, callback, context);
    } else {
      callback.call(context, visual);
    }
  };
  VisualMapping.mapVisual = function(visual, callback, context) {
    var isPrimary;
    var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);
    VisualMapping.eachVisual(visual, function(v, key) {
      var newVal = callback.call(context, v, key);
      isPrimary ? (newVisual = newVal) : (newVisual[key] = newVal);
    });
    return newVisual;
  };
  VisualMapping.retrieveVisuals = function(obj) {
    var ret = {};
    var hasVisual;
    obj && each(visualHandlers, function(h, visualType) {
      if (obj.hasOwnProperty(visualType)) {
        ret[visualType] = obj[visualType];
        hasVisual = true;
      }
    });
    return hasVisual ? ret : null;
  };
  VisualMapping.prepareVisualTypes = function(visualTypes) {
    if (isObject(visualTypes)) {
      var types = [];
      each(visualTypes, function(item, type) {
        types.push(type);
      });
      visualTypes = types;
    } else if (zrUtil.isArray(visualTypes)) {
      visualTypes = visualTypes.slice();
    } else {
      return [];
    }
    visualTypes.sort(function(type1, type2) {
      return (type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0) ? 1 : -1;
    });
    return visualTypes;
  };
  VisualMapping.dependsOn = function(visualType1, visualType2) {
    return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
  };
  VisualMapping.findPieceIndex = function(value, pieceList, findClosestWhenOutside) {
    var possibleI;
    var abs = Infinity;
    for (var i = 0,
        len = pieceList.length; i < len; i++) {
      var pieceValue = pieceList[i].value;
      if (pieceValue != null) {
        if (pieceValue === value) {
          return i;
        }
        findClosestWhenOutside && updatePossible(pieceValue, i);
      }
    }
    for (var i = 0,
        len = pieceList.length; i < len; i++) {
      var piece = pieceList[i];
      var interval = piece.interval;
      var close = piece.close;
      if (interval) {
        if (interval[0] === -Infinity) {
          if (littleThan(close[1], value, interval[1])) {
            return i;
          }
        } else if (interval[1] === Infinity) {
          if (littleThan(close[0], interval[0], value)) {
            return i;
          }
        } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {
          return i;
        }
        findClosestWhenOutside && updatePossible(interval[0], i);
        findClosestWhenOutside && updatePossible(interval[1], i);
      }
    }
    if (findClosestWhenOutside) {
      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
    }
    function updatePossible(val, index) {
      var newAbs = Math.abs(val - value);
      if (newAbs < abs) {
        abs = newAbs;
        possibleI = index;
      }
    }
  };
  function littleThan(close, a, b) {
    return close ? a <= b : a < b;
  }
  module.exports = VisualMapping;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMap/VisualMapView.js", ["zrender/lib/core/util", "../../util/graphic", "../../util/format", "../../util/layout", "../../echarts", "../../visual/VisualMapping", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var formatUtil = $__require('../../util/format');
  var layout = $__require('../../util/layout');
  var echarts = $__require('../../echarts');
  var VisualMapping = $__require('../../visual/VisualMapping');
  module.exports = echarts.extendComponentView({
    type: 'visualMap',
    autoPositionValues: {
      left: 1,
      right: 1,
      top: 1,
      bottom: 1
    },
    init: function(ecModel, api) {
      this.ecModel = ecModel;
      this.api = api;
      this.visualMapModel;
    },
    render: function(visualMapModel, ecModel, api, payload) {
      this.visualMapModel = visualMapModel;
      if (visualMapModel.get('show') === false) {
        this.group.removeAll();
        return;
      }
      this.doRender.apply(this, arguments);
    },
    renderBackground: function(group) {
      var visualMapModel = this.visualMapModel;
      var padding = formatUtil.normalizeCssArray(visualMapModel.get('padding') || 0);
      var rect = group.getBoundingRect();
      group.add(new graphic.Rect({
        z2: -1,
        silent: true,
        shape: {
          x: rect.x - padding[3],
          y: rect.y - padding[0],
          width: rect.width + padding[3] + padding[1],
          height: rect.height + padding[0] + padding[2]
        },
        style: {
          fill: visualMapModel.get('backgroundColor'),
          stroke: visualMapModel.get('borderColor'),
          lineWidth: visualMapModel.get('borderWidth')
        }
      }));
    },
    getControllerVisual: function(targetValue, visualCluster, opts) {
      opts = opts || {};
      var forceState = opts.forceState;
      var visualMapModel = this.visualMapModel;
      var visualObj = {};
      if (visualCluster === 'symbol') {
        visualObj.symbol = visualMapModel.get('itemSymbol');
      }
      if (visualCluster === 'color') {
        var defaultColor = visualMapModel.get('contentColor');
        visualObj.color = defaultColor;
      }
      function getter(key) {
        return visualObj[key];
      }
      function setter(key, value) {
        visualObj[key] = value;
      }
      var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
      var visualTypes = VisualMapping.prepareVisualTypes(mappings);
      zrUtil.each(visualTypes, function(type) {
        var visualMapping = mappings[type];
        if (opts.convertOpacityToAlpha && type === 'opacity') {
          type = 'colorAlpha';
          visualMapping = mappings.__alphaForOpacity;
        }
        if (VisualMapping.dependsOn(type, visualCluster)) {
          visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
        }
      });
      return visualObj[visualCluster];
    },
    positionGroup: function(group) {
      var model = this.visualMapModel;
      var api = this.api;
      layout.positionGroup(group, model.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
    },
    doRender: zrUtil.noop
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMap/helper.js", ["../../util/layout", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var layout = $__require('../../util/layout');
  var helper = {getItemAlign: function(visualMapModel, api, itemSize) {
      var modelOption = visualMapModel.option;
      var itemAlign = modelOption.align;
      if (itemAlign != null && itemAlign !== 'auto') {
        return itemAlign;
      }
      var ecSize = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var realIndex = modelOption.orient === 'horizontal' ? 1 : 0;
      var paramsSet = [['left', 'right', 'width'], ['top', 'bottom', 'height']];
      var reals = paramsSet[realIndex];
      var fakeValue = [0, null, 10];
      var layoutInput = {};
      for (var i = 0; i < 3; i++) {
        layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
        layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
      }
      var rParam = [['x', 'width', 3], ['y', 'height', 0]][realIndex];
      var rect = layout.getLayoutRect(layoutInput, ecSize, modelOption.padding);
      return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
    }};
  module.exports = helper;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMap/PiecewiseView.js", ["./VisualMapView", "zrender/lib/core/util", "../../util/graphic", "../../util/symbol", "../../util/layout", "./helper", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var VisualMapView = $__require('./VisualMapView');
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var symbolCreators = $__require('../../util/symbol');
  var layout = $__require('../../util/layout');
  var helper = $__require('./helper');
  var PiecewiseVisualMapView = VisualMapView.extend({
    type: 'visualMap.piecewise',
    doRender: function() {
      var thisGroup = this.group;
      thisGroup.removeAll();
      var visualMapModel = this.visualMapModel;
      var textGap = visualMapModel.get('textGap');
      var textStyleModel = visualMapModel.textStyleModel;
      var textFont = textStyleModel.getFont();
      var textFill = textStyleModel.getTextColor();
      var itemAlign = this._getItemAlign();
      var itemSize = visualMapModel.itemSize;
      var viewData = this._getViewData();
      var showLabel = !viewData.endsText;
      var showEndsText = !showLabel;
      showEndsText && this._renderEndsText(thisGroup, viewData.endsText[0], itemSize);
      zrUtil.each(viewData.viewPieceList, renderItem, this);
      showEndsText && this._renderEndsText(thisGroup, viewData.endsText[1], itemSize);
      layout.box(visualMapModel.get('orient'), thisGroup, visualMapModel.get('itemGap'));
      this.renderBackground(thisGroup);
      this.positionGroup(thisGroup);
      function renderItem(item) {
        var piece = item.piece;
        var itemGroup = new graphic.Group();
        itemGroup.onclick = zrUtil.bind(this._onItemClick, this, piece);
        this._enableHoverLink(itemGroup, item.indexInModelPieceList);
        var representValue = visualMapModel.getRepresentValue(piece);
        this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]);
        if (showLabel) {
          var visualState = this.visualMapModel.getValueState(representValue);
          itemGroup.add(new graphic.Text({style: {
              x: itemAlign === 'right' ? -textGap : itemSize[0] + textGap,
              y: itemSize[1] / 2,
              text: piece.text,
              textVerticalAlign: 'middle',
              textAlign: itemAlign,
              textFont: textFont,
              fill: textFill,
              opacity: visualState === 'outOfRange' ? 0.5 : 1
            }}));
        }
        thisGroup.add(itemGroup);
      }
    },
    _enableHoverLink: function(itemGroup, pieceIndex) {
      itemGroup.on('mouseover', zrUtil.bind(onHoverLink, this, 'highlight')).on('mouseout', zrUtil.bind(onHoverLink, this, 'downplay'));
      function onHoverLink(method) {
        var visualMapModel = this.visualMapModel;
        visualMapModel.option.hoverLink && this.api.dispatchAction({
          type: method,
          batch: visualMapModel.findTargetDataIndices(pieceIndex)
        });
      }
    },
    _getItemAlign: function() {
      var visualMapModel = this.visualMapModel;
      var modelOption = visualMapModel.option;
      if (modelOption.orient === 'vertical') {
        return helper.getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
      } else {
        var align = modelOption.align;
        if (!align || align === 'auto') {
          align = 'left';
        }
        return align;
      }
    },
    _renderEndsText: function(group, text, itemSize) {
      if (!text) {
        return;
      }
      var itemGroup = new graphic.Group();
      var textStyleModel = this.visualMapModel.textStyleModel;
      itemGroup.add(new graphic.Text({style: {
          x: itemSize[0] / 2,
          y: itemSize[1] / 2,
          textVerticalAlign: 'middle',
          textAlign: 'center',
          text: text,
          textFont: textStyleModel.getFont(),
          fill: textStyleModel.getTextColor()
        }}));
      group.add(itemGroup);
    },
    _getViewData: function() {
      var visualMapModel = this.visualMapModel;
      var viewPieceList = zrUtil.map(visualMapModel.getPieceList(), function(piece, index) {
        return {
          piece: piece,
          indexInModelPieceList: index
        };
      });
      var endsText = visualMapModel.get('text');
      var orient = visualMapModel.get('orient');
      var inverse = visualMapModel.get('inverse');
      if (orient === 'horizontal' ? inverse : !inverse) {
        viewPieceList.reverse();
      } else if (endsText) {
        endsText = endsText.slice().reverse();
      }
      return {
        viewPieceList: viewPieceList,
        endsText: endsText
      };
    },
    _createItemSymbol: function(group, representValue, shapeParam) {
      group.add(symbolCreators.createSymbol(this.getControllerVisual(representValue, 'symbol'), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, 'color')));
    },
    _onItemClick: function(piece) {
      var visualMapModel = this.visualMapModel;
      var option = visualMapModel.option;
      var selected = zrUtil.clone(option.selected);
      var newKey = visualMapModel.getSelectedMapKey(piece);
      if (option.selectedMode === 'single') {
        selected[newKey] = true;
        zrUtil.each(selected, function(o, key) {
          selected[key] = key === newKey;
        });
      } else {
        selected[newKey] = !selected[newKey];
      }
      this.api.dispatchAction({
        type: 'selectDataRange',
        from: this.uid,
        visualMapId: this.visualMapModel.id,
        selected: selected
      });
    }
  });
  module.exports = PiecewiseVisualMapView;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMap/visualMapAction.js", ["../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../../echarts');
  var actionInfo = {
    type: 'selectDataRange',
    event: 'dataRangeSelected',
    update: 'update'
  };
  echarts.registerAction(actionInfo, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'visualMap',
      query: payload
    }, function(model) {
      model.setSelected(payload.selected);
    });
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMapPiecewise.js", ["../echarts", "./visualMap/preprocessor", "./visualMap/typeDefaulter", "./visualMap/visualEncoding", "./visualMap/PiecewiseModel", "./visualMap/PiecewiseView", "./visualMap/visualMapAction", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../echarts').registerPreprocessor($__require('./visualMap/preprocessor'));
  $__require('./visualMap/typeDefaulter');
  $__require('./visualMap/visualEncoding');
  $__require('./visualMap/PiecewiseModel');
  $__require('./visualMap/PiecewiseView');
  $__require('./visualMap/visualMapAction');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/visualMap.js", ["./visualMapContinuous", "./visualMapPiecewise", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./visualMapContinuous');
  $__require('./visualMapPiecewise');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/marker/MarkPointModel.js", ["./MarkerModel", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./MarkerModel').extend({
    type: 'markPoint',
    defaultOption: {
      zlevel: 0,
      z: 5,
      symbol: 'pin',
      symbolSize: 50,
      tooltip: {trigger: 'item'},
      label: {
        normal: {
          show: true,
          position: 'inside'
        },
        emphasis: {show: true}
      },
      itemStyle: {normal: {borderWidth: 2}}
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/Symbol.js", ["zrender/lib/core/util", "../../util/symbol", "../../util/graphic", "../../util/number", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var symbolUtil = $__require('../../util/symbol');
  var graphic = $__require('../../util/graphic');
  var numberUtil = $__require('../../util/number');
  function normalizeSymbolSize(symbolSize) {
    if (!(symbolSize instanceof Array)) {
      symbolSize = [+symbolSize, +symbolSize];
    }
    return symbolSize;
  }
  function Symbol(data, idx, seriesScope) {
    graphic.Group.call(this);
    this.updateData(data, idx, seriesScope);
  }
  var symbolProto = Symbol.prototype;
  function driftSymbol(dx, dy) {
    this.parent.drift(dx, dy);
  }
  symbolProto._createSymbol = function(symbolType, data, idx) {
    this.removeAll();
    var seriesModel = data.hostModel;
    var color = data.getItemVisual(idx, 'color');
    var symbolPath = symbolUtil.createSymbol(symbolType, -0.5, -0.5, 1, 1, color);
    symbolPath.attr({
      z2: 100,
      culling: true,
      scale: [0, 0]
    });
    symbolPath.drift = driftSymbol;
    var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
    graphic.initProps(symbolPath, {scale: size}, seriesModel, idx);
    this._symbolType = symbolType;
    this.add(symbolPath);
  };
  symbolProto.stopSymbolAnimation = function(toLastFrame) {
    this.childAt(0).stopAnimation(toLastFrame);
  };
  symbolProto.getScale = function() {
    return this.childAt(0).scale;
  };
  symbolProto.highlight = function() {
    this.childAt(0).trigger('emphasis');
  };
  symbolProto.downplay = function() {
    this.childAt(0).trigger('normal');
  };
  symbolProto.setZ = function(zlevel, z) {
    var symbolPath = this.childAt(0);
    symbolPath.zlevel = zlevel;
    symbolPath.z = z;
  };
  symbolProto.setDraggable = function(draggable) {
    var symbolPath = this.childAt(0);
    symbolPath.draggable = draggable;
    symbolPath.cursor = draggable ? 'move' : 'pointer';
  };
  symbolProto.updateData = function(data, idx, seriesScope) {
    this.silent = false;
    var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
    var seriesModel = data.hostModel;
    var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
    if (symbolType !== this._symbolType) {
      this._createSymbol(symbolType, data, idx);
    } else {
      var symbolPath = this.childAt(0);
      graphic.updateProps(symbolPath, {scale: symbolSize}, seriesModel, idx);
    }
    this._updateCommon(data, idx, symbolSize, seriesScope);
    this._seriesModel = seriesModel;
  };
  var normalStyleAccessPath = ['itemStyle', 'normal'];
  var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];
  var normalLabelAccessPath = ['label', 'normal'];
  var emphasisLabelAccessPath = ['label', 'emphasis'];
  symbolProto._updateCommon = function(data, idx, symbolSize, seriesScope) {
    var symbolPath = this.childAt(0);
    var seriesModel = data.hostModel;
    var color = data.getItemVisual(idx, 'color');
    if (symbolPath.type !== 'image') {
      symbolPath.useStyle({strokeNoScale: true});
    }
    seriesScope = seriesScope || null;
    var itemStyle = seriesScope && seriesScope.itemStyle;
    var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;
    var symbolRotate = seriesScope && seriesScope.symbolRotate;
    var symbolOffset = seriesScope && seriesScope.symbolOffset;
    var labelModel = seriesScope && seriesScope.labelModel;
    var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
    var hoverAnimation = seriesScope && seriesScope.hoverAnimation;
    if (!seriesScope || data.hasItemOption) {
      var itemModel = data.getItemModel(idx);
      itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);
      hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
      symbolRotate = itemModel.getShallow('symbolRotate');
      symbolOffset = itemModel.getShallow('symbolOffset');
      labelModel = itemModel.getModel(normalLabelAccessPath);
      hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);
      hoverAnimation = itemModel.getShallow('hoverAnimation');
    } else {
      hoverItemStyle = zrUtil.extend({}, hoverItemStyle);
    }
    var elStyle = symbolPath.style;
    symbolPath.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
    if (symbolOffset) {
      symbolPath.attr('position', [numberUtil.parsePercent(symbolOffset[0], symbolSize[0]), numberUtil.parsePercent(symbolOffset[1], symbolSize[1])]);
    }
    symbolPath.setColor(color);
    symbolPath.setStyle(itemStyle);
    var opacity = data.getItemVisual(idx, 'opacity');
    if (opacity != null) {
      elStyle.opacity = opacity;
    }
    var dimensions = data.dimensions.slice();
    var valueDim;
    var dataType;
    while (dimensions.length && (valueDim = dimensions.pop(), dataType = data.getDimensionInfo(valueDim).type, dataType === 'ordinal' || dataType === 'time')) {}
    if (valueDim != null && labelModel.getShallow('show')) {
      graphic.setText(elStyle, labelModel, color);
      elStyle.text = zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal'), data.get(valueDim, idx));
    } else {
      elStyle.text = '';
    }
    if (valueDim != null && hoverLabelModel.getShallow('show')) {
      graphic.setText(hoverItemStyle, hoverLabelModel, color);
      hoverItemStyle.text = zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis'), data.get(valueDim, idx));
    } else {
      hoverItemStyle.text = '';
    }
    var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
    symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');
    graphic.setHoverStyle(symbolPath, hoverItemStyle);
    if (hoverAnimation && seriesModel.ifEnableAnimation()) {
      var onEmphasis = function() {
        var ratio = size[1] / size[0];
        this.animateTo({scale: [Math.max(size[0] * 1.1, size[0] + 3), Math.max(size[1] * 1.1, size[1] + 3 * ratio)]}, 400, 'elasticOut');
      };
      var onNormal = function() {
        this.animateTo({scale: size}, 400, 'elasticOut');
      };
      symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);
    }
  };
  symbolProto.fadeOut = function(cb) {
    var symbolPath = this.childAt(0);
    this.silent = true;
    symbolPath.style.text = '';
    graphic.updateProps(symbolPath, {scale: [0, 0]}, this._seriesModel, this.dataIndex, cb);
  };
  zrUtil.inherits(Symbol, graphic.Group);
  module.exports = Symbol;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/SymbolDraw.js", ["../../util/graphic", "./Symbol", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var Symbol = $__require('./Symbol');
  function SymbolDraw(symbolCtor) {
    this.group = new graphic.Group();
    this._symbolCtor = symbolCtor || Symbol;
  }
  var symbolDrawProto = SymbolDraw.prototype;
  function symbolNeedsDraw(data, idx, isIgnore) {
    var point = data.getItemLayout(idx);
    return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx)) && data.getItemVisual(idx, 'symbol') !== 'none';
  }
  symbolDrawProto.updateData = function(data, isIgnore) {
    var group = this.group;
    var seriesModel = data.hostModel;
    var oldData = this._data;
    var SymbolCtor = this._symbolCtor;
    var seriesScope = {
      itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),
      hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),
      symbolRotate: seriesModel.get('symbolRotate'),
      symbolOffset: seriesModel.get('symbolOffset'),
      hoverAnimation: seriesModel.get('hoverAnimation'),
      labelModel: seriesModel.getModel('label.normal'),
      hoverLabelModel: seriesModel.getModel('label.emphasis')
    };
    data.diff(oldData).add(function(newIdx) {
      var point = data.getItemLayout(newIdx);
      if (symbolNeedsDraw(data, newIdx, isIgnore)) {
        var symbolEl = new SymbolCtor(data, newIdx, seriesScope);
        symbolEl.attr('position', point);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      var point = data.getItemLayout(newIdx);
      if (!symbolNeedsDraw(data, newIdx, isIgnore)) {
        group.remove(symbolEl);
        return;
      }
      if (!symbolEl) {
        symbolEl = new SymbolCtor(data, newIdx);
        symbolEl.attr('position', point);
      } else {
        symbolEl.updateData(data, newIdx, seriesScope);
        graphic.updateProps(symbolEl, {position: point}, seriesModel);
      }
      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && el.fadeOut(function() {
        group.remove(el);
      });
    }).execute();
    this._data = data;
  };
  symbolDrawProto.updateLayout = function() {
    var data = this._data;
    if (data) {
      data.eachItemGraphicEl(function(el, idx) {
        var point = data.getItemLayout(idx);
        el.attr('position', point);
      });
    }
  };
  symbolDrawProto.remove = function(enableAnimation) {
    var group = this.group;
    var data = this._data;
    if (data) {
      if (enableAnimation) {
        data.eachItemGraphicEl(function(el) {
          el.fadeOut(function() {
            group.remove(el);
          });
        });
      } else {
        group.removeAll();
      }
    }
  };
  module.exports = SymbolDraw;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/marker/MarkPointView.js", ["../../chart/helper/SymbolDraw", "zrender/lib/core/util", "../../util/number", "../../data/List", "./markerHelper", "./MarkerView", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SymbolDraw = $__require('../../chart/helper/SymbolDraw');
  var zrUtil = $__require('zrender/lib/core/util');
  var numberUtil = $__require('../../util/number');
  var List = $__require('../../data/List');
  var markerHelper = $__require('./markerHelper');
  function updateMarkerLayout(mpData, seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    mpData.each(function(idx) {
      var itemModel = mpData.getItemModel(idx);
      var point;
      var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());
      var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());
      if (!isNaN(xPx) && !isNaN(yPx)) {
        point = [xPx, yPx];
      } else if (seriesModel.getMarkerPosition) {
        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
      } else if (coordSys) {
        var x = mpData.get(coordSys.dimensions[0], idx);
        var y = mpData.get(coordSys.dimensions[1], idx);
        point = coordSys.dataToPoint([x, y]);
      }
      if (!isNaN(xPx)) {
        point[0] = xPx;
      }
      if (!isNaN(yPx)) {
        point[1] = yPx;
      }
      mpData.setItemLayout(idx, point);
    });
  }
  $__require('./MarkerView').extend({
    type: 'markPoint',
    updateLayout: function(markPointModel, ecModel, api) {
      ecModel.eachSeries(function(seriesModel) {
        var mpModel = seriesModel.markPointModel;
        if (mpModel) {
          updateMarkerLayout(mpModel.getData(), seriesModel, api);
          this.markerGroupMap[seriesModel.name].updateLayout(mpModel);
        }
      }, this);
    },
    renderSeries: function(seriesModel, mpModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesName = seriesModel.name;
      var seriesData = seriesModel.getData();
      var symbolDrawMap = this.markerGroupMap;
      var symbolDraw = symbolDrawMap[seriesName];
      if (!symbolDraw) {
        symbolDraw = symbolDrawMap[seriesName] = new SymbolDraw();
      }
      var mpData = createList(coordSys, seriesModel, mpModel);
      mpModel.setData(mpData);
      updateMarkerLayout(mpModel.getData(), seriesModel, api);
      mpData.each(function(idx) {
        var itemModel = mpData.getItemModel(idx);
        var symbolSize = itemModel.getShallow('symbolSize');
        if (typeof symbolSize === 'function') {
          symbolSize = symbolSize(mpModel.getRawValue(idx), mpModel.getDataParams(idx));
        }
        mpData.setItemVisual(idx, {
          symbolSize: symbolSize,
          color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color'),
          symbol: itemModel.getShallow('symbol')
        });
      });
      symbolDraw.updateData(mpData);
      this.group.add(symbolDraw.group);
      mpData.eachItemGraphicEl(function(el) {
        el.traverse(function(child) {
          child.dataModel = mpModel;
        });
      });
      symbolDraw.__keep = true;
      symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');
    }
  });
  function createList(coordSys, seriesModel, mpModel) {
    var coordDimsInfos;
    if (coordSys) {
      coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function(coordDim) {
        var info = seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0]) || {};
        info.name = coordDim;
        return info;
      });
    } else {
      coordDimsInfos = [{
        name: 'value',
        type: 'float'
      }];
    }
    var mpData = new List(coordDimsInfos, mpModel);
    var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(markerHelper.dataTransform, seriesModel));
    if (coordSys) {
      dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys));
    }
    mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function(item) {
      return item.value;
    });
    return mpData;
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/markPoint.js", ["./marker/MarkPointModel", "./marker/MarkPointView", "../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./marker/MarkPointModel');
  $__require('./marker/MarkPointView');
  $__require('../echarts').registerPreprocessor(function(opt) {
    opt.markPoint = opt.markPoint || {};
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/marker/MarkLineModel.js", ["./MarkerModel", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./MarkerModel').extend({
    type: 'markLine',
    defaultOption: {
      zlevel: 0,
      z: 5,
      symbol: ['circle', 'arrow'],
      symbolSize: [8, 16],
      precision: 2,
      tooltip: {trigger: 'item'},
      label: {
        normal: {
          show: true,
          position: 'end'
        },
        emphasis: {show: true}
      },
      lineStyle: {
        normal: {type: 'dashed'},
        emphasis: {width: 3}
      },
      animationEasing: 'linear'
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/LinePath.js", ["../../util/graphic", "zrender/lib/core/vector", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var vec2 = $__require('zrender/lib/core/vector');
  var straightLineProto = graphic.Line.prototype;
  var bezierCurveProto = graphic.BezierCurve.prototype;
  function isLine(shape) {
    return shape.cpx1 == null || shape.cpy1 == null;
  }
  module.exports = graphic.extendShape({
    type: 'ec-line',
    style: {
      stroke: '#000',
      fill: null
    },
    shape: {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      percent: 1,
      cpx1: null,
      cpy1: null
    },
    buildPath: function(ctx, shape) {
      (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);
    },
    pointAt: function(t) {
      return isLine(this.shape) ? straightLineProto.pointAt.call(this, t) : bezierCurveProto.pointAt.call(this, t);
    },
    tangentAt: function(t) {
      var shape = this.shape;
      var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);
      return vec2.normalize(p, p);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/Line.js", ["../../util/symbol", "zrender/lib/core/vector", "./LinePath", "../../util/graphic", "zrender/lib/core/util", "../../util/number", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var symbolUtil = $__require('../../util/symbol');
  var vector = $__require('zrender/lib/core/vector');
  var LinePath = $__require('./LinePath');
  var graphic = $__require('../../util/graphic');
  var zrUtil = $__require('zrender/lib/core/util');
  var numberUtil = $__require('../../util/number');
  var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];
  function makeSymbolTypeKey(symbolCategory) {
    return '_' + symbolCategory + 'Type';
  }
  function createSymbol(name, lineData, idx) {
    var color = lineData.getItemVisual(idx, 'color');
    var symbolType = lineData.getItemVisual(idx, name);
    var symbolSize = lineData.getItemVisual(idx, name + 'Size');
    if (!symbolType || symbolType === 'none') {
      return;
    }
    if (!zrUtil.isArray(symbolSize)) {
      symbolSize = [symbolSize, symbolSize];
    }
    var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color);
    symbolPath.name = name;
    return symbolPath;
  }
  function createLine(points) {
    var line = new LinePath({name: 'line'});
    setLinePoints(line.shape, points);
    return line;
  }
  function setLinePoints(targetShape, points) {
    var p1 = points[0];
    var p2 = points[1];
    var cp1 = points[2];
    targetShape.x1 = p1[0];
    targetShape.y1 = p1[1];
    targetShape.x2 = p2[0];
    targetShape.y2 = p2[1];
    targetShape.percent = 1;
    if (cp1) {
      targetShape.cpx1 = cp1[0];
      targetShape.cpy1 = cp1[1];
    }
  }
  function updateSymbolAndLabelBeforeLineUpdate() {
    var lineGroup = this;
    var symbolFrom = lineGroup.childOfName('fromSymbol');
    var symbolTo = lineGroup.childOfName('toSymbol');
    var label = lineGroup.childOfName('label');
    if (!symbolFrom && !symbolTo && label.ignore) {
      return;
    }
    var invScale = 1;
    var parentNode = this.parent;
    while (parentNode) {
      if (parentNode.scale) {
        invScale /= parentNode.scale[0];
      }
      parentNode = parentNode.parent;
    }
    var line = lineGroup.childOfName('line');
    if (!this.__dirty && !line.__dirty) {
      return;
    }
    var percent = line.shape.percent;
    var fromPos = line.pointAt(0);
    var toPos = line.pointAt(percent);
    var d = vector.sub([], toPos, fromPos);
    vector.normalize(d, d);
    if (symbolFrom) {
      symbolFrom.attr('position', fromPos);
      var tangent = line.tangentAt(0);
      symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
      symbolFrom.attr('scale', [invScale * percent, invScale * percent]);
    }
    if (symbolTo) {
      symbolTo.attr('position', toPos);
      var tangent = line.tangentAt(1);
      symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
      symbolTo.attr('scale', [invScale * percent, invScale * percent]);
    }
    if (!label.ignore) {
      label.attr('position', toPos);
      var textPosition;
      var textAlign;
      var textVerticalAlign;
      var distance = 5 * invScale;
      if (label.__position === 'end') {
        textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]];
        textAlign = d[0] > 0.8 ? 'left' : (d[0] < -0.8 ? 'right' : 'center');
        textVerticalAlign = d[1] > 0.8 ? 'top' : (d[1] < -0.8 ? 'bottom' : 'middle');
      } else if (label.__position === 'middle') {
        var halfPercent = percent / 2;
        var tangent = line.tangentAt(halfPercent);
        var n = [tangent[1], -tangent[0]];
        var cp = line.pointAt(halfPercent);
        if (n[1] > 0) {
          n[0] = -n[0];
          n[1] = -n[1];
        }
        textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance];
        textAlign = 'center';
        textVerticalAlign = 'bottom';
        var rotation = -Math.atan2(tangent[1], tangent[0]);
        if (toPos[0] < fromPos[0]) {
          rotation = Math.PI + rotation;
        }
        label.attr('rotation', rotation);
      } else {
        textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]];
        textAlign = d[0] > 0.8 ? 'right' : (d[0] < -0.8 ? 'left' : 'center');
        textVerticalAlign = d[1] > 0.8 ? 'bottom' : (d[1] < -0.8 ? 'top' : 'middle');
      }
      label.attr({
        style: {
          textVerticalAlign: label.__verticalAlign || textVerticalAlign,
          textAlign: label.__textAlign || textAlign
        },
        position: textPosition,
        scale: [invScale, invScale]
      });
    }
  }
  function Line(lineData, idx, seriesScope) {
    graphic.Group.call(this);
    this._createLine(lineData, idx, seriesScope);
  }
  var lineProto = Line.prototype;
  lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;
  lineProto._createLine = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var linePoints = lineData.getItemLayout(idx);
    var line = createLine(linePoints);
    line.shape.percent = 0;
    graphic.initProps(line, {shape: {percent: 1}}, seriesModel, idx);
    this.add(line);
    var label = new graphic.Text({name: 'label'});
    this.add(label);
    zrUtil.each(SYMBOL_CATEGORIES, function(symbolCategory) {
      var symbol = createSymbol(symbolCategory, lineData, idx);
      this.add(symbol);
      this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
    }, this);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  lineProto.updateData = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childOfName('line');
    var linePoints = lineData.getItemLayout(idx);
    var target = {shape: {}};
    setLinePoints(target.shape, linePoints);
    graphic.updateProps(line, target, seriesModel, idx);
    zrUtil.each(SYMBOL_CATEGORIES, function(symbolCategory) {
      var symbolType = lineData.getItemVisual(idx, symbolCategory);
      var key = makeSymbolTypeKey(symbolCategory);
      if (this[key] !== symbolType) {
        this.remove(this.childOfName(symbolCategory));
        var symbol = createSymbol(symbolCategory, lineData, idx);
        this.add(symbol);
      }
      this[key] = symbolType;
    }, this);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  lineProto._updateCommonStl = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childOfName('line');
    var lineStyle = seriesScope && seriesScope.lineStyle;
    var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
    var labelModel = seriesScope && seriesScope.labelModel;
    var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
    if (!seriesScope || lineData.hasItemOption) {
      var itemModel = lineData.getItemModel(idx);
      lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();
      hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();
      labelModel = itemModel.getModel('label.normal');
      hoverLabelModel = itemModel.getModel('label.emphasis');
    }
    var visualColor = lineData.getItemVisual(idx, 'color');
    if (isNaN(defaultText)) {
      defaultText = lineData.getName(idx);
    }
    line.useStyle(zrUtil.defaults({
      strokeNoScale: true,
      fill: 'none',
      stroke: visualColor
    }, lineStyle));
    line.hoverStyle = hoverLineStyle;
    var showLabel = labelModel.getShallow('show');
    var hoverShowLabel = hoverLabelModel.getShallow('show');
    var defaultText;
    var label = this.childOfName('label');
    var defaultLabelColor;
    if (showLabel || hoverShowLabel) {
      defaultText = numberUtil.round(seriesModel.getRawValue(idx));
      defaultLabelColor = visualColor || '#000';
    }
    if (showLabel) {
      var textStyleModel = labelModel.getModel('textStyle');
      label.setStyle({
        text: zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType), defaultText),
        textFont: textStyleModel.getFont(),
        fill: textStyleModel.getTextColor() || defaultLabelColor
      });
      label.__textAlign = textStyleModel.get('align');
      label.__verticalAlign = textStyleModel.get('baseline');
      label.__position = labelModel.get('position');
    } else {
      label.setStyle('text', '');
    }
    if (hoverShowLabel) {
      var textStyleHoverModel = hoverLabelModel.getModel('textStyle');
      label.hoverStyle = {
        text: zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType), defaultText),
        textFont: textStyleHoverModel.getFont(),
        fill: textStyleHoverModel.getTextColor() || defaultLabelColor
      };
    } else {
      label.hoverStyle = {text: ''};
    }
    label.ignore = !showLabel && !hoverShowLabel;
    graphic.setHoverStyle(this);
  };
  lineProto.updateLayout = function(lineData, idx) {
    this.setLinePoints(lineData.getItemLayout(idx));
  };
  lineProto.setLinePoints = function(points) {
    var linePath = this.childOfName('line');
    setLinePoints(linePath.shape, points);
    linePath.dirty();
  };
  zrUtil.inherits(Line, graphic.Group);
  module.exports = Line;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/chart/helper/LineDraw.js", ["../../util/graphic", "./Line", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../../util/graphic');
  var LineGroup = $__require('./Line');
  function isPointNaN(pt) {
    return isNaN(pt[0]) || isNaN(pt[1]);
  }
  function lineNeedsDraw(pts) {
    return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
  }
  function LineDraw(ctor) {
    this._ctor = ctor || LineGroup;
    this.group = new graphic.Group();
  }
  var lineDrawProto = LineDraw.prototype;
  lineDrawProto.updateData = function(lineData) {
    var oldLineData = this._lineData;
    var group = this.group;
    var LineCtor = this._ctor;
    var hostModel = lineData.hostModel;
    var seriesScope = {
      lineStyle: hostModel.getModel('lineStyle.normal').getLineStyle(),
      hoverLineStyle: hostModel.getModel('lineStyle.emphasis').getLineStyle(),
      labelModel: hostModel.getModel('label.normal'),
      hoverLabelModel: hostModel.getModel('label.emphasis')
    };
    lineData.diff(oldLineData).add(function(idx) {
      if (!lineNeedsDraw(lineData.getItemLayout(idx))) {
        return;
      }
      var lineGroup = new LineCtor(lineData, idx, seriesScope);
      lineData.setItemGraphicEl(idx, lineGroup);
      group.add(lineGroup);
    }).update(function(newIdx, oldIdx) {
      var lineGroup = oldLineData.getItemGraphicEl(oldIdx);
      if (!lineNeedsDraw(lineData.getItemLayout(newIdx))) {
        group.remove(lineGroup);
        return;
      }
      if (!lineGroup) {
        lineGroup = new LineCtor(lineData, newIdx, seriesScope);
      } else {
        lineGroup.updateData(lineData, newIdx, seriesScope);
      }
      lineData.setItemGraphicEl(newIdx, lineGroup);
      group.add(lineGroup);
    }).remove(function(idx) {
      group.remove(oldLineData.getItemGraphicEl(idx));
    }).execute();
    this._lineData = lineData;
  };
  lineDrawProto.updateLayout = function() {
    var lineData = this._lineData;
    lineData.eachItemGraphicEl(function(el, idx) {
      el.updateLayout(lineData, idx);
    }, this);
  };
  lineDrawProto.remove = function() {
    this.group.removeAll();
  };
  module.exports = LineDraw;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/marker/MarkLineView.js", ["zrender/lib/core/util", "../../data/List", "../../util/number", "./markerHelper", "../../chart/helper/LineDraw", "./MarkerView", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var List = $__require('../../data/List');
  var numberUtil = $__require('../../util/number');
  var markerHelper = $__require('./markerHelper');
  var LineDraw = $__require('../../chart/helper/LineDraw');
  var markLineTransform = function(seriesModel, coordSys, mlModel, item) {
    var data = seriesModel.getData();
    var mlType = item.type;
    if (!zrUtil.isArray(item) && (mlType === 'min' || mlType === 'max' || mlType === 'average' || (item.xAxis != null || item.yAxis != null))) {
      var valueAxis;
      var valueDataDim;
      var value;
      if (item.yAxis != null || item.xAxis != null) {
        valueDataDim = item.yAxis != null ? 'y' : 'x';
        valueAxis = coordSys.getAxis(valueDataDim);
        value = zrUtil.retrieve(item.yAxis, item.xAxis);
      } else {
        var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);
        valueDataDim = axisInfo.valueDataDim;
        valueAxis = axisInfo.valueAxis;
        value = markerHelper.numCalculate(data, valueDataDim, mlType);
      }
      var valueIndex = valueDataDim === 'x' ? 0 : 1;
      var baseIndex = 1 - valueIndex;
      var mlFrom = zrUtil.clone(item);
      var mlTo = {};
      mlFrom.type = null;
      mlFrom.coord = [];
      mlTo.coord = [];
      mlFrom.coord[baseIndex] = -Infinity;
      mlTo.coord[baseIndex] = Infinity;
      var precision = mlModel.get('precision');
      if (precision >= 0) {
        value = +value.toFixed(precision);
      }
      mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
      item = [mlFrom, mlTo, {
        type: mlType,
        valueIndex: item.valueIndex,
        value: value
      }];
    }
    item = [markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), zrUtil.extend({}, item[2])];
    item[2].type = item[2].type || '';
    zrUtil.merge(item[2], item[0]);
    zrUtil.merge(item[2], item[1]);
    return item;
  };
  function isInifinity(val) {
    return !isNaN(val) && !isFinite(val);
  }
  function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
    var otherDimIndex = 1 - dimIndex;
    var dimName = coordSys.dimensions[dimIndex];
    return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
  }
  function markLineFilter(coordSys, item) {
    if (coordSys.type === 'cartesian2d') {
      var fromCoord = item[0].coord;
      var toCoord = item[1].coord;
      if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
        return true;
      }
    }
    return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);
  }
  function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var itemModel = data.getItemModel(idx);
    var point;
    var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());
    var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());
    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } else {
      if (seriesModel.getMarkerPosition) {
        point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
      } else {
        var dims = coordSys.dimensions;
        var x = data.get(dims[0], idx);
        var y = data.get(dims[1], idx);
        point = coordSys.dataToPoint([x, y]);
      }
      if (coordSys.type === 'cartesian2d') {
        var xAxis = coordSys.getAxis('x');
        var yAxis = coordSys.getAxis('y');
        var dims = coordSys.dimensions;
        if (isInifinity(data.get(dims[0], idx))) {
          point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
        } else if (isInifinity(data.get(dims[1], idx))) {
          point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
        }
      }
      if (!isNaN(xPx)) {
        point[0] = xPx;
      }
      if (!isNaN(yPx)) {
        point[1] = yPx;
      }
    }
    data.setItemLayout(idx, point);
  }
  $__require('./MarkerView').extend({
    type: 'markLine',
    updateLayout: function(markLineModel, ecModel, api) {
      ecModel.eachSeries(function(seriesModel) {
        var mlModel = seriesModel.markLineModel;
        if (mlModel) {
          var mlData = mlModel.getData();
          var fromData = mlModel.__from;
          var toData = mlModel.__to;
          fromData.each(function(idx) {
            updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
            updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
          });
          mlData.each(function(idx) {
            mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
          });
          this.markerGroupMap[seriesModel.name].updateLayout();
        }
      }, this);
    },
    renderSeries: function(seriesModel, mlModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesName = seriesModel.name;
      var seriesData = seriesModel.getData();
      var lineDrawMap = this.markerGroupMap;
      var lineDraw = lineDrawMap[seriesName];
      if (!lineDraw) {
        lineDraw = lineDrawMap[seriesName] = new LineDraw();
      }
      this.group.add(lineDraw.group);
      var mlData = createList(coordSys, seriesModel, mlModel);
      var fromData = mlData.from;
      var toData = mlData.to;
      var lineData = mlData.line;
      mlModel.__from = fromData;
      mlModel.__to = toData;
      mlModel.setData(lineData);
      var symbolType = mlModel.get('symbol');
      var symbolSize = mlModel.get('symbolSize');
      if (!zrUtil.isArray(symbolType)) {
        symbolType = [symbolType, symbolType];
      }
      if (typeof symbolSize === 'number') {
        symbolSize = [symbolSize, symbolSize];
      }
      mlData.from.each(function(idx) {
        updateDataVisualAndLayout(fromData, idx, true);
        updateDataVisualAndLayout(toData, idx, false);
      });
      lineData.each(function(idx) {
        var lineColor = lineData.getItemModel(idx).get('lineStyle.normal.color');
        lineData.setItemVisual(idx, {color: lineColor || fromData.getItemVisual(idx, 'color')});
        lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
        lineData.setItemVisual(idx, {
          'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),
          'fromSymbol': fromData.getItemVisual(idx, 'symbol'),
          'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),
          'toSymbol': toData.getItemVisual(idx, 'symbol')
        });
      });
      lineDraw.updateData(lineData);
      mlData.line.eachItemGraphicEl(function(el, idx) {
        el.traverse(function(child) {
          child.dataModel = mlModel;
        });
      });
      function updateDataVisualAndLayout(data, idx, isFrom) {
        var itemModel = data.getItemModel(idx);
        updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
        data.setItemVisual(idx, {
          symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],
          symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],
          color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color')
        });
      }
      lineDraw.__keep = true;
      lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');
    }
  });
  function createList(coordSys, seriesModel, mlModel) {
    var coordDimsInfos;
    if (coordSys) {
      coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function(coordDim) {
        var info = seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0]) || {};
        info.name = coordDim;
        return info;
      });
    } else {
      coordDimsInfos = [{
        name: 'value',
        type: 'float'
      }];
    }
    var fromData = new List(coordDimsInfos, mlModel);
    var toData = new List(coordDimsInfos, mlModel);
    var lineData = new List([], mlModel);
    var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(markLineTransform, seriesModel, coordSys, mlModel));
    if (coordSys) {
      optData = zrUtil.filter(optData, zrUtil.curry(markLineFilter, coordSys));
    }
    var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function(item) {
      return item.value;
    };
    fromData.initData(zrUtil.map(optData, function(item) {
      return item[0];
    }), null, dimValueGetter);
    toData.initData(zrUtil.map(optData, function(item) {
      return item[1];
    }), null, dimValueGetter);
    lineData.initData(zrUtil.map(optData, function(item) {
      return item[2];
    }));
    lineData.hasItemOption = true;
    return {
      from: fromData,
      to: toData,
      line: lineData
    };
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/markLine.js", ["./marker/MarkLineModel", "./marker/MarkLineView", "../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./marker/MarkLineModel');
  $__require('./marker/MarkLineView');
  $__require('../echarts').registerPreprocessor(function(opt) {
    opt.markLine = opt.markLine || {};
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/marker/MarkerModel.js", ["../../util/model", "zrender/lib/core/util", "zrender/lib/core/env", "../../util/format", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var modelUtil = $__require('../../util/model');
  var zrUtil = $__require('zrender/lib/core/util');
  var env = $__require('zrender/lib/core/env');
  var formatUtil = $__require('../../util/format');
  var addCommas = formatUtil.addCommas;
  var encodeHTML = formatUtil.encodeHTML;
  function fillLabel(opt) {
    modelUtil.defaultEmphasis(opt.label, modelUtil.LABEL_OPTIONS);
  }
  var MarkerModel = $__require('../../echarts').extendComponentModel({
    type: 'marker',
    dependencies: ['series', 'grid', 'polar', 'geo'],
    init: function(option, parentModel, ecModel, extraOpt) {
      if (__DEV__) {
        if (this.type === 'marker') {
          throw new Error('Marker component is abstract component. Use markLine, markPoint, markArea instead.');
        }
      }
      this.mergeDefaultAndTheme(option, ecModel);
      this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);
    },
    ifEnableAnimation: function() {
      if (env.node) {
        return false;
      }
      var hostSeries = this.__hostSeries;
      return this.getShallow('animation') && hostSeries && hostSeries.ifEnableAnimation();
    },
    mergeOption: function(newOpt, ecModel, createdBySelf, isInit) {
      var MarkerModel = this.constructor;
      var modelPropName = this.mainType + 'Model';
      if (!createdBySelf) {
        ecModel.eachSeries(function(seriesModel) {
          var markerOpt = seriesModel.get(this.mainType);
          var markerModel = seriesModel[modelPropName];
          if (!markerOpt || !markerOpt.data) {
            seriesModel[modelPropName] = null;
            return;
          }
          if (!markerModel) {
            if (isInit) {
              fillLabel(markerOpt);
            }
            zrUtil.each(markerOpt.data, function(item) {
              if (item instanceof Array) {
                fillLabel(item[0]);
                fillLabel(item[1]);
              } else {
                fillLabel(item);
              }
            });
            var opt = {
              mainType: this.mainType,
              seriesIndex: seriesModel.seriesIndex,
              name: seriesModel.name,
              createdBySelf: true
            };
            markerModel = new MarkerModel(markerOpt, this, ecModel, opt);
            markerModel.__hostSeries = seriesModel;
          } else {
            markerModel.mergeOption(markerOpt, ecModel, true);
          }
          seriesModel[modelPropName] = markerModel;
        }, this);
      }
    },
    formatTooltip: function(dataIndex) {
      var data = this.getData();
      var value = this.getRawValue(dataIndex);
      var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);
      var name = data.getName(dataIndex);
      var html = this.name;
      if (value != null || name) {
        html += '<br />';
      }
      if (name) {
        html += encodeHTML(name);
        if (value != null) {
          html += ' : ';
        }
      }
      if (value != null) {
        html += formattedValue;
      }
      return html;
    },
    getData: function() {
      return this._data;
    },
    setData: function(data) {
      this._data = data;
    }
  });
  zrUtil.mixin(MarkerModel, modelUtil.dataFormatMixin);
  module.exports = MarkerModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/marker/MarkAreaModel.js", ["./MarkerModel", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./MarkerModel').extend({
    type: 'markArea',
    defaultOption: {
      zlevel: 0,
      z: 1,
      tooltip: {trigger: 'item'},
      animation: false,
      label: {
        normal: {
          show: true,
          position: 'top'
        },
        emphasis: {
          show: true,
          position: 'top'
        }
      },
      itemStyle: {normal: {borderWidth: 0}}
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/marker/markerHelper.js", ["zrender/lib/core/util", "../../util/number", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var numberUtil = $__require('../../util/number');
  var indexOf = zrUtil.indexOf;
  function hasXOrY(item) {
    return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
  }
  function hasXAndY(item) {
    return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
  }
  function getPrecision(data, valueAxisDim, dataIndex) {
    var precision = -1;
    do {
      precision = Math.max(numberUtil.getPrecision(data.get(valueAxisDim, dataIndex)), precision);
      data = data.stackedOn;
    } while (data);
    return precision;
  }
  function markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
    var coordArr = [];
    var value = numCalculate(data, targetDataDim, mlType);
    var dataIndex = data.indexOfNearest(targetDataDim, value, true);
    coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true);
    coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true);
    var precision = getPrecision(data, targetDataDim, dataIndex);
    if (precision >= 0) {
      coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
    }
    return coordArr;
  }
  var curry = zrUtil.curry;
  var markerTypeCalculator = {
    min: curry(markerTypeCalculatorWithExtent, 'min'),
    max: curry(markerTypeCalculatorWithExtent, 'max'),
    average: curry(markerTypeCalculatorWithExtent, 'average')
  };
  var dataTransform = function(seriesModel, item) {
    var data = seriesModel.getData();
    var coordSys = seriesModel.coordinateSystem;
    if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {
      var dims = coordSys.dimensions;
      var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);
      item = zrUtil.clone(item);
      if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
        var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);
        var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
        item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
        item.value = item.coord[targetCoordIndex];
      } else {
        var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis];
        for (var i = 0; i < 2; i++) {
          if (markerTypeCalculator[coord[i]]) {
            var dataDim = seriesModel.coordDimToDataDim(dims[i])[0];
            coord[i] = numCalculate(data, dataDim, coord[i]);
          }
        }
        item.coord = coord;
      }
    }
    return item;
  };
  var getAxisInfo = function(item, data, coordSys, seriesModel) {
    var ret = {};
    if (item.valueIndex != null || item.valueDim != null) {
      ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
      ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));
      ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
      ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];
    } else {
      ret.baseAxis = seriesModel.getBaseAxis();
      ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
      ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];
      ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];
    }
    return ret;
  };
  var dataFilter = function(coordSys, item) {
    return (coordSys && coordSys.containData && item.coord && !hasXOrY(item)) ? coordSys.containData(item.coord) : true;
  };
  var dimValueGetter = function(item, dimName, dataIndex, dimIndex) {
    if (dimIndex < 2) {
      return item.coord && item.coord[dimIndex];
    }
    return item.value;
  };
  var numCalculate = function(data, valueDataDim, type) {
    if (type === 'average') {
      var sum = 0;
      var count = 0;
      data.each(valueDataDim, function(val, idx) {
        if (!isNaN(val)) {
          sum += val;
          count++;
        }
      }, true);
      return sum / count;
    } else {
      return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];
    }
  };
  module.exports = {
    dataTransform: dataTransform,
    dataFilter: dataFilter,
    dimValueGetter: dimValueGetter,
    getAxisInfo: getAxisInfo,
    numCalculate: numCalculate
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/marker/MarkerView.js", ["../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('../../echarts').extendComponentView({
    type: 'marker',
    init: function() {
      this.markerGroupMap = {};
    },
    render: function(markerModel, ecModel, api) {
      var markerGroupMap = this.markerGroupMap;
      for (var name in markerGroupMap) {
        markerGroupMap[name].__keep = false;
      }
      var markerModelKey = this.type + 'Model';
      ecModel.eachSeries(function(seriesModel) {
        var markerModel = seriesModel[markerModelKey];
        markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);
      }, this);
      for (var name in markerGroupMap) {
        if (!markerGroupMap[name].__keep) {
          this.group.remove(markerGroupMap[name].group);
        }
      }
    },
    renderSeries: function() {}
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/marker/MarkAreaView.js", ["zrender/lib/core/util", "../../data/List", "../../util/number", "../../util/graphic", "zrender/lib/tool/color", "./markerHelper", "./MarkerView", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var List = $__require('../../data/List');
  var numberUtil = $__require('../../util/number');
  var graphic = $__require('../../util/graphic');
  var colorUtil = $__require('zrender/lib/tool/color');
  var markerHelper = $__require('./markerHelper');
  var markAreaTransform = function(seriesModel, coordSys, maModel, item) {
    var lt = markerHelper.dataTransform(seriesModel, item[0]);
    var rb = markerHelper.dataTransform(seriesModel, item[1]);
    var retrieve = zrUtil.retrieve;
    var ltCoord = lt.coord;
    var rbCoord = rb.coord;
    ltCoord[0] = retrieve(ltCoord[0], -Infinity);
    ltCoord[1] = retrieve(ltCoord[1], -Infinity);
    rbCoord[0] = retrieve(rbCoord[0], Infinity);
    rbCoord[1] = retrieve(rbCoord[1], Infinity);
    var result = zrUtil.mergeAll([{}, lt, rb]);
    result.coord = [lt.coord, rb.coord];
    result.x0 = lt.x;
    result.y0 = lt.y;
    result.x1 = rb.x;
    result.y1 = rb.y;
    return result;
  };
  function isInifinity(val) {
    return !isNaN(val) && !isFinite(val);
  }
  function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
    var otherDimIndex = 1 - dimIndex;
    return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);
  }
  function markAreaFilter(coordSys, item) {
    var fromCoord = item.coord[0];
    var toCoord = item.coord[1];
    if (coordSys.type === 'cartesian2d') {
      if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
        return true;
      }
    }
    return markerHelper.dataFilter(coordSys, {
      coord: fromCoord,
      x: item.x0,
      y: item.y0
    }) || markerHelper.dataFilter(coordSys, {
      coord: toCoord,
      x: item.x1,
      y: item.y1
    });
  }
  function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var itemModel = data.getItemModel(idx);
    var point;
    var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth());
    var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());
    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } else {
      if (seriesModel.getMarkerPosition) {
        point = seriesModel.getMarkerPosition(data.getValues(dims, idx));
      } else {
        var x = data.get(dims[0], idx);
        var y = data.get(dims[1], idx);
        point = coordSys.dataToPoint([x, y], true);
      }
      if (coordSys.type === 'cartesian2d') {
        var xAxis = coordSys.getAxis('x');
        var yAxis = coordSys.getAxis('y');
        var x = data.get(dims[0], idx);
        var y = data.get(dims[1], idx);
        if (isInifinity(x)) {
          point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);
        } else if (isInifinity(y)) {
          point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);
        }
      }
      if (!isNaN(xPx)) {
        point[0] = xPx;
      }
      if (!isNaN(yPx)) {
        point[1] = yPx;
      }
    }
    return point;
  }
  var dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];
  $__require('./MarkerView').extend({
    type: 'markArea',
    updateLayout: function(markAreaModel, ecModel, api) {
      ecModel.eachSeries(function(seriesModel) {
        var maModel = seriesModel.markAreaModel;
        if (maModel) {
          var areaData = maModel.getData();
          areaData.each(function(idx) {
            var points = zrUtil.map(dimPermutations, function(dim) {
              return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
            });
            areaData.setItemLayout(idx, points);
            var el = areaData.getItemGraphicEl(idx);
            el.setShape('points', points);
          });
        }
      }, this);
    },
    renderSeries: function(seriesModel, maModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesName = seriesModel.name;
      var seriesData = seriesModel.getData();
      var areaGroupMap = this.markerGroupMap;
      var polygonGroup = areaGroupMap[seriesName];
      if (!polygonGroup) {
        polygonGroup = areaGroupMap[seriesName] = {group: new graphic.Group()};
      }
      this.group.add(polygonGroup.group);
      polygonGroup.__keep = true;
      var areaData = createList(coordSys, seriesModel, maModel);
      maModel.setData(areaData);
      areaData.each(function(idx) {
        areaData.setItemLayout(idx, zrUtil.map(dimPermutations, function(dim) {
          return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
        }));
        areaData.setItemVisual(idx, {color: seriesData.getVisual('color')});
      });
      areaData.diff(polygonGroup.__data).add(function(idx) {
        var polygon = new graphic.Polygon({shape: {points: areaData.getItemLayout(idx)}});
        areaData.setItemGraphicEl(idx, polygon);
        polygonGroup.group.add(polygon);
      }).update(function(newIdx, oldIdx) {
        var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx);
        graphic.updateProps(polygon, {shape: {points: areaData.getItemLayout(newIdx)}}, maModel, newIdx);
        polygonGroup.group.add(polygon);
        areaData.setItemGraphicEl(newIdx, polygon);
      }).remove(function(idx) {
        var polygon = polygonGroup.__data.getItemGraphicEl(idx);
        polygonGroup.group.remove(polygon);
      }).execute();
      areaData.eachItemGraphicEl(function(polygon, idx) {
        var itemModel = areaData.getItemModel(idx);
        var labelModel = itemModel.getModel('label.normal');
        var labelHoverModel = itemModel.getModel('label.emphasis');
        var color = areaData.getItemVisual(idx, 'color');
        polygon.useStyle(zrUtil.defaults(itemModel.getModel('itemStyle.normal').getItemStyle(), {
          fill: colorUtil.modifyAlpha(color, 0.4),
          stroke: color
        }));
        polygon.hoverStyle = itemModel.getModel('itemStyle.normal').getItemStyle();
        var defaultValue = areaData.getName(idx) || '';
        var textColor = color || polygon.style.fill;
        graphic.setText(polygon.style, labelModel, textColor);
        polygon.style.text = zrUtil.retrieve(maModel.getFormattedLabel(idx, 'normal'), defaultValue);
        graphic.setText(polygon.hoverStyle, labelHoverModel, textColor);
        polygon.hoverStyle.text = zrUtil.retrieve(maModel.getFormattedLabel(idx, 'emphasis'), defaultValue);
        graphic.setHoverStyle(polygon, {});
        polygon.dataModel = maModel;
      });
      polygonGroup.__data = areaData;
      polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');
    }
  });
  function createList(coordSys, seriesModel, maModel) {
    var coordDimsInfos;
    var areaData;
    var dims = ['x0', 'y0', 'x1', 'y1'];
    if (coordSys) {
      coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function(coordDim) {
        var info = seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0]) || {};
        info.name = coordDim;
        return info;
      });
      areaData = new List(zrUtil.map(dims, function(dim, idx) {
        return {
          name: dim,
          type: coordDimsInfos[idx % 2].type
        };
      }), maModel);
    } else {
      coordDimsInfos = [{
        name: 'value',
        type: 'float'
      }];
      areaData = new List(coordDimsInfos, maModel);
    }
    var optData = zrUtil.map(maModel.get('data'), zrUtil.curry(markAreaTransform, seriesModel, coordSys, maModel));
    if (coordSys) {
      optData = zrUtil.filter(optData, zrUtil.curry(markAreaFilter, coordSys));
    }
    var dimValueGetter = coordSys ? function(item, dimName, dataIndex, dimIndex) {
      return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
    } : function(item) {
      return item.value;
    };
    areaData.initData(optData, null, dimValueGetter);
    areaData.hasItemOption = true;
    return areaData;
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/markArea.js", ["./marker/MarkAreaModel", "./marker/MarkAreaView", "../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./marker/MarkAreaModel');
  $__require('./marker/MarkAreaView');
  $__require('../echarts').registerPreprocessor(function(opt) {
    opt.markArea = opt.markArea || {};
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/timeline/preprocessor.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  module.exports = function(option) {
    var timelineOpt = option && option.timeline;
    if (!zrUtil.isArray(timelineOpt)) {
      timelineOpt = timelineOpt ? [timelineOpt] : [];
    }
    zrUtil.each(timelineOpt, function(opt) {
      if (!opt) {
        return;
      }
      compatibleEC2(opt);
    });
  };
  function compatibleEC2(opt) {
    var type = opt.type;
    var ec2Types = {
      'number': 'value',
      'time': 'time'
    };
    if (ec2Types[type]) {
      opt.axisType = ec2Types[type];
      delete opt.type;
    }
    transferItem(opt);
    if (has(opt, 'controlPosition')) {
      var controlStyle = opt.controlStyle || (opt.controlStyle = {});
      if (!has(controlStyle, 'position')) {
        controlStyle.position = opt.controlPosition;
      }
      if (controlStyle.position === 'none' && !has(controlStyle, 'show')) {
        controlStyle.show = false;
        delete controlStyle.position;
      }
      delete opt.controlPosition;
    }
    zrUtil.each(opt.data || [], function(dataItem) {
      if (zrUtil.isObject(dataItem) && !zrUtil.isArray(dataItem)) {
        if (!has(dataItem, 'value') && has(dataItem, 'name')) {
          dataItem.value = dataItem.name;
        }
        transferItem(dataItem);
      }
    });
  }
  function transferItem(opt) {
    var itemStyle = opt.itemStyle || (opt.itemStyle = {});
    var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});
    var label = opt.label || (opt.label || {});
    var labelNormal = label.normal || (label.normal = {});
    var excludeLabelAttr = {
      normal: 1,
      emphasis: 1
    };
    zrUtil.each(label, function(value, name) {
      if (!excludeLabelAttr[name] && !has(labelNormal, name)) {
        labelNormal[name] = value;
      }
    });
    if (itemStyleEmphasis.label && !has(label, 'emphasis')) {
      label.emphasis = itemStyleEmphasis.label;
      delete itemStyleEmphasis.label;
    }
  }
  function has(obj, attr) {
    return obj.hasOwnProperty(attr);
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/timeline/typeDefaulter.js", ["../../model/Component", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../../model/Component').registerSubTypeDefaulter('timeline', function() {
    return 'slider';
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/timeline/timelineAction.js", ["../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../../echarts');
  echarts.registerAction({
    type: 'timelineChange',
    event: 'timelineChanged',
    update: 'prepareAndUpdate'
  }, function(payload, ecModel) {
    var timelineModel = ecModel.getComponent('timeline');
    if (timelineModel && payload.currentIndex != null) {
      timelineModel.setCurrentIndex(payload.currentIndex);
      if (!timelineModel.get('loop', true) && timelineModel.isIndexMax()) {
        timelineModel.setPlayState(false);
      }
    }
    ecModel.resetOption('timeline');
  });
  echarts.registerAction({
    type: 'timelinePlayChange',
    event: 'timelinePlayChanged',
    update: 'update'
  }, function(payload, ecModel) {
    var timelineModel = ecModel.getComponent('timeline');
    if (timelineModel && payload.playState != null) {
      timelineModel.setPlayState(payload.playState);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/timeline/TimelineModel.js", ["../../model/Component", "../../data/List", "zrender/lib/core/util", "../../util/model", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ComponentModel = $__require('../../model/Component');
  var List = $__require('../../data/List');
  var zrUtil = $__require('zrender/lib/core/util');
  var modelUtil = $__require('../../util/model');
  var TimelineModel = ComponentModel.extend({
    type: 'timeline',
    layoutMode: 'box',
    defaultOption: {
      zlevel: 0,
      z: 4,
      show: true,
      axisType: 'time',
      realtime: true,
      left: '20%',
      top: null,
      right: '20%',
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: 'left',
      autoPlay: false,
      rewind: false,
      loop: true,
      playInterval: 2000,
      currentIndex: 0,
      itemStyle: {
        normal: {},
        emphasis: {}
      },
      label: {
        normal: {textStyle: {color: '#000'}},
        emphasis: {}
      },
      data: []
    },
    init: function(option, parentModel, ecModel) {
      this._data;
      this._names;
      this.mergeDefaultAndTheme(option, ecModel);
      this._initData();
    },
    mergeOption: function(option) {
      TimelineModel.superApply(this, 'mergeOption', arguments);
      this._initData();
    },
    setCurrentIndex: function(currentIndex) {
      if (currentIndex == null) {
        currentIndex = this.option.currentIndex;
      }
      var count = this._data.count();
      if (this.option.loop) {
        currentIndex = (currentIndex % count + count) % count;
      } else {
        currentIndex >= count && (currentIndex = count - 1);
        currentIndex < 0 && (currentIndex = 0);
      }
      this.option.currentIndex = currentIndex;
    },
    getCurrentIndex: function() {
      return this.option.currentIndex;
    },
    isIndexMax: function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    },
    setPlayState: function(state) {
      this.option.autoPlay = !!state;
    },
    getPlayState: function() {
      return !!this.option.autoPlay;
    },
    _initData: function() {
      var thisOption = this.option;
      var dataArr = thisOption.data || [];
      var axisType = thisOption.axisType;
      var names = this._names = [];
      if (axisType === 'category') {
        var idxArr = [];
        zrUtil.each(dataArr, function(item, index) {
          var value = modelUtil.getDataItemValue(item);
          var newItem;
          if (zrUtil.isObject(item)) {
            newItem = zrUtil.clone(item);
            newItem.value = index;
          } else {
            newItem = index;
          }
          idxArr.push(newItem);
          if (!zrUtil.isString(value) && (value == null || isNaN(value))) {
            value = '';
          }
          names.push(value + '');
        });
        dataArr = idxArr;
      }
      var dimType = ({
        category: 'ordinal',
        time: 'time'
      })[axisType] || 'number';
      var data = this._data = new List([{
        name: 'value',
        type: dimType
      }], this);
      data.initData(dataArr, names);
    },
    getData: function() {
      return this._data;
    },
    getCategories: function() {
      if (this.get('axisType') === 'category') {
        return this._names.slice();
      }
    }
  });
  module.exports = TimelineModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/timeline/SliderTimelineModel.js", ["./TimelineModel", "zrender/lib/core/util", "../../util/model", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var TimelineModel = $__require('./TimelineModel');
  var zrUtil = $__require('zrender/lib/core/util');
  var modelUtil = $__require('../../util/model');
  var SliderTimelineModel = TimelineModel.extend({
    type: 'timeline.slider',
    defaultOption: {
      backgroundColor: 'rgba(0,0,0,0)',
      borderColor: '#ccc',
      borderWidth: 0,
      orient: 'horizontal',
      inverse: false,
      tooltip: {trigger: 'item'},
      symbol: 'emptyCircle',
      symbolSize: 10,
      lineStyle: {
        show: true,
        width: 2,
        color: '#304654'
      },
      label: {
        position: 'auto',
        normal: {
          show: true,
          interval: 'auto',
          rotate: 0,
          textStyle: {color: '#304654'}
        },
        emphasis: {
          show: true,
          textStyle: {color: '#c23531'}
        }
      },
      itemStyle: {
        normal: {
          color: '#304654',
          borderWidth: 1
        },
        emphasis: {color: '#c23531'}
      },
      checkpointStyle: {
        symbol: 'circle',
        symbolSize: 13,
        color: '#c23531',
        borderWidth: 5,
        borderColor: 'rgba(194,53,49, 0.5)',
        animation: true,
        animationDuration: 300,
        animationEasing: 'quinticInOut'
      },
      controlStyle: {
        show: true,
        showPlayBtn: true,
        showPrevBtn: true,
        showNextBtn: true,
        itemSize: 22,
        itemGap: 12,
        position: 'left',
        playIcon: 'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z',
        stopIcon: 'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z',
        nextIcon: 'path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z',
        prevIcon: 'path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z',
        normal: {
          color: '#304654',
          borderColor: '#304654',
          borderWidth: 1
        },
        emphasis: {
          color: '#c23531',
          borderColor: '#c23531',
          borderWidth: 2
        }
      },
      data: []
    }
  });
  zrUtil.mixin(SliderTimelineModel, modelUtil.dataFormatMixin);
  module.exports = SliderTimelineModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/timeline/TimelineView.js", ["../../view/Component", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ComponentView = $__require('../../view/Component');
  module.exports = ComponentView.extend({type: 'timeline'});
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/Axis.js", ["../util/number", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var numberUtil = $__require('../util/number');
  var linearMap = numberUtil.linearMap;
  var zrUtil = $__require('zrender/lib/core/util');
  function fixExtentWithBands(extent, nTick) {
    var size = extent[1] - extent[0];
    var len = nTick;
    var margin = size / len / 2;
    extent[0] += margin;
    extent[1] -= margin;
  }
  var normalizedExtent = [0, 1];
  var Axis = function(dim, scale, extent) {
    this.dim = dim;
    this.scale = scale;
    this._extent = extent || [0, 0];
    this.inverse = false;
    this.onBand = false;
  };
  Axis.prototype = {
    constructor: Axis,
    contain: function(coord) {
      var extent = this._extent;
      var min = Math.min(extent[0], extent[1]);
      var max = Math.max(extent[0], extent[1]);
      return coord >= min && coord <= max;
    },
    containData: function(data) {
      return this.contain(this.dataToCoord(data));
    },
    getExtent: function() {
      var ret = this._extent.slice();
      return ret;
    },
    getPixelPrecision: function(dataExtent) {
      return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
    },
    setExtent: function(start, end) {
      var extent = this._extent;
      extent[0] = start;
      extent[1] = end;
    },
    dataToCoord: function(data, clamp) {
      var extent = this._extent;
      var scale = this.scale;
      data = scale.normalize(data);
      if (this.onBand && scale.type === 'ordinal') {
        extent = extent.slice();
        fixExtentWithBands(extent, scale.count());
      }
      return linearMap(data, normalizedExtent, extent, clamp);
    },
    coordToData: function(coord, clamp) {
      var extent = this._extent;
      var scale = this.scale;
      if (this.onBand && scale.type === 'ordinal') {
        extent = extent.slice();
        fixExtentWithBands(extent, scale.count());
      }
      var t = linearMap(coord, extent, normalizedExtent, clamp);
      return this.scale.scale(t);
    },
    getTicksCoords: function(alignWithLabel) {
      if (this.onBand && !alignWithLabel) {
        var bands = this.getBands();
        var coords = [];
        for (var i = 0; i < bands.length; i++) {
          coords.push(bands[i][0]);
        }
        if (bands[i - 1]) {
          coords.push(bands[i - 1][1]);
        }
        return coords;
      } else {
        return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);
      }
    },
    getLabelsCoords: function() {
      return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);
    },
    getBands: function() {
      var extent = this.getExtent();
      var bands = [];
      var len = this.scale.count();
      var start = extent[0];
      var end = extent[1];
      var span = end - start;
      for (var i = 0; i < len; i++) {
        bands.push([span * i / len + start, span * (i + 1) / len + start]);
      }
      return bands;
    },
    getBandWidth: function() {
      var axisExtent = this._extent;
      var dataExtent = this.scale.getExtent();
      var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
      len === 0 && (len = 1);
      var size = Math.abs(axisExtent[1] - axisExtent[0]);
      return Math.abs(size) / len;
    }
  };
  module.exports = Axis;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/timeline/TimelineAxis.js", ["zrender/lib/core/util", "../../coord/Axis", "../../coord/axisHelper", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Axis = $__require('../../coord/Axis');
  var axisHelper = $__require('../../coord/axisHelper');
  var TimelineAxis = function(dim, scale, coordExtent, axisType) {
    Axis.call(this, dim, scale, coordExtent);
    this.type = axisType || 'value';
    this._autoLabelInterval;
    this.model = null;
  };
  TimelineAxis.prototype = {
    constructor: TimelineAxis,
    getLabelInterval: function() {
      var timelineModel = this.model;
      var labelModel = timelineModel.getModel('label.normal');
      var labelInterval = labelModel.get('interval');
      if (labelInterval != null && labelInterval != 'auto') {
        return labelInterval;
      }
      var labelInterval = this._autoLabelInterval;
      if (!labelInterval) {
        labelInterval = this._autoLabelInterval = axisHelper.getAxisLabelInterval(zrUtil.map(this.scale.getTicks(), this.dataToCoord, this), axisHelper.getFormattedLabels(this, labelModel.get('formatter')), labelModel.getModel('textStyle').getFont(), timelineModel.get('orient') === 'horizontal');
      }
      return labelInterval;
    },
    isLabelIgnored: function(idx) {
      if (this.type === 'category') {
        var labelInterval = this.getLabelInterval();
        return ((typeof labelInterval === 'function') && !labelInterval(idx, this.scale.getLabel(idx))) || idx % (labelInterval + 1);
      }
    }
  };
  zrUtil.inherits(TimelineAxis, Axis);
  module.exports = TimelineAxis;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/util/symbol.js", ["./graphic", "zrender/lib/core/BoundingRect", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('./graphic');
  var BoundingRect = $__require('zrender/lib/core/BoundingRect');
  var Triangle = graphic.extendShape({
    type: 'triangle',
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path, shape) {
      var cx = shape.cx;
      var cy = shape.cy;
      var width = shape.width / 2;
      var height = shape.height / 2;
      path.moveTo(cx, cy - height);
      path.lineTo(cx + width, cy + height);
      path.lineTo(cx - width, cy + height);
      path.closePath();
    }
  });
  var Diamond = graphic.extendShape({
    type: 'diamond',
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path, shape) {
      var cx = shape.cx;
      var cy = shape.cy;
      var width = shape.width / 2;
      var height = shape.height / 2;
      path.moveTo(cx, cy - height);
      path.lineTo(cx + width, cy);
      path.lineTo(cx, cy + height);
      path.lineTo(cx - width, cy);
      path.closePath();
    }
  });
  var Pin = graphic.extendShape({
    type: 'pin',
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path, shape) {
      var x = shape.x;
      var y = shape.y;
      var w = shape.width / 5 * 3;
      var h = Math.max(w, shape.height);
      var r = w / 2;
      var dy = r * r / (h - r);
      var cy = y - h + r + dy;
      var angle = Math.asin(dy / r);
      var dx = Math.cos(angle) * r;
      var tanX = Math.sin(angle);
      var tanY = Math.cos(angle);
      path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
      var cpLen = r * 0.6;
      var cpLen2 = r * 0.7;
      path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
      path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
      path.closePath();
    }
  });
  var Arrow = graphic.extendShape({
    type: 'arrow',
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(ctx, shape) {
      var height = shape.height;
      var width = shape.width;
      var x = shape.x;
      var y = shape.y;
      var dx = width / 3 * 2;
      ctx.moveTo(x, y);
      ctx.lineTo(x + dx, y + height);
      ctx.lineTo(x, y + height / 4 * 3);
      ctx.lineTo(x - dx, y + height);
      ctx.lineTo(x, y);
      ctx.closePath();
    }
  });
  var symbolCtors = {
    line: graphic.Line,
    rect: graphic.Rect,
    roundRect: graphic.Rect,
    square: graphic.Rect,
    circle: graphic.Circle,
    diamond: Diamond,
    pin: Pin,
    arrow: Arrow,
    triangle: Triangle
  };
  var symbolShapeMakers = {
    line: function(x, y, w, h, shape) {
      shape.x1 = x;
      shape.y1 = y + h / 2;
      shape.x2 = x + w;
      shape.y2 = y + h / 2;
    },
    rect: function(x, y, w, h, shape) {
      shape.x = x;
      shape.y = y;
      shape.width = w;
      shape.height = h;
    },
    roundRect: function(x, y, w, h, shape) {
      shape.x = x;
      shape.y = y;
      shape.width = w;
      shape.height = h;
      shape.r = Math.min(w, h) / 4;
    },
    square: function(x, y, w, h, shape) {
      var size = Math.min(w, h);
      shape.x = x;
      shape.y = y;
      shape.width = size;
      shape.height = size;
    },
    circle: function(x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.r = Math.min(w, h) / 2;
    },
    diamond: function(x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    pin: function(x, y, w, h, shape) {
      shape.x = x + w / 2;
      shape.y = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    arrow: function(x, y, w, h, shape) {
      shape.x = x + w / 2;
      shape.y = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    triangle: function(x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.width = w;
      shape.height = h;
    }
  };
  var symbolBuildProxies = {};
  for (var name in symbolCtors) {
    symbolBuildProxies[name] = new symbolCtors[name]();
  }
  var Symbol = graphic.extendShape({
    type: 'symbol',
    shape: {
      symbolType: '',
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    beforeBrush: function() {
      var style = this.style;
      var shape = this.shape;
      if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
        style.textPosition = ['50%', '40%'];
        style.textAlign = 'center';
        style.textVerticalAlign = 'middle';
      }
    },
    buildPath: function(ctx, shape, inBundle) {
      var symbolType = shape.symbolType;
      var proxySymbol = symbolBuildProxies[symbolType];
      if (shape.symbolType !== 'none') {
        if (!proxySymbol) {
          symbolType = 'rect';
          proxySymbol = symbolBuildProxies[symbolType];
        }
        symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
        proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
      }
    }
  });
  var symbolPathSetColor = function(color) {
    if (this.type !== 'image') {
      var symbolStyle = this.style;
      var symbolShape = this.shape;
      if (symbolShape && symbolShape.symbolType === 'line') {
        symbolStyle.stroke = color;
      } else if (this.__isEmptyBrush) {
        symbolStyle.stroke = color;
        symbolStyle.fill = '#fff';
      } else {
        symbolStyle.fill && (symbolStyle.fill = color);
        symbolStyle.stroke && (symbolStyle.stroke = color);
      }
      this.dirty(false);
    }
  };
  var symbolUtil = {createSymbol: function(symbolType, x, y, w, h, color) {
      var isEmpty = symbolType.indexOf('empty') === 0;
      if (isEmpty) {
        symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
      }
      var symbolPath;
      if (symbolType.indexOf('image://') === 0) {
        symbolPath = new graphic.Image({style: {
            image: symbolType.slice(8),
            x: x,
            y: y,
            width: w,
            height: h
          }});
      } else if (symbolType.indexOf('path://') === 0) {
        symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));
      } else {
        symbolPath = new Symbol({shape: {
            symbolType: symbolType,
            x: x,
            y: y,
            width: w,
            height: h
          }});
      }
      symbolPath.__isEmptyBrush = isEmpty;
      symbolPath.setColor = symbolPathSetColor;
      symbolPath.setColor(color);
      return symbolPath;
    }};
  module.exports = symbolUtil;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/scale/Ordinal.js", ["zrender/lib/core/util", "./Scale", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Scale = $__require('./Scale');
  var scaleProto = Scale.prototype;
  var OrdinalScale = Scale.extend({
    type: 'ordinal',
    init: function(data, extent) {
      this._data = data;
      this._extent = extent || [0, data.length - 1];
    },
    parse: function(val) {
      return typeof val === 'string' ? zrUtil.indexOf(this._data, val) : Math.round(val);
    },
    contain: function(rank) {
      rank = this.parse(rank);
      return scaleProto.contain.call(this, rank) && this._data[rank] != null;
    },
    normalize: function(val) {
      return scaleProto.normalize.call(this, this.parse(val));
    },
    scale: function(val) {
      return Math.round(scaleProto.scale.call(this, val));
    },
    getTicks: function() {
      var ticks = [];
      var extent = this._extent;
      var rank = extent[0];
      while (rank <= extent[1]) {
        ticks.push(rank);
        rank++;
      }
      return ticks;
    },
    getLabel: function(n) {
      return this._data[n];
    },
    count: function() {
      return this._extent[1] - this._extent[0] + 1;
    },
    niceTicks: zrUtil.noop,
    niceExtent: zrUtil.noop
  });
  OrdinalScale.create = function() {
    return new OrdinalScale();
  };
  module.exports = OrdinalScale;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/scale/Time.js", ["zrender/lib/core/util", "../util/number", "../util/format", "./Interval", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var numberUtil = $__require('../util/number');
  var formatUtil = $__require('../util/format');
  var IntervalScale = $__require('./Interval');
  var intervalScaleProto = IntervalScale.prototype;
  var mathCeil = Math.ceil;
  var mathFloor = Math.floor;
  var ONE_SECOND = 1000;
  var ONE_MINUTE = ONE_SECOND * 60;
  var ONE_HOUR = ONE_MINUTE * 60;
  var ONE_DAY = ONE_HOUR * 24;
  var bisect = function(a, x, lo, hi) {
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid][2] < x) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    return lo;
  };
  var TimeScale = IntervalScale.extend({
    type: 'time',
    getLabel: function(val) {
      var stepLvl = this._stepLvl;
      var date = new Date(val);
      return formatUtil.formatTime(stepLvl[0], date);
    },
    niceExtent: function(approxTickNum, fixMin, fixMax) {
      var extent = this._extent;
      if (extent[0] === extent[1]) {
        extent[0] -= ONE_DAY;
        extent[1] += ONE_DAY;
      }
      if (extent[1] === -Infinity && extent[0] === Infinity) {
        var d = new Date();
        extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());
        extent[0] = extent[1] - ONE_DAY;
      }
      this.niceTicks(approxTickNum);
      var interval = this._interval;
      if (!fixMin) {
        extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);
      }
      if (!fixMax) {
        extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);
      }
    },
    niceTicks: function(approxTickNum) {
      approxTickNum = approxTickNum || 10;
      var extent = this._extent;
      var span = extent[1] - extent[0];
      var approxInterval = span / approxTickNum;
      var scaleLevelsLen = scaleLevels.length;
      var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);
      var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];
      var interval = level[2];
      if (level[0] === 'year') {
        var yearSpan = span / interval;
        var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);
        interval *= yearStep;
      }
      var niceExtent = [mathCeil(extent[0] / interval) * interval, mathFloor(extent[1] / interval) * interval];
      this._stepLvl = level;
      this._interval = interval;
      this._niceExtent = niceExtent;
    },
    parse: function(val) {
      return +numberUtil.parseDate(val);
    }
  });
  zrUtil.each(['contain', 'normalize'], function(methodName) {
    TimeScale.prototype[methodName] = function(val) {
      return intervalScaleProto[methodName].call(this, this.parse(val));
    };
  });
  var scaleLevels = [['hh:mm:ss', 1, ONE_SECOND], ['hh:mm:ss', 5, ONE_SECOND * 5], ['hh:mm:ss', 10, ONE_SECOND * 10], ['hh:mm:ss', 15, ONE_SECOND * 15], ['hh:mm:ss', 30, ONE_SECOND * 30], ['hh:mm\nMM-dd', 1, ONE_MINUTE], ['hh:mm\nMM-dd', 5, ONE_MINUTE * 5], ['hh:mm\nMM-dd', 10, ONE_MINUTE * 10], ['hh:mm\nMM-dd', 15, ONE_MINUTE * 15], ['hh:mm\nMM-dd', 30, ONE_MINUTE * 30], ['hh:mm\nMM-dd', 1, ONE_HOUR], ['hh:mm\nMM-dd', 2, ONE_HOUR * 2], ['hh:mm\nMM-dd', 6, ONE_HOUR * 6], ['hh:mm\nMM-dd', 12, ONE_HOUR * 12], ['MM-dd\nyyyy', 1, ONE_DAY], ['week', 7, ONE_DAY * 7], ['month', 1, ONE_DAY * 31], ['quarter', 3, ONE_DAY * 380 / 4], ['half-year', 6, ONE_DAY * 380 / 2], ['year', 1, ONE_DAY * 380]];
  TimeScale.create = function() {
    return new TimeScale();
  };
  module.exports = TimeScale;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/scale/Interval.js", ["../util/number", "../util/format", "./Scale", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var numberUtil = $__require('../util/number');
  var formatUtil = $__require('../util/format');
  var Scale = $__require('./Scale');
  var mathFloor = Math.floor;
  var mathCeil = Math.ceil;
  var IntervalScale = Scale.extend({
    type: 'interval',
    _interval: 0,
    setExtent: function(start, end) {
      var thisExtent = this._extent;
      if (!isNaN(start)) {
        thisExtent[0] = parseFloat(start);
      }
      if (!isNaN(end)) {
        thisExtent[1] = parseFloat(end);
      }
    },
    unionExtent: function(other) {
      var extent = this._extent;
      other[0] < extent[0] && (extent[0] = other[0]);
      other[1] > extent[1] && (extent[1] = other[1]);
      IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
    },
    getInterval: function() {
      if (!this._interval) {
        this.niceTicks();
      }
      return this._interval;
    },
    setInterval: function(interval) {
      this._interval = interval;
      this._niceExtent = this._extent.slice();
    },
    getTicks: function() {
      if (!this._interval) {
        this.niceTicks();
      }
      var interval = this._interval;
      var extent = this._extent;
      var ticks = [];
      var safeLimit = 10000;
      if (interval) {
        var niceExtent = this._niceExtent;
        if (extent[0] < niceExtent[0]) {
          ticks.push(extent[0]);
        }
        var tick = niceExtent[0];
        while (tick <= niceExtent[1]) {
          ticks.push(tick);
          tick = numberUtil.round(tick + interval);
          if (ticks.length > safeLimit) {
            return [];
          }
        }
        if (extent[1] > niceExtent[1]) {
          ticks.push(extent[1]);
        }
      }
      return ticks;
    },
    getTicksLabels: function() {
      var labels = [];
      var ticks = this.getTicks();
      for (var i = 0; i < ticks.length; i++) {
        labels.push(this.getLabel(ticks[i]));
      }
      return labels;
    },
    getLabel: function(data) {
      return formatUtil.addCommas(data);
    },
    niceTicks: function(splitNumber) {
      splitNumber = splitNumber || 5;
      var extent = this._extent;
      var span = extent[1] - extent[0];
      if (!isFinite(span)) {
        return;
      }
      if (span < 0) {
        span = -span;
        extent.reverse();
      }
      var step = numberUtil.nice(span / splitNumber, true);
      var niceExtent = [numberUtil.round(mathCeil(extent[0] / step) * step), numberUtil.round(mathFloor(extent[1] / step) * step)];
      this._interval = step;
      this._niceExtent = niceExtent;
    },
    niceExtent: function(splitNumber, fixMin, fixMax) {
      var extent = this._extent;
      if (extent[0] === extent[1]) {
        if (extent[0] !== 0) {
          var expandSize = extent[0];
          if (!fixMax) {
            extent[1] += expandSize / 2;
            extent[0] -= expandSize / 2;
          } else {
            extent[0] -= expandSize / 2;
          }
        } else {
          extent[1] = 1;
        }
      }
      var span = extent[1] - extent[0];
      if (!isFinite(span)) {
        extent[0] = 0;
        extent[1] = 1;
      }
      this.niceTicks(splitNumber);
      var interval = this._interval;
      if (!fixMin) {
        extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);
      }
      if (!fixMax) {
        extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);
      }
    }
  });
  IntervalScale.create = function() {
    return new IntervalScale();
  };
  module.exports = IntervalScale;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/scale/Log.js", ["zrender/lib/core/util", "./Scale", "../util/number", "./Interval", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var Scale = $__require('./Scale');
  var numberUtil = $__require('../util/number');
  var IntervalScale = $__require('./Interval');
  var scaleProto = Scale.prototype;
  var intervalScaleProto = IntervalScale.prototype;
  var mathFloor = Math.floor;
  var mathCeil = Math.ceil;
  var mathPow = Math.pow;
  var LOG_BASE = 10;
  var mathLog = Math.log;
  var LogScale = Scale.extend({
    type: 'log',
    getTicks: function() {
      return zrUtil.map(intervalScaleProto.getTicks.call(this), function(val) {
        return numberUtil.round(mathPow(LOG_BASE, val));
      });
    },
    getLabel: intervalScaleProto.getLabel,
    scale: function(val) {
      val = scaleProto.scale.call(this, val);
      return mathPow(LOG_BASE, val);
    },
    setExtent: function(start, end) {
      start = mathLog(start) / mathLog(LOG_BASE);
      end = mathLog(end) / mathLog(LOG_BASE);
      intervalScaleProto.setExtent.call(this, start, end);
    },
    getExtent: function() {
      var extent = scaleProto.getExtent.call(this);
      extent[0] = mathPow(LOG_BASE, extent[0]);
      extent[1] = mathPow(LOG_BASE, extent[1]);
      return extent;
    },
    unionExtent: function(extent) {
      extent[0] = mathLog(extent[0]) / mathLog(LOG_BASE);
      extent[1] = mathLog(extent[1]) / mathLog(LOG_BASE);
      scaleProto.unionExtent.call(this, extent);
    },
    niceTicks: function(approxTickNum) {
      approxTickNum = approxTickNum || 10;
      var extent = this._extent;
      var span = extent[1] - extent[0];
      if (span === Infinity || span <= 0) {
        return;
      }
      var interval = mathPow(10, mathFloor(mathLog(span / approxTickNum) / Math.LN10));
      var err = approxTickNum / span * interval;
      if (err <= 0.5) {
        interval *= 10;
      }
      var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];
      this._interval = interval;
      this._niceExtent = niceExtent;
    },
    niceExtent: intervalScaleProto.niceExtent
  });
  zrUtil.each(['contain', 'normalize'], function(methodName) {
    LogScale.prototype[methodName] = function(val) {
      val = mathLog(val) / mathLog(LOG_BASE);
      return scaleProto[methodName].call(this, val);
    };
  });
  LogScale.create = function() {
    return new LogScale();
  };
  module.exports = LogScale;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/scale/Scale.js", ["../util/clazz", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var clazzUtil = $__require('../util/clazz');
  function Scale() {
    this._extent = [Infinity, -Infinity];
    this._interval = 0;
    this.init && this.init.apply(this, arguments);
  }
  var scaleProto = Scale.prototype;
  scaleProto.parse = function(val) {
    return val;
  };
  scaleProto.contain = function(val) {
    var extent = this._extent;
    return val >= extent[0] && val <= extent[1];
  };
  scaleProto.normalize = function(val) {
    var extent = this._extent;
    if (extent[1] === extent[0]) {
      return 0.5;
    }
    return (val - extent[0]) / (extent[1] - extent[0]);
  };
  scaleProto.scale = function(val) {
    var extent = this._extent;
    return val * (extent[1] - extent[0]) + extent[0];
  };
  scaleProto.unionExtent = function(other) {
    var extent = this._extent;
    other[0] < extent[0] && (extent[0] = other[0]);
    other[1] > extent[1] && (extent[1] = other[1]);
  };
  scaleProto.getExtent = function() {
    return this._extent.slice();
  };
  scaleProto.setExtent = function(start, end) {
    var thisExtent = this._extent;
    if (!isNaN(start)) {
      thisExtent[0] = start;
    }
    if (!isNaN(end)) {
      thisExtent[1] = end;
    }
  };
  scaleProto.getTicksLabels = function() {
    var labels = [];
    var ticks = this.getTicks();
    for (var i = 0; i < ticks.length; i++) {
      labels.push(this.getLabel(ticks[i]));
    }
    return labels;
  };
  clazzUtil.enableClassExtend(Scale);
  clazzUtil.enableClassManagement(Scale, {registerWhenExtend: true});
  module.exports = Scale;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/coord/axisHelper.js", ["../scale/Ordinal", "../scale/Interval", "../scale/Time", "../scale/Log", "../scale/Scale", "../util/number", "zrender/lib/core/util", "zrender/lib/contain/text", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var OrdinalScale = $__require('../scale/Ordinal');
  var IntervalScale = $__require('../scale/Interval');
  $__require('../scale/Time');
  $__require('../scale/Log');
  var Scale = $__require('../scale/Scale');
  var numberUtil = $__require('../util/number');
  var zrUtil = $__require('zrender/lib/core/util');
  var textContain = $__require('zrender/lib/contain/text');
  var axisHelper = {};
  axisHelper.getScaleExtent = function(axis, model) {
    var scale = axis.scale;
    var originalExtent = scale.getExtent();
    var span = originalExtent[1] - originalExtent[0];
    if (scale.type === 'ordinal') {
      if (!isFinite(span)) {
        return [0, 0];
      } else {
        return originalExtent;
      }
    }
    var min = model.getMin ? model.getMin() : model.get('min');
    var max = model.getMax ? model.getMax() : model.get('max');
    var crossZero = model.getNeedCrossZero ? model.getNeedCrossZero() : !model.get('scale');
    var boundaryGap = model.get('boundaryGap');
    if (!zrUtil.isArray(boundaryGap)) {
      boundaryGap = [boundaryGap || 0, boundaryGap || 0];
    }
    boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);
    boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);
    var fixMin = true;
    var fixMax = true;
    if (min == null) {
      min = originalExtent[0] - boundaryGap[0] * span;
      fixMin = false;
    }
    if (max == null) {
      max = originalExtent[1] + boundaryGap[1] * span;
      fixMax = false;
    }
    if (min === 'dataMin') {
      min = originalExtent[0];
    }
    if (max === 'dataMax') {
      max = originalExtent[1];
    }
    if (crossZero) {
      if (min > 0 && max > 0 && !fixMin) {
        min = 0;
      }
      if (min < 0 && max < 0 && !fixMax) {
        max = 0;
      }
    }
    return [min, max];
  };
  axisHelper.niceScaleExtent = function(axis, model) {
    var scale = axis.scale;
    var extent = axisHelper.getScaleExtent(axis, model);
    var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;
    var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;
    var splitNumber = model.get('splitNumber');
    scale.setExtent(extent[0], extent[1]);
    scale.niceExtent(splitNumber, fixMin, fixMax);
    var minInterval = model.get('minInterval');
    if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {
      var interval = scale.getInterval();
      var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;
      extent = scale.getExtent();
      scale.setExtent(intervalScale * extent[0], extent[1] * intervalScale);
      scale.niceExtent(splitNumber);
    }
    var interval = model.get('interval');
    if (interval != null) {
      scale.setInterval && scale.setInterval(interval);
    }
  };
  axisHelper.createScaleByModel = function(model, axisType) {
    axisType = axisType || model.get('type');
    if (axisType) {
      switch (axisType) {
        case 'category':
          return new OrdinalScale(model.getCategories(), [Infinity, -Infinity]);
        case 'value':
          return new IntervalScale();
        default:
          return (Scale.getClass(axisType) || IntervalScale).create(model);
      }
    }
  };
  axisHelper.ifAxisCrossZero = function(axis) {
    var dataExtent = axis.scale.getExtent();
    var min = dataExtent[0];
    var max = dataExtent[1];
    return !((min > 0 && max > 0) || (min < 0 && max < 0));
  };
  axisHelper.getAxisLabelInterval = function(tickCoords, labels, font, isAxisHorizontal) {
    var textSpaceTakenRect;
    var autoLabelInterval = 0;
    var accumulatedLabelInterval = 0;
    var step = 1;
    if (labels.length > 40) {
      step = Math.floor(labels.length / 40);
    }
    for (var i = 0; i < tickCoords.length; i += step) {
      var tickCoord = tickCoords[i];
      var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');
      rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;
      rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;
      if (!textSpaceTakenRect) {
        textSpaceTakenRect = rect.clone();
      } else if (textSpaceTakenRect.intersect(rect)) {
        accumulatedLabelInterval++;
        autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);
      } else {
        textSpaceTakenRect.union(rect);
        accumulatedLabelInterval = 0;
      }
    }
    if (autoLabelInterval === 0 && step > 1) {
      return step;
    }
    return (autoLabelInterval + 1) * step - 1;
  };
  axisHelper.getFormattedLabels = function(axis, labelFormatter) {
    var scale = axis.scale;
    var labels = scale.getTicksLabels();
    var ticks = scale.getTicks();
    if (typeof labelFormatter === 'string') {
      labelFormatter = (function(tpl) {
        return function(val) {
          return tpl.replace('{value}', val);
        };
      })(labelFormatter);
      return zrUtil.map(labels, labelFormatter);
    } else if (typeof labelFormatter === 'function') {
      return zrUtil.map(ticks, function(tick, idx) {
        return labelFormatter(axis.type === 'category' ? scale.getLabel(tick) : tick, idx);
      }, this);
    } else {
      return labels;
    }
  };
  module.exports = axisHelper;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/timeline/SliderTimelineView.js", ["zrender/lib/core/util", "../../util/graphic", "../../util/layout", "./TimelineView", "./TimelineAxis", "../../util/symbol", "../../coord/axisHelper", "zrender/lib/core/BoundingRect", "zrender/lib/core/matrix", "../../util/number", "../../util/format", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var layout = $__require('../../util/layout');
  var TimelineView = $__require('./TimelineView');
  var TimelineAxis = $__require('./TimelineAxis');
  var symbolUtil = $__require('../../util/symbol');
  var axisHelper = $__require('../../coord/axisHelper');
  var BoundingRect = $__require('zrender/lib/core/BoundingRect');
  var matrix = $__require('zrender/lib/core/matrix');
  var numberUtil = $__require('../../util/number');
  var formatUtil = $__require('../../util/format');
  var encodeHTML = formatUtil.encodeHTML;
  var bind = zrUtil.bind;
  var each = zrUtil.each;
  var PI = Math.PI;
  module.exports = TimelineView.extend({
    type: 'timeline.slider',
    init: function(ecModel, api) {
      this.api = api;
      this._axis;
      this._viewRect;
      this._timer;
      this._currentPointer;
      this._mainGroup;
      this._labelGroup;
    },
    render: function(timelineModel, ecModel, api, payload) {
      this.model = timelineModel;
      this.api = api;
      this.ecModel = ecModel;
      this.group.removeAll();
      if (timelineModel.get('show', true)) {
        var layoutInfo = this._layout(timelineModel, api);
        var mainGroup = this._createGroup('mainGroup');
        var labelGroup = this._createGroup('labelGroup');
        var axis = this._axis = this._createAxis(layoutInfo, timelineModel);
        timelineModel.formatTooltip = function(dataIndex) {
          return encodeHTML(axis.scale.getLabel(dataIndex));
        };
        each(['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'], function(name) {
          this['_render' + name](layoutInfo, mainGroup, axis, timelineModel);
        }, this);
        this._renderAxisLabel(layoutInfo, labelGroup, axis, timelineModel);
        this._position(layoutInfo, timelineModel);
      }
      this._doPlayStop();
    },
    remove: function() {
      this._clearTimer();
      this.group.removeAll();
    },
    dispose: function() {
      this._clearTimer();
    },
    _layout: function(timelineModel, api) {
      var labelPosOpt = timelineModel.get('label.normal.position');
      var orient = timelineModel.get('orient');
      var viewRect = getViewRect(timelineModel, api);
      if (labelPosOpt == null || labelPosOpt === 'auto') {
        labelPosOpt = orient === 'horizontal' ? ((viewRect.y + viewRect.height / 2) < api.getHeight() / 2 ? '-' : '+') : ((viewRect.x + viewRect.width / 2) < api.getWidth() / 2 ? '+' : '-');
      } else if (isNaN(labelPosOpt)) {
        labelPosOpt = ({
          horizontal: {
            top: '-',
            bottom: '+'
          },
          vertical: {
            left: '-',
            right: '+'
          }
        })[orient][labelPosOpt];
      }
      var labelAlignMap = {
        horizontal: 'center',
        vertical: (labelPosOpt >= 0 || labelPosOpt === '+') ? 'left' : 'right'
      };
      var labelBaselineMap = {
        horizontal: (labelPosOpt >= 0 || labelPosOpt === '+') ? 'top' : 'bottom',
        vertical: 'middle'
      };
      var rotationMap = {
        horizontal: 0,
        vertical: PI / 2
      };
      var mainLength = orient === 'vertical' ? viewRect.height : viewRect.width;
      var controlModel = timelineModel.getModel('controlStyle');
      var showControl = controlModel.get('show');
      var controlSize = showControl ? controlModel.get('itemSize') : 0;
      var controlGap = showControl ? controlModel.get('itemGap') : 0;
      var sizePlusGap = controlSize + controlGap;
      var labelRotation = timelineModel.get('label.normal.rotate') || 0;
      labelRotation = labelRotation * PI / 180;
      var playPosition;
      var prevBtnPosition;
      var nextBtnPosition;
      var axisExtent;
      var controlPosition = controlModel.get('position', true);
      var showControl = controlModel.get('show', true);
      var showPlayBtn = showControl && controlModel.get('showPlayBtn', true);
      var showPrevBtn = showControl && controlModel.get('showPrevBtn', true);
      var showNextBtn = showControl && controlModel.get('showNextBtn', true);
      var xLeft = 0;
      var xRight = mainLength;
      if (controlPosition === 'left' || controlPosition === 'bottom') {
        showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);
        showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);
        showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
      } else {
        showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
        showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);
        showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
      }
      axisExtent = [xLeft, xRight];
      if (timelineModel.get('inverse')) {
        axisExtent.reverse();
      }
      return {
        viewRect: viewRect,
        mainLength: mainLength,
        orient: orient,
        rotation: rotationMap[orient],
        labelRotation: labelRotation,
        labelPosOpt: labelPosOpt,
        labelAlign: labelAlignMap[orient],
        labelBaseline: labelBaselineMap[orient],
        playPosition: playPosition,
        prevBtnPosition: prevBtnPosition,
        nextBtnPosition: nextBtnPosition,
        axisExtent: axisExtent,
        controlSize: controlSize,
        controlGap: controlGap
      };
    },
    _position: function(layoutInfo, timelineModel) {
      var mainGroup = this._mainGroup;
      var labelGroup = this._labelGroup;
      var viewRect = layoutInfo.viewRect;
      if (layoutInfo.orient === 'vertical') {
        var m = matrix.create();
        var rotateOriginX = viewRect.x;
        var rotateOriginY = viewRect.y + viewRect.height;
        matrix.translate(m, m, [-rotateOriginX, -rotateOriginY]);
        matrix.rotate(m, m, -PI / 2);
        matrix.translate(m, m, [rotateOriginX, rotateOriginY]);
        viewRect = viewRect.clone();
        viewRect.applyTransform(m);
      }
      var viewBound = getBound(viewRect);
      var mainBound = getBound(mainGroup.getBoundingRect());
      var labelBound = getBound(labelGroup.getBoundingRect());
      var mainPosition = mainGroup.position;
      var labelsPosition = labelGroup.position;
      labelsPosition[0] = mainPosition[0] = viewBound[0][0];
      var labelPosOpt = layoutInfo.labelPosOpt;
      if (isNaN(labelPosOpt)) {
        var mainBoundIdx = labelPosOpt === '+' ? 0 : 1;
        toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
        toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
      } else {
        var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
        toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
        labelsPosition[1] = mainPosition[1] + labelPosOpt;
      }
      mainGroup.attr('position', mainPosition);
      labelGroup.attr('position', labelsPosition);
      mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
      setOrigin(mainGroup);
      setOrigin(labelGroup);
      function setOrigin(targetGroup) {
        var pos = targetGroup.position;
        targetGroup.origin = [viewBound[0][0] - pos[0], viewBound[1][0] - pos[1]];
      }
      function getBound(rect) {
        return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];
      }
      function toBound(fromPos, from, to, dimIdx, boundIdx) {
        fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
      }
    },
    _createAxis: function(layoutInfo, timelineModel) {
      var data = timelineModel.getData();
      var axisType = timelineModel.get('axisType');
      var scale = axisHelper.createScaleByModel(timelineModel, axisType);
      var dataExtent = data.getDataExtent('value');
      scale.setExtent(dataExtent[0], dataExtent[1]);
      this._customizeScale(scale, data);
      scale.niceTicks();
      var axis = new TimelineAxis('value', scale, layoutInfo.axisExtent, axisType);
      axis.model = timelineModel;
      return axis;
    },
    _customizeScale: function(scale, data) {
      scale.getTicks = function() {
        return data.mapArray(['value'], function(value) {
          return value;
        });
      };
      scale.getTicksLabels = function() {
        return zrUtil.map(this.getTicks(), scale.getLabel, scale);
      };
    },
    _createGroup: function(name) {
      var newGroup = this['_' + name] = new graphic.Group();
      this.group.add(newGroup);
      return newGroup;
    },
    _renderAxisLine: function(layoutInfo, group, axis, timelineModel) {
      var axisExtent = axis.getExtent();
      if (!timelineModel.get('lineStyle.show')) {
        return;
      }
      group.add(new graphic.Line({
        shape: {
          x1: axisExtent[0],
          y1: 0,
          x2: axisExtent[1],
          y2: 0
        },
        style: zrUtil.extend({lineCap: 'round'}, timelineModel.getModel('lineStyle').getLineStyle()),
        silent: true,
        z2: 1
      }));
    },
    _renderAxisTick: function(layoutInfo, group, axis, timelineModel) {
      var data = timelineModel.getData();
      var ticks = axis.scale.getTicks();
      each(ticks, function(value, dataIndex) {
        var tickCoord = axis.dataToCoord(value);
        var itemModel = data.getItemModel(dataIndex);
        var itemStyleModel = itemModel.getModel('itemStyle.normal');
        var hoverStyleModel = itemModel.getModel('itemStyle.emphasis');
        var symbolOpt = {
          position: [tickCoord, 0],
          onclick: bind(this._changeTimeline, this, dataIndex)
        };
        var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);
        graphic.setHoverStyle(el, hoverStyleModel.getItemStyle());
        if (itemModel.get('tooltip')) {
          el.dataIndex = dataIndex;
          el.dataModel = timelineModel;
        } else {
          el.dataIndex = el.dataModel = null;
        }
      }, this);
    },
    _renderAxisLabel: function(layoutInfo, group, axis, timelineModel) {
      var labelModel = timelineModel.getModel('label.normal');
      if (!labelModel.get('show')) {
        return;
      }
      var data = timelineModel.getData();
      var ticks = axis.scale.getTicks();
      var labels = axisHelper.getFormattedLabels(axis, labelModel.get('formatter'));
      var labelInterval = axis.getLabelInterval();
      each(ticks, function(tick, dataIndex) {
        if (axis.isLabelIgnored(dataIndex, labelInterval)) {
          return;
        }
        var itemModel = data.getItemModel(dataIndex);
        var itemTextStyleModel = itemModel.getModel('label.normal.textStyle');
        var hoverTextStyleModel = itemModel.getModel('label.emphasis.textStyle');
        var tickCoord = axis.dataToCoord(tick);
        var textEl = new graphic.Text({
          style: {
            text: labels[dataIndex],
            textAlign: layoutInfo.labelAlign,
            textVerticalAlign: layoutInfo.labelBaseline,
            textFont: itemTextStyleModel.getFont(),
            fill: itemTextStyleModel.getTextColor()
          },
          position: [tickCoord, 0],
          rotation: layoutInfo.labelRotation - layoutInfo.rotation,
          onclick: bind(this._changeTimeline, this, dataIndex),
          silent: false
        });
        group.add(textEl);
        graphic.setHoverStyle(textEl, hoverTextStyleModel.getItemStyle());
      }, this);
    },
    _renderControl: function(layoutInfo, group, axis, timelineModel) {
      var controlSize = layoutInfo.controlSize;
      var rotation = layoutInfo.rotation;
      var itemStyle = timelineModel.getModel('controlStyle.normal').getItemStyle();
      var hoverStyle = timelineModel.getModel('controlStyle.emphasis').getItemStyle();
      var rect = [0, -controlSize / 2, controlSize, controlSize];
      var playState = timelineModel.getPlayState();
      var inverse = timelineModel.get('inverse', true);
      makeBtn(layoutInfo.nextBtnPosition, 'controlStyle.nextIcon', bind(this._changeTimeline, this, inverse ? '-' : '+'));
      makeBtn(layoutInfo.prevBtnPosition, 'controlStyle.prevIcon', bind(this._changeTimeline, this, inverse ? '+' : '-'));
      makeBtn(layoutInfo.playPosition, 'controlStyle.' + (playState ? 'stopIcon' : 'playIcon'), bind(this._handlePlayClick, this, !playState), true);
      function makeBtn(position, iconPath, onclick, willRotate) {
        if (!position) {
          return;
        }
        var opt = {
          position: position,
          origin: [controlSize / 2, 0],
          rotation: willRotate ? -rotation : 0,
          rectHover: true,
          style: itemStyle,
          onclick: onclick
        };
        var btn = makeIcon(timelineModel, iconPath, rect, opt);
        group.add(btn);
        graphic.setHoverStyle(btn, hoverStyle);
      }
    },
    _renderCurrentPointer: function(layoutInfo, group, axis, timelineModel) {
      var data = timelineModel.getData();
      var currentIndex = timelineModel.getCurrentIndex();
      var pointerModel = data.getItemModel(currentIndex).getModel('checkpointStyle');
      var me = this;
      var callback = {
        onCreate: function(pointer) {
          pointer.draggable = true;
          pointer.drift = bind(me._handlePointerDrag, me);
          pointer.ondragend = bind(me._handlePointerDragend, me);
          pointerMoveTo(pointer, currentIndex, axis, timelineModel, true);
        },
        onUpdate: function(pointer) {
          pointerMoveTo(pointer, currentIndex, axis, timelineModel);
        }
      };
      this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);
    },
    _handlePlayClick: function(nextState) {
      this._clearTimer();
      this.api.dispatchAction({
        type: 'timelinePlayChange',
        playState: nextState,
        from: this.uid
      });
    },
    _handlePointerDrag: function(dx, dy, e) {
      this._clearTimer();
      this._pointerChangeTimeline([e.offsetX, e.offsetY]);
    },
    _handlePointerDragend: function(e) {
      this._pointerChangeTimeline([e.offsetX, e.offsetY], true);
    },
    _pointerChangeTimeline: function(mousePos, trigger) {
      var toCoord = this._toAxisCoord(mousePos)[0];
      var axis = this._axis;
      var axisExtent = numberUtil.asc(axis.getExtent().slice());
      toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
      toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
      this._currentPointer.position[0] = toCoord;
      this._currentPointer.dirty();
      var targetDataIndex = this._findNearestTick(toCoord);
      var timelineModel = this.model;
      if (trigger || (targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get('realtime'))) {
        this._changeTimeline(targetDataIndex);
      }
    },
    _doPlayStop: function() {
      this._clearTimer();
      if (this.model.getPlayState()) {
        this._timer = setTimeout(bind(handleFrame, this), this.model.get('playInterval'));
      }
      function handleFrame() {
        var timelineModel = this.model;
        this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get('rewind', true) ? -1 : 1));
      }
    },
    _toAxisCoord: function(vertex) {
      var trans = this._mainGroup.getLocalTransform();
      return graphic.applyTransform(vertex, trans, true);
    },
    _findNearestTick: function(axisCoord) {
      var data = this.model.getData();
      var dist = Infinity;
      var targetDataIndex;
      var axis = this._axis;
      data.each(['value'], function(value, dataIndex) {
        var coord = axis.dataToCoord(value);
        var d = Math.abs(coord - axisCoord);
        if (d < dist) {
          dist = d;
          targetDataIndex = dataIndex;
        }
      });
      return targetDataIndex;
    },
    _clearTimer: function() {
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }
    },
    _changeTimeline: function(nextIndex) {
      var currentIndex = this.model.getCurrentIndex();
      if (nextIndex === '+') {
        nextIndex = currentIndex + 1;
      } else if (nextIndex === '-') {
        nextIndex = currentIndex - 1;
      }
      this.api.dispatchAction({
        type: 'timelineChange',
        currentIndex: nextIndex,
        from: this.uid
      });
    }
  });
  function getViewRect(model, api) {
    return layout.getLayoutRect(model.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    }, model.get('padding'));
  }
  function makeIcon(timelineModel, objPath, rect, opts) {
    var icon = graphic.makePath(timelineModel.get(objPath).replace(/^path:\/\//, ''), zrUtil.clone(opts || {}), new BoundingRect(rect[0], rect[1], rect[2], rect[3]), 'center');
    return icon;
  }
  function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {
    var symbolType = hostModel.get('symbol');
    var color = itemStyleModel.get('color');
    var symbolSize = hostModel.get('symbolSize');
    var halfSymbolSize = symbolSize / 2;
    var itemStyle = itemStyleModel.getItemStyle(['color', 'symbol', 'symbolSize']);
    if (!symbol) {
      symbol = symbolUtil.createSymbol(symbolType, -halfSymbolSize, -halfSymbolSize, symbolSize, symbolSize, color);
      group.add(symbol);
      callback && callback.onCreate(symbol);
    } else {
      symbol.setStyle(itemStyle);
      symbol.setColor(color);
      group.add(symbol);
      callback && callback.onUpdate(symbol);
    }
    opt = zrUtil.merge({
      rectHover: true,
      style: itemStyle,
      z2: 100
    }, opt, true);
    symbol.attr(opt);
    return symbol;
  }
  function pointerMoveTo(pointer, dataIndex, axis, timelineModel, noAnimation) {
    if (pointer.dragging) {
      return;
    }
    var pointerModel = timelineModel.getModel('checkpointStyle');
    var toCoord = axis.dataToCoord(timelineModel.getData().get(['value'], dataIndex));
    if (noAnimation || !pointerModel.get('animation', true)) {
      pointer.attr({position: [toCoord, 0]});
    } else {
      pointer.stopAnimation(true);
      pointer.animateTo({position: [toCoord, 0]}, pointerModel.get('animationDuration', true), pointerModel.get('animationEasing', true));
    }
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/timeline.js", ["../echarts", "./timeline/preprocessor", "./timeline/typeDefaulter", "./timeline/timelineAction", "./timeline/SliderTimelineModel", "./timeline/SliderTimelineView", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../echarts');
  echarts.registerPreprocessor($__require('./timeline/preprocessor'));
  $__require('./timeline/typeDefaulter');
  $__require('./timeline/timelineAction');
  $__require('./timeline/SliderTimelineModel');
  $__require('./timeline/SliderTimelineView');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/toolbox/ToolboxModel.js", ["./featureManager", "zrender/lib/core/util", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var featureManager = $__require('./featureManager');
  var zrUtil = $__require('zrender/lib/core/util');
  var ToolboxModel = $__require('../../echarts').extendComponentModel({
    type: 'toolbox',
    layoutMode: {
      type: 'box',
      ignoreSize: true
    },
    mergeDefaultAndTheme: function(option) {
      ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);
      zrUtil.each(this.option.feature, function(featureOpt, featureName) {
        var Feature = featureManager.get(featureName);
        Feature && zrUtil.merge(featureOpt, Feature.defaultOption);
      });
    },
    defaultOption: {
      show: true,
      z: 6,
      zlevel: 0,
      orient: 'horizontal',
      left: 'right',
      top: 'top',
      backgroundColor: 'transparent',
      borderColor: '#ccc',
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: true,
      iconStyle: {
        normal: {
          borderColor: '#666',
          color: 'none'
        },
        emphasis: {borderColor: '#3E98C5'}
      }
    }
  });
  module.exports = ToolboxModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/helper/listComponent.js", ["../../util/layout", "../../util/format", "../../util/graphic", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var layout = $__require('../../util/layout');
  var formatUtil = $__require('../../util/format');
  var graphic = $__require('../../util/graphic');
  function positionGroup(group, model, api) {
    layout.positionGroup(group, model.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    }, model.get('padding'));
  }
  module.exports = {
    layout: function(group, componentModel, api) {
      var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      }, componentModel.get('padding'));
      layout.box(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);
      positionGroup(group, componentModel, api);
    },
    addBackground: function(group, componentModel) {
      var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));
      var boundingRect = group.getBoundingRect();
      var style = componentModel.getItemStyle(['color', 'opacity']);
      style.fill = componentModel.get('backgroundColor');
      var rect = new graphic.Rect({
        shape: {
          x: boundingRect.x - padding[3],
          y: boundingRect.y - padding[0],
          width: boundingRect.width + padding[1] + padding[3],
          height: boundingRect.height + padding[0] + padding[2]
        },
        style: style,
        silent: true,
        z2: -1
      });
      graphic.subPixelOptimizeRect(rect);
      group.add(rect);
    }
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/toolbox/ToolboxView.js", ["./featureManager", "zrender/lib/core/util", "../../util/graphic", "../../model/Model", "../../data/DataDiffer", "../helper/listComponent", "zrender/lib/contain/text", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var featureManager = $__require('./featureManager');
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var Model = $__require('../../model/Model');
  var DataDiffer = $__require('../../data/DataDiffer');
  var listComponentHelper = $__require('../helper/listComponent');
  var textContain = $__require('zrender/lib/contain/text');
  module.exports = $__require('../../echarts').extendComponentView({
    type: 'toolbox',
    render: function(toolboxModel, ecModel, api, payload) {
      var group = this.group;
      group.removeAll();
      if (!toolboxModel.get('show')) {
        return;
      }
      var itemSize = +toolboxModel.get('itemSize');
      var featureOpts = toolboxModel.get('feature') || {};
      var features = this._features || (this._features = {});
      var featureNames = [];
      zrUtil.each(featureOpts, function(opt, name) {
        featureNames.push(name);
      });
      (new DataDiffer(this._featureNames || [], featureNames)).add(process).update(process).remove(zrUtil.curry(process, null)).execute();
      this._featureNames = featureNames;
      function process(newIndex, oldIndex) {
        var featureName = featureNames[newIndex];
        var oldName = featureNames[oldIndex];
        var featureOpt = featureOpts[featureName];
        var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);
        var feature;
        if (featureName && !oldName) {
          if (isUserFeatureName(featureName)) {
            feature = {
              model: featureModel,
              onclick: featureModel.option.onclick,
              featureName: featureName
            };
          } else {
            var Feature = featureManager.get(featureName);
            if (!Feature) {
              return;
            }
            feature = new Feature(featureModel, ecModel, api);
          }
          features[featureName] = feature;
        } else {
          feature = features[oldName];
          if (!feature) {
            return;
          }
          feature.model = featureModel;
          feature.ecModel = ecModel;
          feature.api = api;
        }
        if (!featureName && oldName) {
          feature.dispose && feature.dispose(ecModel, api);
          return;
        }
        if (!featureModel.get('show') || feature.unusable) {
          feature.remove && feature.remove(ecModel, api);
          return;
        }
        createIconPaths(featureModel, feature, featureName);
        featureModel.setIconStatus = function(iconName, status) {
          var option = this.option;
          var iconPaths = this.iconPaths;
          option.iconStatus = option.iconStatus || {};
          option.iconStatus[iconName] = status;
          iconPaths[iconName] && iconPaths[iconName].trigger(status);
        };
        if (feature.render) {
          feature.render(featureModel, ecModel, api, payload);
        }
      }
      function createIconPaths(featureModel, feature, featureName) {
        var iconStyleModel = featureModel.getModel('iconStyle');
        var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');
        var titles = featureModel.get('title') || {};
        if (typeof icons === 'string') {
          var icon = icons;
          var title = titles;
          icons = {};
          titles = {};
          icons[featureName] = icon;
          titles[featureName] = title;
        }
        var iconPaths = featureModel.iconPaths = {};
        zrUtil.each(icons, function(icon, iconName) {
          var normalStyle = iconStyleModel.getModel('normal').getItemStyle();
          var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();
          var style = {
            x: -itemSize / 2,
            y: -itemSize / 2,
            width: itemSize,
            height: itemSize
          };
          var path = icon.indexOf('image://') === 0 ? (style.image = icon.slice(8), new graphic.Image({style: style})) : graphic.makePath(icon.replace('path://', ''), {
            style: normalStyle,
            hoverStyle: hoverStyle,
            rectHover: true
          }, style, 'center');
          graphic.setHoverStyle(path);
          if (toolboxModel.get('showTitle')) {
            path.__title = titles[iconName];
            path.on('mouseover', function() {
              path.setStyle({
                text: titles[iconName],
                textPosition: hoverStyle.textPosition || 'bottom',
                textFill: hoverStyle.fill || hoverStyle.stroke || '#000',
                textAlign: hoverStyle.textAlign || 'center'
              });
            }).on('mouseout', function() {
              path.setStyle({textFill: null});
            });
          }
          path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');
          group.add(path);
          path.on('click', zrUtil.bind(feature.onclick, feature, ecModel, api, iconName));
          iconPaths[iconName] = path;
        });
      }
      listComponentHelper.layout(group, toolboxModel, api);
      listComponentHelper.addBackground(group, toolboxModel);
      group.eachChild(function(icon) {
        var titleText = icon.__title;
        var hoverStyle = icon.hoverStyle;
        if (hoverStyle && titleText) {
          var rect = textContain.getBoundingRect(titleText, hoverStyle.font);
          var offsetX = icon.position[0] + group.position[0];
          var offsetY = icon.position[1] + group.position[1] + itemSize;
          var needPutOnTop = false;
          if (offsetY + rect.height > api.getHeight()) {
            hoverStyle.textPosition = 'top';
            needPutOnTop = true;
          }
          var topOffset = needPutOnTop ? (-5 - rect.height) : (itemSize + 8);
          if (offsetX + rect.width / 2 > api.getWidth()) {
            hoverStyle.textPosition = ['100%', topOffset];
            hoverStyle.textAlign = 'right';
          } else if (offsetX - rect.width / 2 < 0) {
            hoverStyle.textPosition = [0, topOffset];
            hoverStyle.textAlign = 'left';
          }
        }
      });
    },
    updateView: function(toolboxModel, ecModel, api, payload) {
      zrUtil.each(this._features, function(feature) {
        feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
      });
    },
    updateLayout: function(toolboxModel, ecModel, api, payload) {
      zrUtil.each(this._features, function(feature) {
        feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);
      });
    },
    remove: function(ecModel, api) {
      zrUtil.each(this._features, function(feature) {
        feature.remove && feature.remove(ecModel, api);
      });
      this.group.removeAll();
    },
    dispose: function(ecModel, api) {
      zrUtil.each(this._features, function(feature) {
        feature.dispose && feature.dispose(ecModel, api);
      });
    }
  });
  function isUserFeatureName(featureName) {
    return featureName.indexOf('my') === 0;
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/toolbox/feature/SaveAsImage.js", ["zrender/lib/core/env", "../featureManager", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var env = $__require('zrender/lib/core/env');
  function SaveAsImage(model) {
    this.model = model;
  }
  SaveAsImage.defaultOption = {
    show: true,
    icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',
    title: '',
    type: 'png',
    name: '',
    excludeComponents: ['toolbox'],
    pixelRatio: 1,
    lang: ['']
  };
  SaveAsImage.prototype.unusable = !env.canvasSupported;
  var proto = SaveAsImage.prototype;
  proto.onclick = function(ecModel, api) {
    var model = this.model;
    var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';
    var $a = document.createElement('a');
    var type = model.get('type', true) || 'png';
    $a.download = title + '.' + type;
    $a.target = '_blank';
    var url = api.getConnectedDataURL({
      type: type,
      backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',
      excludeComponents: model.get('excludeComponents'),
      pixelRatio: model.get('pixelRatio')
    });
    $a.href = url;
    if (typeof MouseEvent === 'function') {
      var evt = new MouseEvent('click', {
        view: window,
        bubbles: true,
        cancelable: false
      });
      $a.dispatchEvent(evt);
    } else {
      var lang = model.get('lang');
      var html = '' + '<body style="margin:0;">' + '<img src="' + url + '" style="max-width:100%;" title="' + ((lang && lang[0]) || '') + '" />' + '</body>';
      var tab = window.open();
      tab.document.write(html);
    }
  };
  $__require('../featureManager').register('saveAsImage', SaveAsImage);
  module.exports = SaveAsImage;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/toolbox/feature/MagicType.js", ["zrender/lib/core/util", "../../../echarts", "../featureManager", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  function MagicType(model) {
    this.model = model;
  }
  MagicType.defaultOption = {
    show: true,
    type: [],
    icon: {
      line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',
      bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',
      stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',
      tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'
    },
    title: {
      line: '',
      bar: '',
      stack: '',
      tiled: ''
    },
    option: {},
    seriesIndex: {}
  };
  var proto = MagicType.prototype;
  proto.getIcons = function() {
    var model = this.model;
    var availableIcons = model.get('icon');
    var icons = {};
    zrUtil.each(model.get('type'), function(type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  };
  var seriesOptGenreator = {
    'line': function(seriesType, seriesId, seriesModel, model) {
      if (seriesType === 'bar') {
        return zrUtil.merge({
          id: seriesId,
          type: 'line',
          data: seriesModel.get('data'),
          stack: seriesModel.get('stack'),
          markPoint: seriesModel.get('markPoint'),
          markLine: seriesModel.get('markLine')
        }, model.get('option.line') || {}, true);
      }
    },
    'bar': function(seriesType, seriesId, seriesModel, model) {
      if (seriesType === 'line') {
        return zrUtil.merge({
          id: seriesId,
          type: 'bar',
          data: seriesModel.get('data'),
          stack: seriesModel.get('stack'),
          markPoint: seriesModel.get('markPoint'),
          markLine: seriesModel.get('markLine')
        }, model.get('option.bar') || {}, true);
      }
    },
    'stack': function(seriesType, seriesId, seriesModel, model) {
      if (seriesType === 'line' || seriesType === 'bar') {
        return zrUtil.merge({
          id: seriesId,
          stack: '__ec_magicType_stack__'
        }, model.get('option.stack') || {}, true);
      }
    },
    'tiled': function(seriesType, seriesId, seriesModel, model) {
      if (seriesType === 'line' || seriesType === 'bar') {
        return zrUtil.merge({
          id: seriesId,
          stack: ''
        }, model.get('option.tiled') || {}, true);
      }
    }
  };
  var radioTypes = [['line', 'bar'], ['stack', 'tiled']];
  proto.onclick = function(ecModel, api, type) {
    var model = this.model;
    var seriesIndex = model.get('seriesIndex.' + type);
    if (!seriesOptGenreator[type]) {
      return;
    }
    var newOption = {series: []};
    var generateNewSeriesTypes = function(seriesModel) {
      var seriesType = seriesModel.subType;
      var seriesId = seriesModel.id;
      var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);
      if (newSeriesOpt) {
        zrUtil.defaults(newSeriesOpt, seriesModel.option);
        newOption.series.push(newSeriesOpt);
      }
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {
        var categoryAxis = coordSys.getAxesByScale('ordinal')[0];
        if (categoryAxis) {
          var axisDim = categoryAxis.dim;
          var axisIndex = seriesModel.get(axisDim + 'AxisIndex');
          var axisKey = axisDim + 'Axis';
          newOption[axisKey] = newOption[axisKey] || [];
          for (var i = 0; i <= axisIndex; i++) {
            newOption[axisKey][axisIndex] = newOption[axisKey][axisIndex] || {};
          }
          newOption[axisKey][axisIndex].boundaryGap = type === 'bar' ? true : false;
        }
      }
    };
    zrUtil.each(radioTypes, function(radio) {
      if (zrUtil.indexOf(radio, type) >= 0) {
        zrUtil.each(radio, function(item) {
          model.setIconStatus(item, 'normal');
        });
      }
    });
    model.setIconStatus(type, 'emphasis');
    ecModel.eachComponent({
      mainType: 'series',
      query: seriesIndex == null ? null : {seriesIndex: seriesIndex}
    }, generateNewSeriesTypes);
    api.dispatchAction({
      type: 'changeMagicType',
      currentType: type,
      newOption: newOption
    });
  };
  var echarts = $__require('../../../echarts');
  echarts.registerAction({
    type: 'changeMagicType',
    event: 'magicTypeChanged',
    update: 'prepareAndUpdate'
  }, function(payload, ecModel) {
    ecModel.mergeOption(payload.newOption);
  });
  $__require('../featureManager').register('magicType', MagicType);
  module.exports = MagicType;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/toolbox/feature/DataView.js", ["zrender/lib/core/util", "zrender/lib/core/event", "../featureManager", "../../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var eventTool = $__require('zrender/lib/core/event');
  var BLOCK_SPLITER = new Array(60).join('-');
  var ITEM_SPLITER = '\t';
  function groupSeries(ecModel) {
    var seriesGroupByCategoryAxis = {};
    var otherSeries = [];
    var meta = [];
    ecModel.eachRawSeries(function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {
        var baseAxis = coordSys.getBaseAxis();
        if (baseAxis.type === 'category') {
          var key = baseAxis.dim + '_' + baseAxis.index;
          if (!seriesGroupByCategoryAxis[key]) {
            seriesGroupByCategoryAxis[key] = {
              categoryAxis: baseAxis,
              valueAxis: coordSys.getOtherAxis(baseAxis),
              series: []
            };
            meta.push({
              axisDim: baseAxis.dim,
              axisIndex: baseAxis.index
            });
          }
          seriesGroupByCategoryAxis[key].series.push(seriesModel);
        } else {
          otherSeries.push(seriesModel);
        }
      } else {
        otherSeries.push(seriesModel);
      }
    });
    return {
      seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,
      other: otherSeries,
      meta: meta
    };
  }
  function assembleSeriesWithCategoryAxis(series) {
    var tables = [];
    zrUtil.each(series, function(group, key) {
      var categoryAxis = group.categoryAxis;
      var valueAxis = group.valueAxis;
      var valueAxisDim = valueAxis.dim;
      var headers = [' '].concat(zrUtil.map(group.series, function(series) {
        return series.name;
      }));
      var columns = [categoryAxis.model.getCategories()];
      zrUtil.each(group.series, function(series) {
        columns.push(series.getRawData().mapArray(valueAxisDim, function(val) {
          return val;
        }));
      });
      var lines = [headers.join(ITEM_SPLITER)];
      for (var i = 0; i < columns[0].length; i++) {
        var items = [];
        for (var j = 0; j < columns.length; j++) {
          items.push(columns[j][i]);
        }
        lines.push(items.join(ITEM_SPLITER));
      }
      tables.push(lines.join('\n'));
    });
    return tables.join('\n\n' + BLOCK_SPLITER + '\n\n');
  }
  function assembleOtherSeries(series) {
    return zrUtil.map(series, function(series) {
      var data = series.getRawData();
      var lines = [series.name];
      var vals = [];
      data.each(data.dimensions, function() {
        var argLen = arguments.length;
        var dataIndex = arguments[argLen - 1];
        var name = data.getName(dataIndex);
        for (var i = 0; i < argLen - 1; i++) {
          vals[i] = arguments[i];
        }
        lines.push((name ? (name + ITEM_SPLITER) : '') + vals.join(ITEM_SPLITER));
      });
      return lines.join('\n');
    }).join('\n\n' + BLOCK_SPLITER + '\n\n');
  }
  function getContentFromModel(ecModel) {
    var result = groupSeries(ecModel);
    return {
      value: zrUtil.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function(str) {
        return str.replace(/[\n\t\s]/g, '');
      }).join('\n\n' + BLOCK_SPLITER + '\n\n'),
      meta: result.meta
    };
  }
  function trim(str) {
    return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  }
  function isTSVFormat(block) {
    var firstLine = block.slice(0, block.indexOf('\n'));
    if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
      return true;
    }
  }
  var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');
  function parseTSVContents(tsv) {
    var tsvLines = tsv.split(/\n+/g);
    var headers = trim(tsvLines.shift()).split(itemSplitRegex);
    var categories = [];
    var series = zrUtil.map(headers, function(header) {
      return {
        name: header,
        data: []
      };
    });
    for (var i = 0; i < tsvLines.length; i++) {
      var items = trim(tsvLines[i]).split(itemSplitRegex);
      categories.push(items.shift());
      for (var j = 0; j < items.length; j++) {
        series[j] && (series[j].data[i] = items[j]);
      }
    }
    return {
      series: series,
      categories: categories
    };
  }
  function parseListContents(str) {
    var lines = str.split(/\n+/g);
    var seriesName = trim(lines.shift());
    var data = [];
    for (var i = 0; i < lines.length; i++) {
      var items = trim(lines[i]).split(itemSplitRegex);
      var name = '';
      var value;
      var hasName = false;
      if (isNaN(items[0])) {
        hasName = true;
        name = items[0];
        items = items.slice(1);
        data[i] = {
          name: name,
          value: []
        };
        value = data[i].value;
      } else {
        value = data[i] = [];
      }
      for (var j = 0; j < items.length; j++) {
        value.push(+items[j]);
      }
      if (value.length === 1) {
        hasName ? (data[i].value = value[0]) : (data[i] = value[0]);
      }
    }
    return {
      name: seriesName,
      data: data
    };
  }
  function parseContents(str, blockMetaList) {
    var blocks = str.split(new RegExp('\n*' + BLOCK_SPLITER + '\n*', 'g'));
    var newOption = {series: []};
    zrUtil.each(blocks, function(block, idx) {
      if (isTSVFormat(block)) {
        var result = parseTSVContents(block);
        var blockMeta = blockMetaList[idx];
        var axisKey = blockMeta.axisDim + 'Axis';
        if (blockMeta) {
          newOption[axisKey] = newOption[axisKey] || [];
          newOption[axisKey][blockMeta.axisIndex] = {data: result.categories};
          newOption.series = newOption.series.concat(result.series);
        }
      } else {
        var result = parseListContents(block);
        newOption.series.push(result);
      }
    });
    return newOption;
  }
  function DataView(model) {
    this._dom = null;
    this.model = model;
  }
  DataView.defaultOption = {
    show: true,
    readOnly: false,
    optionToContent: null,
    contentToOption: null,
    icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',
    title: '',
    lang: ['', '', ''],
    backgroundColor: '#fff',
    textColor: '#000',
    textareaColor: '#fff',
    textareaBorderColor: '#333',
    buttonColor: '#c23531',
    buttonTextColor: '#fff'
  };
  DataView.prototype.onclick = function(ecModel, api) {
    var container = api.getDom();
    var model = this.model;
    if (this._dom) {
      container.removeChild(this._dom);
    }
    var root = document.createElement('div');
    root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';
    root.style.backgroundColor = model.get('backgroundColor') || '#fff';
    var header = document.createElement('h4');
    var lang = model.get('lang') || [];
    header.innerHTML = lang[0] || model.get('title');
    header.style.cssText = 'margin: 10px 20px;';
    header.style.color = model.get('textColor');
    var viewMain = document.createElement('div');
    var textarea = document.createElement('textarea');
    viewMain.style.cssText = 'display:block;width:100%;overflow:hidden;';
    var optionToContent = model.get('optionToContent');
    var contentToOption = model.get('contentToOption');
    var result = getContentFromModel(ecModel);
    if (typeof optionToContent === 'function') {
      var htmlOrDom = optionToContent(api.getOption());
      if (typeof htmlOrDom === 'string') {
        viewMain.innerHTML = htmlOrDom;
      } else if (zrUtil.isDom(htmlOrDom)) {
        viewMain.appendChild(htmlOrDom);
      }
    } else {
      viewMain.appendChild(textarea);
      textarea.readOnly = model.get('readOnly');
      textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';
      textarea.style.color = model.get('textColor');
      textarea.style.borderColor = model.get('textareaBorderColor');
      textarea.style.backgroundColor = model.get('textareaColor');
      textarea.value = result.value;
    }
    var blockMetaList = result.meta;
    var buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';
    var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';
    var closeButton = document.createElement('div');
    var refreshButton = document.createElement('div');
    buttonStyle += ';background-color:' + model.get('buttonColor');
    buttonStyle += ';color:' + model.get('buttonTextColor');
    var self = this;
    function close() {
      container.removeChild(root);
      self._dom = null;
    }
    eventTool.addEventListener(closeButton, 'click', close);
    eventTool.addEventListener(refreshButton, 'click', function() {
      var newOption;
      try {
        if (typeof contentToOption === 'function') {
          newOption = contentToOption(viewMain, api.getOption());
        } else {
          newOption = parseContents(textarea.value, blockMetaList);
        }
      } catch (e) {
        close();
        throw new Error('Data view format error ' + e);
      }
      if (newOption) {
        api.dispatchAction({
          type: 'changeDataView',
          newOption: newOption
        });
      }
      close();
    });
    closeButton.innerHTML = lang[1];
    refreshButton.innerHTML = lang[2];
    refreshButton.style.cssText = buttonStyle;
    closeButton.style.cssText = buttonStyle;
    !model.get('readOnly') && buttonContainer.appendChild(refreshButton);
    buttonContainer.appendChild(closeButton);
    eventTool.addEventListener(textarea, 'keydown', function(e) {
      if ((e.keyCode || e.which) === 9) {
        var val = this.value;
        var start = this.selectionStart;
        var end = this.selectionEnd;
        this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end);
        this.selectionStart = this.selectionEnd = start + 1;
        eventTool.stop(e);
      }
    });
    root.appendChild(header);
    root.appendChild(viewMain);
    root.appendChild(buttonContainer);
    viewMain.style.height = (container.clientHeight - 80) + 'px';
    container.appendChild(root);
    this._dom = root;
  };
  DataView.prototype.remove = function(ecModel, api) {
    this._dom && api.getDom().removeChild(this._dom);
  };
  DataView.prototype.dispose = function(ecModel, api) {
    this.remove(ecModel, api);
  };
  function tryMergeDataOption(newData, originalData) {
    return zrUtil.map(newData, function(newVal, idx) {
      var original = originalData && originalData[idx];
      if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {
        if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {
          newVal = newVal.value;
        }
        return zrUtil.defaults({value: newVal}, original);
      } else {
        return newVal;
      }
    });
  }
  $__require('../featureManager').register('dataView', DataView);
  $__require('../../../echarts').registerAction({
    type: 'changeDataView',
    event: 'dataViewChanged',
    update: 'prepareAndUpdate'
  }, function(payload, ecModel) {
    var newSeriesOptList = [];
    zrUtil.each(payload.newOption.series, function(seriesOpt) {
      var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];
      if (!seriesModel) {
        newSeriesOptList.push(zrUtil.extend({type: 'scatter'}, seriesOpt));
      } else {
        var originalData = seriesModel.get('data');
        newSeriesOptList.push({
          name: seriesOpt.name,
          data: tryMergeDataOption(seriesOpt.data, originalData)
        });
      }
    });
    ecModel.mergeOption(zrUtil.defaults({series: newSeriesOptList}, payload.newOption));
  });
  module.exports = DataView;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/helper/interactionMutex.js", ["../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ATTR = '\0_ec_interaction_mutex';
  var interactionMutex = {
    take: function(zr, resourceKey, userKey) {
      var store = getStore(zr);
      store[resourceKey] = userKey;
    },
    release: function(zr, resourceKey, userKey) {
      var store = getStore(zr);
      var uKey = store[resourceKey];
      if (uKey === userKey) {
        store[resourceKey] = null;
      }
    },
    isTaken: function(zr, resourceKey) {
      return !!getStore(zr)[resourceKey];
    }
  };
  function getStore(zr) {
    return zr[ATTR] || (zr[ATTR] = {});
  }
  $__require('../../echarts').registerAction({
    type: 'takeGlobalCursor',
    event: 'globalCursorTaken',
    update: 'update'
  }, function() {});
  module.exports = interactionMutex;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/helper/BrushController.js", ["zrender/lib/mixin/Eventful", "zrender/lib/core/util", "../../util/graphic", "./interactionMutex", "../../data/DataDiffer", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var Eventful = $__require('zrender/lib/mixin/Eventful');
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var interactionMutex = $__require('./interactionMutex');
  var DataDiffer = $__require('../../data/DataDiffer');
  var curry = zrUtil.curry;
  var each = zrUtil.each;
  var map = zrUtil.map;
  var mathMin = Math.min;
  var mathMax = Math.max;
  var mathPow = Math.pow;
  var COVER_Z = 10000;
  var UNSELECT_THRESHOLD = 6;
  var MIN_RESIZE_LINE_WIDTH = 6;
  var MUTEX_RESOURCE_KEY = 'globalPan';
  var DIRECTION_MAP = {
    w: [0, 0],
    e: [0, 1],
    n: [1, 0],
    s: [1, 1]
  };
  var CURSOR_MAP = {
    w: 'ew',
    e: 'ew',
    n: 'ns',
    s: 'ns',
    ne: 'nesw',
    sw: 'nesw',
    nw: 'nwse',
    se: 'nwse'
  };
  var DEFAULT_BRUSH_OPT = {
    brushStyle: {
      lineWidth: 2,
      stroke: 'rgba(0,0,0,0.3)',
      fill: 'rgba(0,0,0,0.1)'
    },
    transformable: true,
    brushMode: 'single',
    removeOnClick: false
  };
  var baseUID = 0;
  function BrushController(zr) {
    if (__DEV__) {
      zrUtil.assert(zr);
    }
    Eventful.call(this);
    this._zr = zr;
    this.group = new graphic.Group();
    this._brushType;
    this._brushOption;
    this._panels;
    this._track = [];
    this._dragging;
    this._covers = [];
    this._creatingCover;
    this._creatingPanel;
    this._enableGlobalPan;
    if (__DEV__) {
      this._mounted;
    }
    this._uid = 'brushController_' + baseUID++;
    this._handlers = {};
    each(mouseHandlers, function(handler, eventName) {
      this._handlers[eventName] = zrUtil.bind(handler, this);
    }, this);
  }
  BrushController.prototype = {
    constructor: BrushController,
    enableBrush: function(brushOption) {
      if (__DEV__) {
        zrUtil.assert(this._mounted);
      }
      this._brushType && doDisableBrush(this);
      brushOption.brushType && doEnableBrush(this, brushOption);
      return this;
    },
    setPanels: function(panelOpts) {
      var oldPanels = this._panels || {};
      var newPanels = this._panels = panelOpts && panelOpts.length && {};
      var thisGroup = this.group;
      newPanels && each(panelOpts, function(panelOpt) {
        var panelId = panelOpt.panelId;
        var panel = oldPanels[panelId];
        if (!panel) {
          panel = new graphic.Rect({
            silent: true,
            invisible: true
          });
          thisGroup.add(panel);
        }
        panel.attr('shape', panelOpt.rect);
        panel.__brushPanelId = panelId;
        newPanels[panelId] = panel;
        oldPanels[panelId] = null;
      });
      each(oldPanels, function(panel) {
        panel && thisGroup.remove(panel);
      });
      return this;
    },
    mount: function(opt) {
      opt = opt || {};
      if (__DEV__) {
        this._mounted = true;
      }
      this._enableGlobalPan = opt.enableGlobalPan;
      var thisGroup = this.group;
      this._zr.add(thisGroup);
      thisGroup.attr({
        position: opt.position || [0, 0],
        rotation: opt.rotation || 0,
        scale: opt.scale || [1, 1]
      });
      return this;
    },
    eachCover: function(cb, context) {
      each(this._covers, cb, context);
    },
    updateCovers: function(brushOptionList) {
      if (__DEV__) {
        zrUtil.assert(this._mounted);
      }
      brushOptionList = zrUtil.map(brushOptionList, function(brushOption) {
        return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
      });
      var tmpIdPrefix = '\0-brush-index-';
      var oldCovers = this._covers;
      var newCovers = this._covers = [];
      var controller = this;
      var creatingCover = this._creatingCover;
      (new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey)).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();
      return this;
      function getKey(brushOption, index) {
        return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;
      }
      function oldGetKey(cover, index) {
        return getKey(cover.__brushOption, index);
      }
      function addOrUpdate(newIndex, oldIndex) {
        var newBrushOption = brushOptionList[newIndex];
        if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
          newCovers[newIndex] = oldCovers[oldIndex];
        } else {
          var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));
          updateCoverAfterCreation(controller, cover);
        }
      }
      function remove(oldIndex) {
        if (oldCovers[oldIndex] !== creatingCover) {
          controller.group.remove(oldCovers[oldIndex]);
        }
      }
    },
    unmount: function() {
      this.enableBrush(false);
      clearCovers(this);
      this._zr.remove(this.group);
      if (__DEV__) {
        this._mounted = false;
      }
      return this;
    },
    dispose: function() {
      this.unmount();
      this.off();
    }
  };
  zrUtil.mixin(BrushController, Eventful);
  function doEnableBrush(controller, brushOption) {
    var zr = controller._zr;
    if (!controller._enableGlobalPan) {
      interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);
    }
    each(controller._handlers, function(handler, eventName) {
      zr.on(eventName, handler);
    });
    controller._brushType = brushOption.brushType;
    controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
  }
  function doDisableBrush(controller) {
    var zr = controller._zr;
    interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);
    each(controller._handlers, function(handler, eventName) {
      zr.off(eventName, handler);
    });
    controller._brushType = controller._brushOption = null;
  }
  function createCover(controller, brushOption) {
    var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
    updateZ(cover);
    cover.__brushOption = brushOption;
    controller.group.add(cover);
    return cover;
  }
  function endCreating(controller, creatingCover) {
    var coverRenderer = getCoverRenderer(creatingCover);
    if (coverRenderer.endCreating) {
      coverRenderer.endCreating(controller, creatingCover);
      updateZ(creatingCover);
    }
    return creatingCover;
  }
  function updateCoverShape(controller, cover) {
    var brushOption = cover.__brushOption;
    getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
  }
  function updateZ(group) {
    group.traverse(function(el) {
      el.z = COVER_Z;
      el.z2 = COVER_Z;
    });
  }
  function updateCoverAfterCreation(controller, cover) {
    getCoverRenderer(cover).updateCommon(controller, cover);
    updateCoverShape(controller, cover);
  }
  function getCoverRenderer(cover) {
    return coverRenderers[cover.__brushOption.brushType];
  }
  function getPanelByPoint(controller, x, y) {
    var panels = controller._panels;
    if (!panels) {
      return true;
    }
    var panel;
    each(panels, function(pn) {
      pn.contain(x, y) && (panel = pn);
    });
    return panel;
  }
  function getPanelByCover(controller, cover) {
    var panels = controller._panels;
    if (!panels) {
      return true;
    }
    var panelId = cover.__brushOption.panelId;
    return panelId != null ? panels[panelId] : true;
  }
  function clearCovers(controller) {
    var covers = controller._covers;
    var originalLength = covers.length;
    each(covers, function(cover) {
      controller.group.remove(cover);
    }, controller);
    covers.length = 0;
    return !!originalLength;
  }
  function trigger(controller, opt) {
    var areas = map(controller._covers, function(cover) {
      var brushOption = cover.__brushOption;
      var range = zrUtil.clone(brushOption.range);
      return {
        brushType: brushOption.brushType,
        panelId: brushOption.panelId,
        range: range
      };
    });
    controller.trigger('brush', areas, {
      isEnd: !!opt.isEnd,
      removeOnClick: !!opt.removeOnClick
    });
  }
  function shouldShowCover(controller) {
    var track = controller._track;
    if (!track.length) {
      return false;
    }
    var p2 = track[track.length - 1];
    var p1 = track[0];
    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    var dist = mathPow(dx * dx + dy * dy, 0.5);
    return dist > UNSELECT_THRESHOLD;
  }
  function getTrackEnds(track) {
    var tail = track.length - 1;
    tail < 0 && (tail = 0);
    return [track[0], track[tail]];
  }
  function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {
    var cover = new graphic.Group();
    cover.add(new graphic.Rect({
      name: 'main',
      style: makeStyle(brushOption),
      silent: true,
      draggable: true,
      cursor: 'move',
      drift: curry(doDrift, controller, cover, 'nswe'),
      ondragend: curry(trigger, controller, {isEnd: true})
    }));
    each(edgeNames, function(name) {
      cover.add(new graphic.Rect({
        name: name,
        style: {opacity: 0},
        draggable: true,
        silent: true,
        invisible: true,
        drift: curry(doDrift, controller, cover, name),
        ondragend: curry(trigger, controller, {isEnd: true})
      }));
    });
    return cover;
  }
  function updateBaseRect(controller, cover, localRange, brushOption) {
    var lineWidth = brushOption.brushStyle.lineWidth || 0;
    var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);
    var x = localRange[0][0];
    var y = localRange[1][0];
    var xa = x - lineWidth / 2;
    var ya = y - lineWidth / 2;
    var x2 = localRange[0][1];
    var y2 = localRange[1][1];
    var x2a = x2 - handleSize + lineWidth / 2;
    var y2a = y2 - handleSize + lineWidth / 2;
    var width = x2 - x;
    var height = y2 - y;
    var widtha = width + lineWidth;
    var heighta = height + lineWidth;
    updateRectShape(controller, cover, 'main', x, y, width, height);
    if (brushOption.transformable) {
      updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);
      updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);
      updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);
      updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);
      updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);
      updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);
      updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);
      updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);
    }
  }
  function updateCommon(controller, cover) {
    var brushOption = cover.__brushOption;
    var transformable = brushOption.transformable;
    var mainEl = cover.childAt(0);
    mainEl.useStyle(makeStyle(brushOption));
    mainEl.attr({
      silent: !transformable,
      cursor: transformable ? 'move' : 'default'
    });
    each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function(name) {
      var el = cover.childOfName(name);
      var globalDir = getGlobalDirection(controller, name);
      el && el.attr({
        silent: !transformable,
        invisible: !transformable,
        cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null
      });
    });
  }
  function updateRectShape(controller, cover, name, x, y, w, h) {
    var el = cover.childOfName(name);
    el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
  }
  function makeStyle(brushOption) {
    return zrUtil.defaults({strokeNoScale: true}, brushOption.brushStyle);
  }
  function formatRectRange(x, y, x2, y2) {
    var min = [mathMin(x, x2), mathMin(y, y2)];
    var max = [mathMax(x, x2), mathMax(y, y2)];
    return [[min[0], max[0]], [min[1], max[1]]];
  }
  function getTransform(controller) {
    return graphic.getTransform(controller.group);
  }
  function getGlobalDirection(controller, localDirection) {
    if (localDirection.length > 1) {
      localDirection = localDirection.split('');
      var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];
      (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();
      return globalDir.join('');
    } else {
      var map = {
        w: 'left',
        e: 'right',
        n: 'top',
        s: 'bottom'
      };
      var inverseMap = {
        left: 'w',
        right: 'e',
        top: 'n',
        bottom: 's'
      };
      var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));
      return inverseMap[globalDir];
    }
  }
  function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {
    var brushOption = cover.__brushOption;
    var rectRange = toRectRange(brushOption.range);
    var localDelta = toLocalDelta(controller, dx, dy);
    each(name.split(''), function(namePart) {
      var ind = DIRECTION_MAP[namePart];
      rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
    });
    brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
    updateCoverAfterCreation(controller, cover);
    trigger(controller, {isEnd: false});
  }
  function driftPolygon(controller, cover, dx, dy, e) {
    var range = cover.__brushOption.range;
    var localDelta = toLocalDelta(controller, dx, dy);
    each(range, function(point) {
      point[0] += localDelta[0];
      point[1] += localDelta[1];
    });
    updateCoverAfterCreation(controller, cover);
    trigger(controller, {isEnd: false});
  }
  function toLocalDelta(controller, dx, dy) {
    var thisGroup = controller.group;
    var localD = thisGroup.transformCoordToLocal(dx, dy);
    var localZero = thisGroup.transformCoordToLocal(0, 0);
    return [localD[0] - localZero[0], localD[1] - localZero[1]];
  }
  function clipByPanel(controller, cover, data) {
    var panel = getPanelByCover(controller, cover);
    if (panel === true) {
      return zrUtil.clone(data);
    }
    var panelRect = panel.getBoundingRect();
    return zrUtil.map(data, function(point) {
      var x = point[0];
      x = mathMax(x, panelRect.x);
      x = mathMin(x, panelRect.x + panelRect.width);
      var y = point[1];
      y = mathMax(y, panelRect.y);
      y = mathMin(y, panelRect.y + panelRect.height);
      return [x, y];
    });
  }
  function pointsToRect(points) {
    var xmin = mathMin(points[0][0], points[1][0]);
    var ymin = mathMin(points[0][1], points[1][1]);
    var xmax = mathMax(points[0][0], points[1][0]);
    var ymax = mathMax(points[0][1], points[1][1]);
    return {
      x: xmin,
      y: ymin,
      width: xmax - xmin,
      height: ymax - ymin
    };
  }
  function resetCursor(controller, e) {
    var x = e.offsetX;
    var y = e.offsetY;
    var zr = controller._zr;
    if (controller._brushType) {
      var panels = controller._panels;
      var covers = controller._covers;
      var inCover;
      for (var i = 0; i < covers.length; i++) {
        if (coverRenderers[covers[i].__brushOption.brushType].contain(covers[i], x, y)) {
          inCover = true;
          break;
        }
      }
      if (!inCover) {
        if (panels) {
          each(panels, function(panel) {
            panel.contain(x, y) && zr.setCursorStyle('crosshair');
          });
        } else {
          zr.setCursorStyle('crosshair');
        }
      }
    }
  }
  function preventDefault(e) {
    var rawE = e.event;
    rawE.preventDefault && rawE.preventDefault();
  }
  function mainShapeContain(cover, x, y) {
    return cover.childOfName('main').contain(x, y);
  }
  function updateCoverByMouse(controller, e, isEnd) {
    var x = e.offsetX;
    var y = e.offsetY;
    var creatingCover = controller._creatingCover;
    var panel = controller._creatingPanel;
    var thisBrushOption = controller._brushOption;
    var eventParams;
    controller._track.push(controller.group.transformCoordToLocal(x, y));
    if (shouldShowCover(controller) || creatingCover) {
      if (panel && !creatingCover) {
        thisBrushOption.brushMode === 'single' && clearCovers(controller);
        var brushOption = zrUtil.clone(thisBrushOption);
        brushOption.panelId = panel === true ? null : panel.__brushPanelId;
        creatingCover = controller._creatingCover = createCover(controller, brushOption);
        controller._covers.push(creatingCover);
      }
      if (creatingCover) {
        var coverRenderer = coverRenderers[controller._brushType];
        var coverBrushOption = creatingCover.__brushOption;
        coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));
        if (isEnd) {
          endCreating(controller, creatingCover);
          coverRenderer.updateCommon(controller, creatingCover);
        }
        updateCoverShape(controller, creatingCover);
        eventParams = {isEnd: isEnd};
      }
    } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {
      if (getPanelByPoint(controller, x, y) && clearCovers(controller)) {
        eventParams = {
          isEnd: isEnd,
          removeOnClick: true
        };
      }
    }
    return eventParams;
  }
  var mouseHandlers = {
    mousedown: function(e) {
      if (this._dragging) {
        handleDragEnd.call(this, e);
      } else if (!e.target || !e.target.draggable) {
        preventDefault(e);
        var x = e.offsetX;
        var y = e.offsetY;
        this._creatingCover = null;
        var panel = this._creatingPanel = getPanelByPoint(this, x, y);
        if (panel) {
          this._dragging = true;
          this._track = [this.group.transformCoordToLocal(x, y)];
        }
      }
    },
    mousemove: function(e) {
      resetCursor(this, e);
      if (this._dragging) {
        preventDefault(e);
        var eventParams = updateCoverByMouse(this, e, false);
        eventParams && trigger(this, eventParams);
      }
    },
    mouseup: handleDragEnd
  };
  function handleDragEnd(e) {
    if (this._dragging) {
      preventDefault(e);
      var eventParams = updateCoverByMouse(this, e, true);
      this._dragging = false;
      this._track = [];
      this._creatingCover = null;
      eventParams && trigger(this, eventParams);
    }
  }
  var coverRenderers = {
    lineX: getLineRenderer(0),
    lineY: getLineRenderer(1),
    rect: {
      createCover: function(controller, brushOption) {
        return createBaseRectCover(curry(driftRect, function(range) {
          return range;
        }, function(range) {
          return range;
        }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);
      },
      getCreatingRange: function(localTrack) {
        var ends = getTrackEnds(localTrack);
        return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
      },
      updateCoverShape: function(controller, cover, localRange, brushOption) {
        updateBaseRect(controller, cover, localRange, brushOption);
      },
      updateCommon: updateCommon,
      contain: mainShapeContain
    },
    polygon: {
      createCover: function(controller, brushOption) {
        var cover = new graphic.Group();
        cover.add(new graphic.Polyline({
          name: 'main',
          style: makeStyle(brushOption),
          silent: true
        }));
        return cover;
      },
      getCreatingRange: function(localTrack) {
        return localTrack;
      },
      endCreating: function(controller, cover) {
        cover.remove(cover.childAt(0));
        cover.add(new graphic.Polygon({
          name: 'main',
          draggable: true,
          drift: curry(driftPolygon, controller, cover),
          ondragend: curry(trigger, controller, {isEnd: true})
        }));
      },
      updateCoverShape: function(controller, cover, localRange, brushOption) {
        cover.childAt(0).setShape({points: clipByPanel(controller, cover, localRange)});
      },
      updateCommon: updateCommon,
      contain: mainShapeContain
    }
  };
  function getLineRenderer(xyIndex) {
    return {
      createCover: function(controller, brushOption) {
        return createBaseRectCover(curry(driftRect, function(range) {
          var rectRange = [range, [0, 100]];
          xyIndex && rectRange.reverse();
          return rectRange;
        }, function(rectRange) {
          return rectRange[xyIndex];
        }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);
      },
      getCreatingRange: function(localTrack) {
        var ends = getTrackEnds(localTrack);
        var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);
        var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);
        return [min, max];
      },
      updateCoverShape: function(controller, cover, localRange, brushOption) {
        var brushWidth = brushOption.brushStyle.width;
        var otherExtent;
        if (brushWidth == null) {
          var panel = getPanelByCover(controller, cover);
          var base = 0;
          if (panel !== true) {
            var rect = panel.getBoundingRect();
            brushWidth = xyIndex ? rect.width : rect.height;
            base = xyIndex ? rect.x : rect.y;
          }
          otherExtent = [base, base + (brushWidth || 0)];
        } else {
          otherExtent = [-brushWidth / 2, brushWidth / 2];
        }
        var rectRange = [localRange, otherExtent];
        xyIndex && rectRange.reverse();
        updateBaseRect(controller, cover, rectRange, brushOption);
      },
      updateCommon: updateCommon,
      contain: mainShapeContain
    };
  }
  module.exports = BrushController;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/helper/brushHelper.js", ["zrender/lib/core/util", "../../util/graphic", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var graphic = $__require('../../util/graphic');
  var each = zrUtil.each;
  var helper = {};
  var COMPONENT_NAMES = ['geo', 'xAxis', 'yAxis'];
  var PANEL_ID_SPLIT = '--';
  var COORD_CONVERTS = ['dataToPoint', 'pointToData'];
  helper.parseOutputRanges = function(areas, coordInfoList, ecModel, rangesCoordInfo) {
    each(areas, function(area, index) {
      var panelId = area.panelId;
      if (panelId) {
        panelId = panelId.split(PANEL_ID_SPLIT);
        area[panelId[0] + 'Index'] = +panelId[1];
        var coordInfo = findCoordInfo(area, coordInfoList);
        area.coordRange = coordConvert[area.brushType](1, coordInfo, area.range);
        rangesCoordInfo && (rangesCoordInfo[index] = coordInfo);
      }
    });
  };
  helper.parseInputRanges = function(brushModel, ecModel) {
    each(brushModel.areas, function(area) {
      var coordInfo = findCoordInfo(area, brushModel.coordInfoList);
      if (__DEV__) {
        zrUtil.assert(!coordInfo || coordInfo === true || area.coordRange, 'coordRange must be specified when coord index specified.');
        zrUtil.assert(!coordInfo || coordInfo !== true || area.range, 'range must be specified.');
      }
      area.range = area.range || [];
      if (coordInfo && coordInfo !== true) {
        area.range = coordConvert[area.brushType](0, coordInfo, area.coordRange);
        area.panelId = coordInfo.panelId;
      }
    });
  };
  helper.makePanelOpts = function(coordInfoList) {
    var panelOpts = [];
    each(coordInfoList, function(coordInfo) {
      var coordSys = coordInfo.coordSys;
      var rect;
      if (coordInfo.geoIndex >= 0) {
        rect = coordSys.getBoundingRect().clone();
        rect.applyTransform(graphic.getTransform(coordSys));
      } else {
        rect = coordSys.grid.getRect().clone();
      }
      panelOpts.push({
        panelId: coordInfo.panelId,
        rect: rect
      });
    });
    return panelOpts;
  };
  helper.makeCoordInfoList = function(option, ecModel) {
    var coordInfoList = [];
    each(COMPONENT_NAMES, function(componentName) {
      var componentIndices = option[componentName + 'Index'];
      if (componentIndices == null || componentIndices === 'none') {
        return;
      }
      if (componentIndices !== 'all' && !zrUtil.isArray(componentIndices)) {
        componentIndices = [componentIndices];
      }
      ecModel.eachComponent({mainType: componentName}, function(componentModel, index) {
        if (componentIndices !== 'all' && zrUtil.indexOf(componentIndices, index) < 0) {
          return;
        }
        var grid;
        var coordSys;
        (componentName === 'xAxis' || componentName === 'yAxis') ? (grid = componentModel.axis.grid) : (coordSys = componentModel.coordinateSystem);
        var coordInfo;
        for (var i = 0,
            len = coordInfoList.length; i < len; i++) {
          var cInfo = coordInfoList[i];
          if (__DEV__) {
            zrUtil.assert(cInfo[componentName + 'Index'] != index, 'Coord should not be defined duplicately: ' + componentName + index);
          }
          if (componentName === 'yAxis' && !cInfo.yAxis && cInfo.xAxis) {
            var aCoordSys = grid.getCartesian(cInfo.xAxisIndex, index);
            if (aCoordSys) {
              coordSys = aCoordSys;
              coordInfo = cInfo;
              break;
            }
          }
        }
        !coordInfo && coordInfoList.push(coordInfo = {});
        coordInfo[componentName] = componentModel;
        coordInfo[componentName + 'Index'] = index;
        coordInfo.panelId = componentName + PANEL_ID_SPLIT + index;
        coordInfo.coordSys = coordSys || grid.getCartesian(coordInfo.xAxisIndex, coordInfo.yAxisIndex);
        coordInfo.coordSys ? (coordInfoList[componentName + 'Has'] = true) : coordInfoList.pop();
      });
    });
    return coordInfoList;
  };
  helper.controlSeries = function(area, brushModel, seriesModel) {
    var coordInfo = findCoordInfo(area, brushModel.coordInfoList);
    return coordInfo === true || (coordInfo && coordInfo.coordSys === seriesModel.coordinateSystem);
  };
  function formatMinMax(minMax) {
    minMax[0] > minMax[1] && minMax.reverse();
    return minMax;
  }
  function findCoordInfo(area, coordInfoList) {
    var isGlobal = true;
    for (var j = 0; j < COMPONENT_NAMES.length; j++) {
      var indexAttr = COMPONENT_NAMES[j] + 'Index';
      if (area[indexAttr] >= 0) {
        isGlobal = false;
        for (var i = 0; i < coordInfoList.length; i++) {
          if (coordInfoList[i][indexAttr] === area[indexAttr]) {
            return coordInfoList[i];
          }
        }
      }
    }
    return isGlobal;
  }
  function axisConvert(axisName, to, coordInfo, coordRange) {
    var axis = coordInfo.coordSys.getAxis(axisName);
    if (__DEV__) {
      zrUtil.assert(axis, 'line brush is only available in cartesian (grid).');
    }
    return formatMinMax(zrUtil.map([0, 1], function(i) {
      return to ? axis.coordToData(axis.toLocalCoord(coordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(coordRange[i]));
    }));
  }
  var coordConvert = {
    lineX: zrUtil.curry(axisConvert, 'x'),
    lineY: zrUtil.curry(axisConvert, 'y'),
    rect: function(to, coordInfo, coordRange) {
      var coordSys = coordInfo.coordSys;
      var xminymin = coordSys[COORD_CONVERTS[to]]([coordRange[0][0], coordRange[1][0]]);
      var xmaxymax = coordSys[COORD_CONVERTS[to]]([coordRange[0][1], coordRange[1][1]]);
      return [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
    },
    polygon: function(to, coordInfo, coordRange) {
      var coordSys = coordInfo.coordSys;
      return zrUtil.map(coordRange, coordSys[COORD_CONVERTS[to]], coordSys);
    }
  };
  module.exports = helper;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/typeDefaulter.js", ["../../model/Component", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('../../model/Component').registerSubTypeDefaulter('dataZoom', function(option) {
    return 'slider';
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/AxisProxy.js", ["zrender/lib/core/util", "../../util/number", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var numberUtil = $__require('../../util/number');
  var each = zrUtil.each;
  var asc = numberUtil.asc;
  var AxisProxy = function(dimName, axisIndex, dataZoomModel, ecModel) {
    this._dimName = dimName;
    this._axisIndex = axisIndex;
    this._valueWindow;
    this._percentWindow;
    this._dataExtent;
    this.ecModel = ecModel;
    this._dataZoomModel = dataZoomModel;
  };
  AxisProxy.prototype = {
    constructor: AxisProxy,
    hostedBy: function(dataZoomModel) {
      return this._dataZoomModel === dataZoomModel;
    },
    getDataExtent: function() {
      return this._dataExtent.slice();
    },
    getDataValueWindow: function() {
      return this._valueWindow.slice();
    },
    getDataPercentWindow: function() {
      return this._percentWindow.slice();
    },
    getTargetSeriesModels: function() {
      var seriesModels = [];
      this.ecModel.eachSeries(function(seriesModel) {
        if (this._axisIndex === +seriesModel.get(this._dimName + 'AxisIndex')) {
          seriesModels.push(seriesModel);
        }
      }, this);
      return seriesModels;
    },
    getAxisModel: function() {
      return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);
    },
    getOtherAxisModel: function() {
      var axisDim = this._dimName;
      var ecModel = this.ecModel;
      var axisModel = this.getAxisModel();
      var isCartesian = axisDim === 'x' || axisDim === 'y';
      var otherAxisDim;
      var coordSysIndexName;
      if (isCartesian) {
        coordSysIndexName = 'gridIndex';
        otherAxisDim = axisDim === 'x' ? 'y' : 'x';
      } else {
        coordSysIndexName = 'polarIndex';
        otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';
      }
      var foundOtherAxisModel;
      ecModel.eachComponent(otherAxisDim + 'Axis', function(otherAxisModel) {
        if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {
          foundOtherAxisModel = otherAxisModel;
        }
      });
      return foundOtherAxisModel;
    },
    reset: function(dataZoomModel) {
      if (dataZoomModel !== this._dataZoomModel) {
        return;
      }
      var dataExtent = this._dataExtent = calculateDataExtent(this._dimName, this.getTargetSeriesModels());
      var dataWindow = calculateDataWindow(dataZoomModel.option, dataExtent, this);
      this._valueWindow = dataWindow.valueWindow;
      this._percentWindow = dataWindow.percentWindow;
      setAxisModel(this);
    },
    restore: function(dataZoomModel) {
      if (dataZoomModel !== this._dataZoomModel) {
        return;
      }
      this._valueWindow = this._percentWindow = null;
      setAxisModel(this, true);
    },
    filterData: function(dataZoomModel) {
      if (dataZoomModel !== this._dataZoomModel) {
        return;
      }
      var axisDim = this._dimName;
      var seriesModels = this.getTargetSeriesModels();
      var filterMode = dataZoomModel.get('filterMode');
      var valueWindow = this._valueWindow;
      var otherAxisModel = this.getOtherAxisModel();
      if (dataZoomModel.get('$fromToolbox') && otherAxisModel && otherAxisModel.get('type') === 'category') {
        filterMode = 'empty';
      }
      each(seriesModels, function(seriesModel) {
        var seriesData = seriesModel.getData();
        seriesData && each(seriesModel.coordDimToDataDim(axisDim), function(dim) {
          if (filterMode === 'empty') {
            seriesModel.setData(seriesData.map(dim, function(value) {
              return !isInWindow(value) ? NaN : value;
            }));
          } else {
            seriesData.filterSelf(dim, isInWindow);
          }
        });
      });
      function isInWindow(value) {
        return value >= valueWindow[0] && value <= valueWindow[1];
      }
    }
  };
  function calculateDataExtent(axisDim, seriesModels) {
    var dataExtent = [Infinity, -Infinity];
    each(seriesModels, function(seriesModel) {
      var seriesData = seriesModel.getData();
      if (seriesData) {
        each(seriesModel.coordDimToDataDim(axisDim), function(dim) {
          var seriesExtent = seriesData.getDataExtent(dim);
          seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
          seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
        });
      }
    }, this);
    return dataExtent;
  }
  function calculateDataWindow(opt, dataExtent, axisProxy) {
    var axisModel = axisProxy.getAxisModel();
    var scale = axisModel.axis.scale;
    var percentExtent = [0, 100];
    var percentWindow = [opt.start, opt.end];
    var valueWindow = [];
    dataExtent = dataExtent.slice();
    fixExtendByAxis(dataExtent, axisModel, scale);
    each(['startValue', 'endValue'], function(prop) {
      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);
    });
    each([0, 1], function(idx) {
      var boundValue = valueWindow[idx];
      var boundPercent = percentWindow[idx];
      if (boundPercent != null || boundValue == null) {
        if (boundPercent == null) {
          boundPercent = percentExtent[idx];
        }
        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));
      } else {
        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);
      }
      valueWindow[idx] = boundValue;
      percentWindow[idx] = boundPercent;
    });
    return {
      valueWindow: asc(valueWindow),
      percentWindow: asc(percentWindow)
    };
  }
  function fixExtendByAxis(dataExtent, axisModel, scale) {
    each(['min', 'max'], function(minMax, index) {
      var axisMax = axisModel.get(minMax, true);
      if (axisMax != null && (axisMax + '').toLowerCase() !== 'data' + minMax) {
        dataExtent[index] = scale.parse(axisMax);
      }
    });
    if (!axisModel.get('scale', true)) {
      dataExtent[0] > 0 && (dataExtent[0] = 0);
      dataExtent[1] < 0 && (dataExtent[1] = 0);
    }
    return dataExtent;
  }
  function setAxisModel(axisProxy, isRestore) {
    var axisModel = axisProxy.getAxisModel();
    var percentWindow = axisProxy._percentWindow;
    var valueWindow = axisProxy._valueWindow;
    if (!percentWindow) {
      return;
    }
    var isFull = isRestore || (percentWindow[0] === 0 && percentWindow[1] === 100);
    var precision = !isRestore && numberUtil.getPixelPrecision(valueWindow, [0, 500]);
    var invalidPrecision = !isRestore && !(precision < 20 && precision >= 0);
    var useOrigin = isRestore || isFull || invalidPrecision;
    axisModel.setRange && axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));
  }
  module.exports = AxisProxy;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/DataZoomModel.js", ["zrender/lib/core/util", "zrender/lib/core/env", "../../echarts", "../../util/model", "./AxisProxy", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var env = $__require('zrender/lib/core/env');
  var echarts = $__require('../../echarts');
  var modelUtil = $__require('../../util/model');
  var AxisProxy = $__require('./AxisProxy');
  var each = zrUtil.each;
  var eachAxisDim = modelUtil.eachAxisDim;
  var DataZoomModel = echarts.extendComponentModel({
    type: 'dataZoom',
    dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'series'],
    defaultOption: {
      zlevel: 0,
      z: 4,
      orient: null,
      xAxisIndex: null,
      yAxisIndex: null,
      angleAxisIndex: null,
      radiusAxisIndex: null,
      filterMode: 'filter',
      throttle: null,
      start: 0,
      end: 100,
      startValue: null,
      endValue: null
    },
    init: function(option, parentModel, ecModel) {
      this._dataIntervalByAxis = {};
      this._dataInfo = {};
      this._axisProxies = {};
      this.textStyleModel;
      this._autoThrottle = true;
      var rawOption = retrieveRaw(option);
      this.mergeDefaultAndTheme(option, ecModel);
      this.doInit(rawOption);
    },
    mergeOption: function(newOption) {
      var rawOption = retrieveRaw(newOption);
      zrUtil.merge(this.option, newOption, true);
      this.doInit(rawOption);
    },
    doInit: function(rawOption) {
      var thisOption = this.option;
      if (!env.canvasSupported) {
        thisOption.realtime = false;
      }
      this._setDefaultThrottle(rawOption);
      processRangeProp('start', 'startValue', rawOption, thisOption);
      processRangeProp('end', 'endValue', rawOption, thisOption);
      this.textStyleModel = this.getModel('textStyle');
      this._resetTarget();
      this._giveAxisProxies();
    },
    _giveAxisProxies: function() {
      var axisProxies = this._axisProxies;
      this.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel, ecModel) {
        var axisModel = this.dependentModels[dimNames.axis][axisIndex];
        var axisProxy = axisModel.__dzAxisProxy || (axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel));
        axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;
      }, this);
    },
    _resetTarget: function() {
      var thisOption = this.option;
      var autoMode = this._judgeAutoMode();
      eachAxisDim(function(dimNames) {
        var axisIndexName = dimNames.axisIndex;
        thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);
      }, this);
      if (autoMode === 'axisIndex') {
        this._autoSetAxisIndex();
      } else if (autoMode === 'orient') {
        this._autoSetOrient();
      }
    },
    _judgeAutoMode: function() {
      var thisOption = this.option;
      var hasIndexSpecified = false;
      eachAxisDim(function(dimNames) {
        if (thisOption[dimNames.axisIndex] != null) {
          hasIndexSpecified = true;
        }
      }, this);
      var orient = thisOption.orient;
      if (orient == null && hasIndexSpecified) {
        return 'orient';
      } else if (!hasIndexSpecified) {
        if (orient == null) {
          thisOption.orient = 'horizontal';
        }
        return 'axisIndex';
      }
    },
    _autoSetAxisIndex: function() {
      var autoAxisIndex = true;
      var orient = this.get('orient', true);
      var thisOption = this.option;
      if (autoAxisIndex) {
        var dimNames = orient === 'vertical' ? {
          dim: 'y',
          axisIndex: 'yAxisIndex',
          axis: 'yAxis'
        } : {
          dim: 'x',
          axisIndex: 'xAxisIndex',
          axis: 'xAxis'
        };
        if (this.dependentModels[dimNames.axis].length) {
          thisOption[dimNames.axisIndex] = [0];
          autoAxisIndex = false;
        }
      }
      if (autoAxisIndex) {
        eachAxisDim(function(dimNames) {
          if (!autoAxisIndex) {
            return;
          }
          var axisIndices = [];
          var axisModels = this.dependentModels[dimNames.axis];
          if (axisModels.length && !axisIndices.length) {
            for (var i = 0,
                len = axisModels.length; i < len; i++) {
              if (axisModels[i].get('type') === 'category') {
                axisIndices.push(i);
              }
            }
          }
          thisOption[dimNames.axisIndex] = axisIndices;
          if (axisIndices.length) {
            autoAxisIndex = false;
          }
        }, this);
      }
      if (autoAxisIndex) {
        this.ecModel.eachSeries(function(seriesModel) {
          if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {
            eachAxisDim(function(dimNames) {
              var axisIndices = thisOption[dimNames.axisIndex];
              var axisIndex = seriesModel.get(dimNames.axisIndex);
              if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {
                axisIndices.push(axisIndex);
              }
            });
          }
        }, this);
      }
    },
    _autoSetOrient: function() {
      var dim;
      this.eachTargetAxis(function(dimNames) {
        !dim && (dim = dimNames.name);
      }, this);
      this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';
    },
    _isSeriesHasAllAxesTypeOf: function(seriesModel, axisType) {
      var is = true;
      eachAxisDim(function(dimNames) {
        var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);
        var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];
        if (!axisModel || axisModel.get('type') !== axisType) {
          is = false;
        }
      }, this);
      return is;
    },
    _setDefaultThrottle: function(rawOption) {
      if (rawOption.hasOwnProperty('throttle')) {
        this._autoThrottle = false;
      }
      if (this._autoThrottle) {
        var globalOption = this.ecModel.option;
        this.option.throttle = (globalOption.animation && globalOption.animationDurationUpdate > 0) ? 100 : 20;
      }
    },
    getFirstTargetAxisModel: function() {
      var firstAxisModel;
      eachAxisDim(function(dimNames) {
        if (firstAxisModel == null) {
          var indices = this.get(dimNames.axisIndex);
          if (indices.length) {
            firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];
          }
        }
      }, this);
      return firstAxisModel;
    },
    eachTargetAxis: function(callback, context) {
      var ecModel = this.ecModel;
      eachAxisDim(function(dimNames) {
        each(this.get(dimNames.axisIndex), function(axisIndex) {
          callback.call(context, dimNames, axisIndex, this, ecModel);
        }, this);
      }, this);
    },
    getAxisProxy: function(dimName, axisIndex) {
      return this._axisProxies[dimName + '_' + axisIndex];
    },
    setRawRange: function(opt) {
      each(['start', 'end', 'startValue', 'endValue'], function(name) {
        this.option[name] = opt[name];
      }, this);
    },
    getPercentRange: function() {
      var axisProxy = this.findRepresentativeAxisProxy();
      if (axisProxy) {
        return axisProxy.getDataPercentWindow();
      }
    },
    getValueRange: function(axisDimName, axisIndex) {
      if (axisDimName == null && axisIndex == null) {
        var axisProxy = this.findRepresentativeAxisProxy();
        if (axisProxy) {
          return axisProxy.getDataValueWindow();
        }
      } else {
        return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();
      }
    },
    findRepresentativeAxisProxy: function() {
      var axisProxies = this._axisProxies;
      for (var key in axisProxies) {
        if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {
          return axisProxies[key];
        }
      }
      for (var key in axisProxies) {
        if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {
          return axisProxies[key];
        }
      }
    }
  });
  function retrieveRaw(option) {
    var ret = {};
    each(['start', 'end', 'startValue', 'endValue', 'throttle'], function(name) {
      option.hasOwnProperty(name) && (ret[name] = option[name]);
    });
    return ret;
  }
  function processRangeProp(percentProp, valueProp, rawOption, thisOption) {
    if (rawOption[valueProp] != null && rawOption[percentProp] == null) {
      thisOption[percentProp] = null;
    }
  }
  module.exports = DataZoomModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/SelectZoomModel.js", ["./DataZoomModel", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var DataZoomModel = $__require('./DataZoomModel');
  module.exports = DataZoomModel.extend({type: 'dataZoom.select'});
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/DataZoomView.js", ["../../view/Component", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ComponentView = $__require('../../view/Component');
  module.exports = ComponentView.extend({
    type: 'dataZoom',
    render: function(dataZoomModel, ecModel, api, payload) {
      this.dataZoomModel = dataZoomModel;
      this.ecModel = ecModel;
      this.api = api;
    },
    getTargetInfo: function() {
      var dataZoomModel = this.dataZoomModel;
      var ecModel = this.ecModel;
      var cartesians = [];
      var polars = [];
      var axisModels = [];
      dataZoomModel.eachTargetAxis(function(dimNames, axisIndex) {
        var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);
        if (axisModel) {
          axisModels.push(axisModel);
          var gridIndex = axisModel.get('gridIndex');
          var polarIndex = axisModel.get('polarIndex');
          if (gridIndex != null) {
            var coordModel = ecModel.getComponent('grid', gridIndex);
            save(coordModel, axisModel, cartesians, gridIndex);
          } else if (polarIndex != null) {
            var coordModel = ecModel.getComponent('polar', polarIndex);
            save(coordModel, axisModel, polars, polarIndex);
          }
        }
      }, this);
      function save(coordModel, axisModel, store, coordIndex) {
        var item;
        for (var i = 0; i < store.length; i++) {
          if (store[i].model === coordModel) {
            item = store[i];
            break;
          }
        }
        if (!item) {
          store.push(item = {
            model: coordModel,
            axisModels: [],
            coordIndex: coordIndex
          });
        }
        item.axisModels.push(axisModel);
      }
      return {
        cartesians: cartesians,
        polars: polars,
        axisModels: axisModels
      };
    }
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/SelectZoomView.js", ["./DataZoomView", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./DataZoomView').extend({type: 'dataZoom.select'});
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/dataZoomProcessor.js", ["../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var echarts = $__require('../../echarts');
  echarts.registerProcessor(function(ecModel, api) {
    ecModel.eachComponent('dataZoom', function(dataZoomModel) {
      dataZoomModel.eachTargetAxis(resetSingleAxis);
      dataZoomModel.eachTargetAxis(filterSingleAxis);
    });
    ecModel.eachComponent('dataZoom', function(dataZoomModel) {
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      var percentRange = axisProxy.getDataPercentWindow();
      var valueRange = axisProxy.getDataValueWindow();
      dataZoomModel.setRawRange({
        start: percentRange[0],
        end: percentRange[1],
        startValue: valueRange[0],
        endValue: valueRange[1]
      });
    });
  });
  function resetSingleAxis(dimNames, axisIndex, dataZoomModel) {
    dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);
  }
  function filterSingleAxis(dimNames, axisIndex, dataZoomModel) {
    dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);
  }
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/dataZoomAction.js", ["zrender/lib/core/util", "../../util/model", "../../echarts", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var modelUtil = $__require('../../util/model');
  var echarts = $__require('../../echarts');
  echarts.registerAction('dataZoom', function(payload, ecModel) {
    var linkedNodesFinder = modelUtil.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), modelUtil.eachAxisDim, function(model, dimNames) {
      return model.get(dimNames.axisIndex);
    });
    var effectedModels = [];
    ecModel.eachComponent({
      mainType: 'dataZoom',
      query: payload
    }, function(model, index) {
      effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);
    });
    zrUtil.each(effectedModels, function(dataZoomModel, index) {
      dataZoomModel.setRawRange({
        start: payload.start,
        end: payload.end,
        startValue: payload.startValue,
        endValue: payload.endValue
      });
    });
  });
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoomSelect.js", ["./dataZoom/typeDefaulter", "./dataZoom/DataZoomModel", "./dataZoom/DataZoomView", "./dataZoom/SelectZoomModel", "./dataZoom/SelectZoomView", "./dataZoom/dataZoomProcessor", "./dataZoom/dataZoomAction", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./dataZoom/typeDefaulter');
  $__require('./dataZoom/DataZoomModel');
  $__require('./dataZoom/DataZoomView');
  $__require('./dataZoom/SelectZoomModel');
  $__require('./dataZoom/SelectZoomView');
  $__require('./dataZoom/dataZoomProcessor');
  $__require('./dataZoom/dataZoomAction');
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/toolbox/feature/DataZoom.js", ["zrender/lib/core/util", "../../helper/BrushController", "../../helper/brushHelper", "../../dataZoom/history", "../../dataZoomSelect", "../featureManager", "../../../echarts", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var BrushController = $__require('../../helper/BrushController');
  var brushHelper = $__require('../../helper/brushHelper');
  var history = $__require('../../dataZoom/history');
  var each = zrUtil.each;
  $__require('../../dataZoomSelect');
  var DATA_ZOOM_ID_BASE = '\0_ec_\0toolbox-dataZoom_';
  function DataZoom(model, ecModel, api) {
    (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this)).mount();
    this._isZoomActive;
  }
  DataZoom.defaultOption = {
    show: true,
    icon: {
      zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',
      back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'
    },
    title: {
      zoom: '',
      back: ''
    }
  };
  var proto = DataZoom.prototype;
  proto.render = function(featureModel, ecModel, api, payload) {
    this.model = featureModel;
    this.ecModel = ecModel;
    this.api = api;
    updateZoomBtnStatus(featureModel, ecModel, this, payload);
    updateBackBtnStatus(featureModel, ecModel);
  };
  proto.onclick = function(ecModel, api, type) {
    handlers[type].call(this);
  };
  proto.remove = function(ecModel, api) {
    this._brushController.unmount();
  };
  proto.dispose = function(ecModel, api) {
    this._brushController.dispose();
  };
  var handlers = {
    zoom: function() {
      var nextActive = !this._isZoomActive;
      this.api.dispatchAction({
        type: 'takeGlobalCursor',
        key: 'dataZoomSelect',
        dataZoomSelectActive: nextActive
      });
    },
    back: function() {
      this._dispatchZoomAction(history.pop(this.ecModel));
    }
  };
  proto._onBrush = function(areas, opt) {
    if (!opt.isEnd || !areas.length) {
      return;
    }
    var snapshot = {};
    var ecModel = this.ecModel;
    this._brushController.updateCovers([]);
    var coordInfoList = brushHelper.makeCoordInfoList(retrieveAxisSetting(this.model.option), ecModel);
    var rangesCoordInfoList = [];
    brushHelper.parseOutputRanges(areas, coordInfoList, ecModel, rangesCoordInfoList);
    var area = areas[0];
    var coordInfo = rangesCoordInfoList[0];
    var coordRange = area.coordRange;
    var brushType = area.brushType;
    if (coordInfo && coordRange) {
      if (brushType === 'rect') {
        setBatch('xAxis', coordRange[0], coordInfo);
        setBatch('yAxis', coordRange[1], coordInfo);
      } else {
        var axisNames = {
          lineX: 'xAxis',
          lineY: 'yAxis'
        };
        setBatch(axisNames[brushType], coordRange, coordInfo);
      }
    }
    history.push(ecModel, snapshot);
    this._dispatchZoomAction(snapshot);
    function setBatch(axisName, minMax, coordInfo) {
      var dataZoomModel = findDataZoom(axisName, coordInfo[axisName], ecModel);
      if (dataZoomModel) {
        snapshot[dataZoomModel.id] = {
          dataZoomId: dataZoomModel.id,
          startValue: minMax[0],
          endValue: minMax[1]
        };
      }
    }
    function findDataZoom(axisName, axisModel, ecModel) {
      var dataZoomModel;
      ecModel.eachComponent({
        mainType: 'dataZoom',
        subType: 'select'
      }, function(dzModel, dataZoomIndex) {
        var axisIndex = dzModel.get(axisName + 'Index');
        if (axisIndex != null && ecModel.getComponent(axisName, axisIndex) === axisModel) {
          dataZoomModel = dzModel;
        }
      });
      return dataZoomModel;
    }
  };
  proto._dispatchZoomAction = function(snapshot) {
    var batch = [];
    each(snapshot, function(batchItem, dataZoomId) {
      batch.push(zrUtil.clone(batchItem));
    });
    batch.length && this.api.dispatchAction({
      type: 'dataZoom',
      from: this.uid,
      batch: batch
    });
  };
  function retrieveAxisSetting(option) {
    var setting = {};
    zrUtil.each(['xAxisIndex', 'yAxisIndex'], function(name) {
      setting[name] = option[name];
      setting[name] == null && (setting[name] = 'all');
      (setting[name] === false || setting[name] === 'none') && (setting[name] = []);
    });
    return setting;
  }
  function updateBackBtnStatus(featureModel, ecModel) {
    featureModel.setIconStatus('back', history.count(ecModel) > 1 ? 'emphasis' : 'normal');
  }
  function updateZoomBtnStatus(featureModel, ecModel, view, payload) {
    var zoomActive = view._isZoomActive;
    if (payload && payload.type === 'takeGlobalCursor') {
      zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;
    }
    view._isZoomActive = zoomActive;
    featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');
    var coordInfoList = brushHelper.makeCoordInfoList(retrieveAxisSetting(featureModel.option), ecModel);
    var brushType = (coordInfoList.xAxisHas && !coordInfoList.yAxisHas) ? 'lineX' : (!coordInfoList.xAxisHas && coordInfoList.yAxisHas) ? 'lineY' : 'rect';
    view._brushController.setPanels(brushHelper.makePanelOpts(coordInfoList)).enableBrush(zoomActive ? {
      brushType: brushType,
      brushStyle: {
        lineWidth: 0,
        fill: 'rgba(0,0,0,0.2)'
      }
    } : false);
  }
  $__require('../featureManager').register('dataZoom', DataZoom);
  $__require('../../../echarts').registerPreprocessor(function(option) {
    if (!option) {
      return;
    }
    var dataZoomOpts = option.dataZoom || (option.dataZoom = []);
    if (!zrUtil.isArray(dataZoomOpts)) {
      option.dataZoom = dataZoomOpts = [dataZoomOpts];
    }
    var toolboxOpt = option.toolbox;
    if (toolboxOpt) {
      if (zrUtil.isArray(toolboxOpt)) {
        toolboxOpt = toolboxOpt[0];
      }
      if (toolboxOpt && toolboxOpt.feature) {
        var dataZoomOpt = toolboxOpt.feature.dataZoom;
        addForAxis('xAxis', dataZoomOpt);
        addForAxis('yAxis', dataZoomOpt);
      }
    }
    function addForAxis(axisName, dataZoomOpt) {
      if (!dataZoomOpt) {
        return;
      }
      var axisIndicesName = axisName + 'Index';
      var givenAxisIndices = dataZoomOpt[axisIndicesName];
      if (givenAxisIndices != null && givenAxisIndices != 'all' && !zrUtil.isArray(givenAxisIndices)) {
        givenAxisIndices = (givenAxisIndices === false || givenAxisIndices === 'none') ? [] : [givenAxisIndices];
      }
      forEachComponent(axisName, function(axisOpt, axisIndex) {
        if (givenAxisIndices != null && givenAxisIndices != 'all' && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1) {
          return;
        }
        var newOpt = {
          type: 'select',
          $fromToolbox: true,
          id: DATA_ZOOM_ID_BASE + axisName + axisIndex
        };
        newOpt[axisIndicesName] = axisIndex;
        dataZoomOpts.push(newOpt);
      });
    }
    function forEachComponent(mainType, cb) {
      var opts = option[mainType];
      if (!zrUtil.isArray(opts)) {
        opts = opts ? [opts] : [];
      }
      each(opts, cb);
    }
  });
  module.exports = DataZoom;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/dataZoom/history.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var each = zrUtil.each;
  var ATTR = '\0_ec_hist_store';
  var history = {
    push: function(ecModel, newSnapshot) {
      var store = giveStore(ecModel);
      each(newSnapshot, function(batchItem, dataZoomId) {
        var i = store.length - 1;
        for (; i >= 0; i--) {
          var snapshot = store[i];
          if (snapshot[dataZoomId]) {
            break;
          }
        }
        if (i < 0) {
          var dataZoomModel = ecModel.queryComponents({
            mainType: 'dataZoom',
            subType: 'select',
            id: dataZoomId
          })[0];
          if (dataZoomModel) {
            var percentRange = dataZoomModel.getPercentRange();
            store[0][dataZoomId] = {
              dataZoomId: dataZoomId,
              start: percentRange[0],
              end: percentRange[1]
            };
          }
        }
      });
      store.push(newSnapshot);
    },
    pop: function(ecModel) {
      var store = giveStore(ecModel);
      var head = store[store.length - 1];
      store.length > 1 && store.pop();
      var snapshot = {};
      each(head, function(batchItem, dataZoomId) {
        for (var i = store.length - 1; i >= 0; i--) {
          var batchItem = store[i][dataZoomId];
          if (batchItem) {
            snapshot[dataZoomId] = batchItem;
            break;
          }
        }
      });
      return snapshot;
    },
    clear: function(ecModel) {
      ecModel[ATTR] = null;
    },
    count: function(ecModel) {
      return giveStore(ecModel).length;
    }
  };
  function giveStore(ecModel) {
    var store = ecModel[ATTR];
    if (!store) {
      store = ecModel[ATTR] = [{}];
    }
    return store;
  }
  module.exports = history;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/toolbox/featureManager.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var features = {};
  module.exports = {
    register: function(name, ctor) {
      features[name] = ctor;
    },
    get: function(name) {
      return features[name];
    }
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/model/globalDefault.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var platform = '';
  if (typeof navigator !== 'undefined') {
    platform = navigator.platform || '';
  }
  module.exports = {
    color: ['#c23531', '#2f4554', '#61a0a8', '#d48265', '#91c7ae', '#749f83', '#ca8622', '#bda29a', '#6e7074', '#546570', '#c4ccd3'],
    grid: {},
    textStyle: {
      fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
      fontSize: 12,
      fontStyle: 'normal',
      fontWeight: 'normal'
    },
    blendMode: null,
    animation: true,
    animationDuration: 1000,
    animationDurationUpdate: 300,
    animationEasing: 'exponentialOut',
    animationEasingUpdate: 'cubicOut',
    animationThreshold: 2000,
    progressiveThreshold: 3000,
    progressive: 400,
    hoverLayerThreshold: 3000
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/model/Global.js", ["zrender/lib/core/util", "../util/model", "./Model", "./Component", "./globalDefault", "./mixin/colorPalette", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var modelUtil = $__require('../util/model');
  var Model = $__require('./Model');
  var each = zrUtil.each;
  var filter = zrUtil.filter;
  var map = zrUtil.map;
  var isArray = zrUtil.isArray;
  var indexOf = zrUtil.indexOf;
  var isObject = zrUtil.isObject;
  var ComponentModel = $__require('./Component');
  var globalDefault = $__require('./globalDefault');
  var OPTION_INNER_KEY = '\0_ec_inner';
  var GlobalModel = Model.extend({
    constructor: GlobalModel,
    init: function(option, parentModel, theme, optionManager) {
      theme = theme || {};
      this.option = null;
      this._theme = new Model(theme);
      this._optionManager = optionManager;
    },
    setOption: function(option, optionPreprocessorFuncs) {
      zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');
      this._optionManager.setOption(option, optionPreprocessorFuncs);
      this.resetOption();
    },
    resetOption: function(type) {
      var optionChanged = false;
      var optionManager = this._optionManager;
      if (!type || type === 'recreate') {
        var baseOption = optionManager.mountOption(type === 'recreate');
        if (!this.option || type === 'recreate') {
          initBase.call(this, baseOption);
        } else {
          this.restoreData();
          this.mergeOption(baseOption);
        }
        optionChanged = true;
      }
      if (type === 'timeline' || type === 'media') {
        this.restoreData();
      }
      if (!type || type === 'recreate' || type === 'timeline') {
        var timelineOption = optionManager.getTimelineOption(this);
        timelineOption && (this.mergeOption(timelineOption), optionChanged = true);
      }
      if (!type || type === 'recreate' || type === 'media') {
        var mediaOptions = optionManager.getMediaOption(this, this._api);
        if (mediaOptions.length) {
          each(mediaOptions, function(mediaOption) {
            this.mergeOption(mediaOption, optionChanged = true);
          }, this);
        }
      }
      return optionChanged;
    },
    mergeOption: function(newOption) {
      var option = this.option;
      var componentsMap = this._componentsMap;
      var newCptTypes = [];
      each(newOption, function(componentOption, mainType) {
        if (componentOption == null) {
          return;
        }
        if (!ComponentModel.hasClass(mainType)) {
          option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);
        } else {
          newCptTypes.push(mainType);
        }
      });
      ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);
      function visitComponent(mainType, dependencies) {
        var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);
        var mapResult = modelUtil.mappingToExists(componentsMap[mainType], newCptOptionList);
        makeKeyInfo(mainType, mapResult);
        var dependentModels = getComponentsByTypes(componentsMap, dependencies);
        option[mainType] = [];
        componentsMap[mainType] = [];
        each(mapResult, function(resultItem, index) {
          var componentModel = resultItem.exist;
          var newCptOption = resultItem.option;
          zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition');
          if (!newCptOption) {
            componentModel.mergeOption({}, this);
            componentModel.optionUpdated({}, false);
          } else {
            var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);
            if (componentModel && componentModel instanceof ComponentModelClass) {
              componentModel.mergeOption(newCptOption, this);
              componentModel.optionUpdated(newCptOption, false);
            } else {
              var extraOpt = zrUtil.extend({
                dependentModels: dependentModels,
                componentIndex: index
              }, resultItem.keyInfo);
              componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);
              componentModel.init(newCptOption, this, this, extraOpt);
              componentModel.optionUpdated(null, true);
            }
          }
          componentsMap[mainType][index] = componentModel;
          option[mainType][index] = componentModel.option;
        }, this);
        if (mainType === 'series') {
          this._seriesIndices = createSeriesIndices(componentsMap.series);
        }
      }
    },
    getOption: function() {
      var option = zrUtil.clone(this.option);
      each(option, function(opts, mainType) {
        if (ComponentModel.hasClass(mainType)) {
          var opts = modelUtil.normalizeToArray(opts);
          for (var i = opts.length - 1; i >= 0; i--) {
            if (modelUtil.isIdInner(opts[i])) {
              opts.splice(i, 1);
            }
          }
          option[mainType] = opts;
        }
      });
      delete option[OPTION_INNER_KEY];
      return option;
    },
    getTheme: function() {
      return this._theme;
    },
    getComponent: function(mainType, idx) {
      var list = this._componentsMap[mainType];
      if (list) {
        return list[idx || 0];
      }
    },
    queryComponents: function(condition) {
      var mainType = condition.mainType;
      if (!mainType) {
        return [];
      }
      var index = condition.index;
      var id = condition.id;
      var name = condition.name;
      var cpts = this._componentsMap[mainType];
      if (!cpts || !cpts.length) {
        return [];
      }
      var result;
      if (index != null) {
        if (!isArray(index)) {
          index = [index];
        }
        result = filter(map(index, function(idx) {
          return cpts[idx];
        }), function(val) {
          return !!val;
        });
      } else if (id != null) {
        var isIdArray = isArray(id);
        result = filter(cpts, function(cpt) {
          return (isIdArray && indexOf(id, cpt.id) >= 0) || (!isIdArray && cpt.id === id);
        });
      } else if (name != null) {
        var isNameArray = isArray(name);
        result = filter(cpts, function(cpt) {
          return (isNameArray && indexOf(name, cpt.name) >= 0) || (!isNameArray && cpt.name === name);
        });
      }
      return filterBySubType(result, condition);
    },
    findComponents: function(condition) {
      var query = condition.query;
      var mainType = condition.mainType;
      var queryCond = getQueryCond(query);
      var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap[mainType];
      return doFilter(filterBySubType(result, condition));
      function getQueryCond(q) {
        var indexAttr = mainType + 'Index';
        var idAttr = mainType + 'Id';
        var nameAttr = mainType + 'Name';
        return q && (q.hasOwnProperty(indexAttr) || q.hasOwnProperty(idAttr) || q.hasOwnProperty(nameAttr)) ? {
          mainType: mainType,
          index: q[indexAttr],
          id: q[idAttr],
          name: q[nameAttr]
        } : null;
      }
      function doFilter(res) {
        return condition.filter ? filter(res, condition.filter) : res;
      }
    },
    eachComponent: function(mainType, cb, context) {
      var componentsMap = this._componentsMap;
      if (typeof mainType === 'function') {
        context = cb;
        cb = mainType;
        each(componentsMap, function(components, componentType) {
          each(components, function(component, index) {
            cb.call(context, componentType, component, index);
          });
        });
      } else if (zrUtil.isString(mainType)) {
        each(componentsMap[mainType], cb, context);
      } else if (isObject(mainType)) {
        var queryResult = this.findComponents(mainType);
        each(queryResult, cb, context);
      }
    },
    getSeriesByName: function(name) {
      var series = this._componentsMap.series;
      return filter(series, function(oneSeries) {
        return oneSeries.name === name;
      });
    },
    getSeriesByIndex: function(seriesIndex) {
      return this._componentsMap.series[seriesIndex];
    },
    getSeriesByType: function(subType) {
      var series = this._componentsMap.series;
      return filter(series, function(oneSeries) {
        return oneSeries.subType === subType;
      });
    },
    getSeries: function() {
      return this._componentsMap.series.slice();
    },
    eachSeries: function(cb, context) {
      assertSeriesInitialized(this);
      each(this._seriesIndices, function(rawSeriesIndex) {
        var series = this._componentsMap.series[rawSeriesIndex];
        cb.call(context, series, rawSeriesIndex);
      }, this);
    },
    eachRawSeries: function(cb, context) {
      each(this._componentsMap.series, cb, context);
    },
    eachSeriesByType: function(subType, cb, context) {
      assertSeriesInitialized(this);
      each(this._seriesIndices, function(rawSeriesIndex) {
        var series = this._componentsMap.series[rawSeriesIndex];
        if (series.subType === subType) {
          cb.call(context, series, rawSeriesIndex);
        }
      }, this);
    },
    eachRawSeriesByType: function(subType, cb, context) {
      return each(this.getSeriesByType(subType), cb, context);
    },
    isSeriesFiltered: function(seriesModel) {
      assertSeriesInitialized(this);
      return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;
    },
    filterSeries: function(cb, context) {
      assertSeriesInitialized(this);
      var filteredSeries = filter(this._componentsMap.series, cb, context);
      this._seriesIndices = createSeriesIndices(filteredSeries);
    },
    restoreData: function() {
      var componentsMap = this._componentsMap;
      this._seriesIndices = createSeriesIndices(componentsMap.series);
      var componentTypes = [];
      each(componentsMap, function(components, componentType) {
        componentTypes.push(componentType);
      });
      ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function(componentType, dependencies) {
        each(componentsMap[componentType], function(component) {
          component.restoreData();
        });
      });
    }
  });
  function mergeTheme(option, theme) {
    for (var name in theme) {
      if (!ComponentModel.hasClass(name)) {
        if (typeof theme[name] === 'object') {
          option[name] = !option[name] ? zrUtil.clone(theme[name]) : zrUtil.merge(option[name], theme[name], false);
        } else {
          if (option[name] == null) {
            option[name] = theme[name];
          }
        }
      }
    }
  }
  function initBase(baseOption) {
    baseOption = baseOption;
    this.option = {};
    this.option[OPTION_INNER_KEY] = 1;
    this._componentsMap = {};
    this._seriesIndices = null;
    mergeTheme(baseOption, this._theme.option);
    zrUtil.merge(baseOption, globalDefault, false);
    this.mergeOption(baseOption);
  }
  function getComponentsByTypes(componentsMap, types) {
    if (!zrUtil.isArray(types)) {
      types = types ? [types] : [];
    }
    var ret = {};
    each(types, function(type) {
      ret[type] = (componentsMap[type] || []).slice();
    });
    return ret;
  }
  function makeKeyInfo(mainType, mapResult) {
    var idMap = {};
    each(mapResult, function(item, index) {
      var existCpt = item.exist;
      existCpt && (idMap[existCpt.id] = item);
    });
    each(mapResult, function(item, index) {
      var opt = item.option;
      zrUtil.assert(!opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item, 'id duplicates: ' + (opt && opt.id));
      opt && opt.id != null && (idMap[opt.id] = item);
      if (isObject(opt)) {
        var subType = determineSubType(mainType, opt, item.exist);
        item.keyInfo = {
          mainType: mainType,
          subType: subType
        };
      }
    });
    each(mapResult, function(item, index) {
      var existCpt = item.exist;
      var opt = item.option;
      var keyInfo = item.keyInfo;
      if (!isObject(opt)) {
        return;
      }
      keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\0-';
      if (existCpt) {
        keyInfo.id = existCpt.id;
      } else if (opt.id != null) {
        keyInfo.id = opt.id + '';
      } else {
        var idNum = 0;
        do {
          keyInfo.id = '\0' + keyInfo.name + '\0' + idNum++;
        } while (idMap[keyInfo.id]);
      }
      idMap[keyInfo.id] = item;
    });
  }
  function determineSubType(mainType, newCptOption, existComponent) {
    var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel.determineSubType(mainType, newCptOption);
    return subType;
  }
  function createSeriesIndices(seriesModels) {
    return map(seriesModels, function(series) {
      return series.componentIndex;
    }) || [];
  }
  function filterBySubType(components, condition) {
    return condition.hasOwnProperty('subType') ? filter(components, function(cpt) {
      return cpt.subType === condition.subType;
    }) : components;
  }
  function assertSeriesInitialized(ecModel) {
    if (__DEV__) {
      if (!ecModel._seriesIndices) {
        throw new Error('Series has not been initialized yet.');
      }
    }
  }
  zrUtil.mixin(GlobalModel, $__require('./mixin/colorPalette'));
  module.exports = GlobalModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/ExtensionAPI.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var echartsAPIList = ['getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'];
  function ExtensionAPI(chartInstance) {
    zrUtil.each(echartsAPIList, function(name) {
      this[name] = zrUtil.bind(chartInstance[name], chartInstance);
    }, this);
  }
  module.exports = ExtensionAPI;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/CoordinateSystem.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var coordinateSystemCreators = {};
  function CoordinateSystemManager() {
    this._coordinateSystems = [];
  }
  CoordinateSystemManager.prototype = {
    constructor: CoordinateSystemManager,
    create: function(ecModel, api) {
      var coordinateSystems = [];
      for (var type in coordinateSystemCreators) {
        var list = coordinateSystemCreators[type].create(ecModel, api);
        list && (coordinateSystems = coordinateSystems.concat(list));
      }
      this._coordinateSystems = coordinateSystems;
    },
    update: function(ecModel, api) {
      var coordinateSystems = this._coordinateSystems;
      for (var i = 0; i < coordinateSystems.length; i++) {
        coordinateSystems[i].update && coordinateSystems[i].update(ecModel, api);
      }
    }
  };
  CoordinateSystemManager.register = function(type, coordinateSystemCreator) {
    coordinateSystemCreators[type] = coordinateSystemCreator;
  };
  CoordinateSystemManager.get = function(type) {
    return coordinateSystemCreators[type];
  };
  module.exports = CoordinateSystemManager;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/model/OptionManager.js", ["zrender/lib/core/util", "../util/model", "./Component", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var modelUtil = $__require('../util/model');
  var ComponentModel = $__require('./Component');
  var each = zrUtil.each;
  var clone = zrUtil.clone;
  var map = zrUtil.map;
  var merge = zrUtil.merge;
  var QUERY_REG = /^(min|max)?(.+)$/;
  function OptionManager(api) {
    this._api = api;
    this._timelineOptions = [];
    this._mediaList = [];
    this._mediaDefault;
    this._currentMediaIndices = [];
    this._optionBackup;
    this._newBaseOption;
  }
  OptionManager.prototype = {
    constructor: OptionManager,
    setOption: function(rawOption, optionPreprocessorFuncs) {
      rawOption = clone(rawOption, true);
      var oldOptionBackup = this._optionBackup;
      var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);
      this._newBaseOption = newParsedOption.baseOption;
      if (oldOptionBackup) {
        mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);
        if (newParsedOption.timelineOptions.length) {
          oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;
        }
        if (newParsedOption.mediaList.length) {
          oldOptionBackup.mediaList = newParsedOption.mediaList;
        }
        if (newParsedOption.mediaDefault) {
          oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;
        }
      } else {
        this._optionBackup = newParsedOption;
      }
    },
    mountOption: function(isRecreate) {
      var optionBackup = this._optionBackup;
      this._timelineOptions = map(optionBackup.timelineOptions, clone);
      this._mediaList = map(optionBackup.mediaList, clone);
      this._mediaDefault = clone(optionBackup.mediaDefault);
      this._currentMediaIndices = [];
      return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);
    },
    getTimelineOption: function(ecModel) {
      var option;
      var timelineOptions = this._timelineOptions;
      if (timelineOptions.length) {
        var timelineModel = ecModel.getComponent('timeline');
        if (timelineModel) {
          option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);
        }
      }
      return option;
    },
    getMediaOption: function(ecModel) {
      var ecWidth = this._api.getWidth();
      var ecHeight = this._api.getHeight();
      var mediaList = this._mediaList;
      var mediaDefault = this._mediaDefault;
      var indices = [];
      var result = [];
      if (!mediaList.length && !mediaDefault) {
        return result;
      }
      for (var i = 0,
          len = mediaList.length; i < len; i++) {
        if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
          indices.push(i);
        }
      }
      if (!indices.length && mediaDefault) {
        indices = [-1];
      }
      if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
        result = map(indices, function(index) {
          return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
        });
      }
      this._currentMediaIndices = indices;
      return result;
    }
  };
  function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
    var timelineOptions = [];
    var mediaList = [];
    var mediaDefault;
    var baseOption;
    var timelineOpt = rawOption.timeline;
    if (rawOption.baseOption) {
      baseOption = rawOption.baseOption;
    }
    if (timelineOpt || rawOption.options) {
      baseOption = baseOption || {};
      timelineOptions = (rawOption.options || []).slice();
    }
    if (rawOption.media) {
      baseOption = baseOption || {};
      var media = rawOption.media;
      each(media, function(singleMedia) {
        if (singleMedia && singleMedia.option) {
          if (singleMedia.query) {
            mediaList.push(singleMedia);
          } else if (!mediaDefault) {
            mediaDefault = singleMedia;
          }
        }
      });
    }
    if (!baseOption) {
      baseOption = rawOption;
    }
    if (!baseOption.timeline) {
      baseOption.timeline = timelineOpt;
    }
    each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function(media) {
      return media.option;
    })), function(option) {
      each(optionPreprocessorFuncs, function(preProcess) {
        preProcess(option, isNew);
      });
    });
    return {
      baseOption: baseOption,
      timelineOptions: timelineOptions,
      mediaDefault: mediaDefault,
      mediaList: mediaList
    };
  }
  function applyMediaQuery(query, ecWidth, ecHeight) {
    var realMap = {
      width: ecWidth,
      height: ecHeight,
      aspectratio: ecWidth / ecHeight
    };
    var applicatable = true;
    zrUtil.each(query, function(value, attr) {
      var matched = attr.match(QUERY_REG);
      if (!matched || !matched[1] || !matched[2]) {
        return;
      }
      var operator = matched[1];
      var realAttr = matched[2].toLowerCase();
      if (!compare(realMap[realAttr], value, operator)) {
        applicatable = false;
      }
    });
    return applicatable;
  }
  function compare(real, expect, operator) {
    if (operator === 'min') {
      return real >= expect;
    } else if (operator === 'max') {
      return real <= expect;
    } else {
      return real === expect;
    }
  }
  function indicesEquals(indices1, indices2) {
    return indices1.join(',') === indices2.join(',');
  }
  function mergeOption(oldOption, newOption) {
    newOption = newOption || {};
    each(newOption, function(newCptOpt, mainType) {
      if (newCptOpt == null) {
        return;
      }
      var oldCptOpt = oldOption[mainType];
      if (!ComponentModel.hasClass(mainType)) {
        oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);
      } else {
        newCptOpt = modelUtil.normalizeToArray(newCptOpt);
        oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);
        var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);
        oldOption[mainType] = map(mapResult, function(item) {
          return (item.option && item.exist) ? merge(item.exist, item.option, true) : (item.exist || item.option);
        });
      }
    });
  }
  module.exports = OptionManager;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/util/layout.js", ["zrender/lib/core/util", "zrender/lib/core/BoundingRect", "./number", "./format", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var BoundingRect = $__require('zrender/lib/core/BoundingRect');
  var numberUtil = $__require('./number');
  var formatUtil = $__require('./format');
  var parsePercent = numberUtil.parsePercent;
  var each = zrUtil.each;
  var layout = {};
  var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];
  function boxLayout(orient, group, gap, maxWidth, maxHeight) {
    var x = 0;
    var y = 0;
    if (maxWidth == null) {
      maxWidth = Infinity;
    }
    if (maxHeight == null) {
      maxHeight = Infinity;
    }
    var currentLineMaxSize = 0;
    group.eachChild(function(child, idx) {
      var position = child.position;
      var rect = child.getBoundingRect();
      var nextChild = group.childAt(idx + 1);
      var nextChildRect = nextChild && nextChild.getBoundingRect();
      var nextX;
      var nextY;
      if (orient === 'horizontal') {
        var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);
        nextX = x + moveX;
        if (nextX > maxWidth || child.newline) {
          x = 0;
          nextX = moveX;
          y += currentLineMaxSize + gap;
          currentLineMaxSize = rect.height;
        } else {
          currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
        }
      } else {
        var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);
        nextY = y + moveY;
        if (nextY > maxHeight || child.newline) {
          x += currentLineMaxSize + gap;
          y = 0;
          nextY = moveY;
          currentLineMaxSize = rect.width;
        } else {
          currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
        }
      }
      if (child.newline) {
        return;
      }
      position[0] = x;
      position[1] = y;
      orient === 'horizontal' ? (x = nextX + gap) : (y = nextY + gap);
    });
  }
  layout.box = boxLayout;
  layout.vbox = zrUtil.curry(boxLayout, 'vertical');
  layout.hbox = zrUtil.curry(boxLayout, 'horizontal');
  layout.getAvailableSize = function(positionInfo, containerRect, margin) {
    var containerWidth = containerRect.width;
    var containerHeight = containerRect.height;
    var x = parsePercent(positionInfo.x, containerWidth);
    var y = parsePercent(positionInfo.y, containerHeight);
    var x2 = parsePercent(positionInfo.x2, containerWidth);
    var y2 = parsePercent(positionInfo.y2, containerHeight);
    (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);
    (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);
    (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);
    (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);
    margin = formatUtil.normalizeCssArray(margin || 0);
    return {
      width: Math.max(x2 - x - margin[1] - margin[3], 0),
      height: Math.max(y2 - y - margin[0] - margin[2], 0)
    };
  };
  layout.getLayoutRect = function(positionInfo, containerRect, margin) {
    margin = formatUtil.normalizeCssArray(margin || 0);
    var containerWidth = containerRect.width;
    var containerHeight = containerRect.height;
    var left = parsePercent(positionInfo.left, containerWidth);
    var top = parsePercent(positionInfo.top, containerHeight);
    var right = parsePercent(positionInfo.right, containerWidth);
    var bottom = parsePercent(positionInfo.bottom, containerHeight);
    var width = parsePercent(positionInfo.width, containerWidth);
    var height = parsePercent(positionInfo.height, containerHeight);
    var verticalMargin = margin[2] + margin[0];
    var horizontalMargin = margin[1] + margin[3];
    var aspect = positionInfo.aspect;
    if (isNaN(width)) {
      width = containerWidth - right - horizontalMargin - left;
    }
    if (isNaN(height)) {
      height = containerHeight - bottom - verticalMargin - top;
    }
    if (isNaN(width) && isNaN(height)) {
      if (aspect > containerWidth / containerHeight) {
        width = containerWidth * 0.8;
      } else {
        height = containerHeight * 0.8;
      }
    }
    if (aspect != null) {
      if (isNaN(width)) {
        width = aspect * height;
      }
      if (isNaN(height)) {
        height = width / aspect;
      }
    }
    if (isNaN(left)) {
      left = containerWidth - right - width - horizontalMargin;
    }
    if (isNaN(top)) {
      top = containerHeight - bottom - height - verticalMargin;
    }
    switch (positionInfo.left || positionInfo.right) {
      case 'center':
        left = containerWidth / 2 - width / 2 - margin[3];
        break;
      case 'right':
        left = containerWidth - width - horizontalMargin;
        break;
    }
    switch (positionInfo.top || positionInfo.bottom) {
      case 'middle':
      case 'center':
        top = containerHeight / 2 - height / 2 - margin[0];
        break;
      case 'bottom':
        top = containerHeight - height - verticalMargin;
        break;
    }
    left = left || 0;
    top = top || 0;
    if (isNaN(width)) {
      width = containerWidth - left - (right || 0);
    }
    if (isNaN(height)) {
      height = containerHeight - top - (bottom || 0);
    }
    var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
    rect.margin = margin;
    return rect;
  };
  layout.positionGroup = function(group, positionInfo, containerRect, margin) {
    var groupRect = group.getBoundingRect();
    positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {
      width: groupRect.width,
      height: groupRect.height
    });
    positionInfo = layout.getLayoutRect(positionInfo, containerRect, margin);
    group.attr('position', [positionInfo.x - groupRect.x, positionInfo.y - groupRect.y]);
  };
  layout.mergeLayoutParam = function(targetOption, newOption, opt) {
    !zrUtil.isObject(opt) && (opt = {});
    var hNames = ['width', 'left', 'right'];
    var vNames = ['height', 'top', 'bottom'];
    var hResult = merge(hNames);
    var vResult = merge(vNames);
    copy(hNames, targetOption, hResult);
    copy(vNames, targetOption, vResult);
    function merge(names) {
      var newParams = {};
      var newValueCount = 0;
      var merged = {};
      var mergedValueCount = 0;
      var enoughParamNumber = opt.ignoreSize ? 1 : 2;
      each(names, function(name) {
        merged[name] = targetOption[name];
      });
      each(names, function(name) {
        hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
        hasValue(newParams, name) && newValueCount++;
        hasValue(merged, name) && mergedValueCount++;
      });
      if (mergedValueCount === enoughParamNumber || !newValueCount) {
        return merged;
      } else if (newValueCount >= enoughParamNumber) {
        return newParams;
      } else {
        for (var i = 0; i < names.length; i++) {
          var name = names[i];
          if (!hasProp(newParams, name) && hasProp(targetOption, name)) {
            newParams[name] = targetOption[name];
            break;
          }
        }
        return newParams;
      }
    }
    function hasProp(obj, name) {
      return obj.hasOwnProperty(name);
    }
    function hasValue(obj, name) {
      return obj[name] != null && obj[name] !== 'auto';
    }
    function copy(names, target, source) {
      each(names, function(name) {
        target[name] = source[name];
      });
    }
  };
  layout.getLayoutParams = function(source) {
    return layout.copyLayoutParams({}, source);
  };
  layout.copyLayoutParams = function(target, source) {
    source && target && each(LOCATION_PARAMS, function(name) {
      source.hasOwnProperty(name) && (target[name] = source[name]);
    });
    return target;
  };
  module.exports = layout;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/model/mixin/boxLayout.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {getBoxLayoutParams: function() {
      return {
        left: this.get('left'),
        top: this.get('top'),
        right: this.get('right'),
        bottom: this.get('bottom'),
        width: this.get('width'),
        height: this.get('height')
      };
    }};
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/model/Component.js", ["./Model", "zrender/lib/core/util", "../util/component", "../util/clazz", "../util/layout", "./mixin/boxLayout", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var Model = $__require('./Model');
  var zrUtil = $__require('zrender/lib/core/util');
  var arrayPush = Array.prototype.push;
  var componentUtil = $__require('../util/component');
  var clazzUtil = $__require('../util/clazz');
  var layout = $__require('../util/layout');
  var ComponentModel = Model.extend({
    type: 'component',
    id: '',
    name: '',
    mainType: '',
    subType: '',
    componentIndex: 0,
    defaultOption: null,
    ecModel: null,
    dependentModels: [],
    uid: null,
    layoutMode: null,
    $constructor: function(option, parentModel, ecModel, extraOpt) {
      Model.call(this, option, parentModel, ecModel, extraOpt);
      zrUtil.extend(this, extraOpt);
      this.uid = componentUtil.getUID('componentModel');
    },
    init: function(option, parentModel, ecModel, extraOpt) {
      this.mergeDefaultAndTheme(option, ecModel);
    },
    mergeDefaultAndTheme: function(option, ecModel) {
      var layoutMode = this.layoutMode;
      var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};
      var themeModel = ecModel.getTheme();
      zrUtil.merge(option, themeModel.get(this.mainType));
      zrUtil.merge(option, this.getDefaultOption());
      if (layoutMode) {
        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
      }
    },
    mergeOption: function(option) {
      zrUtil.merge(this.option, option, true);
      var layoutMode = this.layoutMode;
      if (layoutMode) {
        layout.mergeLayoutParam(this.option, option, layoutMode);
      }
    },
    optionUpdated: function(newCptOption, isInit) {},
    getDefaultOption: function() {
      if (!this.hasOwnProperty('__defaultOption')) {
        var optList = [];
        var Class = this.constructor;
        while (Class) {
          var opt = Class.prototype.defaultOption;
          opt && optList.push(opt);
          Class = Class.superClass;
        }
        var defaultOption = {};
        for (var i = optList.length - 1; i >= 0; i--) {
          defaultOption = zrUtil.merge(defaultOption, optList[i], true);
        }
        this.__defaultOption = defaultOption;
      }
      return this.__defaultOption;
    }
  });
  clazzUtil.enableClassManagement(ComponentModel, {registerWhenExtend: true});
  componentUtil.enableSubTypeDefaulter(ComponentModel);
  componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);
  function getDependencies(componentType) {
    var deps = [];
    zrUtil.each(ComponentModel.getClassesByMainType(componentType), function(Clazz) {
      arrayPush.apply(deps, Clazz.prototype.dependencies || []);
    });
    return zrUtil.map(deps, function(type) {
      return clazzUtil.parseClassType(type).main;
    });
  }
  zrUtil.mixin(ComponentModel, $__require('./mixin/boxLayout'));
  module.exports = ComponentModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/model/mixin/colorPalette.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {
    clearColorPalette: function() {
      this._colorIdx = 0;
      this._colorNameMap = {};
    },
    getColorFromPalette: function(name, scope) {
      scope = scope || this;
      var colorIdx = scope._colorIdx || 0;
      var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});
      if (colorNameMap[name]) {
        return colorNameMap[name];
      }
      var colorPalette = this.get('color', true) || [];
      if (!colorPalette.length) {
        return;
      }
      var color = colorPalette[colorIdx];
      if (name) {
        colorNameMap[name] = color;
      }
      scope._colorIdx = (colorIdx + 1) % colorPalette.length;
      return color;
    }
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/model/Series.js", ["zrender/lib/core/util", "../util/format", "../util/model", "./Component", "./mixin/colorPalette", "zrender/lib/core/env", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var formatUtil = $__require('../util/format');
  var modelUtil = $__require('../util/model');
  var ComponentModel = $__require('./Component');
  var colorPaletteMixin = $__require('./mixin/colorPalette');
  var env = $__require('zrender/lib/core/env');
  var encodeHTML = formatUtil.encodeHTML;
  var addCommas = formatUtil.addCommas;
  var SeriesModel = ComponentModel.extend({
    type: 'series.__base__',
    seriesIndex: 0,
    coordinateSystem: null,
    defaultOption: null,
    legendDataProvider: null,
    visualColorAccessPath: 'itemStyle.normal.color',
    init: function(option, parentModel, ecModel, extraOpt) {
      this.seriesIndex = this.componentIndex;
      this.mergeDefaultAndTheme(option, ecModel);
      this._dataBeforeProcessed = this.getInitialData(option, ecModel);
      this._data = this._dataBeforeProcessed.cloneShallow();
    },
    mergeDefaultAndTheme: function(option, ecModel) {
      zrUtil.merge(option, ecModel.getTheme().get(this.subType));
      zrUtil.merge(option, this.getDefaultOption());
      modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);
      this.fillDataTextStyle(option.data);
    },
    mergeOption: function(newSeriesOption, ecModel) {
      newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);
      this.fillDataTextStyle(newSeriesOption.data);
      var data = this.getInitialData(newSeriesOption, ecModel);
      if (data) {
        this._data = data;
        this._dataBeforeProcessed = data.cloneShallow();
      }
    },
    fillDataTextStyle: function(data) {
      if (data) {
        for (var i = 0; i < data.length; i++) {
          if (data[i] && data[i].label) {
            modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);
          }
        }
      }
    },
    getInitialData: function() {},
    getData: function(dataType) {
      return dataType == null ? this._data : this._data.getLinkedData(dataType);
    },
    setData: function(data) {
      this._data = data;
    },
    getRawData: function() {
      return this._dataBeforeProcessed;
    },
    coordDimToDataDim: function(coordDim) {
      return [coordDim];
    },
    dataDimToCoordDim: function(dataDim) {
      return dataDim;
    },
    getBaseAxis: function() {
      var coordSys = this.coordinateSystem;
      return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
    },
    formatTooltip: function(dataIndex, multipleSeries, dataType) {
      function formatArrayValue(value) {
        return zrUtil.map(value, function(val, idx) {
          var dimInfo = data.getDimensionInfo(idx);
          var dimType = dimInfo && dimInfo.type;
          if (dimType === 'ordinal') {
            return val;
          } else if (dimType === 'time') {
            return multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);
          } else {
            return addCommas(val);
          }
        }).filter(function(val) {
          return !!val;
        }).join(', ');
      }
      var data = this._data;
      var value = this.getRawValue(dataIndex);
      var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value);
      var name = data.getName(dataIndex);
      var color = data.getItemVisual(dataIndex, 'color');
      var colorEl = '<span style="display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '"></span>';
      var seriesName = this.name;
      if (seriesName === '\0-') {
        seriesName = '';
      }
      return !multipleSeries ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl + (name ? encodeHTML(name) + ' : ' + formattedValue : formattedValue)) : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);
    },
    ifEnableAnimation: function() {
      if (env.node) {
        return false;
      }
      var animationEnabled = this.getShallow('animation');
      if (animationEnabled) {
        if (this.getData().count() > this.getShallow('animationThreshold')) {
          animationEnabled = false;
        }
      }
      return animationEnabled;
    },
    restoreData: function() {
      this._data = this._dataBeforeProcessed.cloneShallow();
    },
    getColorFromPalette: function(name, scope) {
      var ecModel = this.ecModel;
      var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);
      if (!color) {
        color = ecModel.getColorFromPalette(name, scope);
      }
      return color;
    },
    getAxisTooltipDataIndex: null
  });
  zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);
  zrUtil.mixin(SeriesModel, colorPaletteMixin);
  module.exports = SeriesModel;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/view/Component.js", ["zrender/lib/container/Group", "../util/component", "../util/clazz", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var Group = $__require('zrender/lib/container/Group');
  var componentUtil = $__require('../util/component');
  var clazzUtil = $__require('../util/clazz');
  var Component = function() {
    this.group = new Group();
    this.uid = componentUtil.getUID('viewComponent');
  };
  Component.prototype = {
    constructor: Component,
    init: function(ecModel, api) {},
    render: function(componentModel, ecModel, api, payload) {},
    dispose: function() {}
  };
  var componentProto = Component.prototype;
  componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function(seriesModel, ecModel, api, payload) {};
  clazzUtil.enableClassExtend(Component);
  clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});
  module.exports = Component;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/util/component.js", ["zrender/lib/core/util", "./clazz", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var clazz = $__require('./clazz');
  var parseClassType = clazz.parseClassType;
  var base = 0;
  var componentUtil = {};
  var DELIMITER = '_';
  componentUtil.getUID = function(type) {
    return [(type || ''), base++, Math.random()].join(DELIMITER);
  };
  componentUtil.enableSubTypeDefaulter = function(entity) {
    var subTypeDefaulters = {};
    entity.registerSubTypeDefaulter = function(componentType, defaulter) {
      componentType = parseClassType(componentType);
      subTypeDefaulters[componentType.main] = defaulter;
    };
    entity.determineSubType = function(componentType, option) {
      var type = option.type;
      if (!type) {
        var componentTypeMain = parseClassType(componentType).main;
        if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
          type = subTypeDefaulters[componentTypeMain](option);
        }
      }
      return type;
    };
    return entity;
  };
  componentUtil.enableTopologicalTravel = function(entity, dependencyGetter) {
    entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
      if (!targetNameList.length) {
        return;
      }
      var result = makeDepndencyGraph(fullNameList);
      var graph = result.graph;
      var stack = result.noEntryList;
      var targetNameSet = {};
      zrUtil.each(targetNameList, function(name) {
        targetNameSet[name] = true;
      });
      while (stack.length) {
        var currComponentType = stack.pop();
        var currVertex = graph[currComponentType];
        var isInTargetNameSet = !!targetNameSet[currComponentType];
        if (isInTargetNameSet) {
          callback.call(context, currComponentType, currVertex.originalDeps.slice());
          delete targetNameSet[currComponentType];
        }
        zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
      }
      zrUtil.each(targetNameSet, function() {
        throw new Error('Circle dependency may exists');
      });
      function removeEdge(succComponentType) {
        graph[succComponentType].entryCount--;
        if (graph[succComponentType].entryCount === 0) {
          stack.push(succComponentType);
        }
      }
      function removeEdgeAndAdd(succComponentType) {
        targetNameSet[succComponentType] = true;
        removeEdge(succComponentType);
      }
    };
    function makeDepndencyGraph(fullNameList) {
      var graph = {};
      var noEntryList = [];
      zrUtil.each(fullNameList, function(name) {
        var thisItem = createDependencyGraphItem(graph, name);
        var originalDeps = thisItem.originalDeps = dependencyGetter(name);
        var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
        thisItem.entryCount = availableDeps.length;
        if (thisItem.entryCount === 0) {
          noEntryList.push(name);
        }
        zrUtil.each(availableDeps, function(dependentName) {
          if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {
            thisItem.predecessor.push(dependentName);
          }
          var thatItem = createDependencyGraphItem(graph, dependentName);
          if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {
            thatItem.successor.push(name);
          }
        });
      });
      return {
        graph: graph,
        noEntryList: noEntryList
      };
    }
    function createDependencyGraphItem(graph, name) {
      if (!graph[name]) {
        graph[name] = {
          predecessor: [],
          successor: []
        };
      }
      return graph[name];
    }
    function getAvailableDependencies(originalDeps, fullNameList) {
      var availableDeps = [];
      zrUtil.each(originalDeps, function(dep) {
        zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
      });
      return availableDeps;
    }
  };
  module.exports = componentUtil;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/view/Chart.js", ["zrender/lib/container/Group", "../util/component", "../util/clazz", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var Group = $__require('zrender/lib/container/Group');
  var componentUtil = $__require('../util/component');
  var clazzUtil = $__require('../util/clazz');
  function Chart() {
    this.group = new Group();
    this.uid = componentUtil.getUID('viewChart');
  }
  Chart.prototype = {
    type: 'chart',
    init: function(ecModel, api) {},
    render: function(seriesModel, ecModel, api, payload) {},
    highlight: function(seriesModel, ecModel, api, payload) {
      toggleHighlight(seriesModel.getData(), payload, 'emphasis');
    },
    downplay: function(seriesModel, ecModel, api, payload) {
      toggleHighlight(seriesModel.getData(), payload, 'normal');
    },
    remove: function(ecModel, api) {
      this.group.removeAll();
    },
    dispose: function() {}
  };
  var chartProto = Chart.prototype;
  chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  function elSetState(el, state) {
    if (el) {
      el.trigger(state);
      if (el.type === 'group') {
        for (var i = 0; i < el.childCount(); i++) {
          elSetState(el.childAt(i), state);
        }
      }
    }
  }
  function toggleHighlight(data, payload, state) {
    var dataIndex = payload && payload.dataIndex;
    var name = payload && payload.name;
    if (dataIndex != null) {
      var dataIndices = dataIndex instanceof Array ? dataIndex : [dataIndex];
      for (var i = 0,
          len = dataIndices.length; i < len; i++) {
        elSetState(data.getItemGraphicEl(dataIndices[i]), state);
      }
    } else if (name) {
      var names = name instanceof Array ? name : [name];
      for (var i = 0,
          len = names.length; i < len; i++) {
        var dataIndex = data.indexOfName(names[i]);
        elSetState(data.getItemGraphicEl(dataIndex), state);
      }
    } else {
      data.eachItemGraphicEl(function(el) {
        elSetState(el, state);
      });
    }
  }
  clazzUtil.enableClassExtend(Chart);
  clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});
  module.exports = Chart;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/tool/transformPath.js", ["../core/PathProxy", "../core/vector"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var CMD = $__require('../core/PathProxy').CMD;
  var vec2 = $__require('../core/vector');
  var v2ApplyTransform = vec2.applyTransform;
  var points = [[], [], []];
  var mathSqrt = Math.sqrt;
  var mathAtan2 = Math.atan2;
  function transformPath(path, m) {
    var data = path.data;
    var cmd;
    var nPoint;
    var i;
    var j;
    var k;
    var p;
    var M = CMD.M;
    var C = CMD.C;
    var L = CMD.L;
    var R = CMD.R;
    var A = CMD.A;
    var Q = CMD.Q;
    for (i = 0, j = 0; i < data.length; ) {
      cmd = data[i++];
      j = i;
      nPoint = 0;
      switch (cmd) {
        case M:
          nPoint = 1;
          break;
        case L:
          nPoint = 1;
          break;
        case C:
          nPoint = 3;
          break;
        case Q:
          nPoint = 2;
          break;
        case A:
          var x = m[4];
          var y = m[5];
          var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
          var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
          var angle = mathAtan2(-m[1] / sy, m[0] / sx);
          data[i++] += x;
          data[i++] += y;
          data[i++] *= sx;
          data[i++] *= sy;
          data[i++] += angle;
          data[i++] += angle;
          i += 2;
          j = i;
          break;
        case R:
          p[0] = data[i++];
          p[1] = data[i++];
          v2ApplyTransform(p, p, m);
          data[j++] = p[0];
          data[j++] = p[1];
          p[0] += data[i++];
          p[1] += data[i++];
          v2ApplyTransform(p, p, m);
          data[j++] = p[0];
          data[j++] = p[1];
      }
      for (k = 0; k < nPoint; k++) {
        var p = points[k];
        p[0] = data[i++];
        p[1] = data[i++];
        v2ApplyTransform(p, p, m);
        data[j++] = p[0];
        data[j++] = p[1];
      }
    }
  }
  module.exports = transformPath;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/tool/path.js", ["../graphic/Path", "../core/PathProxy", "./transformPath", "../core/matrix"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Path = $__require('../graphic/Path');
  var PathProxy = $__require('../core/PathProxy');
  var transformPath = $__require('./transformPath');
  var matrix = $__require('../core/matrix');
  var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
  var mathSqrt = Math.sqrt;
  var mathSin = Math.sin;
  var mathCos = Math.cos;
  var PI = Math.PI;
  var vMag = function(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  };
  var vRatio = function(u, v) {
    return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
  };
  var vAngle = function(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
  };
  function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
    var psi = psiDeg * (PI / 180.0);
    var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;
    var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;
    var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
    if (lambda > 1) {
      rx *= mathSqrt(lambda);
      ry *= mathSqrt(lambda);
    }
    var f = (fa === fs ? -1 : 1) * mathSqrt((((rx * rx) * (ry * ry)) - ((rx * rx) * (yp * yp)) - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp) + (ry * ry) * (xp * xp))) || 0;
    var cxp = f * rx * yp / ry;
    var cyp = f * -ry * xp / rx;
    var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;
    var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;
    var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
      dTheta = PI;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (fs === 0 && dTheta > 0) {
      dTheta = dTheta - 2 * PI;
    }
    if (fs === 1 && dTheta < 0) {
      dTheta = dTheta + 2 * PI;
    }
    path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
  }
  function createPathProxyFromString(data) {
    if (!data) {
      return [];
    }
    var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');
    var n;
    for (n = 0; n < cc.length; n++) {
      cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
    }
    var arr = cs.split('|');
    var cpx = 0;
    var cpy = 0;
    var path = new PathProxy();
    var CMD = PathProxy.CMD;
    var prevCmd;
    for (n = 1; n < arr.length; n++) {
      var str = arr[n];
      var c = str.charAt(0);
      var off = 0;
      var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
      var cmd;
      if (p.length > 0 && p[0] === '') {
        p.shift();
      }
      for (var i = 0; i < p.length; i++) {
        p[i] = parseFloat(p[i]);
      }
      while (off < p.length && !isNaN(p[off])) {
        if (isNaN(p[0])) {
          break;
        }
        var ctlPtx;
        var ctlPty;
        var rx;
        var ry;
        var psi;
        var fa;
        var fs;
        var x1 = cpx;
        var y1 = cpy;
        switch (c) {
          case 'l':
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD.L;
            path.addData(cmd, cpx, cpy);
            break;
          case 'L':
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD.L;
            path.addData(cmd, cpx, cpy);
            break;
          case 'm':
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD.M;
            path.addData(cmd, cpx, cpy);
            c = 'l';
            break;
          case 'M':
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD.M;
            path.addData(cmd, cpx, cpy);
            c = 'L';
            break;
          case 'h':
            cpx += p[off++];
            cmd = CMD.L;
            path.addData(cmd, cpx, cpy);
            break;
          case 'H':
            cpx = p[off++];
            cmd = CMD.L;
            path.addData(cmd, cpx, cpy);
            break;
          case 'v':
            cpy += p[off++];
            cmd = CMD.L;
            path.addData(cmd, cpx, cpy);
            break;
          case 'V':
            cpy = p[off++];
            cmd = CMD.L;
            path.addData(cmd, cpx, cpy);
            break;
          case 'C':
            cmd = CMD.C;
            path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
            cpx = p[off - 2];
            cpy = p[off - 1];
            break;
          case 'c':
            cmd = CMD.C;
            path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
            cpx += p[off - 2];
            cpy += p[off - 1];
            break;
          case 'S':
            ctlPtx = cpx;
            ctlPty = cpy;
            var len = path.len();
            var pathData = path.data;
            if (prevCmd === CMD.C) {
              ctlPtx += cpx - pathData[len - 4];
              ctlPty += cpy - pathData[len - 3];
            }
            cmd = CMD.C;
            x1 = p[off++];
            y1 = p[off++];
            cpx = p[off++];
            cpy = p[off++];
            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
            break;
          case 's':
            ctlPtx = cpx;
            ctlPty = cpy;
            var len = path.len();
            var pathData = path.data;
            if (prevCmd === CMD.C) {
              ctlPtx += cpx - pathData[len - 4];
              ctlPty += cpy - pathData[len - 3];
            }
            cmd = CMD.C;
            x1 = cpx + p[off++];
            y1 = cpy + p[off++];
            cpx += p[off++];
            cpy += p[off++];
            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
            break;
          case 'Q':
            x1 = p[off++];
            y1 = p[off++];
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD.Q;
            path.addData(cmd, x1, y1, cpx, cpy);
            break;
          case 'q':
            x1 = p[off++] + cpx;
            y1 = p[off++] + cpy;
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD.Q;
            path.addData(cmd, x1, y1, cpx, cpy);
            break;
          case 'T':
            ctlPtx = cpx;
            ctlPty = cpy;
            var len = path.len();
            var pathData = path.data;
            if (prevCmd === CMD.Q) {
              ctlPtx += cpx - pathData[len - 4];
              ctlPty += cpy - pathData[len - 3];
            }
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD.Q;
            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
            break;
          case 't':
            ctlPtx = cpx;
            ctlPty = cpy;
            var len = path.len();
            var pathData = path.data;
            if (prevCmd === CMD.Q) {
              ctlPtx += cpx - pathData[len - 4];
              ctlPty += cpy - pathData[len - 3];
            }
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD.Q;
            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
            break;
          case 'A':
            rx = p[off++];
            ry = p[off++];
            psi = p[off++];
            fa = p[off++];
            fs = p[off++];
            x1 = cpx, y1 = cpy;
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD.A;
            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
            break;
          case 'a':
            rx = p[off++];
            ry = p[off++];
            psi = p[off++];
            fa = p[off++];
            fs = p[off++];
            x1 = cpx, y1 = cpy;
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD.A;
            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
            break;
        }
      }
      if (c === 'z' || c === 'Z') {
        cmd = CMD.Z;
        path.addData(cmd);
      }
      prevCmd = cmd;
    }
    path.toStatic();
    return path;
  }
  function createPathOptions(str, opts) {
    var pathProxy = createPathProxyFromString(str);
    var transform;
    opts = opts || {};
    opts.buildPath = function(path) {
      path.setData(pathProxy.data);
      transform && transformPath(path, transform);
      var ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx);
      }
    };
    opts.applyTransform = function(m) {
      if (!transform) {
        transform = matrix.create();
      }
      matrix.mul(transform, m, transform);
    };
    return opts;
  }
  module.exports = {
    createFromString: function(str, opts) {
      return new Path(createPathOptions(str, opts));
    },
    extendFromString: function(str, opts) {
      return Path.extend(createPathOptions(str, opts));
    },
    mergePath: function(pathEls, opts) {
      var pathList = [];
      var len = pathEls.length;
      for (var i = 0; i < len; i++) {
        var pathEl = pathEls[i];
        if (pathEl.__dirty) {
          pathEl.buildPath(pathEl.path, pathEl.shape, true);
        }
        pathList.push(pathEl.path);
      }
      var pathBundle = new Path(opts);
      pathBundle.buildPath = function(path) {
        path.appendPath(pathList);
        var ctx = path.getContext();
        if (ctx) {
          path.rebuildPath(ctx);
        }
      };
      return pathBundle;
    }
  };
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/shape/Circle.js", ["../Path"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('../Path').extend({
    type: 'circle',
    shape: {
      cx: 0,
      cy: 0,
      r: 0
    },
    buildPath: function(ctx, shape, inBundle) {
      if (inBundle) {
        ctx.moveTo(shape.cx + shape.r, shape.cy);
      }
      ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/shape/Sector.js", ["../Path"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('../Path').extend({
    type: 'sector',
    shape: {
      cx: 0,
      cy: 0,
      r0: 0,
      r: 0,
      startAngle: 0,
      endAngle: Math.PI * 2,
      clockwise: true
    },
    buildPath: function(ctx, shape) {
      var x = shape.cx;
      var y = shape.cy;
      var r0 = Math.max(shape.r0 || 0, 0);
      var r = Math.max(shape.r, 0);
      var startAngle = shape.startAngle;
      var endAngle = shape.endAngle;
      var clockwise = shape.clockwise;
      var unitX = Math.cos(startAngle);
      var unitY = Math.sin(startAngle);
      ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
      ctx.lineTo(unitX * r + x, unitY * r + y);
      ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
      ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);
      if (r0 !== 0) {
        ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
      }
      ctx.closePath();
    }
  });
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/shape/Ring.js", ["../Path"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('../Path').extend({
    type: 'ring',
    shape: {
      cx: 0,
      cy: 0,
      r: 0,
      r0: 0
    },
    buildPath: function(ctx, shape) {
      var x = shape.cx;
      var y = shape.cy;
      var PI2 = Math.PI * 2;
      ctx.moveTo(x + shape.r, y);
      ctx.arc(x, y, shape.r, 0, PI2, false);
      ctx.moveTo(x + shape.r0, y);
      ctx.arc(x, y, shape.r0, 0, PI2, true);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/shape/Polygon.js", ["../helper/poly", "../Path"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var polyHelper = $__require('../helper/poly');
  module.exports = $__require('../Path').extend({
    type: 'polygon',
    shape: {
      points: null,
      smooth: false,
      smoothConstraint: null
    },
    buildPath: function(ctx, shape) {
      polyHelper.buildPath(ctx, shape, true);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/helper/smoothSpline.js", ["../../core/vector"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var vec2 = $__require('../../core/vector');
  function interpolate(p0, p1, p2, p3, t, t2, t3) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
  module.exports = function(points, isLoop) {
    var len = points.length;
    var ret = [];
    var distance = 0;
    for (var i = 1; i < len; i++) {
      distance += vec2.distance(points[i - 1], points[i]);
    }
    var segs = distance / 2;
    segs = segs < len ? len : segs;
    for (var i = 0; i < segs; i++) {
      var pos = i / (segs - 1) * (isLoop ? len : len - 1);
      var idx = Math.floor(pos);
      var w = pos - idx;
      var p0;
      var p1 = points[idx % len];
      var p2;
      var p3;
      if (!isLoop) {
        p0 = points[idx === 0 ? idx : idx - 1];
        p2 = points[idx > len - 2 ? len - 1 : idx + 1];
        p3 = points[idx > len - 3 ? len - 1 : idx + 2];
      } else {
        p0 = points[(idx - 1 + len) % len];
        p2 = points[(idx + 1) % len];
        p3 = points[(idx + 2) % len];
      }
      var w2 = w * w;
      var w3 = w * w2;
      ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
    }
    return ret;
  };
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/helper/smoothBezier.js", ["../../core/vector"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var vec2 = $__require('../../core/vector');
  var v2Min = vec2.min;
  var v2Max = vec2.max;
  var v2Scale = vec2.scale;
  var v2Distance = vec2.distance;
  var v2Add = vec2.add;
  module.exports = function(points, smooth, isLoop, constraint) {
    var cps = [];
    var v = [];
    var v1 = [];
    var v2 = [];
    var prevPoint;
    var nextPoint;
    var min,
        max;
    if (constraint) {
      min = [Infinity, Infinity];
      max = [-Infinity, -Infinity];
      for (var i = 0,
          len = points.length; i < len; i++) {
        v2Min(min, min, points[i]);
        v2Max(max, max, points[i]);
      }
      v2Min(min, min, constraint[0]);
      v2Max(max, max, constraint[1]);
    }
    for (var i = 0,
        len = points.length; i < len; i++) {
      var point = points[i];
      if (isLoop) {
        prevPoint = points[i ? i - 1 : len - 1];
        nextPoint = points[(i + 1) % len];
      } else {
        if (i === 0 || i === len - 1) {
          cps.push(vec2.clone(points[i]));
          continue;
        } else {
          prevPoint = points[i - 1];
          nextPoint = points[i + 1];
        }
      }
      vec2.sub(v, nextPoint, prevPoint);
      v2Scale(v, v, smooth);
      var d0 = v2Distance(point, prevPoint);
      var d1 = v2Distance(point, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      v2Scale(v1, v, -d0);
      v2Scale(v2, v, d1);
      var cp0 = v2Add([], point, v1);
      var cp1 = v2Add([], point, v2);
      if (constraint) {
        v2Max(cp0, cp0, min);
        v2Min(cp0, cp0, max);
        v2Max(cp1, cp1, min);
        v2Min(cp1, cp1, max);
      }
      cps.push(cp0);
      cps.push(cp1);
    }
    if (isLoop) {
      cps.push(cps.shift());
    }
    return cps;
  };
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/helper/poly.js", ["./smoothSpline", "./smoothBezier"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var smoothSpline = $__require('./smoothSpline');
  var smoothBezier = $__require('./smoothBezier');
  module.exports = {buildPath: function(ctx, shape, closePath) {
      var points = shape.points;
      var smooth = shape.smooth;
      if (points && points.length >= 2) {
        if (smooth && smooth !== 'spline') {
          var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
          ctx.moveTo(points[0][0], points[0][1]);
          var len = points.length;
          for (var i = 0; i < (closePath ? len : len - 1); i++) {
            var cp1 = controlPoints[i * 2];
            var cp2 = controlPoints[i * 2 + 1];
            var p = points[(i + 1) % len];
            ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
          }
        } else {
          if (smooth === 'spline') {
            points = smoothSpline(points, closePath);
          }
          ctx.moveTo(points[0][0], points[0][1]);
          for (var i = 1,
              l = points.length; i < l; i++) {
            ctx.lineTo(points[i][0], points[i][1]);
          }
        }
        closePath && ctx.closePath();
      }
    }};
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/shape/Polyline.js", ["../helper/poly", "../Path"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var polyHelper = $__require('../helper/poly');
  module.exports = $__require('../Path').extend({
    type: 'polyline',
    shape: {
      points: null,
      smooth: false,
      smoothConstraint: null
    },
    style: {
      stroke: '#000',
      fill: null
    },
    buildPath: function(ctx, shape) {
      polyHelper.buildPath(ctx, shape, false);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/helper/roundRect.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {buildPath: function(ctx, shape) {
      var x = shape.x;
      var y = shape.y;
      var width = shape.width;
      var height = shape.height;
      var r = shape.r;
      var r1;
      var r2;
      var r3;
      var r4;
      if (width < 0) {
        x = x + width;
        width = -width;
      }
      if (height < 0) {
        y = y + height;
        height = -height;
      }
      if (typeof r === 'number') {
        r1 = r2 = r3 = r4 = r;
      } else if (r instanceof Array) {
        if (r.length === 1) {
          r1 = r2 = r3 = r4 = r[0];
        } else if (r.length === 2) {
          r1 = r3 = r[0];
          r2 = r4 = r[1];
        } else if (r.length === 3) {
          r1 = r[0];
          r2 = r4 = r[1];
          r3 = r[2];
        } else {
          r1 = r[0];
          r2 = r[1];
          r3 = r[2];
          r4 = r[3];
        }
      } else {
        r1 = r2 = r3 = r4 = 0;
      }
      var total;
      if (r1 + r2 > width) {
        total = r1 + r2;
        r1 *= width / total;
        r2 *= width / total;
      }
      if (r3 + r4 > width) {
        total = r3 + r4;
        r3 *= width / total;
        r4 *= width / total;
      }
      if (r2 + r3 > height) {
        total = r2 + r3;
        r2 *= height / total;
        r3 *= height / total;
      }
      if (r1 + r4 > height) {
        total = r1 + r4;
        r1 *= height / total;
        r4 *= height / total;
      }
      ctx.moveTo(x + r1, y);
      ctx.lineTo(x + width - r2, y);
      r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);
      ctx.lineTo(x + width, y + height - r3);
      r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);
      ctx.lineTo(x + r4, y + height);
      r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);
      ctx.lineTo(x, y + r1);
      r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
    }};
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/shape/Rect.js", ["../helper/roundRect", "../Path"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var roundRectHelper = $__require('../helper/roundRect');
  module.exports = $__require('../Path').extend({
    type: 'rect',
    shape: {
      r: 0,
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(ctx, shape) {
      var x = shape.x;
      var y = shape.y;
      var width = shape.width;
      var height = shape.height;
      if (!shape.r) {
        ctx.rect(x, y, width, height);
      } else {
        roundRectHelper.buildPath(ctx, shape);
      }
      ctx.closePath();
      return;
    }
  });
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/shape/Line.js", ["../Path"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('../Path').extend({
    type: 'line',
    shape: {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      percent: 1
    },
    style: {
      stroke: '#000',
      fill: null
    },
    buildPath: function(ctx, shape) {
      var x1 = shape.x1;
      var y1 = shape.y1;
      var x2 = shape.x2;
      var y2 = shape.y2;
      var percent = shape.percent;
      if (percent === 0) {
        return;
      }
      ctx.moveTo(x1, y1);
      if (percent < 1) {
        x2 = x1 * (1 - percent) + x2 * percent;
        y2 = y1 * (1 - percent) + y2 * percent;
      }
      ctx.lineTo(x2, y2);
    },
    pointAt: function(p) {
      var shape = this.shape;
      return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
    }
  });
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/shape/BezierCurve.js", ["../../core/curve", "../../core/vector", "../Path"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var curveTool = $__require('../../core/curve');
  var vec2 = $__require('../../core/vector');
  var quadraticSubdivide = curveTool.quadraticSubdivide;
  var cubicSubdivide = curveTool.cubicSubdivide;
  var quadraticAt = curveTool.quadraticAt;
  var cubicAt = curveTool.cubicAt;
  var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;
  var cubicDerivativeAt = curveTool.cubicDerivativeAt;
  var out = [];
  function someVectorAt(shape, t, isTangent) {
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    if (cpx2 === null || cpy2 === null) {
      return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
    } else {
      return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
    }
  }
  module.exports = $__require('../Path').extend({
    type: 'bezier-curve',
    shape: {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      cpx1: 0,
      cpy1: 0,
      percent: 1
    },
    style: {
      stroke: '#000',
      fill: null
    },
    buildPath: function(ctx, shape) {
      var x1 = shape.x1;
      var y1 = shape.y1;
      var x2 = shape.x2;
      var y2 = shape.y2;
      var cpx1 = shape.cpx1;
      var cpy1 = shape.cpy1;
      var cpx2 = shape.cpx2;
      var cpy2 = shape.cpy2;
      var percent = shape.percent;
      if (percent === 0) {
        return;
      }
      ctx.moveTo(x1, y1);
      if (cpx2 == null || cpy2 == null) {
        if (percent < 1) {
          quadraticSubdivide(x1, cpx1, x2, percent, out);
          cpx1 = out[1];
          x2 = out[2];
          quadraticSubdivide(y1, cpy1, y2, percent, out);
          cpy1 = out[1];
          y2 = out[2];
        }
        ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
      } else {
        if (percent < 1) {
          cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
          cpx1 = out[1];
          cpx2 = out[2];
          x2 = out[3];
          cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
          cpy1 = out[1];
          cpy2 = out[2];
          y2 = out[3];
        }
        ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
      }
    },
    pointAt: function(t) {
      return someVectorAt(this.shape, t, false);
    },
    tangentAt: function(t) {
      var p = someVectorAt(this.shape, t, true);
      return vec2.normalize(p, p);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/shape/Arc.js", ["../Path"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('../Path').extend({
    type: 'arc',
    shape: {
      cx: 0,
      cy: 0,
      r: 0,
      startAngle: 0,
      endAngle: Math.PI * 2,
      clockwise: true
    },
    style: {
      stroke: '#000',
      fill: null
    },
    buildPath: function(ctx, shape) {
      var x = shape.cx;
      var y = shape.cy;
      var r = Math.max(shape.r, 0);
      var startAngle = shape.startAngle;
      var endAngle = shape.endAngle;
      var clockwise = shape.clockwise;
      var unitX = Math.cos(startAngle);
      var unitY = Math.sin(startAngle);
      ctx.moveTo(unitX * r + x, unitY * r + y);
      ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/CompoundPath.js", ["./Path"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Path = $__require('./Path');
  module.exports = Path.extend({
    type: 'compound',
    shape: {paths: null},
    _updatePathDirty: function() {
      var dirtyPath = this.__dirtyPath;
      var paths = this.shape.paths;
      for (var i = 0; i < paths.length; i++) {
        dirtyPath = dirtyPath || paths[i].__dirtyPath;
      }
      this.__dirtyPath = dirtyPath;
      this.__dirty = this.__dirty || dirtyPath;
    },
    beforeBrush: function() {
      this._updatePathDirty();
      var paths = this.shape.paths || [];
      var scale = this.getGlobalScale();
      for (var i = 0; i < paths.length; i++) {
        paths[i].path.setScale(scale[0], scale[1]);
      }
    },
    buildPath: function(ctx, shape) {
      var paths = shape.paths || [];
      for (var i = 0; i < paths.length; i++) {
        paths[i].buildPath(ctx, paths[i].shape, true);
      }
    },
    afterBrush: function() {
      var paths = this.shape.paths;
      for (var i = 0; i < paths.length; i++) {
        paths[i].__dirtyPath = false;
      }
    },
    getBoundingRect: function() {
      this._updatePathDirty();
      return Path.prototype.getBoundingRect.call(this);
    }
  });
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/LinearGradient.js", ["../core/util", "./Gradient"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('../core/util');
  var Gradient = $__require('./Gradient');
  var LinearGradient = function(x, y, x2, y2, colorStops, globalCoord) {
    this.x = x == null ? 0 : x;
    this.y = y == null ? 0 : y;
    this.x2 = x2 == null ? 1 : x2;
    this.y2 = y2 == null ? 0 : y2;
    this.type = 'linear';
    this.global = globalCoord || false;
    Gradient.call(this, colorStops);
  };
  LinearGradient.prototype = {constructor: LinearGradient};
  zrUtil.inherits(LinearGradient, Gradient);
  module.exports = LinearGradient;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/RadialGradient.js", ["../core/util", "./Gradient"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('../core/util');
  var Gradient = $__require('./Gradient');
  var RadialGradient = function(x, y, r, colorStops, globalCoord) {
    this.x = x == null ? 0.5 : x;
    this.y = y == null ? 0.5 : y;
    this.r = r == null ? 0.5 : r;
    this.type = 'radial';
    this.global = globalCoord || false;
    Gradient.call(this, colorStops);
  };
  RadialGradient.prototype = {constructor: RadialGradient};
  zrUtil.inherits(RadialGradient, Gradient);
  module.exports = RadialGradient;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/util/graphic.js", ["zrender/lib/core/util", "zrender/lib/tool/path", "zrender/lib/graphic/Path", "zrender/lib/tool/color", "zrender/lib/core/matrix", "zrender/lib/core/vector", "zrender/lib/graphic/Gradient", "zrender/lib/container/Group", "zrender/lib/graphic/Image", "zrender/lib/graphic/Text", "zrender/lib/graphic/shape/Circle", "zrender/lib/graphic/shape/Sector", "zrender/lib/graphic/shape/Ring", "zrender/lib/graphic/shape/Polygon", "zrender/lib/graphic/shape/Polyline", "zrender/lib/graphic/shape/Rect", "zrender/lib/graphic/shape/Line", "zrender/lib/graphic/shape/BezierCurve", "zrender/lib/graphic/shape/Arc", "zrender/lib/graphic/CompoundPath", "zrender/lib/graphic/LinearGradient", "zrender/lib/graphic/RadialGradient", "zrender/lib/core/BoundingRect", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var pathTool = $__require('zrender/lib/tool/path');
  var round = Math.round;
  var Path = $__require('zrender/lib/graphic/Path');
  var colorTool = $__require('zrender/lib/tool/color');
  var matrix = $__require('zrender/lib/core/matrix');
  var vector = $__require('zrender/lib/core/vector');
  var Gradient = $__require('zrender/lib/graphic/Gradient');
  var graphic = {};
  graphic.Group = $__require('zrender/lib/container/Group');
  graphic.Image = $__require('zrender/lib/graphic/Image');
  graphic.Text = $__require('zrender/lib/graphic/Text');
  graphic.Circle = $__require('zrender/lib/graphic/shape/Circle');
  graphic.Sector = $__require('zrender/lib/graphic/shape/Sector');
  graphic.Ring = $__require('zrender/lib/graphic/shape/Ring');
  graphic.Polygon = $__require('zrender/lib/graphic/shape/Polygon');
  graphic.Polyline = $__require('zrender/lib/graphic/shape/Polyline');
  graphic.Rect = $__require('zrender/lib/graphic/shape/Rect');
  graphic.Line = $__require('zrender/lib/graphic/shape/Line');
  graphic.BezierCurve = $__require('zrender/lib/graphic/shape/BezierCurve');
  graphic.Arc = $__require('zrender/lib/graphic/shape/Arc');
  graphic.CompoundPath = $__require('zrender/lib/graphic/CompoundPath');
  graphic.LinearGradient = $__require('zrender/lib/graphic/LinearGradient');
  graphic.RadialGradient = $__require('zrender/lib/graphic/RadialGradient');
  graphic.BoundingRect = $__require('zrender/lib/core/BoundingRect');
  graphic.extendShape = function(opts) {
    return Path.extend(opts);
  };
  graphic.extendPath = function(pathData, opts) {
    return pathTool.extendFromString(pathData, opts);
  };
  graphic.makePath = function(pathData, opts, rect, layout) {
    var path = pathTool.createFromString(pathData, opts);
    var boundingRect = path.getBoundingRect();
    if (rect) {
      var aspect = boundingRect.width / boundingRect.height;
      if (layout === 'center') {
        var width = rect.height * aspect;
        var height;
        if (width <= rect.width) {
          height = rect.height;
        } else {
          width = rect.width;
          height = width / aspect;
        }
        var cx = rect.x + rect.width / 2;
        var cy = rect.y + rect.height / 2;
        rect.x = cx - width / 2;
        rect.y = cy - height / 2;
        rect.width = width;
        rect.height = height;
      }
      this.resizePath(path, rect);
    }
    return path;
  };
  graphic.mergePath = pathTool.mergePath, graphic.resizePath = function(path, rect) {
    if (!path.applyTransform) {
      return;
    }
    var pathRect = path.getBoundingRect();
    var m = pathRect.calculateTransform(rect);
    path.applyTransform(m);
  };
  graphic.subPixelOptimizeLine = function(param) {
    var subPixelOptimize = graphic.subPixelOptimize;
    var shape = param.shape;
    var lineWidth = param.style.lineWidth;
    if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
      shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
    }
    if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
      shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
    }
    return param;
  };
  graphic.subPixelOptimizeRect = function(param) {
    var subPixelOptimize = graphic.subPixelOptimize;
    var shape = param.shape;
    var lineWidth = param.style.lineWidth;
    var originX = shape.x;
    var originY = shape.y;
    var originWidth = shape.width;
    var originHeight = shape.height;
    shape.x = subPixelOptimize(shape.x, lineWidth, true);
    shape.y = subPixelOptimize(shape.y, lineWidth, true);
    shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);
    shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);
    return param;
  };
  graphic.subPixelOptimize = function(position, lineWidth, positiveOrNegative) {
    var doubledPosition = round(position * 2);
    return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
  };
  function hasFillOrStroke(fillOrStroke) {
    return fillOrStroke != null && fillOrStroke != 'none';
  }
  function liftColor(color) {
    return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;
  }
  function cacheElementStl(el) {
    if (el.__hoverStlDirty) {
      var stroke = el.style.stroke;
      var fill = el.style.fill;
      var hoverStyle = el.__hoverStl;
      hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);
      hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);
      var normalStyle = {};
      for (var name in hoverStyle) {
        if (hoverStyle.hasOwnProperty(name)) {
          normalStyle[name] = el.style[name];
        }
      }
      el.__normalStl = normalStyle;
      el.__hoverStlDirty = false;
    }
  }
  function doSingleEnterHover(el) {
    if (el.__isHover) {
      return;
    }
    cacheElementStl(el);
    if (el.useHoverLayer) {
      el.__zr && el.__zr.addHover(el, el.__hoverStl);
    } else {
      el.setStyle(el.__hoverStl);
      el.z2 += 1;
    }
    el.__isHover = true;
  }
  function doSingleLeaveHover(el) {
    if (!el.__isHover) {
      return;
    }
    var normalStl = el.__normalStl;
    if (el.useHoverLayer) {
      el.__zr && el.__zr.removeHover(el);
    } else {
      normalStl && el.setStyle(normalStl);
      el.z2 -= 1;
    }
    el.__isHover = false;
  }
  function doEnterHover(el) {
    el.type === 'group' ? el.traverse(function(child) {
      if (child.type !== 'group') {
        doSingleEnterHover(child);
      }
    }) : doSingleEnterHover(el);
  }
  function doLeaveHover(el) {
    el.type === 'group' ? el.traverse(function(child) {
      if (child.type !== 'group') {
        doSingleLeaveHover(child);
      }
    }) : doSingleLeaveHover(el);
  }
  function setElementHoverStl(el, hoverStl) {
    el.__hoverStl = el.hoverStyle || hoverStl || {};
    el.__hoverStlDirty = true;
    if (el.__isHover) {
      cacheElementStl(el);
    }
  }
  function onElementMouseOver() {
    !this.__isEmphasis && doEnterHover(this);
  }
  function onElementMouseOut() {
    !this.__isEmphasis && doLeaveHover(this);
  }
  function enterEmphasis() {
    this.__isEmphasis = true;
    doEnterHover(this);
  }
  function leaveEmphasis() {
    this.__isEmphasis = false;
    doLeaveHover(this);
  }
  graphic.setHoverStyle = function(el, hoverStyle) {
    el.type === 'group' ? el.traverse(function(child) {
      if (child.type !== 'group') {
        setElementHoverStl(child, hoverStyle);
      }
    }) : setElementHoverStl(el, hoverStyle);
    el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut);
    el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);
  };
  graphic.setText = function(textStyle, labelModel, color) {
    var labelPosition = labelModel.getShallow('position') || 'inside';
    var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
    var textStyleModel = labelModel.getModel('textStyle');
    zrUtil.extend(textStyle, {
      textDistance: labelModel.getShallow('distance') || 5,
      textFont: textStyleModel.getFont(),
      textPosition: labelPosition,
      textFill: textStyleModel.getTextColor() || labelColor
    });
  };
  function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {
    if (typeof dataIndex === 'function') {
      cb = dataIndex;
      dataIndex = null;
    }
    var animationEnabled = animatableModel && (animatableModel.ifEnableAnimation ? animatableModel.ifEnableAnimation() : animatableModel.getShallow('animation'));
    if (animationEnabled) {
      var postfix = isUpdate ? 'Update' : '';
      var duration = animatableModel && animatableModel.getShallow('animationDuration' + postfix);
      var animationEasing = animatableModel && animatableModel.getShallow('animationEasing' + postfix);
      var animationDelay = animatableModel && animatableModel.getShallow('animationDelay' + postfix);
      if (typeof animationDelay === 'function') {
        animationDelay = animationDelay(dataIndex);
      }
      duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb) : (el.attr(props), cb && cb());
    } else {
      el.attr(props);
      cb && cb();
    }
  }
  graphic.updateProps = function(el, props, animatableModel, dataIndex, cb) {
    animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);
  };
  graphic.initProps = function(el, props, animatableModel, dataIndex, cb) {
    animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);
  };
  graphic.getTransform = function(target, ancestor) {
    var mat = matrix.identity([]);
    while (target && target !== ancestor) {
      matrix.mul(mat, target.getLocalTransform(), mat);
      target = target.parent;
    }
    return mat;
  };
  graphic.applyTransform = function(vertex, transform, invert) {
    if (invert) {
      transform = matrix.invert([], transform);
    }
    return vector.applyTransform([], vertex, transform);
  };
  graphic.transformDirection = function(direction, transform, invert) {
    var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0) ? 1 : Math.abs(2 * transform[4] / transform[0]);
    var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0) ? 1 : Math.abs(2 * transform[4] / transform[2]);
    var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];
    vertex = graphic.applyTransform(vertex, transform, invert);
    return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? (vertex[0] > 0 ? 'right' : 'left') : (vertex[1] > 0 ? 'bottom' : 'top');
  };
  graphic.groupTransition = function(g1, g2, animatableModel, cb) {
    if (!g1 || !g2) {
      return;
    }
    function getElMap(g) {
      var elMap = {};
      g.traverse(function(el) {
        if (!el.isGroup && el.anid) {
          elMap[el.anid] = el;
        }
      });
      return elMap;
    }
    function getAnimatableProps(el) {
      var obj = {
        position: vector.clone(el.position),
        rotation: el.rotation
      };
      if (el.shape) {
        obj.shape = zrUtil.extend({}, el.shape);
      }
      return obj;
    }
    var elMap1 = getElMap(g1);
    g2.traverse(function(el) {
      if (!el.isGroup && el.anid) {
        var oldEl = elMap1[el.anid];
        if (oldEl) {
          var newProp = getAnimatableProps(el);
          el.attr(getAnimatableProps(oldEl));
          graphic.updateProps(el, newProp, animatableModel, el.dataIndex);
        }
      }
    });
  };
  module.exports = graphic;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/loading/default.js", ["../util/graphic", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var graphic = $__require('../util/graphic');
  var zrUtil = $__require('zrender/lib/core/util');
  var PI = Math.PI;
  module.exports = function(api, opts) {
    opts = opts || {};
    zrUtil.defaults(opts, {
      text: 'loading',
      color: '#c23531',
      textColor: '#000',
      maskColor: 'rgba(255, 255, 255, 0.8)',
      zlevel: 0
    });
    var mask = new graphic.Rect({
      style: {fill: opts.maskColor},
      zlevel: opts.zlevel,
      z: 10000
    });
    var arc = new graphic.Arc({
      shape: {
        startAngle: -PI / 2,
        endAngle: -PI / 2 + 0.1,
        r: 10
      },
      style: {
        stroke: opts.color,
        lineCap: 'round',
        lineWidth: 5
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    var labelRect = new graphic.Rect({
      style: {
        fill: 'none',
        text: opts.text,
        textPosition: 'right',
        textDistance: 10,
        textFill: opts.textColor
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    arc.animateShape(true).when(1000, {endAngle: PI * 3 / 2}).start('circularInOut');
    arc.animateShape(true).when(1000, {startAngle: PI * 3 / 2}).delay(300).start('circularInOut');
    var group = new graphic.Group();
    group.add(arc);
    group.add(labelRect);
    group.add(mask);
    group.resize = function() {
      var cx = api.getWidth() / 2;
      var cy = api.getHeight() / 2;
      arc.setShape({
        cx: cx,
        cy: cy
      });
      var r = arc.shape.r;
      labelRect.setShape({
        x: cx - r,
        y: cy - r,
        width: r * 2,
        height: r * 2
      });
      mask.setShape({
        x: 0,
        y: 0,
        width: api.getWidth(),
        height: api.getHeight()
      });
    };
    group.resize();
    return group;
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/visual/seriesColor.js", ["zrender/lib/graphic/Gradient", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var Gradient = $__require('zrender/lib/graphic/Gradient');
  module.exports = function(ecModel) {
    function encodeColor(seriesModel) {
      var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');
      var data = seriesModel.getData();
      var color = seriesModel.get(colorAccessPath) || seriesModel.getColorFromPalette(seriesModel.get('name'));
      data.setVisual('color', color);
      if (!ecModel.isSeriesFiltered(seriesModel)) {
        if (typeof color === 'function' && !(color instanceof Gradient)) {
          data.each(function(idx) {
            data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));
          });
        }
        data.each(function(idx) {
          var itemModel = data.getItemModel(idx);
          var color = itemModel.get(colorAccessPath, true);
          if (color != null) {
            data.setItemVisual(idx, 'color', color);
          }
        });
      }
    }
    ecModel.eachRawSeries(encodeColor);
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/preprocessor/helper/compatStyle.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];
  function compatItemStyle(opt) {
    var itemStyleOpt = opt && opt.itemStyle;
    if (itemStyleOpt) {
      zrUtil.each(POSSIBLE_STYLES, function(styleName) {
        var normalItemStyleOpt = itemStyleOpt.normal;
        var emphasisItemStyleOpt = itemStyleOpt.emphasis;
        if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
          opt[styleName] = opt[styleName] || {};
          if (!opt[styleName].normal) {
            opt[styleName].normal = normalItemStyleOpt[styleName];
          } else {
            zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
          }
          normalItemStyleOpt[styleName] = null;
        }
        if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
          opt[styleName] = opt[styleName] || {};
          if (!opt[styleName].emphasis) {
            opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
          } else {
            zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
          }
          emphasisItemStyleOpt[styleName] = null;
        }
      });
    }
  }
  module.exports = function(seriesOpt) {
    if (!seriesOpt) {
      return;
    }
    compatItemStyle(seriesOpt);
    compatItemStyle(seriesOpt.markPoint);
    compatItemStyle(seriesOpt.markLine);
    var data = seriesOpt.data;
    if (data) {
      for (var i = 0; i < data.length; i++) {
        compatItemStyle(data[i]);
      }
      var markPoint = seriesOpt.markPoint;
      if (markPoint && markPoint.data) {
        var mpData = markPoint.data;
        for (var i = 0; i < mpData.length; i++) {
          compatItemStyle(mpData[i]);
        }
      }
      var markLine = seriesOpt.markLine;
      if (markLine && markLine.data) {
        var mlData = markLine.data;
        for (var i = 0; i < mlData.length; i++) {
          if (zrUtil.isArray(mlData[i])) {
            compatItemStyle(mlData[i][0]);
            compatItemStyle(mlData[i][1]);
          } else {
            compatItemStyle(mlData[i]);
          }
        }
      }
    }
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/preprocessor/backwardCompat.js", ["zrender/lib/core/util", "./helper/compatStyle", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var compatStyle = $__require('./helper/compatStyle');
  function get(opt, path) {
    path = path.split(',');
    var obj = opt;
    for (var i = 0; i < path.length; i++) {
      obj = obj && obj[path[i]];
      if (obj == null) {
        break;
      }
    }
    return obj;
  }
  function set(opt, path, val, overwrite) {
    path = path.split(',');
    var obj = opt;
    var key;
    for (var i = 0; i < path.length - 1; i++) {
      key = path[i];
      if (obj[key] == null) {
        obj[key] = {};
      }
      obj = obj[key];
    }
    if (overwrite || obj[path[i]] == null) {
      obj[path[i]] = val;
    }
  }
  function compatLayoutProperties(option) {
    each(LAYOUT_PROPERTIES, function(prop) {
      if (prop[0] in option && !(prop[1] in option)) {
        option[prop[1]] = option[prop[0]];
      }
    });
  }
  var LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];
  var COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];
  var COMPATITABLE_SERIES = ['bar', 'boxplot', 'candlestick', 'chord', 'effectScatter', 'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel', 'pie', 'radar', 'sankey', 'scatter', 'treemap'];
  var each = zrUtil.each;
  module.exports = function(option) {
    each(option.series, function(seriesOpt) {
      if (!zrUtil.isObject(seriesOpt)) {
        return;
      }
      var seriesType = seriesOpt.type;
      compatStyle(seriesOpt);
      if (seriesType === 'pie' || seriesType === 'gauge') {
        if (seriesOpt.clockWise != null) {
          seriesOpt.clockwise = seriesOpt.clockWise;
        }
      }
      if (seriesType === 'gauge') {
        var pointerColor = get(seriesOpt, 'pointer.color');
        pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);
      }
      for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {
        if (COMPATITABLE_SERIES[i] === seriesOpt.type) {
          compatLayoutProperties(seriesOpt);
          break;
        }
      }
    });
    if (option.dataRange) {
      option.visualMap = option.dataRange;
    }
    each(COMPATITABLE_COMPONENTS, function(componentName) {
      var options = option[componentName];
      if (options) {
        if (!zrUtil.isArray(options)) {
          options = [options];
        }
        each(options, function(option) {
          compatLayoutProperties(option);
        });
      }
    });
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/data/DataDiffer.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function defaultKeyGetter(item) {
    return item;
  }
  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {
    this._old = oldArr;
    this._new = newArr;
    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
    this._newKeyGetter = newKeyGetter || defaultKeyGetter;
  }
  DataDiffer.prototype = {
    constructor: DataDiffer,
    add: function(func) {
      this._add = func;
      return this;
    },
    update: function(func) {
      this._update = func;
      return this;
    },
    remove: function(func) {
      this._remove = func;
      return this;
    },
    execute: function() {
      var oldArr = this._old;
      var newArr = this._new;
      var oldKeyGetter = this._oldKeyGetter;
      var newKeyGetter = this._newKeyGetter;
      var oldDataIndexMap = {};
      var newDataIndexMap = {};
      var oldDataKeyArr = [];
      var newDataKeyArr = [];
      var i;
      initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);
      initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);
      for (i = 0; i < oldArr.length; i++) {
        var key = oldDataKeyArr[i];
        var idx = newDataIndexMap[key];
        if (idx != null) {
          var len = idx.length;
          if (len) {
            len === 1 && (newDataIndexMap[key] = null);
            idx = idx.unshift();
          } else {
            newDataIndexMap[key] = null;
          }
          this._update && this._update(idx, i);
        } else {
          this._remove && this._remove(i);
        }
      }
      for (var i = 0; i < newDataKeyArr.length; i++) {
        var key = newDataKeyArr[i];
        if (newDataIndexMap.hasOwnProperty(key)) {
          var idx = newDataIndexMap[key];
          if (idx == null) {
            continue;
          }
          if (!idx.length) {
            this._add && this._add(idx);
          } else {
            for (var j = 0,
                len = idx.length; j < len; j++) {
              this._add && this._add(idx[j]);
            }
          }
        }
      }
    }
  };
  function initIndexMap(arr, map, keyArr, keyGetter) {
    for (var i = 0; i < arr.length; i++) {
      var key = keyGetter(arr[i], i);
      var existence = map[key];
      if (existence == null) {
        keyArr.push(key);
        map[key] = i;
      } else {
        if (!existence.length) {
          map[key] = existence = [existence];
        }
        existence.push(i);
      }
    }
  }
  module.exports = DataDiffer;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/util/model.js", ["./format", "./number", "../model/Model", "zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var formatUtil = $__require('./format');
  var nubmerUtil = $__require('./number');
  var Model = $__require('../model/Model');
  var zrUtil = $__require('zrender/lib/core/util');
  var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle'];
  var modelUtil = {};
  modelUtil.createNameEach = function(names, attrs) {
    names = names.slice();
    var capitalNames = zrUtil.map(names, modelUtil.capitalFirst);
    attrs = (attrs || []).slice();
    var capitalAttrs = zrUtil.map(attrs, modelUtil.capitalFirst);
    return function(callback, context) {
      zrUtil.each(names, function(name, index) {
        var nameObj = {
          name: name,
          capital: capitalNames[index]
        };
        for (var j = 0; j < attrs.length; j++) {
          nameObj[attrs[j]] = name + capitalAttrs[j];
        }
        callback.call(context, nameObj);
      });
    };
  };
  modelUtil.capitalFirst = function(str) {
    return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
  };
  modelUtil.eachAxisDim = modelUtil.createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index']);
  modelUtil.normalizeToArray = function(value) {
    return value instanceof Array ? value : value == null ? [] : [value];
  };
  modelUtil.createLinkedNodesFinder = function(forEachNode, forEachEdgeType, edgeIdGetter) {
    return function(sourceNode) {
      var result = {
        nodes: [],
        records: {}
      };
      forEachEdgeType(function(edgeType) {
        result.records[edgeType.name] = {};
      });
      if (!sourceNode) {
        return result;
      }
      absorb(sourceNode, result);
      var existsLink;
      do {
        existsLink = false;
        forEachNode(processSingleNode);
      } while (existsLink);
      function processSingleNode(node) {
        if (!isNodeAbsorded(node, result) && isLinked(node, result)) {
          absorb(node, result);
          existsLink = true;
        }
      }
      return result;
    };
    function isNodeAbsorded(node, result) {
      return zrUtil.indexOf(result.nodes, node) >= 0;
    }
    function isLinked(node, result) {
      var hasLink = false;
      forEachEdgeType(function(edgeType) {
        zrUtil.each(edgeIdGetter(node, edgeType) || [], function(edgeId) {
          result.records[edgeType.name][edgeId] && (hasLink = true);
        });
      });
      return hasLink;
    }
    function absorb(node, result) {
      result.nodes.push(node);
      forEachEdgeType(function(edgeType) {
        zrUtil.each(edgeIdGetter(node, edgeType) || [], function(edgeId) {
          result.records[edgeType.name][edgeId] = true;
        });
      });
    }
  };
  modelUtil.defaultEmphasis = function(opt, subOpts) {
    if (opt) {
      var emphasisOpt = opt.emphasis = opt.emphasis || {};
      var normalOpt = opt.normal = opt.normal || {};
      zrUtil.each(subOpts, function(subOptName) {
        var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);
        if (val != null) {
          emphasisOpt[subOptName] = val;
        }
      });
    }
  };
  modelUtil.LABEL_OPTIONS = ['position', 'show', 'textStyle', 'distance', 'formatter'];
  modelUtil.getDataItemValue = function(dataItem) {
    return dataItem && (dataItem.value == null ? dataItem : dataItem.value);
  };
  modelUtil.isDataItemOption = function(dataItem) {
    return zrUtil.isObject(dataItem) && !(dataItem instanceof Array);
  };
  modelUtil.converDataValue = function(value, dimInfo) {
    var dimType = dimInfo && dimInfo.type;
    if (dimType === 'ordinal') {
      return value;
    }
    if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {
      value = +nubmerUtil.parseDate(value);
    }
    return (value == null || value === '') ? NaN : +value;
  };
  modelUtil.createDataFormatModel = function(data, opt) {
    var model = new Model();
    zrUtil.mixin(model, modelUtil.dataFormatMixin);
    model.seriesIndex = opt.seriesIndex;
    model.name = opt.name || '';
    model.mainType = opt.mainType;
    model.subType = opt.subType;
    model.getData = function() {
      return data;
    };
    return model;
  };
  modelUtil.dataFormatMixin = {
    getDataParams: function(dataIndex, dataType) {
      var data = this.getData(dataType);
      var seriesIndex = this.seriesIndex;
      var seriesName = this.name;
      var rawValue = this.getRawValue(dataIndex, dataType);
      var rawDataIndex = data.getRawIndex(dataIndex);
      var name = data.getName(dataIndex, true);
      var itemOpt = data.getRawDataItem(dataIndex);
      return {
        componentType: this.mainType,
        componentSubType: this.subType,
        seriesType: this.mainType === 'series' ? this.subType : null,
        seriesIndex: seriesIndex,
        seriesName: seriesName,
        name: name,
        dataIndex: rawDataIndex,
        data: itemOpt,
        dataType: dataType,
        value: rawValue,
        color: data.getItemVisual(dataIndex, 'color'),
        $vars: ['seriesName', 'name', 'value']
      };
    },
    getFormattedLabel: function(dataIndex, status, dataType, dimIndex) {
      status = status || 'normal';
      var data = this.getData(dataType);
      var itemModel = data.getItemModel(dataIndex);
      var params = this.getDataParams(dataIndex, dataType);
      if (dimIndex != null && (params.value instanceof Array)) {
        params.value = params.value[dimIndex];
      }
      var formatter = itemModel.get(['label', status, 'formatter']);
      if (typeof formatter === 'function') {
        params.status = status;
        return formatter(params);
      } else if (typeof formatter === 'string') {
        return formatUtil.formatTpl(formatter, params);
      }
    },
    getRawValue: function(idx, dataType) {
      var data = this.getData(dataType);
      var dataItem = data.getRawDataItem(idx);
      if (dataItem != null) {
        return (zrUtil.isObject(dataItem) && !(dataItem instanceof Array)) ? dataItem.value : dataItem;
      }
    },
    formatTooltip: zrUtil.noop
  };
  modelUtil.mappingToExists = function(exists, newCptOptions) {
    newCptOptions = (newCptOptions || []).slice();
    var result = zrUtil.map(exists || [], function(obj, index) {
      return {exist: obj};
    });
    zrUtil.each(newCptOptions, function(cptOption, index) {
      if (!zrUtil.isObject(cptOption)) {
        return;
      }
      for (var i = 0; i < result.length; i++) {
        var exist = result[i].exist;
        if (!result[i].option && ((cptOption.id != null && exist.id === cptOption.id + '') || (cptOption.name != null && !modelUtil.isIdInner(cptOption) && !modelUtil.isIdInner(exist) && exist.name === cptOption.name + ''))) {
          result[i].option = cptOption;
          newCptOptions[index] = null;
          break;
        }
      }
    });
    zrUtil.each(newCptOptions, function(cptOption, index) {
      if (!zrUtil.isObject(cptOption)) {
        return;
      }
      var i = 0;
      for (; i < result.length; i++) {
        var exist = result[i].exist;
        if (!result[i].option && !modelUtil.isIdInner(exist) && cptOption.id == null) {
          result[i].option = cptOption;
          break;
        }
      }
      if (i >= result.length) {
        result.push({option: cptOption});
      }
    });
    return result;
  };
  modelUtil.isIdInner = function(cptOption) {
    return zrUtil.isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\0_ec_\0') === 0;
  };
  modelUtil.compressBatches = function(batchA, batchB) {
    var mapA = {};
    var mapB = {};
    makeMap(batchA || [], mapA);
    makeMap(batchB || [], mapB, mapA);
    return [mapToArray(mapA), mapToArray(mapB)];
    function makeMap(sourceBatch, map, otherMap) {
      for (var i = 0,
          len = sourceBatch.length; i < len; i++) {
        var seriesId = sourceBatch[i].seriesId;
        var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);
        var otherDataIndices = otherMap && otherMap[seriesId];
        for (var j = 0,
            lenj = dataIndices.length; j < lenj; j++) {
          var dataIndex = dataIndices[j];
          if (otherDataIndices && otherDataIndices[dataIndex]) {
            otherDataIndices[dataIndex] = null;
          } else {
            (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
          }
        }
      }
    }
    function mapToArray(map, isData) {
      var result = [];
      for (var i in map) {
        if (map.hasOwnProperty(i) && map[i] != null) {
          if (isData) {
            result.push(+i);
          } else {
            var dataIndices = mapToArray(map[i], true);
            dataIndices.length && result.push({
              seriesId: i,
              dataIndex: dataIndices
            });
          }
        }
      }
      return result;
    }
  };
  module.exports = modelUtil;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/data/List.js", ["../model/Model", "./DataDiffer", "zrender/lib/core/util", "../util/model", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var UNDEFINED = 'undefined';
  var globalObj = typeof window === 'undefined' ? global : window;
  var Float64Array = typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array;
  var Int32Array = typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array;
  var dataCtors = {
    'float': Float64Array,
    'int': Int32Array,
    'ordinal': Array,
    'number': Array,
    'time': Array
  };
  var Model = $__require('../model/Model');
  var DataDiffer = $__require('./DataDiffer');
  var zrUtil = $__require('zrender/lib/core/util');
  var modelUtil = $__require('../util/model');
  var isObject = zrUtil.isObject;
  var TRANSFERABLE_PROPERTIES = ['stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'];
  var transferProperties = function(a, b) {
    zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function(propName) {
      if (b.hasOwnProperty(propName)) {
        a[propName] = b[propName];
      }
    });
    a.__wrappedMethods = b.__wrappedMethods;
  };
  var List = function(dimensions, hostModel) {
    dimensions = dimensions || ['x', 'y'];
    var dimensionInfos = {};
    var dimensionNames = [];
    for (var i = 0; i < dimensions.length; i++) {
      var dimensionName;
      var dimensionInfo = {};
      if (typeof dimensions[i] === 'string') {
        dimensionName = dimensions[i];
        dimensionInfo = {
          name: dimensionName,
          stackable: false,
          type: 'number'
        };
      } else {
        dimensionInfo = dimensions[i];
        dimensionName = dimensionInfo.name;
        dimensionInfo.type = dimensionInfo.type || 'number';
      }
      dimensionNames.push(dimensionName);
      dimensionInfos[dimensionName] = dimensionInfo;
    }
    this.dimensions = dimensionNames;
    this._dimensionInfos = dimensionInfos;
    this.hostModel = hostModel;
    this.dataType;
    this.indices = [];
    this._storage = {};
    this._nameList = [];
    this._idList = [];
    this._optionModels = [];
    this.stackedOn = null;
    this._visual = {};
    this._layout = {};
    this._itemVisuals = [];
    this._itemLayouts = [];
    this._graphicEls = [];
    this._rawData;
    this._extent;
  };
  var listProto = List.prototype;
  listProto.type = 'list';
  listProto.hasItemOption = true;
  listProto.getDimension = function(dim) {
    if (!isNaN(dim)) {
      dim = this.dimensions[dim] || dim;
    }
    return dim;
  };
  listProto.getDimensionInfo = function(dim) {
    return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);
  };
  listProto.initData = function(data, nameList, dimValueGetter) {
    data = data || [];
    if (__DEV__) {
      if (!zrUtil.isArray(data)) {
        throw new Error('Invalid data.');
      }
    }
    this._rawData = data;
    var storage = this._storage = {};
    var indices = this.indices = [];
    var dimensions = this.dimensions;
    var size = data.length;
    var dimensionInfoMap = this._dimensionInfos;
    var idList = [];
    var nameRepeatCount = {};
    nameList = nameList || [];
    for (var i = 0; i < dimensions.length; i++) {
      var dimInfo = dimensionInfoMap[dimensions[i]];
      var DataCtor = dataCtors[dimInfo.type];
      storage[dimensions[i]] = new DataCtor(size);
    }
    var self = this;
    if (!dimValueGetter) {
      self.hasItemOption = false;
    }
    dimValueGetter = dimValueGetter || function(dataItem, dimName, dataIndex, dimIndex) {
      var value = modelUtil.getDataItemValue(dataItem);
      if (modelUtil.isDataItemOption(dataItem)) {
        self.hasItemOption = true;
      }
      return modelUtil.converDataValue((value instanceof Array) ? value[dimIndex] : value, dimensionInfoMap[dimName]);
    };
    for (var idx = 0; idx < data.length; idx++) {
      var dataItem = data[idx];
      for (var k = 0; k < dimensions.length; k++) {
        var dim = dimensions[k];
        var dimStorage = storage[dim];
        dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);
      }
      indices.push(idx);
    }
    for (var i = 0; i < data.length; i++) {
      if (!nameList[i]) {
        if (data[i] && data[i].name != null) {
          nameList[i] = data[i].name;
        }
      }
      var name = nameList[i] || '';
      var id = data[i] && data[i].id;
      if (!id && name) {
        nameRepeatCount[name] = nameRepeatCount[name] || 0;
        id = name;
        if (nameRepeatCount[name] > 0) {
          id += '__ec__' + nameRepeatCount[name];
        }
        nameRepeatCount[name]++;
      }
      id && (idList[i] = id);
    }
    this._nameList = nameList;
    this._idList = idList;
  };
  listProto.count = function() {
    return this.indices.length;
  };
  listProto.get = function(dim, idx, stack) {
    var storage = this._storage;
    var dataIndex = this.indices[idx];
    if (dataIndex == null) {
      return NaN;
    }
    var value = storage[dim] && storage[dim][dataIndex];
    if (stack) {
      var dimensionInfo = this._dimensionInfos[dim];
      if (dimensionInfo && dimensionInfo.stackable) {
        var stackedOn = this.stackedOn;
        while (stackedOn) {
          var stackedValue = stackedOn.get(dim, idx);
          if ((value >= 0 && stackedValue > 0) || (value <= 0 && stackedValue < 0)) {
            value += stackedValue;
          }
          stackedOn = stackedOn.stackedOn;
        }
      }
    }
    return value;
  };
  listProto.getValues = function(dimensions, idx, stack) {
    var values = [];
    if (!zrUtil.isArray(dimensions)) {
      stack = idx;
      idx = dimensions;
      dimensions = this.dimensions;
    }
    for (var i = 0,
        len = dimensions.length; i < len; i++) {
      values.push(this.get(dimensions[i], idx, stack));
    }
    return values;
  };
  listProto.hasValue = function(idx) {
    var dimensions = this.dimensions;
    var dimensionInfos = this._dimensionInfos;
    for (var i = 0,
        len = dimensions.length; i < len; i++) {
      if (dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {
        return false;
      }
    }
    return true;
  };
  listProto.getDataExtent = function(dim, stack) {
    dim = this.getDimension(dim);
    var dimData = this._storage[dim];
    var dimInfo = this.getDimensionInfo(dim);
    stack = (dimInfo && dimInfo.stackable) && stack;
    var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];
    var value;
    if (dimExtent) {
      return dimExtent;
    }
    if (dimData) {
      var min = Infinity;
      var max = -Infinity;
      for (var i = 0,
          len = this.count(); i < len; i++) {
        value = this.get(dim, i, stack);
        value < min && (min = value);
        value > max && (max = value);
      }
      return (this._extent[dim + !!stack] = [min, max]);
    } else {
      return [Infinity, -Infinity];
    }
  };
  listProto.getSum = function(dim, stack) {
    var dimData = this._storage[dim];
    var sum = 0;
    if (dimData) {
      for (var i = 0,
          len = this.count(); i < len; i++) {
        var value = this.get(dim, i, stack);
        if (!isNaN(value)) {
          sum += value;
        }
      }
    }
    return sum;
  };
  listProto.indexOf = function(dim, value) {
    var storage = this._storage;
    var dimData = storage[dim];
    var indices = this.indices;
    if (dimData) {
      for (var i = 0,
          len = indices.length; i < len; i++) {
        var rawIndex = indices[i];
        if (dimData[rawIndex] === value) {
          return i;
        }
      }
    }
    return -1;
  };
  listProto.indexOfName = function(name) {
    var indices = this.indices;
    var nameList = this._nameList;
    for (var i = 0,
        len = indices.length; i < len; i++) {
      var rawIndex = indices[i];
      if (nameList[rawIndex] === name) {
        return i;
      }
    }
    return -1;
  };
  listProto.indexOfRawIndex = function(rawIndex) {
    var indices = this.indices;
    var left = 0;
    var right = indices.length - 1;
    while (left <= right) {
      var mid = (left + right) / 2 | 0;
      if (indices[mid] < rawIndex) {
        left = mid + 1;
      } else if (indices[mid] > rawIndex) {
        right = mid - 1;
      } else {
        return mid;
      }
    }
    return -1;
  };
  listProto.indexOfNearest = function(dim, value, stack, maxDistance) {
    var storage = this._storage;
    var dimData = storage[dim];
    if (maxDistance == null) {
      maxDistance = Infinity;
    }
    var nearestIdx = -1;
    if (dimData) {
      var minDist = Number.MAX_VALUE;
      for (var i = 0,
          len = this.count(); i < len; i++) {
        var diff = value - this.get(dim, i, stack);
        var dist = Math.abs(diff);
        if (diff <= maxDistance && (dist < minDist || (dist === minDist && diff > 0))) {
          minDist = dist;
          nearestIdx = i;
        }
      }
    }
    return nearestIdx;
  };
  listProto.getRawIndex = function(idx) {
    var rawIdx = this.indices[idx];
    return rawIdx == null ? -1 : rawIdx;
  };
  listProto.getRawDataItem = function(idx) {
    return this._rawData[this.getRawIndex(idx)];
  };
  listProto.getName = function(idx) {
    return this._nameList[this.indices[idx]] || '';
  };
  listProto.getId = function(idx) {
    return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');
  };
  function normalizeDimensions(dimensions) {
    if (!zrUtil.isArray(dimensions)) {
      dimensions = [dimensions];
    }
    return dimensions;
  }
  listProto.each = function(dims, cb, stack, context) {
    if (typeof dims === 'function') {
      context = stack;
      stack = cb;
      cb = dims;
      dims = [];
    }
    dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);
    var value = [];
    var dimSize = dims.length;
    var indices = this.indices;
    context = context || this;
    for (var i = 0; i < indices.length; i++) {
      switch (dimSize) {
        case 0:
          cb.call(context, i);
          break;
        case 1:
          cb.call(context, this.get(dims[0], i, stack), i);
          break;
        case 2:
          cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);
          break;
        default:
          for (var k = 0; k < dimSize; k++) {
            value[k] = this.get(dims[k], i, stack);
          }
          value[k] = i;
          cb.apply(context, value);
      }
    }
  };
  listProto.filterSelf = function(dimensions, cb, stack, context) {
    if (typeof dimensions === 'function') {
      context = stack;
      stack = cb;
      cb = dimensions;
      dimensions = [];
    }
    dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
    var newIndices = [];
    var value = [];
    var dimSize = dimensions.length;
    var indices = this.indices;
    context = context || this;
    for (var i = 0; i < indices.length; i++) {
      var keep;
      if (dimSize === 1) {
        keep = cb.call(context, this.get(dimensions[0], i, stack), i);
      } else {
        for (var k = 0; k < dimSize; k++) {
          value[k] = this.get(dimensions[k], i, stack);
        }
        value[k] = i;
        keep = cb.apply(context, value);
      }
      if (keep) {
        newIndices.push(indices[i]);
      }
    }
    this.indices = newIndices;
    this._extent = {};
    return this;
  };
  listProto.mapArray = function(dimensions, cb, stack, context) {
    if (typeof dimensions === 'function') {
      context = stack;
      stack = cb;
      cb = dimensions;
      dimensions = [];
    }
    var result = [];
    this.each(dimensions, function() {
      result.push(cb && cb.apply(this, arguments));
    }, stack, context);
    return result;
  };
  function cloneListForMapAndSample(original, excludeDimensions) {
    var allDimensions = original.dimensions;
    var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel);
    transferProperties(list, original);
    var storage = list._storage = {};
    var originalStorage = original._storage;
    for (var i = 0; i < allDimensions.length; i++) {
      var dim = allDimensions[i];
      var dimStore = originalStorage[dim];
      if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {
        storage[dim] = new dimStore.constructor(originalStorage[dim].length);
      } else {
        storage[dim] = originalStorage[dim];
      }
    }
    return list;
  }
  listProto.map = function(dimensions, cb, stack, context) {
    dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
    var list = cloneListForMapAndSample(this, dimensions);
    var indices = list.indices = this.indices;
    var storage = list._storage;
    var tmpRetValue = [];
    this.each(dimensions, function() {
      var idx = arguments[arguments.length - 1];
      var retValue = cb && cb.apply(this, arguments);
      if (retValue != null) {
        if (typeof retValue === 'number') {
          tmpRetValue[0] = retValue;
          retValue = tmpRetValue;
        }
        for (var i = 0; i < retValue.length; i++) {
          var dim = dimensions[i];
          var dimStore = storage[dim];
          var rawIdx = indices[idx];
          if (dimStore) {
            dimStore[rawIdx] = retValue[i];
          }
        }
      }
    }, stack, context);
    return list;
  };
  listProto.downSample = function(dimension, rate, sampleValue, sampleIndex) {
    var list = cloneListForMapAndSample(this, [dimension]);
    var storage = this._storage;
    var targetStorage = list._storage;
    var originalIndices = this.indices;
    var indices = list.indices = [];
    var frameValues = [];
    var frameIndices = [];
    var frameSize = Math.floor(1 / rate);
    var dimStore = targetStorage[dimension];
    var len = this.count();
    for (var i = 0; i < storage[dimension].length; i++) {
      targetStorage[dimension][i] = storage[dimension][i];
    }
    for (var i = 0; i < len; i += frameSize) {
      if (frameSize > len - i) {
        frameSize = len - i;
        frameValues.length = frameSize;
      }
      for (var k = 0; k < frameSize; k++) {
        var idx = originalIndices[i + k];
        frameValues[k] = dimStore[idx];
        frameIndices[k] = idx;
      }
      var value = sampleValue(frameValues);
      var idx = frameIndices[sampleIndex(frameValues, value) || 0];
      dimStore[idx] = value;
      indices.push(idx);
    }
    return list;
  };
  listProto.getItemModel = function(idx) {
    var hostModel = this.hostModel;
    idx = this.indices[idx];
    return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);
  };
  listProto.diff = function(otherList) {
    var idList = this._idList;
    var otherIdList = otherList && otherList._idList;
    return new DataDiffer(otherList ? otherList.indices : [], this.indices, function(idx) {
      return otherIdList[idx] || (idx + '');
    }, function(idx) {
      return idList[idx] || (idx + '');
    });
  };
  listProto.getVisual = function(key) {
    var visual = this._visual;
    return visual && visual[key];
  };
  listProto.setVisual = function(key, val) {
    if (isObject(key)) {
      for (var name in key) {
        if (key.hasOwnProperty(name)) {
          this.setVisual(name, key[name]);
        }
      }
      return;
    }
    this._visual = this._visual || {};
    this._visual[key] = val;
  };
  listProto.setLayout = function(key, val) {
    if (isObject(key)) {
      for (var name in key) {
        if (key.hasOwnProperty(name)) {
          this.setLayout(name, key[name]);
        }
      }
      return;
    }
    this._layout[key] = val;
  };
  listProto.getLayout = function(key) {
    return this._layout[key];
  };
  listProto.getItemLayout = function(idx) {
    return this._itemLayouts[idx];
  };
  listProto.setItemLayout = function(idx, layout, merge) {
    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;
  };
  listProto.clearItemLayouts = function() {
    this._itemLayouts.length = 0;
  };
  listProto.getItemVisual = function(idx, key, ignoreParent) {
    var itemVisual = this._itemVisuals[idx];
    var val = itemVisual && itemVisual[key];
    if (val == null && !ignoreParent) {
      return this.getVisual(key);
    }
    return val;
  };
  listProto.setItemVisual = function(idx, key, value) {
    var itemVisual = this._itemVisuals[idx] || {};
    this._itemVisuals[idx] = itemVisual;
    if (isObject(key)) {
      for (var name in key) {
        if (key.hasOwnProperty(name)) {
          itemVisual[name] = key[name];
        }
      }
      return;
    }
    itemVisual[key] = value;
  };
  listProto.clearAllVisual = function() {
    this._visual = {};
    this._itemVisuals = [];
  };
  var setItemDataAndSeriesIndex = function(child) {
    child.seriesIndex = this.seriesIndex;
    child.dataIndex = this.dataIndex;
    child.dataType = this.dataType;
  };
  listProto.setItemGraphicEl = function(idx, el) {
    var hostModel = this.hostModel;
    if (el) {
      el.dataIndex = idx;
      el.dataType = this.dataType;
      el.seriesIndex = hostModel && hostModel.seriesIndex;
      if (el.type === 'group') {
        el.traverse(setItemDataAndSeriesIndex, el);
      }
    }
    this._graphicEls[idx] = el;
  };
  listProto.getItemGraphicEl = function(idx) {
    return this._graphicEls[idx];
  };
  listProto.eachItemGraphicEl = function(cb, context) {
    zrUtil.each(this._graphicEls, function(el, idx) {
      if (el) {
        cb && cb.call(context, el, idx);
      }
    });
  };
  listProto.cloneShallow = function() {
    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);
    var list = new List(dimensionInfoList, this.hostModel);
    list._storage = this._storage;
    transferProperties(list, this);
    list.indices = this.indices.slice();
    if (this._extent) {
      list._extent = zrUtil.extend({}, this._extent);
    }
    return list;
  };
  listProto.wrapMethod = function(methodName, injectFunction) {
    var originalMethod = this[methodName];
    if (typeof originalMethod !== 'function') {
      return;
    }
    this.__wrappedMethods = this.__wrappedMethods || [];
    this.__wrappedMethods.push(methodName);
    this[methodName] = function() {
      var res = originalMethod.apply(this, arguments);
      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));
    };
  };
  listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];
  listProto.CHANGABLE_METHODS = ['filterSelf'];
  module.exports = List;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/util/clazz.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var clazz = {};
  var TYPE_DELIMITER = '.';
  var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';
  var parseClassType = clazz.parseClassType = function(componentType) {
    var ret = {
      main: '',
      sub: ''
    };
    if (componentType) {
      componentType = componentType.split(TYPE_DELIMITER);
      ret.main = componentType[0] || '';
      ret.sub = componentType[1] || '';
    }
    return ret;
  };
  clazz.enableClassExtend = function(RootClass) {
    RootClass.$constructor = RootClass;
    RootClass.extend = function(proto) {
      var superClass = this;
      var ExtendedClass = function() {
        if (!proto.$constructor) {
          superClass.apply(this, arguments);
        } else {
          proto.$constructor.apply(this, arguments);
        }
      };
      zrUtil.extend(ExtendedClass.prototype, proto);
      ExtendedClass.extend = this.extend;
      ExtendedClass.superCall = superCall;
      ExtendedClass.superApply = superApply;
      zrUtil.inherits(ExtendedClass, this);
      ExtendedClass.superClass = superClass;
      return ExtendedClass;
    };
  };
  function superCall(context, methodName) {
    var args = zrUtil.slice(arguments, 2);
    return this.superClass.prototype[methodName].apply(context, args);
  }
  function superApply(context, methodName, args) {
    return this.superClass.prototype[methodName].apply(context, args);
  }
  clazz.enableClassManagement = function(entity, options) {
    options = options || {};
    var storage = {};
    entity.registerClass = function(Clazz, componentType) {
      if (componentType) {
        componentType = parseClassType(componentType);
        if (!componentType.sub) {
          if (__DEV__) {
            if (storage[componentType.main]) {
              console.warn(componentType.main + ' exists.');
            }
          }
          storage[componentType.main] = Clazz;
        } else if (componentType.sub !== IS_CONTAINER) {
          var container = makeContainer(componentType);
          container[componentType.sub] = Clazz;
        }
      }
      return Clazz;
    };
    entity.getClass = function(componentTypeMain, subType, throwWhenNotFound) {
      var Clazz = storage[componentTypeMain];
      if (Clazz && Clazz[IS_CONTAINER]) {
        Clazz = subType ? Clazz[subType] : null;
      }
      if (throwWhenNotFound && !Clazz) {
        throw new Error('Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.');
      }
      return Clazz;
    };
    entity.getClassesByMainType = function(componentType) {
      componentType = parseClassType(componentType);
      var result = [];
      var obj = storage[componentType.main];
      if (obj && obj[IS_CONTAINER]) {
        zrUtil.each(obj, function(o, type) {
          type !== IS_CONTAINER && result.push(o);
        });
      } else {
        result.push(obj);
      }
      return result;
    };
    entity.hasClass = function(componentType) {
      componentType = parseClassType(componentType);
      return !!storage[componentType.main];
    };
    entity.getAllClassMainTypes = function() {
      var types = [];
      zrUtil.each(storage, function(obj, type) {
        types.push(type);
      });
      return types;
    };
    entity.hasSubTypes = function(componentType) {
      componentType = parseClassType(componentType);
      var obj = storage[componentType.main];
      return obj && obj[IS_CONTAINER];
    };
    entity.parseClassType = parseClassType;
    function makeContainer(componentType) {
      var container = storage[componentType.main];
      if (!container || !container[IS_CONTAINER]) {
        container = storage[componentType.main] = {};
        container[IS_CONTAINER] = true;
      }
      return container;
    }
    if (options.registerWhenExtend) {
      var originalExtend = entity.extend;
      if (originalExtend) {
        entity.extend = function(proto) {
          var ExtendedClass = originalExtend.call(this, proto);
          return entity.registerClass(ExtendedClass, proto.type);
        };
      }
    }
    return entity;
  };
  clazz.setReadOnly = function(obj, properties) {};
  module.exports = clazz;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/model/mixin/lineStyle.js", ["./makeStyleMapper", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var getLineStyle = $__require('./makeStyleMapper')([['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);
  module.exports = {
    getLineStyle: function(excludes) {
      var style = getLineStyle.call(this, excludes);
      var lineDash = this.getLineDash();
      lineDash && (style.lineDash = lineDash);
      return style;
    },
    getLineDash: function() {
      var lineType = this.get('type');
      return (lineType === 'solid' || lineType == null) ? null : (lineType === 'dashed' ? [5, 5] : [1, 1]);
    }
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/model/mixin/areaStyle.js", ["./makeStyleMapper", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {getAreaStyle: $__require('./makeStyleMapper')([['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']])};
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/model/mixin/textStyle.js", ["zrender/lib/contain/text", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var textContain = $__require('zrender/lib/contain/text');
  function getShallow(model, path) {
    return model && model.getShallow(path);
  }
  module.exports = {
    getTextColor: function() {
      var ecModel = this.ecModel;
      return this.getShallow('color') || (ecModel && ecModel.get('textStyle.color'));
    },
    getFont: function() {
      var ecModel = this.ecModel;
      var gTextStyleModel = ecModel && ecModel.getModel('textStyle');
      return [this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'), this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'), (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px', this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'].join(' ');
    },
    getTextRect: function(text) {
      var textStyle = this.get('textStyle') || {};
      return textContain.getBoundingRect(text, this.getFont(), textStyle.align, textStyle.baseline);
    },
    truncateText: function(text, containerWidth, ellipsis, options) {
      return textContain.truncateText(text, containerWidth, this.getFont(), ellipsis, options);
    }
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/model/mixin/makeStyleMapper.js", ["zrender/lib/core/util", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  module.exports = function(properties) {
    for (var i = 0; i < properties.length; i++) {
      if (!properties[i][1]) {
        properties[i][1] = properties[i][0];
      }
    }
    return function(excludes) {
      var style = {};
      for (var i = 0; i < properties.length; i++) {
        var propName = properties[i][1];
        if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {
          continue;
        }
        var val = this.getShallow(propName);
        if (val != null) {
          style[properties[i][0]] = val;
        }
      }
      return style;
    };
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/model/mixin/itemStyle.js", ["./makeStyleMapper", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var getItemStyle = $__require('./makeStyleMapper')([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);
  module.exports = {
    getItemStyle: function(excludes) {
      var style = getItemStyle.call(this, excludes);
      var lineDash = this.getBorderLineDash();
      lineDash && (style.lineDash = lineDash);
      return style;
    },
    getBorderLineDash: function() {
      var lineType = this.get('borderType');
      return (lineType === 'solid' || lineType == null) ? null : (lineType === 'dashed' ? [5, 5] : [1, 1]);
    }
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/model/Model.js", ["zrender/lib/core/util", "../util/clazz", "./mixin/lineStyle", "./mixin/areaStyle", "./mixin/textStyle", "./mixin/itemStyle", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var clazzUtil = $__require('../util/clazz');
  function Model(option, parentModel, ecModel) {
    this.parentModel = parentModel;
    this.ecModel = ecModel;
    this.option = option;
  }
  Model.prototype = {
    constructor: Model,
    init: null,
    mergeOption: function(option) {
      zrUtil.merge(this.option, option, true);
    },
    get: function(path, ignoreParent) {
      if (!path) {
        return this.option;
      }
      if (typeof path === 'string') {
        path = path.split('.');
      }
      var obj = this.option;
      var parentModel = this.parentModel;
      for (var i = 0; i < path.length; i++) {
        if (!path[i]) {
          continue;
        }
        obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;
        if (obj == null) {
          break;
        }
      }
      if (obj == null && parentModel && !ignoreParent) {
        obj = parentModel.get(path);
      }
      return obj;
    },
    getShallow: function(key, ignoreParent) {
      var option = this.option;
      var val = option && option[key];
      var parentModel = this.parentModel;
      if (val == null && parentModel && !ignoreParent) {
        val = parentModel.getShallow(key);
      }
      return val;
    },
    getModel: function(path, parentModel) {
      var obj = this.get(path, true);
      var thisParentModel = this.parentModel;
      var model = new Model(obj, parentModel || (thisParentModel && thisParentModel.getModel(path)), this.ecModel);
      return model;
    },
    isEmpty: function() {
      return this.option == null;
    },
    restoreData: function() {},
    clone: function() {
      var Ctor = this.constructor;
      return new Ctor(zrUtil.clone(this.option));
    },
    setReadOnly: function(properties) {
      clazzUtil.setReadOnly(this, properties);
    }
  };
  clazzUtil.enableClassExtend(Model);
  var mixin = zrUtil.mixin;
  mixin(Model, $__require('./mixin/lineStyle'));
  mixin(Model, $__require('./mixin/areaStyle'));
  mixin(Model, $__require('./mixin/textStyle'));
  mixin(Model, $__require('./mixin/itemStyle'));
  module.exports = Model;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/util/number.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var number = {};
  var RADIAN_EPSILON = 1e-4;
  function _trim(str) {
    return str.replace(/^\s+/, '').replace(/\s+$/, '');
  }
  number.linearMap = function(val, domain, range, clamp) {
    var subDomain = domain[1] - domain[0];
    var subRange = range[1] - range[0];
    if (subDomain === 0) {
      return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;
    }
    if (clamp) {
      if (subDomain > 0) {
        if (val <= domain[0]) {
          return range[0];
        } else if (val >= domain[1]) {
          return range[1];
        }
      } else {
        if (val >= domain[0]) {
          return range[0];
        } else if (val <= domain[1]) {
          return range[1];
        }
      }
    } else {
      if (val === domain[0]) {
        return range[0];
      }
      if (val === domain[1]) {
        return range[1];
      }
    }
    return (val - domain[0]) / subDomain * subRange + range[0];
  };
  number.parsePercent = function(percent, all) {
    switch (percent) {
      case 'center':
      case 'middle':
        percent = '50%';
        break;
      case 'left':
      case 'top':
        percent = '0%';
        break;
      case 'right':
      case 'bottom':
        percent = '100%';
        break;
    }
    if (typeof percent === 'string') {
      if (_trim(percent).match(/%$/)) {
        return parseFloat(percent) / 100 * all;
      }
      return parseFloat(percent);
    }
    return percent == null ? NaN : +percent;
  };
  number.round = function(x) {
    return +(+x).toFixed(10);
  };
  number.asc = function(arr) {
    arr.sort(function(a, b) {
      return a - b;
    });
    return arr;
  };
  number.getPrecision = function(val) {
    val = +val;
    if (isNaN(val)) {
      return 0;
    }
    var e = 1;
    var count = 0;
    while (Math.round(val * e) / e !== val) {
      e *= 10;
      count++;
    }
    return count;
  };
  number.getPixelPrecision = function(dataExtent, pixelExtent) {
    var log = Math.log;
    var LN10 = Math.LN10;
    var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
    var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
    return Math.max(-dataQuantity + sizeQuantity, 0);
  };
  number.MAX_SAFE_INTEGER = 9007199254740991;
  number.remRadian = function(radian) {
    var pi2 = Math.PI * 2;
    return (radian % pi2 + pi2) % pi2;
  };
  number.isRadianAroundZero = function(val) {
    return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
  };
  number.parseDate = function(value) {
    return value instanceof Date ? value : new Date(typeof value === 'string' ? (new Date(value.replace(/-/g, '/')) - new Date('1970/01/01')) : Math.round(value));
  };
  number.quantity = function(val) {
    return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));
  };
  number.nice = function(val, round) {
    var exp10 = number.quantity(val);
    var f = val / exp10;
    var nf;
    if (round) {
      if (f < 1.5) {
        nf = 1;
      } else if (f < 2.5) {
        nf = 2;
      } else if (f < 4) {
        nf = 3;
      } else if (f < 7) {
        nf = 5;
      } else {
        nf = 10;
      }
    } else {
      if (f < 1) {
        nf = 1;
      } else if (f < 2) {
        nf = 2;
      } else if (f < 3) {
        nf = 3;
      } else if (f < 5) {
        nf = 5;
      } else {
        nf = 10;
      }
    }
    return nf * exp10;
  };
  module.exports = number;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/util/format.js", ["zrender/lib/core/util", "./number", "zrender/lib/contain/text", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('zrender/lib/core/util');
  var numberUtil = $__require('./number');
  var textContain = $__require('zrender/lib/contain/text');
  function addCommas(x) {
    if (isNaN(x)) {
      return '-';
    }
    x = (x + '').split('.');
    return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (x.length > 1 ? ('.' + x[1]) : '');
  }
  function toCamelCase(str) {
    return str.toLowerCase().replace(/-(.)/g, function(match, group1) {
      return group1.toUpperCase();
    });
  }
  function normalizeCssArray(val) {
    var len = val.length;
    if (typeof(val) === 'number') {
      return [val, val, val, val];
    } else if (len === 2) {
      return [val[0], val[1], val[0], val[1]];
    } else if (len === 3) {
      return [val[0], val[1], val[2], val[1]];
    }
    return val;
  }
  function encodeHTML(source) {
    return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
  }
  var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
  function wrapVar(varName, seriesIdx) {
    return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
  }
  function formatTpl(tpl, paramsList) {
    if (!zrUtil.isArray(paramsList)) {
      paramsList = [paramsList];
    }
    var seriesLen = paramsList.length;
    if (!seriesLen) {
      return '';
    }
    var $vars = paramsList[0].$vars || [];
    for (var i = 0; i < $vars.length; i++) {
      var alias = TPL_VAR_ALIAS[i];
      tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
    }
    for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
      for (var k = 0; k < $vars.length; k++) {
        tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), paramsList[seriesIdx][$vars[k]]);
      }
    }
    return tpl;
  }
  function formatTime(tpl, value) {
    if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {
      tpl = 'MM-dd\nyyyy';
    }
    var date = numberUtil.parseDate(value);
    var y = date.getFullYear();
    var M = date.getMonth() + 1;
    var d = date.getDate();
    var h = date.getHours();
    var m = date.getMinutes();
    var s = date.getSeconds();
    tpl = tpl.replace('MM', s2d(M)).toLowerCase().replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);
    return tpl;
  }
  function s2d(str) {
    return str < 10 ? ('0' + str) : str;
  }
  module.exports = {
    normalizeCssArray: normalizeCssArray,
    addCommas: addCommas,
    toCamelCase: toCamelCase,
    encodeHTML: encodeHTML,
    formatTpl: formatTpl,
    formatTime: formatTime,
    truncateText: textContain.truncateText
  };
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/echarts.js", ["zrender/lib/core/env", "./model/Global", "./ExtensionAPI", "./CoordinateSystem", "./model/OptionManager", "./model/Component", "./model/Series", "./view/Component", "./view/Chart", "./util/graphic", "zrender", "zrender/lib/core/util", "zrender/lib/tool/color", "zrender/lib/mixin/Eventful", "zrender/lib/core/timsort", "./loading/default", "./visual/seriesColor", "./preprocessor/backwardCompat", "./data/List", "./model/Model", "./util/number", "./util/format", "zrender/lib/core/matrix", "zrender/lib/core/vector", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  if (typeof __DEV__ === 'undefined') {
    if (typeof window !== 'undefined') {
      window.__DEV__ = true;
    } else if (typeof global !== 'undefined') {
      global.__DEV__ = true;
    }
  }
  var env = $__require('zrender/lib/core/env');
  var GlobalModel = $__require('./model/Global');
  var ExtensionAPI = $__require('./ExtensionAPI');
  var CoordinateSystemManager = $__require('./CoordinateSystem');
  var OptionManager = $__require('./model/OptionManager');
  var ComponentModel = $__require('./model/Component');
  var SeriesModel = $__require('./model/Series');
  var ComponentView = $__require('./view/Component');
  var ChartView = $__require('./view/Chart');
  var graphic = $__require('./util/graphic');
  var zrender = $__require('zrender');
  var zrUtil = $__require('zrender/lib/core/util');
  var colorTool = $__require('zrender/lib/tool/color');
  var Eventful = $__require('zrender/lib/mixin/Eventful');
  var timsort = $__require('zrender/lib/core/timsort');
  var each = zrUtil.each;
  var PRIORITY_PROCESSOR_FILTER = 1000;
  var PRIORITY_PROCESSOR_STATISTIC = 5000;
  var PRIORITY_VISUAL_LAYOUT = 1000;
  var PRIORITY_VISUAL_GLOBAL = 2000;
  var PRIORITY_VISUAL_CHART = 3000;
  var PRIORITY_VISUAL_COMPONENT = 4000;
  var PRIORITY_VISUAL_BRUSH = 5000;
  var IN_MAIN_PROCESS = '__flag_in_main_process';
  var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';
  function createRegisterEventWithLowercaseName(method) {
    return function(eventName, handler, context) {
      eventName = eventName && eventName.toLowerCase();
      Eventful.prototype[method].call(this, eventName, handler, context);
    };
  }
  function MessageCenter() {
    Eventful.call(this);
  }
  MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');
  MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');
  MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');
  zrUtil.mixin(MessageCenter, Eventful);
  function ECharts(dom, theme, opts) {
    opts = opts || {};
    if (typeof theme === 'string') {
      theme = themeStorage[theme];
    }
    this.id;
    this.group;
    this._dom = dom;
    this._zr = zrender.init(dom, {
      renderer: opts.renderer || 'canvas',
      devicePixelRatio: opts.devicePixelRatio
    });
    this._theme = zrUtil.clone(theme);
    this._chartsViews = [];
    this._chartsMap = {};
    this._componentsViews = [];
    this._componentsMap = {};
    this._api = new ExtensionAPI(this);
    this._coordSysMgr = new CoordinateSystemManager();
    Eventful.call(this);
    this._messageCenter = new MessageCenter();
    this._initEvents();
    this.resize = zrUtil.bind(this.resize, this);
    this._pendingActions = [];
    function prioritySortFunc(a, b) {
      return a.prio - b.prio;
    }
    timsort(visualFuncs, prioritySortFunc);
    timsort(dataProcessorFuncs, prioritySortFunc);
  }
  var echartsProto = ECharts.prototype;
  echartsProto.getDom = function() {
    return this._dom;
  };
  echartsProto.getZr = function() {
    return this._zr;
  };
  echartsProto.setOption = function(option, notMerge, notRefreshImmediately) {
    if (__DEV__) {
      zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');
    }
    this[IN_MAIN_PROCESS] = true;
    if (!this._model || notMerge) {
      var optionManager = new OptionManager(this._api);
      var theme = this._theme;
      var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);
      ecModel.init(null, null, theme, optionManager);
    }
    this._model.setOption(option, optionPreprocessorFuncs);
    updateMethods.prepareAndUpdate.call(this);
    this[IN_MAIN_PROCESS] = false;
    this._flushPendingActions();
    !notRefreshImmediately && this._zr.refreshImmediately();
  };
  echartsProto.setTheme = function() {
    console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');
  };
  echartsProto.getModel = function() {
    return this._model;
  };
  echartsProto.getOption = function() {
    return this._model.getOption();
  };
  echartsProto.getWidth = function() {
    return this._zr.getWidth();
  };
  echartsProto.getHeight = function() {
    return this._zr.getHeight();
  };
  echartsProto.getRenderedCanvas = function(opts) {
    if (!env.canvasSupported) {
      return;
    }
    opts = opts || {};
    opts.pixelRatio = opts.pixelRatio || 1;
    opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');
    var zr = this._zr;
    var list = zr.storage.getDisplayList();
    zrUtil.each(list, function(el) {
      el.stopAnimation(true);
    });
    return zr.painter.getRenderedCanvas(opts);
  };
  echartsProto.getDataURL = function(opts) {
    opts = opts || {};
    var excludeComponents = opts.excludeComponents;
    var ecModel = this._model;
    var excludesComponentViews = [];
    var self = this;
    each(excludeComponents, function(componentType) {
      ecModel.eachComponent({mainType: componentType}, function(component) {
        var view = self._componentsMap[component.__viewId];
        if (!view.group.ignore) {
          excludesComponentViews.push(view);
          view.group.ignore = true;
        }
      });
    });
    var url = this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));
    each(excludesComponentViews, function(view) {
      view.group.ignore = false;
    });
    return url;
  };
  echartsProto.getConnectedDataURL = function(opts) {
    if (!env.canvasSupported) {
      return;
    }
    var groupId = this.group;
    var mathMin = Math.min;
    var mathMax = Math.max;
    var MAX_NUMBER = Infinity;
    if (connectedGroups[groupId]) {
      var left = MAX_NUMBER;
      var top = MAX_NUMBER;
      var right = -MAX_NUMBER;
      var bottom = -MAX_NUMBER;
      var canvasList = [];
      var dpr = (opts && opts.pixelRatio) || 1;
      for (var id in instances) {
        var chart = instances[id];
        if (chart.group === groupId) {
          var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));
          var boundingRect = chart.getDom().getBoundingClientRect();
          left = mathMin(boundingRect.left, left);
          top = mathMin(boundingRect.top, top);
          right = mathMax(boundingRect.right, right);
          bottom = mathMax(boundingRect.bottom, bottom);
          canvasList.push({
            dom: canvas,
            left: boundingRect.left,
            top: boundingRect.top
          });
        }
      }
      left *= dpr;
      top *= dpr;
      right *= dpr;
      bottom *= dpr;
      var width = right - left;
      var height = bottom - top;
      var targetCanvas = zrUtil.createCanvas();
      targetCanvas.width = width;
      targetCanvas.height = height;
      var zr = zrender.init(targetCanvas);
      each(canvasList, function(item) {
        var img = new graphic.Image({style: {
            x: item.left * dpr - left,
            y: item.top * dpr - top,
            image: item.dom
          }});
        zr.add(img);
      });
      zr.refreshImmediately();
      return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));
    } else {
      return this.getDataURL(opts);
    }
  };
  var updateMethods = {
    update: function(payload) {
      var ecModel = this._model;
      var api = this._api;
      var coordSysMgr = this._coordSysMgr;
      var zr = this._zr;
      if (!ecModel) {
        return;
      }
      ecModel.restoreData();
      coordSysMgr.create(this._model, this._api);
      processData.call(this, ecModel, api);
      stackSeriesData.call(this, ecModel);
      coordSysMgr.update(ecModel, api);
      doVisualEncoding.call(this, ecModel, payload);
      doRender.call(this, ecModel, payload);
      var backgroundColor = ecModel.get('backgroundColor') || 'transparent';
      var painter = zr.painter;
      if (painter.isSingleCanvas && painter.isSingleCanvas()) {
        zr.configLayer(0, {clearColor: backgroundColor});
      } else {
        if (!env.canvasSupported) {
          var colorArr = colorTool.parse(backgroundColor);
          backgroundColor = colorTool.stringify(colorArr, 'rgb');
          if (colorArr[3] === 0) {
            backgroundColor = 'transparent';
          }
        }
        if (backgroundColor.colorStops || backgroundColor.image) {
          zr.configLayer(0, {clearColor: backgroundColor});
          this[HAS_GRADIENT_OR_PATTERN_BG] = true;
          this._dom.style.background = 'transparent';
        } else {
          if (this[HAS_GRADIENT_OR_PATTERN_BG]) {
            zr.configLayer(0, {clearColor: null});
          }
          this[HAS_GRADIENT_OR_PATTERN_BG] = false;
          this._dom.style.background = backgroundColor;
        }
      }
    },
    updateView: function(payload) {
      var ecModel = this._model;
      if (!ecModel) {
        return;
      }
      ecModel.eachSeries(function(seriesModel) {
        seriesModel.getData().clearAllVisual();
      });
      doVisualEncoding.call(this, ecModel, payload);
      invokeUpdateMethod.call(this, 'updateView', ecModel, payload);
    },
    updateVisual: function(payload) {
      var ecModel = this._model;
      if (!ecModel) {
        return;
      }
      ecModel.eachSeries(function(seriesModel) {
        seriesModel.getData().clearAllVisual();
      });
      doVisualEncoding.call(this, ecModel, payload);
      invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);
    },
    updateLayout: function(payload) {
      var ecModel = this._model;
      if (!ecModel) {
        return;
      }
      doLayout.call(this, ecModel, payload);
      invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);
    },
    highlight: function(payload) {
      toggleHighlight.call(this, 'highlight', payload);
    },
    downplay: function(payload) {
      toggleHighlight.call(this, 'downplay', payload);
    },
    prepareAndUpdate: function(payload) {
      var ecModel = this._model;
      prepareView.call(this, 'component', ecModel);
      prepareView.call(this, 'chart', ecModel);
      updateMethods.update.call(this, payload);
    }
  };
  function toggleHighlight(method, payload) {
    var ecModel = this._model;
    if (!ecModel) {
      return;
    }
    ecModel.eachComponent({
      mainType: 'series',
      query: payload
    }, function(seriesModel, index) {
      var chartView = this._chartsMap[seriesModel.__viewId];
      if (chartView && chartView.__alive) {
        chartView[method](seriesModel, ecModel, this._api, payload);
      }
    }, this);
  }
  echartsProto.resize = function() {
    if (__DEV__) {
      zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');
    }
    this[IN_MAIN_PROCESS] = true;
    this._zr.resize();
    var optionChanged = this._model && this._model.resetOption('media');
    updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);
    this._loadingFX && this._loadingFX.resize();
    this[IN_MAIN_PROCESS] = false;
    this._flushPendingActions();
  };
  var defaultLoadingEffect = $__require('./loading/default');
  echartsProto.showLoading = function(name, cfg) {
    if (zrUtil.isObject(name)) {
      cfg = name;
      name = 'default';
    }
    this.hideLoading();
    var el = defaultLoadingEffect(this._api, cfg);
    var zr = this._zr;
    this._loadingFX = el;
    zr.add(el);
  };
  echartsProto.hideLoading = function() {
    this._loadingFX && this._zr.remove(this._loadingFX);
    this._loadingFX = null;
  };
  echartsProto.makeActionFromEvent = function(eventObj) {
    var payload = zrUtil.extend({}, eventObj);
    payload.type = eventActionMap[eventObj.type];
    return payload;
  };
  echartsProto.dispatchAction = function(payload, silent) {
    var actionWrap = actions[payload.type];
    if (!actionWrap) {
      return;
    }
    var actionInfo = actionWrap.actionInfo;
    var updateMethod = actionInfo.update || 'update';
    if (this[IN_MAIN_PROCESS]) {
      this._pendingActions.push(payload);
      return;
    }
    this[IN_MAIN_PROCESS] = true;
    var payloads = [payload];
    var batched = false;
    if (payload.batch) {
      batched = true;
      payloads = zrUtil.map(payload.batch, function(item) {
        item = zrUtil.defaults(zrUtil.extend({}, item), payload);
        item.batch = null;
        return item;
      });
    }
    var eventObjBatch = [];
    var eventObj;
    var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';
    for (var i = 0; i < payloads.length; i++) {
      var batchItem = payloads[i];
      eventObj = actionWrap.action(batchItem, this._model);
      eventObj = eventObj || zrUtil.extend({}, batchItem);
      eventObj.type = actionInfo.event || eventObj.type;
      eventObjBatch.push(eventObj);
      isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);
    }
    (updateMethod !== 'none' && !isHighlightOrDownplay) && updateMethods[updateMethod].call(this, payload);
    if (batched) {
      eventObj = {
        type: actionInfo.event || payload.type,
        batch: eventObjBatch
      };
    } else {
      eventObj = eventObjBatch[0];
    }
    this[IN_MAIN_PROCESS] = false;
    !silent && this._messageCenter.trigger(eventObj.type, eventObj);
    this._flushPendingActions();
  };
  echartsProto._flushPendingActions = function() {
    var pendingActions = this._pendingActions;
    while (pendingActions.length) {
      var payload = pendingActions.shift();
      this.dispatchAction(payload);
    }
  };
  echartsProto.on = createRegisterEventWithLowercaseName('on');
  echartsProto.off = createRegisterEventWithLowercaseName('off');
  echartsProto.one = createRegisterEventWithLowercaseName('one');
  function invokeUpdateMethod(methodName, ecModel, payload) {
    var api = this._api;
    each(this._componentsViews, function(component) {
      var componentModel = component.__model;
      component[methodName](componentModel, ecModel, api, payload);
      updateZ(componentModel, component);
    }, this);
    ecModel.eachSeries(function(seriesModel, idx) {
      var chart = this._chartsMap[seriesModel.__viewId];
      chart[methodName](seriesModel, ecModel, api, payload);
      updateZ(seriesModel, chart);
      updateProgressiveAndBlend(seriesModel, chart);
    }, this);
    updateHoverLayerStatus(this._zr, ecModel);
  }
  function prepareView(type, ecModel) {
    var isComponent = type === 'component';
    var viewList = isComponent ? this._componentsViews : this._chartsViews;
    var viewMap = isComponent ? this._componentsMap : this._chartsMap;
    var zr = this._zr;
    for (var i = 0; i < viewList.length; i++) {
      viewList[i].__alive = false;
    }
    ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function(componentType, model) {
      if (isComponent) {
        if (componentType === 'series') {
          return;
        }
      } else {
        model = componentType;
      }
      var viewId = model.id + '_' + model.type;
      var view = viewMap[viewId];
      if (!view) {
        var classType = ComponentModel.parseClassType(model.type);
        var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);
        if (Clazz) {
          view = new Clazz();
          view.init(ecModel, this._api);
          viewMap[viewId] = view;
          viewList.push(view);
          zr.add(view.group);
        } else {
          return;
        }
      }
      model.__viewId = viewId;
      view.__alive = true;
      view.__id = viewId;
      view.__model = model;
    }, this);
    for (var i = 0; i < viewList.length; ) {
      var view = viewList[i];
      if (!view.__alive) {
        zr.remove(view.group);
        view.dispose(ecModel, this._api);
        viewList.splice(i, 1);
        delete viewMap[view.__id];
      } else {
        i++;
      }
    }
  }
  function processData(ecModel, api) {
    each(dataProcessorFuncs, function(process) {
      process.func(ecModel, api);
    });
  }
  function stackSeriesData(ecModel) {
    var stackedDataMap = {};
    ecModel.eachSeries(function(series) {
      var stack = series.get('stack');
      var data = series.getData();
      if (stack && data.type === 'list') {
        var previousStack = stackedDataMap[stack];
        if (previousStack) {
          data.stackedOn = previousStack;
        }
        stackedDataMap[stack] = data;
      }
    });
  }
  function doLayout(ecModel, payload) {
    var api = this._api;
    each(visualFuncs, function(visual) {
      if (visual.isLayout) {
        visual.func(ecModel, api, payload);
      }
    });
  }
  function doVisualEncoding(ecModel, payload) {
    var api = this._api;
    ecModel.clearColorPalette();
    ecModel.eachSeries(function(seriesModel) {
      seriesModel.clearColorPalette();
    });
    each(visualFuncs, function(visual) {
      visual.func(ecModel, api, payload);
    });
  }
  function doRender(ecModel, payload) {
    var api = this._api;
    each(this._componentsViews, function(componentView) {
      var componentModel = componentView.__model;
      componentView.render(componentModel, ecModel, api, payload);
      updateZ(componentModel, componentView);
    }, this);
    each(this._chartsViews, function(chart) {
      chart.__alive = false;
    }, this);
    ecModel.eachSeries(function(seriesModel, idx) {
      var chartView = this._chartsMap[seriesModel.__viewId];
      chartView.__alive = true;
      chartView.render(seriesModel, ecModel, api, payload);
      chartView.group.silent = !!seriesModel.get('silent');
      updateZ(seriesModel, chartView);
      updateProgressiveAndBlend(seriesModel, chartView);
    }, this);
    updateHoverLayerStatus(this._zr, ecModel);
    each(this._chartsViews, function(chart) {
      if (!chart.__alive) {
        chart.remove(ecModel, api);
      }
    }, this);
  }
  var MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousedown', 'mouseup', 'globalout'];
  echartsProto._initEvents = function() {
    each(MOUSE_EVENT_NAMES, function(eveName) {
      this._zr.on(eveName, function(e) {
        var ecModel = this.getModel();
        var el = e.target;
        if (el && el.dataIndex != null) {
          var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
          var params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};
          params.event = e;
          params.type = eveName;
          this.trigger(eveName, params);
        } else if (el && el.eventData) {
          this.trigger(eveName, el.eventData);
        }
      }, this);
    }, this);
    each(eventActionMap, function(actionType, eventType) {
      this._messageCenter.on(eventType, function(event) {
        this.trigger(eventType, event);
      }, this);
    }, this);
  };
  echartsProto.isDisposed = function() {
    return this._disposed;
  };
  echartsProto.clear = function() {
    this.setOption({}, true);
  };
  echartsProto.dispose = function() {
    if (this._disposed) {
      if (__DEV__) {
        console.warn('Instance ' + this.id + ' has been disposed');
      }
      return;
    }
    this._disposed = true;
    var api = this._api;
    var ecModel = this._model;
    each(this._componentsViews, function(component) {
      component.dispose(ecModel, api);
    });
    each(this._chartsViews, function(chart) {
      chart.dispose(ecModel, api);
    });
    this._zr.dispose();
    delete instances[this.id];
  };
  zrUtil.mixin(ECharts, Eventful);
  function updateHoverLayerStatus(zr, ecModel) {
    var storage = zr.storage;
    var elCount = 0;
    storage.traverse(function(el) {
      if (!el.isGroup) {
        elCount++;
      }
    });
    if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {
      storage.traverse(function(el) {
        if (!el.isGroup) {
          el.useHoverLayer = true;
        }
      });
    }
  }
  function updateProgressiveAndBlend(seriesModel, chartView) {
    var elCount = 0;
    chartView.group.traverse(function(el) {
      if (el.type !== 'group' && !el.ignore) {
        elCount++;
      }
    });
    var frameDrawNum = +seriesModel.get('progressive');
    var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;
    if (needProgressive) {
      chartView.group.traverse(function(el) {
        if (!el.isGroup) {
          el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;
          if (needProgressive) {
            el.stopAnimation(true);
          }
        }
      });
    }
    var blendMode = seriesModel.get('blendMode') || null;
    if (__DEV__) {
      if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {
        console.warn('Only canvas support blendMode');
      }
    }
    chartView.group.traverse(function(el) {
      if (!el.isGroup) {
        el.setStyle('blend', blendMode);
      }
    });
  }
  function updateZ(model, view) {
    var z = model.get('z');
    var zlevel = model.get('zlevel');
    view.group.traverse(function(el) {
      if (el.type !== 'group') {
        z != null && (el.z = z);
        zlevel != null && (el.zlevel = zlevel);
      }
    });
  }
  var actions = [];
  var eventActionMap = {};
  var dataProcessorFuncs = [];
  var optionPreprocessorFuncs = [];
  var visualFuncs = [];
  var themeStorage = {};
  var instances = {};
  var connectedGroups = {};
  var idBase = new Date() - 0;
  var groupIdBase = new Date() - 0;
  var DOM_ATTRIBUTE_KEY = '_echarts_instance_';
  var echarts = {
    version: '3.2.2',
    dependencies: {zrender: '3.1.2'}
  };
  function enableConnect(chart) {
    var STATUS_PENDING = 0;
    var STATUS_UPDATING = 1;
    var STATUS_UPDATED = 2;
    var STATUS_KEY = '__connectUpdateStatus';
    function updateConnectedChartsStatus(charts, status) {
      for (var i = 0; i < charts.length; i++) {
        var otherChart = charts[i];
        otherChart[STATUS_KEY] = status;
      }
    }
    zrUtil.each(eventActionMap, function(actionType, eventType) {
      chart._messageCenter.on(eventType, function(event) {
        if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {
          var action = chart.makeActionFromEvent(event);
          var otherCharts = [];
          for (var id in instances) {
            var otherChart = instances[id];
            if (otherChart !== chart && otherChart.group === chart.group) {
              otherCharts.push(otherChart);
            }
          }
          updateConnectedChartsStatus(otherCharts, STATUS_PENDING);
          each(otherCharts, function(otherChart) {
            if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {
              otherChart.dispatchAction(action);
            }
          });
          updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);
        }
      });
    });
  }
  echarts.init = function(dom, theme, opts) {
    if (__DEV__) {
      if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {
        throw new Error('ZRender ' + zrender.version + ' is too old for ECharts ' + echarts.version + '. Current version need ZRender ' + echarts.dependencies.zrender + '+');
      }
      if (!dom) {
        throw new Error('Initialize failed: invalid dom.');
      }
      if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {
        console.warn('Can\'t get dom width or height');
      }
    }
    var chart = new ECharts(dom, theme, opts);
    chart.id = 'ec_' + idBase++;
    instances[chart.id] = chart;
    dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);
    enableConnect(chart);
    return chart;
  };
  echarts.connect = function(groupId) {
    if (zrUtil.isArray(groupId)) {
      var charts = groupId;
      groupId = null;
      zrUtil.each(charts, function(chart) {
        if (chart.group != null) {
          groupId = chart.group;
        }
      });
      groupId = groupId || ('g_' + groupIdBase++);
      zrUtil.each(charts, function(chart) {
        chart.group = groupId;
      });
    }
    connectedGroups[groupId] = true;
    return groupId;
  };
  echarts.disConnect = function(groupId) {
    connectedGroups[groupId] = false;
  };
  echarts.dispose = function(chart) {
    if (zrUtil.isDom(chart)) {
      chart = echarts.getInstanceByDom(chart);
    } else if (typeof chart === 'string') {
      chart = instances[chart];
    }
    if ((chart instanceof ECharts) && !chart.isDisposed()) {
      chart.dispose();
    }
  };
  echarts.getInstanceByDom = function(dom) {
    var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
    return instances[key];
  };
  echarts.getInstanceById = function(key) {
    return instances[key];
  };
  echarts.registerTheme = function(name, theme) {
    themeStorage[name] = theme;
  };
  echarts.registerPreprocessor = function(preprocessorFunc) {
    optionPreprocessorFuncs.push(preprocessorFunc);
  };
  echarts.registerProcessor = function(priority, processorFunc) {
    if (typeof priority === 'function') {
      processorFunc = priority;
      priority = PRIORITY_PROCESSOR_FILTER;
    }
    if (__DEV__) {
      if (isNaN(priority)) {
        throw new Error('Unkown processor priority');
      }
    }
    dataProcessorFuncs.push({
      prio: priority,
      func: processorFunc
    });
  };
  echarts.registerAction = function(actionInfo, eventName, action) {
    if (typeof eventName === 'function') {
      action = eventName;
      eventName = '';
    }
    var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : ([actionInfo, actionInfo = {event: eventName}][0]);
    actionInfo.event = (actionInfo.event || actionType).toLowerCase();
    eventName = actionInfo.event;
    if (!actions[actionType]) {
      actions[actionType] = {
        action: action,
        actionInfo: actionInfo
      };
    }
    eventActionMap[eventName] = actionType;
  };
  echarts.registerCoordinateSystem = function(type, CoordinateSystem) {
    CoordinateSystemManager.register(type, CoordinateSystem);
  };
  echarts.registerLayout = function(priority, layoutFunc) {
    if (typeof priority === 'function') {
      layoutFunc = priority;
      priority = PRIORITY_VISUAL_LAYOUT;
    }
    if (__DEV__) {
      if (isNaN(priority)) {
        throw new Error('Unkown layout priority');
      }
    }
    visualFuncs.push({
      prio: priority,
      func: layoutFunc,
      isLayout: true
    });
  };
  echarts.registerVisual = function(priority, visualFunc) {
    if (typeof priority === 'function') {
      visualFunc = priority;
      priority = PRIORITY_VISUAL_CHART;
    }
    if (__DEV__) {
      if (isNaN(priority)) {
        throw new Error('Unkown visual priority');
      }
    }
    visualFuncs.push({
      prio: priority,
      func: visualFunc
    });
  };
  var parseClassType = ComponentModel.parseClassType;
  echarts.extendComponentModel = function(opts, superClass) {
    var Clazz = ComponentModel;
    if (superClass) {
      var classType = parseClassType(superClass);
      Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
    }
    return Clazz.extend(opts);
  };
  echarts.extendComponentView = function(opts, superClass) {
    var Clazz = ComponentView;
    if (superClass) {
      var classType = parseClassType(superClass);
      Clazz = ComponentView.getClass(classType.main, classType.sub, true);
    }
    return Clazz.extend(opts);
  };
  echarts.extendSeriesModel = function(opts, superClass) {
    var Clazz = SeriesModel;
    if (superClass) {
      superClass = 'series.' + superClass.replace('series.', '');
      var classType = parseClassType(superClass);
      Clazz = SeriesModel.getClass(classType.main, classType.sub, true);
    }
    return Clazz.extend(opts);
  };
  echarts.extendChartView = function(opts, superClass) {
    var Clazz = ChartView;
    if (superClass) {
      superClass.replace('series.', '');
      var classType = parseClassType(superClass);
      Clazz = ChartView.getClass(classType.main, true);
    }
    return ChartView.extend(opts);
  };
  echarts.setCanvasCreator = function(creator) {
    zrUtil.createCanvas = creator;
  };
  echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, $__require('./visual/seriesColor'));
  echarts.registerPreprocessor($__require('./preprocessor/backwardCompat'));
  echarts.registerAction({
    type: 'highlight',
    event: 'highlight',
    update: 'highlight'
  }, zrUtil.noop);
  echarts.registerAction({
    type: 'downplay',
    event: 'downplay',
    update: 'downplay'
  }, zrUtil.noop);
  echarts.List = $__require('./data/List');
  echarts.Model = $__require('./model/Model');
  echarts.graphic = $__require('./util/graphic');
  echarts.number = $__require('./util/number');
  echarts.format = $__require('./util/format');
  echarts.matrix = $__require('zrender/lib/core/matrix');
  echarts.vector = $__require('zrender/lib/core/vector');
  echarts.color = $__require('zrender/lib/tool/color');
  echarts.util = {};
  each(['map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter', 'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction', 'extend', 'defaults'], function(name) {
    echarts.util[name] = zrUtil[name];
  });
  echarts.PRIORITY = {
    PROCESSOR: {
      FILTER: PRIORITY_PROCESSOR_FILTER,
      STATISTIC: PRIORITY_PROCESSOR_STATISTIC
    },
    VISUAL: {
      LAYOUT: PRIORITY_VISUAL_LAYOUT,
      GLOBAL: PRIORITY_VISUAL_GLOBAL,
      CHART: PRIORITY_VISUAL_CHART,
      COMPONENT: PRIORITY_VISUAL_COMPONENT,
      BRUSH: PRIORITY_VISUAL_BRUSH
    }
  };
  module.exports = echarts;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/toolbox/feature/Restore.js", ["../../dataZoom/history", "../featureManager", "../../../echarts", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var history = $__require('../../dataZoom/history');
  function Restore(model) {
    this.model = model;
  }
  Restore.defaultOption = {
    show: true,
    icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',
    title: ''
  };
  var proto = Restore.prototype;
  proto.onclick = function(ecModel, api, type) {
    history.clear(ecModel);
    api.dispatchAction({
      type: 'restore',
      from: this.uid
    });
  };
  $__require('../featureManager').register('restore', Restore);
  $__require('../../../echarts').registerAction({
    type: 'restore',
    event: 'restore',
    update: 'prepareAndUpdate'
  }, function(payload, ecModel) {
    ecModel.resetOption('recreate');
  });
  module.exports = Restore;
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2/lib/component/toolbox.js", ["./toolbox/ToolboxModel", "./toolbox/ToolboxView", "./toolbox/feature/SaveAsImage", "./toolbox/feature/MagicType", "./toolbox/feature/DataView", "./toolbox/feature/DataZoom", "./toolbox/feature/Restore", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./toolbox/ToolboxModel');
  $__require('./toolbox/ToolboxView');
  $__require('./toolbox/feature/SaveAsImage');
  $__require('./toolbox/feature/MagicType');
  $__require('./toolbox/feature/DataView');
  $__require('./toolbox/feature/DataZoom');
  $__require('./toolbox/feature/Restore');
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/Text.js", ["./Displayable", "../core/util", "../contain/text"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Displayable = $__require('./Displayable');
  var zrUtil = $__require('../core/util');
  var textContain = $__require('../contain/text');
  var Text = function(opts) {
    Displayable.call(this, opts);
  };
  Text.prototype = {
    constructor: Text,
    type: 'text',
    brush: function(ctx, prevEl) {
      var style = this.style;
      var x = style.x || 0;
      var y = style.y || 0;
      var text = style.text;
      text != null && (text += '');
      style.bind(ctx, this, prevEl);
      if (text) {
        this.setTransform(ctx);
        var textBaseline;
        var textAlign = style.textAlign;
        var font = style.textFont || style.font;
        if (style.textVerticalAlign) {
          var rect = textContain.getBoundingRect(text, font, style.textAlign, 'top');
          textBaseline = 'middle';
          switch (style.textVerticalAlign) {
            case 'middle':
              y -= rect.height / 2 - rect.lineHeight / 2;
              break;
            case 'bottom':
              y -= rect.height - rect.lineHeight / 2;
              break;
            default:
              y += rect.lineHeight / 2;
          }
        } else {
          textBaseline = style.textBaseline;
        }
        ctx.font = font;
        ctx.textAlign = textAlign || 'left';
        if (ctx.textAlign !== textAlign) {
          ctx.textAlign = 'left';
        }
        ctx.textBaseline = textBaseline || 'alphabetic';
        if (ctx.textBaseline !== textBaseline) {
          ctx.textBaseline = 'alphabetic';
        }
        var lineHeight = textContain.measureText('', ctx.font).width;
        var textLines = text.split('\n');
        for (var i = 0; i < textLines.length; i++) {
          style.hasFill() && ctx.fillText(textLines[i], x, y);
          style.hasStroke() && ctx.strokeText(textLines[i], x, y);
          y += lineHeight;
        }
        this.restoreTransform(ctx);
      }
    },
    getBoundingRect: function() {
      if (!this._rect) {
        var style = this.style;
        var textVerticalAlign = style.textVerticalAlign;
        var rect = textContain.getBoundingRect(style.text + '', style.textFont || style.font, style.textAlign, textVerticalAlign ? 'top' : style.textBaseline);
        switch (textVerticalAlign) {
          case 'middle':
            rect.y -= rect.height / 2;
            break;
          case 'bottom':
            rect.y -= rect.height;
            break;
        }
        rect.x += style.x || 0;
        rect.y += style.y || 0;
        this._rect = rect;
      }
      return this._rect;
    }
  };
  zrUtil.inherits(Text, Displayable);
  module.exports = Text;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/bbox.js", ["./vector", "./curve"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var vec2 = $__require('./vector');
  var curve = $__require('./curve');
  var bbox = {};
  var mathMin = Math.min;
  var mathMax = Math.max;
  var mathSin = Math.sin;
  var mathCos = Math.cos;
  var start = vec2.create();
  var end = vec2.create();
  var extremity = vec2.create();
  var PI2 = Math.PI * 2;
  bbox.fromPoints = function(points, min, max) {
    if (points.length === 0) {
      return;
    }
    var p = points[0];
    var left = p[0];
    var right = p[0];
    var top = p[1];
    var bottom = p[1];
    var i;
    for (i = 1; i < points.length; i++) {
      p = points[i];
      left = mathMin(left, p[0]);
      right = mathMax(right, p[0]);
      top = mathMin(top, p[1]);
      bottom = mathMax(bottom, p[1]);
    }
    min[0] = left;
    min[1] = top;
    max[0] = right;
    max[1] = bottom;
  };
  bbox.fromLine = function(x0, y0, x1, y1, min, max) {
    min[0] = mathMin(x0, x1);
    min[1] = mathMin(y0, y1);
    max[0] = mathMax(x0, x1);
    max[1] = mathMax(y0, y1);
  };
  var xDim = [];
  var yDim = [];
  bbox.fromCubic = function(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
    var cubicExtrema = curve.cubicExtrema;
    var cubicAt = curve.cubicAt;
    var i;
    var n = cubicExtrema(x0, x1, x2, x3, xDim);
    min[0] = Infinity;
    min[1] = Infinity;
    max[0] = -Infinity;
    max[1] = -Infinity;
    for (i = 0; i < n; i++) {
      var x = cubicAt(x0, x1, x2, x3, xDim[i]);
      min[0] = mathMin(x, min[0]);
      max[0] = mathMax(x, max[0]);
    }
    n = cubicExtrema(y0, y1, y2, y3, yDim);
    for (i = 0; i < n; i++) {
      var y = cubicAt(y0, y1, y2, y3, yDim[i]);
      min[1] = mathMin(y, min[1]);
      max[1] = mathMax(y, max[1]);
    }
    min[0] = mathMin(x0, min[0]);
    max[0] = mathMax(x0, max[0]);
    min[0] = mathMin(x3, min[0]);
    max[0] = mathMax(x3, max[0]);
    min[1] = mathMin(y0, min[1]);
    max[1] = mathMax(y0, max[1]);
    min[1] = mathMin(y3, min[1]);
    max[1] = mathMax(y3, max[1]);
  };
  bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {
    var quadraticExtremum = curve.quadraticExtremum;
    var quadraticAt = curve.quadraticAt;
    var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
    var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
    var x = quadraticAt(x0, x1, x2, tx);
    var y = quadraticAt(y0, y1, y2, ty);
    min[0] = mathMin(x0, x2, x);
    min[1] = mathMin(y0, y2, y);
    max[0] = mathMax(x0, x2, x);
    max[1] = mathMax(y0, y2, y);
  };
  bbox.fromArc = function(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
    var vec2Min = vec2.min;
    var vec2Max = vec2.max;
    var diff = Math.abs(startAngle - endAngle);
    if (diff % PI2 < 1e-4 && diff > 1e-4) {
      min[0] = x - rx;
      min[1] = y - ry;
      max[0] = x + rx;
      max[1] = y + ry;
      return;
    }
    start[0] = mathCos(startAngle) * rx + x;
    start[1] = mathSin(startAngle) * ry + y;
    end[0] = mathCos(endAngle) * rx + x;
    end[1] = mathSin(endAngle) * ry + y;
    vec2Min(min, start, end);
    vec2Max(max, start, end);
    startAngle = startAngle % (PI2);
    if (startAngle < 0) {
      startAngle = startAngle + PI2;
    }
    endAngle = endAngle % (PI2);
    if (endAngle < 0) {
      endAngle = endAngle + PI2;
    }
    if (startAngle > endAngle && !anticlockwise) {
      endAngle += PI2;
    } else if (startAngle < endAngle && anticlockwise) {
      startAngle += PI2;
    }
    if (anticlockwise) {
      var tmp = endAngle;
      endAngle = startAngle;
      startAngle = tmp;
    }
    for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
      if (angle > startAngle) {
        extremity[0] = mathCos(angle) * rx + x;
        extremity[1] = mathSin(angle) * ry + y;
        vec2Min(min, extremity, min);
        vec2Max(max, extremity, max);
      }
    }
  };
  module.exports = bbox;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/PathProxy.js", ["./curve", "./vector", "./bbox", "./BoundingRect", "../config"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var curve = $__require('./curve');
  var vec2 = $__require('./vector');
  var bbox = $__require('./bbox');
  var BoundingRect = $__require('./BoundingRect');
  var dpr = $__require('../config').devicePixelRatio;
  var CMD = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,
    R: 7
  };
  var min = [];
  var max = [];
  var min2 = [];
  var max2 = [];
  var mathMin = Math.min;
  var mathMax = Math.max;
  var mathCos = Math.cos;
  var mathSin = Math.sin;
  var mathSqrt = Math.sqrt;
  var mathAbs = Math.abs;
  var hasTypedArray = typeof Float32Array != 'undefined';
  var PathProxy = function() {
    this.data = [];
    this._len = 0;
    this._ctx = null;
    this._xi = 0;
    this._yi = 0;
    this._x0 = 0;
    this._y0 = 0;
    this._ux = 0;
    this._uy = 0;
  };
  PathProxy.prototype = {
    constructor: PathProxy,
    _lineDash: null,
    _dashOffset: 0,
    _dashIdx: 0,
    _dashSum: 0,
    setScale: function(sx, sy) {
      this._ux = mathAbs(1 / dpr / sx) || 0;
      this._uy = mathAbs(1 / dpr / sy) || 0;
    },
    getContext: function() {
      return this._ctx;
    },
    beginPath: function(ctx) {
      this._ctx = ctx;
      ctx && ctx.beginPath();
      this._len = 0;
      if (this._lineDash) {
        this._lineDash = null;
        this._dashOffset = 0;
      }
      return this;
    },
    moveTo: function(x, y) {
      this.addData(CMD.M, x, y);
      this._ctx && this._ctx.moveTo(x, y);
      this._x0 = x;
      this._y0 = y;
      this._xi = x;
      this._yi = y;
      return this;
    },
    lineTo: function(x, y) {
      var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;
      this.addData(CMD.L, x, y);
      if (this._ctx && exceedUnit) {
        this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
      }
      if (exceedUnit) {
        this._xi = x;
        this._yi = y;
      }
      return this;
    },
    bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
      this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
      if (this._ctx) {
        this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
      }
      this._xi = x3;
      this._yi = y3;
      return this;
    },
    quadraticCurveTo: function(x1, y1, x2, y2) {
      this.addData(CMD.Q, x1, y1, x2, y2);
      if (this._ctx) {
        this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
      }
      this._xi = x2;
      this._yi = y2;
      return this;
    },
    arc: function(cx, cy, r, startAngle, endAngle, anticlockwise) {
      this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
      this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
      this._xi = mathCos(endAngle) * r + cx;
      this._xi = mathSin(endAngle) * r + cx;
      return this;
    },
    arcTo: function(x1, y1, x2, y2, radius) {
      if (this._ctx) {
        this._ctx.arcTo(x1, y1, x2, y2, radius);
      }
      return this;
    },
    rect: function(x, y, w, h) {
      this._ctx && this._ctx.rect(x, y, w, h);
      this.addData(CMD.R, x, y, w, h);
      return this;
    },
    closePath: function() {
      this.addData(CMD.Z);
      var ctx = this._ctx;
      var x0 = this._x0;
      var y0 = this._y0;
      if (ctx) {
        this._needsDash() && this._dashedLineTo(x0, y0);
        ctx.closePath();
      }
      this._xi = x0;
      this._yi = y0;
      return this;
    },
    fill: function(ctx) {
      ctx && ctx.fill();
      this.toStatic();
    },
    stroke: function(ctx) {
      ctx && ctx.stroke();
      this.toStatic();
    },
    setLineDash: function(lineDash) {
      if (lineDash instanceof Array) {
        this._lineDash = lineDash;
        this._dashIdx = 0;
        var lineDashSum = 0;
        for (var i = 0; i < lineDash.length; i++) {
          lineDashSum += lineDash[i];
        }
        this._dashSum = lineDashSum;
      }
      return this;
    },
    setLineDashOffset: function(offset) {
      this._dashOffset = offset;
      return this;
    },
    len: function() {
      return this._len;
    },
    setData: function(data) {
      var len = data.length;
      if (!(this.data && this.data.length == len) && hasTypedArray) {
        this.data = new Float32Array(len);
      }
      for (var i = 0; i < len; i++) {
        this.data[i] = data[i];
      }
      this._len = len;
    },
    appendPath: function(path) {
      if (!(path instanceof Array)) {
        path = [path];
      }
      var len = path.length;
      var appendSize = 0;
      var offset = this._len;
      for (var i = 0; i < len; i++) {
        appendSize += path[i].len();
      }
      if (hasTypedArray && (this.data instanceof Float32Array)) {
        this.data = new Float32Array(offset + appendSize);
      }
      for (var i = 0; i < len; i++) {
        var appendPathData = path[i].data;
        for (var k = 0; k < appendPathData.length; k++) {
          this.data[offset++] = appendPathData[k];
        }
      }
      this._len = offset;
    },
    addData: function(cmd) {
      var data = this.data;
      if (this._len + arguments.length > data.length) {
        this._expandData();
        data = this.data;
      }
      for (var i = 0; i < arguments.length; i++) {
        data[this._len++] = arguments[i];
      }
      this._prevCmd = cmd;
    },
    _expandData: function() {
      if (!(this.data instanceof Array)) {
        var newData = [];
        for (var i = 0; i < this._len; i++) {
          newData[i] = this.data[i];
        }
        this.data = newData;
      }
    },
    _needsDash: function() {
      return this._lineDash;
    },
    _dashedLineTo: function(x1, y1) {
      var dashSum = this._dashSum;
      var offset = this._dashOffset;
      var lineDash = this._lineDash;
      var ctx = this._ctx;
      var x0 = this._xi;
      var y0 = this._yi;
      var dx = x1 - x0;
      var dy = y1 - y0;
      var dist = mathSqrt(dx * dx + dy * dy);
      var x = x0;
      var y = y0;
      var dash;
      var nDash = lineDash.length;
      var idx;
      dx /= dist;
      dy /= dist;
      if (offset < 0) {
        offset = dashSum + offset;
      }
      offset %= dashSum;
      x -= offset * dx;
      y -= offset * dy;
      while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1) || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {
        idx = this._dashIdx;
        dash = lineDash[idx];
        x += dx * dash;
        y += dy * dash;
        this._dashIdx = (idx + 1) % nDash;
        if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {
          continue;
        }
        ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
      }
      dx = x - x1;
      dy = y - y1;
      this._dashOffset = -mathSqrt(dx * dx + dy * dy);
    },
    _dashedBezierTo: function(x1, y1, x2, y2, x3, y3) {
      var dashSum = this._dashSum;
      var offset = this._dashOffset;
      var lineDash = this._lineDash;
      var ctx = this._ctx;
      var x0 = this._xi;
      var y0 = this._yi;
      var t;
      var dx;
      var dy;
      var cubicAt = curve.cubicAt;
      var bezierLen = 0;
      var idx = this._dashIdx;
      var nDash = lineDash.length;
      var x;
      var y;
      var tmpLen = 0;
      if (offset < 0) {
        offset = dashSum + offset;
      }
      offset %= dashSum;
      for (t = 0; t < 1; t += 0.1) {
        dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
        dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
        bezierLen += mathSqrt(dx * dx + dy * dy);
      }
      for (; idx < nDash; idx++) {
        tmpLen += lineDash[idx];
        if (tmpLen > offset) {
          break;
        }
      }
      t = (tmpLen - offset) / bezierLen;
      while (t <= 1) {
        x = cubicAt(x0, x1, x2, x3, t);
        y = cubicAt(y0, y1, y2, y3, t);
        idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        t += lineDash[idx] / bezierLen;
        idx = (idx + 1) % nDash;
      }
      (idx % 2 !== 0) && ctx.lineTo(x3, y3);
      dx = x3 - x;
      dy = y3 - y;
      this._dashOffset = -mathSqrt(dx * dx + dy * dy);
    },
    _dashedQuadraticTo: function(x1, y1, x2, y2) {
      var x3 = x2;
      var y3 = y2;
      x2 = (x2 + 2 * x1) / 3;
      y2 = (y2 + 2 * y1) / 3;
      x1 = (this._xi + 2 * x1) / 3;
      y1 = (this._yi + 2 * y1) / 3;
      this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
    },
    toStatic: function() {
      var data = this.data;
      if (data instanceof Array) {
        data.length = this._len;
        if (hasTypedArray) {
          this.data = new Float32Array(data);
        }
      }
    },
    getBoundingRect: function() {
      min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
      max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
      var data = this.data;
      var xi = 0;
      var yi = 0;
      var x0 = 0;
      var y0 = 0;
      for (var i = 0; i < data.length; ) {
        var cmd = data[i++];
        if (i == 1) {
          xi = data[i];
          yi = data[i + 1];
          x0 = xi;
          y0 = yi;
        }
        switch (cmd) {
          case CMD.M:
            x0 = data[i++];
            y0 = data[i++];
            xi = x0;
            yi = y0;
            min2[0] = x0;
            min2[1] = y0;
            max2[0] = x0;
            max2[1] = y0;
            break;
          case CMD.L:
            bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD.C:
            bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD.Q:
            bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD.A:
            var cx = data[i++];
            var cy = data[i++];
            var rx = data[i++];
            var ry = data[i++];
            var startAngle = data[i++];
            var endAngle = data[i++] + startAngle;
            var psi = data[i++];
            var anticlockwise = 1 - data[i++];
            if (i == 1) {
              x0 = mathCos(startAngle) * rx + cx;
              y0 = mathSin(startAngle) * ry + cy;
            }
            bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
            xi = mathCos(endAngle) * rx + cx;
            yi = mathSin(endAngle) * ry + cy;
            break;
          case CMD.R:
            x0 = xi = data[i++];
            y0 = yi = data[i++];
            var width = data[i++];
            var height = data[i++];
            bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
            break;
          case CMD.Z:
            xi = x0;
            yi = y0;
            break;
        }
        vec2.min(min, min, min2);
        vec2.max(max, max, max2);
      }
      if (i === 0) {
        min[0] = min[1] = max[0] = max[1] = 0;
      }
      return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
    },
    rebuildPath: function(ctx) {
      var d = this.data;
      var x0,
          y0;
      var xi,
          yi;
      var x,
          y;
      var ux = this._ux;
      var uy = this._uy;
      var len = this._len;
      for (var i = 0; i < len; ) {
        var cmd = d[i++];
        if (i == 1) {
          xi = d[i];
          yi = d[i + 1];
          x0 = xi;
          y0 = yi;
        }
        switch (cmd) {
          case CMD.M:
            x0 = xi = d[i++];
            y0 = yi = d[i++];
            ctx.moveTo(xi, yi);
            break;
          case CMD.L:
            x = d[i++];
            y = d[i++];
            if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
              ctx.lineTo(x, y);
              xi = x;
              yi = y;
            }
            break;
          case CMD.C:
            ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
            xi = d[i - 2];
            yi = d[i - 1];
            break;
          case CMD.Q:
            ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
            xi = d[i - 2];
            yi = d[i - 1];
            break;
          case CMD.A:
            var cx = d[i++];
            var cy = d[i++];
            var rx = d[i++];
            var ry = d[i++];
            var theta = d[i++];
            var dTheta = d[i++];
            var psi = d[i++];
            var fs = d[i++];
            var r = (rx > ry) ? rx : ry;
            var scaleX = (rx > ry) ? 1 : rx / ry;
            var scaleY = (rx > ry) ? ry / rx : 1;
            var isEllipse = Math.abs(rx - ry) > 1e-3;
            var endAngle = theta + dTheta;
            if (isEllipse) {
              ctx.translate(cx, cy);
              ctx.rotate(psi);
              ctx.scale(scaleX, scaleY);
              ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
              ctx.scale(1 / scaleX, 1 / scaleY);
              ctx.rotate(-psi);
              ctx.translate(-cx, -cy);
            } else {
              ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
            }
            if (i == 1) {
              x0 = mathCos(theta) * rx + cx;
              y0 = mathSin(theta) * ry + cy;
            }
            xi = mathCos(endAngle) * rx + cx;
            yi = mathSin(endAngle) * ry + cy;
            break;
          case CMD.R:
            x0 = xi = d[i];
            y0 = yi = d[i + 1];
            ctx.rect(d[i++], d[i++], d[i++], d[i++]);
            break;
          case CMD.Z:
            ctx.closePath();
            xi = x0;
            yi = y0;
        }
      }
    }
  };
  PathProxy.CMD = CMD;
  module.exports = PathProxy;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/contain/line.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {containStroke: function(x0, y0, x1, y1, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }
      var _l = lineWidth;
      var _a = 0;
      var _b = x0;
      if ((y > y0 + _l && y > y1 + _l) || (y < y0 - _l && y < y1 - _l) || (x > x0 + _l && x > x1 + _l) || (x < x0 - _l && x < x1 - _l)) {
        return false;
      }
      if (x0 !== x1) {
        _a = (y0 - y1) / (x0 - x1);
        _b = (x0 * y1 - x1 * y0) / (x0 - x1);
      } else {
        return Math.abs(x - x0) <= _l / 2;
      }
      var tmp = _a * x - y + _b;
      var _s = tmp * tmp / (_a * _a + 1);
      return _s <= _l / 2 * _l / 2;
    }};
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/contain/cubic.js", ["../core/curve"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var curve = $__require('../core/curve');
  module.exports = {containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }
      var _l = lineWidth;
      if ((y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l) || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l) || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l) || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)) {
        return false;
      }
      var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
      return d <= _l / 2;
    }};
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/contain/quadratic.js", ["../core/curve"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var curve = $__require('../core/curve');
  module.exports = {containStroke: function(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }
      var _l = lineWidth;
      if ((y > y0 + _l && y > y1 + _l && y > y2 + _l) || (y < y0 - _l && y < y1 - _l && y < y2 - _l) || (x > x0 + _l && x > x1 + _l && x > x2 + _l) || (x < x0 - _l && x < x1 - _l && x < x2 - _l)) {
        return false;
      }
      var d = curve.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
      return d <= _l / 2;
    }};
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/contain/arc.js", ["./util"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var normalizeRadian = $__require('./util').normalizeRadian;
  var PI2 = Math.PI * 2;
  module.exports = {containStroke: function(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }
      var _l = lineWidth;
      x -= cx;
      y -= cy;
      var d = Math.sqrt(x * x + y * y);
      if ((d - _l > r) || (d + _l < r)) {
        return false;
      }
      if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
        return true;
      }
      if (anticlockwise) {
        var tmp = startAngle;
        startAngle = normalizeRadian(endAngle);
        endAngle = normalizeRadian(tmp);
      } else {
        startAngle = normalizeRadian(startAngle);
        endAngle = normalizeRadian(endAngle);
      }
      if (startAngle > endAngle) {
        endAngle += PI2;
      }
      var angle = Math.atan2(y, x);
      if (angle < 0) {
        angle += PI2;
      }
      return (angle >= startAngle && angle <= endAngle) || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
    }};
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/contain/util.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var PI2 = Math.PI * 2;
  module.exports = {normalizeRadian: function(angle) {
      angle %= PI2;
      if (angle < 0) {
        angle += PI2;
      }
      return angle;
    }};
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/curve.js", ["./vector"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var vec2 = $__require('./vector');
  var v2Create = vec2.create;
  var v2DistSquare = vec2.distSquare;
  var mathPow = Math.pow;
  var mathSqrt = Math.sqrt;
  var EPSILON = 1e-8;
  var EPSILON_NUMERIC = 1e-4;
  var THREE_SQRT = mathSqrt(3);
  var ONE_THIRD = 1 / 3;
  var _v0 = v2Create();
  var _v1 = v2Create();
  var _v2 = v2Create();
  function isAroundZero(val) {
    return val > -EPSILON && val < EPSILON;
  }
  function isNotAroundZero(val) {
    return val > EPSILON || val < -EPSILON;
  }
  function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
  }
  function cubicDerivativeAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
  }
  function cubicRootAt(p0, p1, p2, p3, val, roots) {
    var a = p3 + 3 * (p1 - p2) - p0;
    var b = 3 * (p2 - p1 * 2 + p0);
    var c = 3 * (p1 - p0);
    var d = p0 - val;
    var A = b * b - 3 * a * c;
    var B = b * c - 9 * a * d;
    var C = c * c - 3 * b * d;
    var n = 0;
    if (isAroundZero(A) && isAroundZero(B)) {
      if (isAroundZero(b)) {
        roots[0] = 0;
      } else {
        var t1 = -c / b;
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }
      }
    } else {
      var disc = B * B - 4 * A * C;
      if (isAroundZero(disc)) {
        var K = B / A;
        var t1 = -b / a + K;
        var t2 = -K / 2;
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          roots[n++] = t2;
        }
      } else if (disc > 0) {
        var discSqrt = mathSqrt(disc);
        var Y1 = A * b + 1.5 * a * (-B + discSqrt);
        var Y2 = A * b + 1.5 * a * (-B - discSqrt);
        if (Y1 < 0) {
          Y1 = -mathPow(-Y1, ONE_THIRD);
        } else {
          Y1 = mathPow(Y1, ONE_THIRD);
        }
        if (Y2 < 0) {
          Y2 = -mathPow(-Y2, ONE_THIRD);
        } else {
          Y2 = mathPow(Y2, ONE_THIRD);
        }
        var t1 = (-b - (Y1 + Y2)) / (3 * a);
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }
      } else {
        var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
        var theta = Math.acos(T) / 3;
        var ASqrt = mathSqrt(A);
        var tmp = Math.cos(theta);
        var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
        var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
        var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          roots[n++] = t2;
        }
        if (t3 >= 0 && t3 <= 1) {
          roots[n++] = t3;
        }
      }
    }
    return n;
  }
  function cubicExtrema(p0, p1, p2, p3, extrema) {
    var b = 6 * p2 - 12 * p1 + 6 * p0;
    var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
    var c = 3 * p1 - 3 * p0;
    var n = 0;
    if (isAroundZero(a)) {
      if (isNotAroundZero(b)) {
        var t1 = -c / b;
        if (t1 >= 0 && t1 <= 1) {
          extrema[n++] = t1;
        }
      }
    } else {
      var disc = b * b - 4 * a * c;
      if (isAroundZero(disc)) {
        extrema[0] = -b / (2 * a);
      } else if (disc > 0) {
        var discSqrt = mathSqrt(disc);
        var t1 = (-b + discSqrt) / (2 * a);
        var t2 = (-b - discSqrt) / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
          extrema[n++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          extrema[n++] = t2;
        }
      }
    }
    return n;
  }
  function cubicSubdivide(p0, p1, p2, p3, t, out) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p23 = (p3 - p2) * t + p2;
    var p012 = (p12 - p01) * t + p01;
    var p123 = (p23 - p12) * t + p12;
    var p0123 = (p123 - p012) * t + p012;
    out[0] = p0;
    out[1] = p01;
    out[2] = p012;
    out[3] = p0123;
    out[4] = p0123;
    out[5] = p123;
    out[6] = p23;
    out[7] = p3;
  }
  function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
    var t;
    var interval = 0.005;
    var d = Infinity;
    var prev;
    var next;
    var d1;
    var d2;
    _v0[0] = x;
    _v0[1] = y;
    for (var _t = 0; _t < 1; _t += 0.05) {
      _v1[0] = cubicAt(x0, x1, x2, x3, _t);
      _v1[1] = cubicAt(y0, y1, y2, y3, _t);
      d1 = v2DistSquare(_v0, _v1);
      if (d1 < d) {
        t = _t;
        d = d1;
      }
    }
    d = Infinity;
    for (var i = 0; i < 32; i++) {
      if (interval < EPSILON_NUMERIC) {
        break;
      }
      prev = t - interval;
      next = t + interval;
      _v1[0] = cubicAt(x0, x1, x2, x3, prev);
      _v1[1] = cubicAt(y0, y1, y2, y3, prev);
      d1 = v2DistSquare(_v1, _v0);
      if (prev >= 0 && d1 < d) {
        t = prev;
        d = d1;
      } else {
        _v2[0] = cubicAt(x0, x1, x2, x3, next);
        _v2[1] = cubicAt(y0, y1, y2, y3, next);
        d2 = v2DistSquare(_v2, _v0);
        if (next <= 1 && d2 < d) {
          t = next;
          d = d2;
        } else {
          interval *= 0.5;
        }
      }
    }
    if (out) {
      out[0] = cubicAt(x0, x1, x2, x3, t);
      out[1] = cubicAt(y0, y1, y2, y3, t);
    }
    return mathSqrt(d);
  }
  function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
  }
  function quadraticDerivativeAt(p0, p1, p2, t) {
    return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
  }
  function quadraticRootAt(p0, p1, p2, val, roots) {
    var a = p0 - 2 * p1 + p2;
    var b = 2 * (p1 - p0);
    var c = p0 - val;
    var n = 0;
    if (isAroundZero(a)) {
      if (isNotAroundZero(b)) {
        var t1 = -c / b;
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }
      }
    } else {
      var disc = b * b - 4 * a * c;
      if (isAroundZero(disc)) {
        var t1 = -b / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }
      } else if (disc > 0) {
        var discSqrt = mathSqrt(disc);
        var t1 = (-b + discSqrt) / (2 * a);
        var t2 = (-b - discSqrt) / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          roots[n++] = t2;
        }
      }
    }
    return n;
  }
  function quadraticExtremum(p0, p1, p2) {
    var divider = p0 + p2 - 2 * p1;
    if (divider === 0) {
      return 0.5;
    } else {
      return (p0 - p1) / divider;
    }
  }
  function quadraticSubdivide(p0, p1, p2, t, out) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p012 = (p12 - p01) * t + p01;
    out[0] = p0;
    out[1] = p01;
    out[2] = p012;
    out[3] = p012;
    out[4] = p12;
    out[5] = p2;
  }
  function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
    var t;
    var interval = 0.005;
    var d = Infinity;
    _v0[0] = x;
    _v0[1] = y;
    for (var _t = 0; _t < 1; _t += 0.05) {
      _v1[0] = quadraticAt(x0, x1, x2, _t);
      _v1[1] = quadraticAt(y0, y1, y2, _t);
      var d1 = v2DistSquare(_v0, _v1);
      if (d1 < d) {
        t = _t;
        d = d1;
      }
    }
    d = Infinity;
    for (var i = 0; i < 32; i++) {
      if (interval < EPSILON_NUMERIC) {
        break;
      }
      var prev = t - interval;
      var next = t + interval;
      _v1[0] = quadraticAt(x0, x1, x2, prev);
      _v1[1] = quadraticAt(y0, y1, y2, prev);
      var d1 = v2DistSquare(_v1, _v0);
      if (prev >= 0 && d1 < d) {
        t = prev;
        d = d1;
      } else {
        _v2[0] = quadraticAt(x0, x1, x2, next);
        _v2[1] = quadraticAt(y0, y1, y2, next);
        var d2 = v2DistSquare(_v2, _v0);
        if (next <= 1 && d2 < d) {
          t = next;
          d = d2;
        } else {
          interval *= 0.5;
        }
      }
    }
    if (out) {
      out[0] = quadraticAt(x0, x1, x2, t);
      out[1] = quadraticAt(y0, y1, y2, t);
    }
    return mathSqrt(d);
  }
  module.exports = {
    cubicAt: cubicAt,
    cubicDerivativeAt: cubicDerivativeAt,
    cubicRootAt: cubicRootAt,
    cubicExtrema: cubicExtrema,
    cubicSubdivide: cubicSubdivide,
    cubicProjectPoint: cubicProjectPoint,
    quadraticAt: quadraticAt,
    quadraticDerivativeAt: quadraticDerivativeAt,
    quadraticRootAt: quadraticRootAt,
    quadraticExtremum: quadraticExtremum,
    quadraticSubdivide: quadraticSubdivide,
    quadraticProjectPoint: quadraticProjectPoint
  };
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/contain/windingLine.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function windingLine(x0, y0, x1, y1, x, y) {
    if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
      return 0;
    }
    if (y1 === y0) {
      return 0;
    }
    var dir = y1 < y0 ? 1 : -1;
    var t = (y - y0) / (y1 - y0);
    if (t === 1 || t === 0) {
      dir = y1 < y0 ? 0.5 : -0.5;
    }
    var x_ = t * (x1 - x0) + x0;
    return x_ > x ? dir : 0;
  };
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/contain/path.js", ["../core/PathProxy", "./line", "./cubic", "./quadratic", "./arc", "./util", "../core/curve", "./windingLine"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var CMD = $__require('../core/PathProxy').CMD;
  var line = $__require('./line');
  var cubic = $__require('./cubic');
  var quadratic = $__require('./quadratic');
  var arc = $__require('./arc');
  var normalizeRadian = $__require('./util').normalizeRadian;
  var curve = $__require('../core/curve');
  var windingLine = $__require('./windingLine');
  var containStroke = line.containStroke;
  var PI2 = Math.PI * 2;
  var EPSILON = 1e-4;
  function isAroundEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
  }
  var roots = [-1, -1, -1];
  var extrema = [-1, -1];
  function swapExtrema() {
    var tmp = extrema[0];
    extrema[0] = extrema[1];
    extrema[1] = tmp;
  }
  function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
    if ((y > y0 && y > y1 && y > y2 && y > y3) || (y < y0 && y < y1 && y < y2 && y < y3)) {
      return 0;
    }
    var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
    if (nRoots === 0) {
      return 0;
    } else {
      var w = 0;
      var nExtrema = -1;
      var y0_,
          y1_;
      for (var i = 0; i < nRoots; i++) {
        var t = roots[i];
        var unit = (t === 0 || t === 1) ? 0.5 : 1;
        var x_ = curve.cubicAt(x0, x1, x2, x3, t);
        if (x_ < x) {
          continue;
        }
        if (nExtrema < 0) {
          nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
          if (extrema[1] < extrema[0] && nExtrema > 1) {
            swapExtrema();
          }
          y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
          if (nExtrema > 1) {
            y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
          }
        }
        if (nExtrema == 2) {
          if (t < extrema[0]) {
            w += y0_ < y0 ? unit : -unit;
          } else if (t < extrema[1]) {
            w += y1_ < y0_ ? unit : -unit;
          } else {
            w += y3 < y1_ ? unit : -unit;
          }
        } else {
          if (t < extrema[0]) {
            w += y0_ < y0 ? unit : -unit;
          } else {
            w += y3 < y0_ ? unit : -unit;
          }
        }
      }
      return w;
    }
  }
  function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
    if ((y > y0 && y > y1 && y > y2) || (y < y0 && y < y1 && y < y2)) {
      return 0;
    }
    var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
    if (nRoots === 0) {
      return 0;
    } else {
      var t = curve.quadraticExtremum(y0, y1, y2);
      if (t >= 0 && t <= 1) {
        var w = 0;
        var y_ = curve.quadraticAt(y0, y1, y2, t);
        for (var i = 0; i < nRoots; i++) {
          var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;
          var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
          if (x_ < x) {
            continue;
          }
          if (roots[i] < t) {
            w += y_ < y0 ? unit : -unit;
          } else {
            w += y2 < y_ ? unit : -unit;
          }
        }
        return w;
      } else {
        var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;
        var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
        if (x_ < x) {
          return 0;
        }
        return y2 < y0 ? unit : -unit;
      }
    }
  }
  function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
    y -= cy;
    if (y > r || y < -r) {
      return 0;
    }
    var tmp = Math.sqrt(r * r - y * y);
    roots[0] = -tmp;
    roots[1] = tmp;
    var diff = Math.abs(startAngle - endAngle);
    if (diff < 1e-4) {
      return 0;
    }
    if (diff % PI2 < 1e-4) {
      startAngle = 0;
      endAngle = PI2;
      var dir = anticlockwise ? 1 : -1;
      if (x >= roots[0] + cx && x <= roots[1] + cx) {
        return dir;
      } else {
        return 0;
      }
    }
    if (anticlockwise) {
      var tmp = startAngle;
      startAngle = normalizeRadian(endAngle);
      endAngle = normalizeRadian(tmp);
    } else {
      startAngle = normalizeRadian(startAngle);
      endAngle = normalizeRadian(endAngle);
    }
    if (startAngle > endAngle) {
      endAngle += PI2;
    }
    var w = 0;
    for (var i = 0; i < 2; i++) {
      var x_ = roots[i];
      if (x_ + cx > x) {
        var angle = Math.atan2(y, x_);
        var dir = anticlockwise ? 1 : -1;
        if (angle < 0) {
          angle = PI2 + angle;
        }
        if ((angle >= startAngle && angle <= endAngle) || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)) {
          if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
            dir = -dir;
          }
          w += dir;
        }
      }
    }
    return w;
  }
  function containPath(data, lineWidth, isStroke, x, y) {
    var w = 0;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    for (var i = 0; i < data.length; ) {
      var cmd = data[i++];
      if (cmd === CMD.M && i > 1) {
        if (!isStroke) {
          w += windingLine(xi, yi, x0, y0, x, y);
        }
      }
      if (i == 1) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }
      switch (cmd) {
        case CMD.M:
          x0 = data[i++];
          y0 = data[i++];
          xi = x0;
          yi = y0;
          break;
        case CMD.L:
          if (isStroke) {
            if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
          }
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD.C:
          if (isStroke) {
            if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
          }
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD.Q:
          if (isStroke) {
            if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
          }
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD.A:
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var theta = data[i++];
          var dTheta = data[i++];
          var psi = data[i++];
          var anticlockwise = 1 - data[i++];
          var x1 = Math.cos(theta) * rx + cx;
          var y1 = Math.sin(theta) * ry + cy;
          if (i > 1) {
            w += windingLine(xi, yi, x1, y1, x, y);
          } else {
            x0 = x1;
            y0 = y1;
          }
          var _x = (x - cx) * ry / rx + cx;
          if (isStroke) {
            if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
              return true;
            }
          } else {
            w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
          }
          xi = Math.cos(theta + dTheta) * rx + cx;
          yi = Math.sin(theta + dTheta) * ry + cy;
          break;
        case CMD.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++];
          var x1 = x0 + width;
          var y1 = y0 + height;
          if (isStroke) {
            if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingLine(x1, y0, x1, y1, x, y);
            w += windingLine(x0, y1, x0, y0, x, y);
          }
          break;
        case CMD.Z:
          if (isStroke) {
            if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingLine(xi, yi, x0, y0, x, y);
          }
          xi = x0;
          yi = y0;
          break;
      }
    }
    if (!isStroke && !isAroundEqual(yi, y0)) {
      w += windingLine(xi, yi, x0, y0, x, y) || 0;
    }
    return w !== 0;
  }
  module.exports = {
    contain: function(pathData, x, y) {
      return containPath(pathData, 0, false, x, y);
    },
    containStroke: function(pathData, lineWidth, x, y) {
      return containPath(pathData, lineWidth, true, x, y);
    }
  };
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/Path.js", ["./Displayable", "../core/util", "../core/PathProxy", "../contain/path", "./Pattern"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Displayable = $__require('./Displayable');
  var zrUtil = $__require('../core/util');
  var PathProxy = $__require('../core/PathProxy');
  var pathContain = $__require('../contain/path');
  var Pattern = $__require('./Pattern');
  var getCanvasPattern = Pattern.prototype.getCanvasPattern;
  var abs = Math.abs;
  function Path(opts) {
    Displayable.call(this, opts);
    this.path = new PathProxy();
  }
  Path.prototype = {
    constructor: Path,
    type: 'path',
    __dirtyPath: true,
    strokeContainThreshold: 5,
    brush: function(ctx, prevEl) {
      var style = this.style;
      var path = this.path;
      var hasStroke = style.hasStroke();
      var hasFill = style.hasFill();
      var fill = style.fill;
      var stroke = style.stroke;
      var hasFillGradient = hasFill && !!(fill.colorStops);
      var hasStrokeGradient = hasStroke && !!(stroke.colorStops);
      var hasFillPattern = hasFill && !!(fill.image);
      var hasStrokePattern = hasStroke && !!(stroke.image);
      style.bind(ctx, this, prevEl);
      this.setTransform(ctx);
      if (this.__dirty) {
        var rect = this.getBoundingRect();
        if (hasFillGradient) {
          this._fillGradient = style.getGradient(ctx, fill, rect);
        }
        if (hasStrokeGradient) {
          this._strokeGradient = style.getGradient(ctx, stroke, rect);
        }
      }
      if (hasFillGradient) {
        ctx.fillStyle = this._fillGradient;
      } else if (hasFillPattern) {
        ctx.fillStyle = getCanvasPattern.call(fill, ctx);
      }
      if (hasStrokeGradient) {
        ctx.strokeStyle = this._strokeGradient;
      } else if (hasStrokePattern) {
        ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
      }
      var lineDash = style.lineDash;
      var lineDashOffset = style.lineDashOffset;
      var ctxLineDash = !!ctx.setLineDash;
      var scale = this.getGlobalScale();
      path.setScale(scale[0], scale[1]);
      if (this.__dirtyPath || (lineDash && !ctxLineDash && hasStroke)) {
        path = this.path.beginPath(ctx);
        if (lineDash && !ctxLineDash) {
          path.setLineDash(lineDash);
          path.setLineDashOffset(lineDashOffset);
        }
        this.buildPath(path, this.shape, false);
        this.__dirtyPath = false;
      } else {
        ctx.beginPath();
        this.path.rebuildPath(ctx);
      }
      hasFill && path.fill(ctx);
      if (lineDash && ctxLineDash) {
        ctx.setLineDash(lineDash);
        ctx.lineDashOffset = lineDashOffset;
      }
      hasStroke && path.stroke(ctx);
      if (lineDash && ctxLineDash) {
        ctx.setLineDash([]);
      }
      this.restoreTransform(ctx);
      if (style.text || style.text === 0) {
        this.drawRectText(ctx, this.getBoundingRect());
      }
    },
    buildPath: function(ctx, shapeCfg, inBundle) {},
    getBoundingRect: function() {
      var rect = this._rect;
      var style = this.style;
      var needsUpdateRect = !rect;
      if (needsUpdateRect) {
        var path = this.path;
        if (this.__dirtyPath) {
          path.beginPath();
          this.buildPath(path, this.shape, false);
        }
        rect = path.getBoundingRect();
      }
      this._rect = rect;
      if (style.hasStroke()) {
        var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
        if (this.__dirty || needsUpdateRect) {
          rectWithStroke.copy(rect);
          var w = style.lineWidth;
          var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
          if (!style.hasFill()) {
            w = Math.max(w, this.strokeContainThreshold || 4);
          }
          if (lineScale > 1e-10) {
            rectWithStroke.width += w / lineScale;
            rectWithStroke.height += w / lineScale;
            rectWithStroke.x -= w / lineScale / 2;
            rectWithStroke.y -= w / lineScale / 2;
          }
        }
        return rectWithStroke;
      }
      return rect;
    },
    contain: function(x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      var style = this.style;
      x = localPos[0];
      y = localPos[1];
      if (rect.contain(x, y)) {
        var pathData = this.path.data;
        if (style.hasStroke()) {
          var lineWidth = style.lineWidth;
          var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
          if (lineScale > 1e-10) {
            if (!style.hasFill()) {
              lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
            }
            if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
              return true;
            }
          }
        }
        if (style.hasFill()) {
          return pathContain.contain(pathData, x, y);
        }
      }
      return false;
    },
    dirty: function(dirtyPath) {
      if (dirtyPath == null) {
        dirtyPath = true;
      }
      if (dirtyPath) {
        this.__dirtyPath = dirtyPath;
        this._rect = null;
      }
      this.__dirty = true;
      this.__zr && this.__zr.refresh();
      if (this.__clipTarget) {
        this.__clipTarget.dirty();
      }
    },
    animateShape: function(loop) {
      return this.animate('shape', loop);
    },
    attrKV: function(key, value) {
      if (key === 'shape') {
        this.setShape(value);
        this.__dirtyPath = true;
        this._rect = null;
      } else {
        Displayable.prototype.attrKV.call(this, key, value);
      }
    },
    setShape: function(key, value) {
      var shape = this.shape;
      if (shape) {
        if (zrUtil.isObject(key)) {
          for (var name in key) {
            shape[name] = key[name];
          }
        } else {
          shape[key] = value;
        }
        this.dirty(true);
      }
      return this;
    },
    getLineScale: function() {
      var m = this.transform;
      return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
    }
  };
  Path.extend = function(defaults) {
    var Sub = function(opts) {
      Path.call(this, opts);
      if (defaults.style) {
        this.style.extendFrom(defaults.style, false);
      }
      var defaultShape = defaults.shape;
      if (defaultShape) {
        this.shape = this.shape || {};
        var thisShape = this.shape;
        for (var name in defaultShape) {
          if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
            thisShape[name] = defaultShape[name];
          }
        }
      }
      defaults.init && defaults.init.call(this, opts);
    };
    zrUtil.inherits(Sub, Path);
    for (var name in defaults) {
      if (name !== 'style' && name !== 'shape') {
        Sub.prototype[name] = defaults[name];
      }
    }
    return Sub;
  };
  zrUtil.inherits(Path, Displayable);
  module.exports = Path;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/Gradient.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Gradient = function(colorStops) {
    this.colorStops = colorStops || [];
  };
  Gradient.prototype = {
    constructor: Gradient,
    addColorStop: function(offset, color) {
      this.colorStops.push({
        offset: offset,
        color: color
      });
    }
  };
  module.exports = Gradient;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/vml/graphic.js", ["../core/env", "../core/vector", "../core/BoundingRect", "../core/PathProxy", "../tool/color", "../contain/text", "../graphic/mixin/RectText", "../graphic/Displayable", "../graphic/Image", "../graphic/Text", "../graphic/Path", "../graphic/Gradient", "./core"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  if (!$__require('../core/env').canvasSupported) {
    var vec2 = $__require('../core/vector');
    var BoundingRect = $__require('../core/BoundingRect');
    var CMD = $__require('../core/PathProxy').CMD;
    var colorTool = $__require('../tool/color');
    var textContain = $__require('../contain/text');
    var RectText = $__require('../graphic/mixin/RectText');
    var Displayable = $__require('../graphic/Displayable');
    var ZImage = $__require('../graphic/Image');
    var Text = $__require('../graphic/Text');
    var Path = $__require('../graphic/Path');
    var Gradient = $__require('../graphic/Gradient');
    var vmlCore = $__require('./core');
    var round = Math.round;
    var sqrt = Math.sqrt;
    var abs = Math.abs;
    var cos = Math.cos;
    var sin = Math.sin;
    var mathMax = Math.max;
    var applyTransform = vec2.applyTransform;
    var comma = ',';
    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
    var Z = 21600;
    var Z2 = Z / 2;
    var ZLEVEL_BASE = 100000;
    var Z_BASE = 1000;
    var initRootElStyle = function(el) {
      el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
      el.coordsize = Z + ',' + Z;
      el.coordorigin = '0,0';
    };
    var encodeHtmlAttribute = function(s) {
      return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
    };
    var rgb2Str = function(r, g, b) {
      return 'rgb(' + [r, g, b].join(',') + ')';
    };
    var append = function(parent, child) {
      if (child && parent && child.parentNode !== parent) {
        parent.appendChild(child);
      }
    };
    var remove = function(parent, child) {
      if (child && parent && child.parentNode === parent) {
        parent.removeChild(child);
      }
    };
    var getZIndex = function(zlevel, z, z2) {
      return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
    };
    var parsePercent = function(value, maxValue) {
      if (typeof value === 'string') {
        if (value.lastIndexOf('%') >= 0) {
          return parseFloat(value) / 100 * maxValue;
        }
        return parseFloat(value);
      }
      return value;
    };
    var setColorAndOpacity = function(el, color, opacity) {
      var colorArr = colorTool.parse(color);
      opacity = +opacity;
      if (isNaN(opacity)) {
        opacity = 1;
      }
      if (colorArr) {
        el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
        el.opacity = opacity * colorArr[3];
      }
    };
    var getColorAndAlpha = function(color) {
      var colorArr = colorTool.parse(color);
      return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];
    };
    var updateFillNode = function(el, style, zrEl) {
      var fill = style.fill;
      if (fill != null) {
        if (fill instanceof Gradient) {
          var gradientType;
          var angle = 0;
          var focus = [0, 0];
          var shift = 0;
          var expansion = 1;
          var rect = zrEl.getBoundingRect();
          var rectWidth = rect.width;
          var rectHeight = rect.height;
          if (fill.type === 'linear') {
            gradientType = 'gradient';
            var transform = zrEl.transform;
            var p0 = [fill.x * rectWidth, fill.y * rectHeight];
            var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
            if (transform) {
              applyTransform(p0, p0, transform);
              applyTransform(p1, p1, transform);
            }
            var dx = p1[0] - p0[0];
            var dy = p1[1] - p0[1];
            angle = Math.atan2(dx, dy) * 180 / Math.PI;
            if (angle < 0) {
              angle += 360;
            }
            if (angle < 1e-6) {
              angle = 0;
            }
          } else {
            gradientType = 'gradientradial';
            var p0 = [fill.x * rectWidth, fill.y * rectHeight];
            var transform = zrEl.transform;
            var scale = zrEl.scale;
            var width = rectWidth;
            var height = rectHeight;
            focus = [(p0[0] - rect.x) / width, (p0[1] - rect.y) / height];
            if (transform) {
              applyTransform(p0, p0, transform);
            }
            width /= scale[0] * Z;
            height /= scale[1] * Z;
            var dimension = mathMax(width, height);
            shift = 2 * 0 / dimension;
            expansion = 2 * fill.r / dimension - shift;
          }
          var stops = fill.colorStops.slice();
          stops.sort(function(cs1, cs2) {
            return cs1.offset - cs2.offset;
          });
          var length = stops.length;
          var colorAndAlphaList = [];
          var colors = [];
          for (var i = 0; i < length; i++) {
            var stop = stops[i];
            var colorAndAlpha = getColorAndAlpha(stop.color);
            colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);
            if (i === 0 || i === length - 1) {
              colorAndAlphaList.push(colorAndAlpha);
            }
          }
          if (length >= 2) {
            var color1 = colorAndAlphaList[0][0];
            var color2 = colorAndAlphaList[1][0];
            var opacity1 = colorAndAlphaList[0][1] * style.opacity;
            var opacity2 = colorAndAlphaList[1][1] * style.opacity;
            el.type = gradientType;
            el.method = 'none';
            el.focus = '100%';
            el.angle = angle;
            el.color = color1;
            el.color2 = color2;
            el.colors = colors.join(',');
            el.opacity = opacity2;
            el.opacity2 = opacity1;
          }
          if (gradientType === 'radial') {
            el.focusposition = focus.join(',');
          }
        } else {
          setColorAndOpacity(el, fill, style.opacity);
        }
      }
    };
    var updateStrokeNode = function(el, style) {
      if (style.lineDash != null) {
        el.dashstyle = style.lineDash.join(' ');
      }
      if (style.stroke != null && !(style.stroke instanceof Gradient)) {
        setColorAndOpacity(el, style.stroke, style.opacity);
      }
    };
    var updateFillAndStroke = function(vmlEl, type, style, zrEl) {
      var isFill = type == 'fill';
      var el = vmlEl.getElementsByTagName(type)[0];
      if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {
        vmlEl[isFill ? 'filled' : 'stroked'] = 'true';
        if (style[type] instanceof Gradient) {
          remove(vmlEl, el);
        }
        if (!el) {
          el = vmlCore.createNode(type);
        }
        isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
        append(vmlEl, el);
      } else {
        vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
        remove(vmlEl, el);
      }
    };
    var points = [[], [], []];
    var pathDataToString = function(data, m) {
      var M = CMD.M;
      var C = CMD.C;
      var L = CMD.L;
      var A = CMD.A;
      var Q = CMD.Q;
      var str = [];
      var nPoint;
      var cmdStr;
      var cmd;
      var i;
      var xi;
      var yi;
      for (i = 0; i < data.length; ) {
        cmd = data[i++];
        cmdStr = '';
        nPoint = 0;
        switch (cmd) {
          case M:
            cmdStr = ' m ';
            nPoint = 1;
            xi = data[i++];
            yi = data[i++];
            points[0][0] = xi;
            points[0][1] = yi;
            break;
          case L:
            cmdStr = ' l ';
            nPoint = 1;
            xi = data[i++];
            yi = data[i++];
            points[0][0] = xi;
            points[0][1] = yi;
            break;
          case Q:
          case C:
            cmdStr = ' c ';
            nPoint = 3;
            var x1 = data[i++];
            var y1 = data[i++];
            var x2 = data[i++];
            var y2 = data[i++];
            var x3;
            var y3;
            if (cmd === Q) {
              x3 = x2;
              y3 = y2;
              x2 = (x2 + 2 * x1) / 3;
              y2 = (y2 + 2 * y1) / 3;
              x1 = (xi + 2 * x1) / 3;
              y1 = (yi + 2 * y1) / 3;
            } else {
              x3 = data[i++];
              y3 = data[i++];
            }
            points[0][0] = x1;
            points[0][1] = y1;
            points[1][0] = x2;
            points[1][1] = y2;
            points[2][0] = x3;
            points[2][1] = y3;
            xi = x3;
            yi = y3;
            break;
          case A:
            var x = 0;
            var y = 0;
            var sx = 1;
            var sy = 1;
            var angle = 0;
            if (m) {
              x = m[4];
              y = m[5];
              sx = sqrt(m[0] * m[0] + m[1] * m[1]);
              sy = sqrt(m[2] * m[2] + m[3] * m[3]);
              angle = Math.atan2(-m[1] / sy, m[0] / sx);
            }
            var cx = data[i++];
            var cy = data[i++];
            var rx = data[i++];
            var ry = data[i++];
            var startAngle = data[i++] + angle;
            var endAngle = data[i++] + startAngle + angle;
            i++;
            var clockwise = data[i++];
            var x0 = cx + cos(startAngle) * rx;
            var y0 = cy + sin(startAngle) * ry;
            var x1 = cx + cos(endAngle) * rx;
            var y1 = cy + sin(endAngle) * ry;
            var type = clockwise ? ' wa ' : ' at ';
            if (Math.abs(x0 - x1) < 1e-10) {
              if (Math.abs(endAngle - startAngle) > 1e-2) {
                if (clockwise) {
                  x0 += 270 / Z;
                }
              } else {
                if (Math.abs(y0 - cy) < 1e-10) {
                  if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {
                    y1 -= 270 / Z;
                  } else {
                    y1 += 270 / Z;
                  }
                } else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {
                  x1 += 270 / Z;
                } else {
                  x1 -= 270 / Z;
                }
              }
            }
            str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));
            xi = x1;
            yi = y1;
            break;
          case CMD.R:
            var p0 = points[0];
            var p1 = points[1];
            p0[0] = data[i++];
            p0[1] = data[i++];
            p1[0] = p0[0] + data[i++];
            p1[1] = p0[1] + data[i++];
            if (m) {
              applyTransform(p0, p0, m);
              applyTransform(p1, p1, m);
            }
            p0[0] = round(p0[0] * Z - Z2);
            p1[0] = round(p1[0] * Z - Z2);
            p0[1] = round(p0[1] * Z - Z2);
            p1[1] = round(p1[1] * Z - Z2);
            str.push(' m ', p0[0], comma, p0[1], ' l ', p1[0], comma, p0[1], ' l ', p1[0], comma, p1[1], ' l ', p0[0], comma, p1[1]);
            break;
          case CMD.Z:
            str.push(' x ');
        }
        if (nPoint > 0) {
          str.push(cmdStr);
          for (var k = 0; k < nPoint; k++) {
            var p = points[k];
            m && applyTransform(p, p, m);
            str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');
          }
        }
      }
      return str.join('');
    };
    Path.prototype.brushVML = function(vmlRoot) {
      var style = this.style;
      var vmlEl = this._vmlEl;
      if (!vmlEl) {
        vmlEl = vmlCore.createNode('shape');
        initRootElStyle(vmlEl);
        this._vmlEl = vmlEl;
      }
      updateFillAndStroke(vmlEl, 'fill', style, this);
      updateFillAndStroke(vmlEl, 'stroke', style, this);
      var m = this.transform;
      var needTransform = m != null;
      var strokeEl = vmlEl.getElementsByTagName('stroke')[0];
      if (strokeEl) {
        var lineWidth = style.lineWidth;
        if (needTransform && !style.strokeNoScale) {
          var det = m[0] * m[3] - m[1] * m[2];
          lineWidth *= sqrt(abs(det));
        }
        strokeEl.weight = lineWidth + 'px';
      }
      var path = this.path;
      if (this.__dirtyPath) {
        path.beginPath();
        this.buildPath(path, this.shape);
        path.toStatic();
        this.__dirtyPath = false;
      }
      vmlEl.path = pathDataToString(path.data, this.transform);
      vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
      append(vmlRoot, vmlEl);
      if (style.text) {
        this.drawRectText(vmlRoot, this.getBoundingRect());
      } else {
        this.removeRectText(vmlRoot);
      }
    };
    Path.prototype.onRemove = function(vmlRoot) {
      remove(vmlRoot, this._vmlEl);
      this.removeRectText(vmlRoot);
    };
    Path.prototype.onAdd = function(vmlRoot) {
      append(vmlRoot, this._vmlEl);
      this.appendRectText(vmlRoot);
    };
    var isImage = function(img) {
      return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';
    };
    ZImage.prototype.brushVML = function(vmlRoot) {
      var style = this.style;
      var image = style.image;
      var ow;
      var oh;
      if (isImage(image)) {
        var src = image.src;
        if (src === this._imageSrc) {
          ow = this._imageWidth;
          oh = this._imageHeight;
        } else {
          var imageRuntimeStyle = image.runtimeStyle;
          var oldRuntimeWidth = imageRuntimeStyle.width;
          var oldRuntimeHeight = imageRuntimeStyle.height;
          imageRuntimeStyle.width = 'auto';
          imageRuntimeStyle.height = 'auto';
          ow = image.width;
          oh = image.height;
          imageRuntimeStyle.width = oldRuntimeWidth;
          imageRuntimeStyle.height = oldRuntimeHeight;
          this._imageSrc = src;
          this._imageWidth = ow;
          this._imageHeight = oh;
        }
        image = src;
      } else {
        if (image === this._imageSrc) {
          ow = this._imageWidth;
          oh = this._imageHeight;
        }
      }
      if (!image) {
        return;
      }
      var x = style.x || 0;
      var y = style.y || 0;
      var dw = style.width;
      var dh = style.height;
      var sw = style.sWidth;
      var sh = style.sHeight;
      var sx = style.sx || 0;
      var sy = style.sy || 0;
      var hasCrop = sw && sh;
      var vmlEl = this._vmlEl;
      if (!vmlEl) {
        vmlEl = vmlCore.doc.createElement('div');
        initRootElStyle(vmlEl);
        this._vmlEl = vmlEl;
      }
      var vmlElStyle = vmlEl.style;
      var hasRotation = false;
      var m;
      var scaleX = 1;
      var scaleY = 1;
      if (this.transform) {
        m = this.transform;
        scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
        scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
        hasRotation = m[1] || m[2];
      }
      if (hasRotation) {
        var p0 = [x, y];
        var p1 = [x + dw, y];
        var p2 = [x, y + dh];
        var p3 = [x + dw, y + dh];
        applyTransform(p0, p0, m);
        applyTransform(p1, p1, m);
        applyTransform(p2, p2, m);
        applyTransform(p3, p3, m);
        var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
        var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
        var transformFilter = [];
        transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));
        vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';
        vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';
      } else {
        if (m) {
          x = x * scaleX + m[4];
          y = y * scaleY + m[5];
        }
        vmlElStyle.filter = '';
        vmlElStyle.left = round(x) + 'px';
        vmlElStyle.top = round(y) + 'px';
      }
      var imageEl = this._imageEl;
      var cropEl = this._cropEl;
      if (!imageEl) {
        imageEl = vmlCore.doc.createElement('div');
        this._imageEl = imageEl;
      }
      var imageELStyle = imageEl.style;
      if (hasCrop) {
        if (!(ow && oh)) {
          var tmpImage = new Image();
          var self = this;
          tmpImage.onload = function() {
            tmpImage.onload = null;
            ow = tmpImage.width;
            oh = tmpImage.height;
            imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
            imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
            self._imageWidth = ow;
            self._imageHeight = oh;
            self._imageSrc = image;
          };
          tmpImage.src = image;
        } else {
          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
        }
        if (!cropEl) {
          cropEl = vmlCore.doc.createElement('div');
          cropEl.style.overflow = 'hidden';
          this._cropEl = cropEl;
        }
        var cropElStyle = cropEl.style;
        cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
        cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
        cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';
        if (!cropEl.parentNode) {
          vmlEl.appendChild(cropEl);
        }
        if (imageEl.parentNode != cropEl) {
          cropEl.appendChild(imageEl);
        }
      } else {
        imageELStyle.width = round(scaleX * dw) + 'px';
        imageELStyle.height = round(scaleY * dh) + 'px';
        vmlEl.appendChild(imageEl);
        if (cropEl && cropEl.parentNode) {
          vmlEl.removeChild(cropEl);
          this._cropEl = null;
        }
      }
      var filterStr = '';
      var alpha = style.opacity;
      if (alpha < 1) {
        filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
      }
      filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
      imageELStyle.filter = filterStr;
      vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
      append(vmlRoot, vmlEl);
      if (style.text) {
        this.drawRectText(vmlRoot, this.getBoundingRect());
      }
    };
    ZImage.prototype.onRemove = function(vmlRoot) {
      remove(vmlRoot, this._vmlEl);
      this._vmlEl = null;
      this._cropEl = null;
      this._imageEl = null;
      this.removeRectText(vmlRoot);
    };
    ZImage.prototype.onAdd = function(vmlRoot) {
      append(vmlRoot, this._vmlEl);
      this.appendRectText(vmlRoot);
    };
    var DEFAULT_STYLE_NORMAL = 'normal';
    var fontStyleCache = {};
    var fontStyleCacheCount = 0;
    var MAX_FONT_CACHE_SIZE = 100;
    var fontEl = document.createElement('div');
    var getFontStyle = function(fontString) {
      var fontStyle = fontStyleCache[fontString];
      if (!fontStyle) {
        if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
          fontStyleCacheCount = 0;
          fontStyleCache = {};
        }
        var style = fontEl.style;
        var fontFamily;
        try {
          style.font = fontString;
          fontFamily = style.fontFamily.split(',')[0];
        } catch (e) {}
        fontStyle = {
          style: style.fontStyle || DEFAULT_STYLE_NORMAL,
          variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
          weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
          size: parseFloat(style.fontSize || 12) | 0,
          family: fontFamily || 'Microsoft YaHei'
        };
        fontStyleCache[fontString] = fontStyle;
        fontStyleCacheCount++;
      }
      return fontStyle;
    };
    var textMeasureEl;
    textContain.measureText = function(text, textFont) {
      var doc = vmlCore.doc;
      if (!textMeasureEl) {
        textMeasureEl = doc.createElement('div');
        textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';
        vmlCore.doc.body.appendChild(textMeasureEl);
      }
      try {
        textMeasureEl.style.font = textFont;
      } catch (ex) {}
      textMeasureEl.innerHTML = '';
      textMeasureEl.appendChild(doc.createTextNode(text));
      return {width: textMeasureEl.offsetWidth};
    };
    var tmpRect = new BoundingRect();
    var drawRectText = function(vmlRoot, rect, textRect, fromTextEl) {
      var style = this.style;
      var text = style.text;
      if (!text) {
        return;
      }
      var x;
      var y;
      var align = style.textAlign;
      var fontStyle = getFontStyle(style.textFont);
      var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px "' + fontStyle.family + '"';
      var baseline = style.textBaseline;
      var verticalAlign = style.textVerticalAlign;
      textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
      var m = this.transform;
      if (m && !fromTextEl) {
        tmpRect.copy(rect);
        tmpRect.applyTransform(m);
        rect = tmpRect;
      }
      if (!fromTextEl) {
        var textPosition = style.textPosition;
        var distance = style.textDistance;
        if (textPosition instanceof Array) {
          x = rect.x + parsePercent(textPosition[0], rect.width);
          y = rect.y + parsePercent(textPosition[1], rect.height);
          align = align || 'left';
          baseline = baseline || 'top';
        } else {
          var res = textContain.adjustTextPositionOnRect(textPosition, rect, textRect, distance);
          x = res.x;
          y = res.y;
          align = align || res.textAlign;
          baseline = baseline || res.textBaseline;
        }
      } else {
        x = rect.x;
        y = rect.y;
      }
      if (verticalAlign) {
        switch (verticalAlign) {
          case 'middle':
            y -= textRect.height / 2;
            break;
          case 'bottom':
            y -= textRect.height;
            break;
        }
        baseline = 'top';
      }
      var fontSize = fontStyle.size;
      switch (baseline) {
        case 'hanging':
        case 'top':
          y += fontSize / 1.75;
          break;
        case 'middle':
          break;
        default:
          y -= fontSize / 2.25;
          break;
      }
      switch (align) {
        case 'left':
          break;
        case 'center':
          x -= textRect.width / 2;
          break;
        case 'right':
          x -= textRect.width;
          break;
      }
      var createNode = vmlCore.createNode;
      var textVmlEl = this._textVmlEl;
      var pathEl;
      var textPathEl;
      var skewEl;
      if (!textVmlEl) {
        textVmlEl = createNode('line');
        pathEl = createNode('path');
        textPathEl = createNode('textpath');
        skewEl = createNode('skew');
        textPathEl.style['v-text-align'] = 'left';
        initRootElStyle(textVmlEl);
        pathEl.textpathok = true;
        textPathEl.on = true;
        textVmlEl.from = '0 0';
        textVmlEl.to = '1000 0.05';
        append(textVmlEl, skewEl);
        append(textVmlEl, pathEl);
        append(textVmlEl, textPathEl);
        this._textVmlEl = textVmlEl;
      } else {
        skewEl = textVmlEl.firstChild;
        pathEl = skewEl.nextSibling;
        textPathEl = pathEl.nextSibling;
      }
      var coords = [x, y];
      var textVmlElStyle = textVmlEl.style;
      if (m && fromTextEl) {
        applyTransform(coords, coords, m);
        skewEl.on = true;
        skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';
        skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);
        skewEl.origin = '0 0';
        textVmlElStyle.left = '0px';
        textVmlElStyle.top = '0px';
      } else {
        skewEl.on = false;
        textVmlElStyle.left = round(x) + 'px';
        textVmlElStyle.top = round(y) + 'px';
      }
      textPathEl.string = encodeHtmlAttribute(text);
      try {
        textPathEl.style.font = font;
      } catch (e) {}
      updateFillAndStroke(textVmlEl, 'fill', {
        fill: fromTextEl ? style.fill : style.textFill,
        opacity: style.opacity
      }, this);
      updateFillAndStroke(textVmlEl, 'stroke', {
        stroke: fromTextEl ? style.stroke : style.textStroke,
        opacity: style.opacity,
        lineDash: style.lineDash
      }, this);
      textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
      append(vmlRoot, textVmlEl);
    };
    var removeRectText = function(vmlRoot) {
      remove(vmlRoot, this._textVmlEl);
      this._textVmlEl = null;
    };
    var appendRectText = function(vmlRoot) {
      append(vmlRoot, this._textVmlEl);
    };
    var list = [RectText, Displayable, ZImage, Path, Text];
    for (var i = 0; i < list.length; i++) {
      var proto = list[i].prototype;
      proto.drawRectText = drawRectText;
      proto.removeRectText = removeRectText;
      proto.appendRectText = appendRectText;
    }
    Text.prototype.brushVML = function(vmlRoot) {
      var style = this.style;
      if (style.text) {
        this.drawRectText(vmlRoot, {
          x: style.x || 0,
          y: style.y || 0,
          width: 0,
          height: 0
        }, this.getBoundingRect(), true);
      } else {
        this.removeRectText(vmlRoot);
      }
    };
    Text.prototype.onRemove = function(vmlRoot) {
      this.removeRectText(vmlRoot);
    };
    Text.prototype.onAdd = function(vmlRoot) {
      this.appendRectText(vmlRoot);
    };
  }
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/mixin/Draggable.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function Draggable() {
    this.on('mousedown', this._dragStart, this);
    this.on('mousemove', this._drag, this);
    this.on('mouseup', this._dragEnd, this);
    this.on('globalout', this._dragEnd, this);
  }
  Draggable.prototype = {
    constructor: Draggable,
    _dragStart: function(e) {
      var draggingTarget = e.target;
      if (draggingTarget && draggingTarget.draggable) {
        this._draggingTarget = draggingTarget;
        draggingTarget.dragging = true;
        this._x = e.offsetX;
        this._y = e.offsetY;
        this.dispatchToElement(draggingTarget, 'dragstart', e.event);
      }
    },
    _drag: function(e) {
      var draggingTarget = this._draggingTarget;
      if (draggingTarget) {
        var x = e.offsetX;
        var y = e.offsetY;
        var dx = x - this._x;
        var dy = y - this._y;
        this._x = x;
        this._y = y;
        draggingTarget.drift(dx, dy, e);
        this.dispatchToElement(draggingTarget, 'drag', e.event);
        var dropTarget = this.findHover(x, y, draggingTarget);
        var lastDropTarget = this._dropTarget;
        this._dropTarget = dropTarget;
        if (draggingTarget !== dropTarget) {
          if (lastDropTarget && dropTarget !== lastDropTarget) {
            this.dispatchToElement(lastDropTarget, 'dragleave', e.event);
          }
          if (dropTarget && dropTarget !== lastDropTarget) {
            this.dispatchToElement(dropTarget, 'dragenter', e.event);
          }
        }
      }
    },
    _dragEnd: function(e) {
      var draggingTarget = this._draggingTarget;
      if (draggingTarget) {
        draggingTarget.dragging = false;
      }
      this.dispatchToElement(draggingTarget, 'dragend', e.event);
      if (this._dropTarget) {
        this.dispatchToElement(this._dropTarget, 'drop', e.event);
      }
      this._draggingTarget = null;
      this._dropTarget = null;
    }
  };
  module.exports = Draggable;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/Handler.js", ["./core/util", "./mixin/Draggable", "./mixin/Eventful"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var util = $__require('./core/util');
  var Draggable = $__require('./mixin/Draggable');
  var Eventful = $__require('./mixin/Eventful');
  function makeEventPacket(eveType, target, event) {
    return {
      type: eveType,
      event: event,
      target: target,
      cancelBubble: false,
      offsetX: event.zrX,
      offsetY: event.zrY,
      gestureEvent: event.gestureEvent,
      pinchX: event.pinchX,
      pinchY: event.pinchY,
      pinchScale: event.pinchScale,
      wheelDelta: event.zrDelta
    };
  }
  function EmptyProxy() {}
  EmptyProxy.prototype.dispose = function() {};
  var handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove'];
  var Handler = function(storage, painter, proxy) {
    Eventful.call(this);
    this.storage = storage;
    this.painter = painter;
    proxy = proxy || new EmptyProxy();
    this.proxy = proxy;
    proxy.handler = this;
    this._hovered;
    this._lastTouchMoment;
    this._lastX;
    this._lastY;
    Draggable.call(this);
    util.each(handlerNames, function(name) {
      proxy.on && proxy.on(name, this[name], this);
    }, this);
  };
  Handler.prototype = {
    constructor: Handler,
    mousemove: function(event) {
      var x = event.zrX;
      var y = event.zrY;
      var hovered = this.findHover(x, y, null);
      var lastHovered = this._hovered;
      var proxy = this.proxy;
      this._hovered = hovered;
      proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');
      if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {
        this.dispatchToElement(lastHovered, 'mouseout', event);
      }
      this.dispatchToElement(hovered, 'mousemove', event);
      if (hovered && hovered !== lastHovered) {
        this.dispatchToElement(hovered, 'mouseover', event);
      }
    },
    mouseout: function(event) {
      this.dispatchToElement(this._hovered, 'mouseout', event);
      this.trigger('globalout', {event: event});
    },
    resize: function(event) {
      this._hovered = null;
    },
    dispatch: function(eventName, eventArgs) {
      var handler = this[eventName];
      handler && handler.call(this, eventArgs);
    },
    dispose: function() {
      this.proxy.dispose();
      this.storage = this.proxy = this.painter = null;
    },
    setCursorStyle: function(cursorStyle) {
      var proxy = this.proxy;
      proxy.setCursor && proxy.setCursor(cursorStyle);
    },
    dispatchToElement: function(targetEl, eventName, event) {
      var eventHandler = 'on' + eventName;
      var eventPacket = makeEventPacket(eventName, targetEl, event);
      var el = targetEl;
      while (el) {
        el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
        el.trigger(eventName, eventPacket);
        el = el.parent;
        if (eventPacket.cancelBubble) {
          break;
        }
      }
      if (!eventPacket.cancelBubble) {
        this.trigger(eventName, eventPacket);
        this.painter && this.painter.eachOtherLayer(function(layer) {
          if (typeof(layer[eventHandler]) == 'function') {
            layer[eventHandler].call(layer, eventPacket);
          }
          if (layer.trigger) {
            layer.trigger(eventName, eventPacket);
          }
        });
      }
    },
    findHover: function(x, y, exclude) {
      var list = this.storage.getDisplayList();
      for (var i = list.length - 1; i >= 0; i--) {
        if (!list[i].silent && list[i] !== exclude && !list[i].ignore && isHover(list[i], x, y)) {
          return list[i];
        }
      }
    }
  };
  util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function(name) {
    Handler.prototype[name] = function(event) {
      var hovered = this.findHover(event.zrX, event.zrY, null);
      if (name === 'mousedown') {
        this._downel = hovered;
        this._upel = hovered;
      } else if (name === 'mosueup') {
        this._upel = hovered;
      } else if (name === 'click') {
        if (this._downel !== this._upel) {
          return;
        }
      }
      this.dispatchToElement(hovered, name, event);
    };
  });
  function isHover(displayable, x, y) {
    if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
      var el = displayable;
      while (el) {
        if (el.silent || (el.clipPath && !el.clipPath.contain(x, y))) {
          return false;
        }
        el = el.parent;
      }
      return true;
    }
    return false;
  }
  util.mixin(Handler, Eventful);
  util.mixin(Handler, Draggable);
  module.exports = Handler;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/container/Group.js", ["../core/util", "../Element", "../core/BoundingRect"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('../core/util');
  var Element = $__require('../Element');
  var BoundingRect = $__require('../core/BoundingRect');
  var Group = function(opts) {
    opts = opts || {};
    Element.call(this, opts);
    for (var key in opts) {
      this[key] = opts[key];
    }
    this._children = [];
    this.__storage = null;
    this.__dirty = true;
  };
  Group.prototype = {
    constructor: Group,
    isGroup: true,
    type: 'group',
    silent: false,
    children: function() {
      return this._children.slice();
    },
    childAt: function(idx) {
      return this._children[idx];
    },
    childOfName: function(name) {
      var children = this._children;
      for (var i = 0; i < children.length; i++) {
        if (children[i].name === name) {
          return children[i];
        }
      }
    },
    childCount: function() {
      return this._children.length;
    },
    add: function(child) {
      if (child && child !== this && child.parent !== this) {
        this._children.push(child);
        this._doAdd(child);
      }
      return this;
    },
    addBefore: function(child, nextSibling) {
      if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
        var children = this._children;
        var idx = children.indexOf(nextSibling);
        if (idx >= 0) {
          children.splice(idx, 0, child);
          this._doAdd(child);
        }
      }
      return this;
    },
    _doAdd: function(child) {
      if (child.parent) {
        child.parent.remove(child);
      }
      child.parent = this;
      var storage = this.__storage;
      var zr = this.__zr;
      if (storage && storage !== child.__storage) {
        storage.addToMap(child);
        if (child instanceof Group) {
          child.addChildrenToStorage(storage);
        }
      }
      zr && zr.refresh();
    },
    remove: function(child) {
      var zr = this.__zr;
      var storage = this.__storage;
      var children = this._children;
      var idx = zrUtil.indexOf(children, child);
      if (idx < 0) {
        return this;
      }
      children.splice(idx, 1);
      child.parent = null;
      if (storage) {
        storage.delFromMap(child.id);
        if (child instanceof Group) {
          child.delChildrenFromStorage(storage);
        }
      }
      zr && zr.refresh();
      return this;
    },
    removeAll: function() {
      var children = this._children;
      var storage = this.__storage;
      var child;
      var i;
      for (i = 0; i < children.length; i++) {
        child = children[i];
        if (storage) {
          storage.delFromMap(child.id);
          if (child instanceof Group) {
            child.delChildrenFromStorage(storage);
          }
        }
        child.parent = null;
      }
      children.length = 0;
      return this;
    },
    eachChild: function(cb, context) {
      var children = this._children;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        cb.call(context, child, i);
      }
      return this;
    },
    traverse: function(cb, context) {
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        cb.call(context, child);
        if (child.type === 'group') {
          child.traverse(cb, context);
        }
      }
      return this;
    },
    addChildrenToStorage: function(storage) {
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        storage.addToMap(child);
        if (child instanceof Group) {
          child.addChildrenToStorage(storage);
        }
      }
    },
    delChildrenFromStorage: function(storage) {
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        storage.delFromMap(child.id);
        if (child instanceof Group) {
          child.delChildrenFromStorage(storage);
        }
      }
    },
    dirty: function() {
      this.__dirty = true;
      this.__zr && this.__zr.refresh();
      return this;
    },
    getBoundingRect: function(includeChildren) {
      var rect = null;
      var tmpRect = new BoundingRect(0, 0, 0, 0);
      var children = includeChildren || this._children;
      var tmpMat = [];
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.ignore || child.invisible) {
          continue;
        }
        var childRect = child.getBoundingRect();
        var transform = child.getLocalTransform(tmpMat);
        if (transform) {
          tmpRect.copy(childRect);
          tmpRect.applyTransform(transform);
          rect = rect || tmpRect.clone();
          rect.union(tmpRect);
        } else {
          rect = rect || childRect.clone();
          rect.union(childRect);
        }
      }
      return rect || tmpRect;
    }
  };
  zrUtil.inherits(Group, Element);
  module.exports = Group;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/Storage.js", ["./core/util", "./core/env", "./container/Group", "./core/timsort"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var util = $__require('./core/util');
  var env = $__require('./core/env');
  var Group = $__require('./container/Group');
  var timsort = $__require('./core/timsort');
  function shapeCompareFunc(a, b) {
    if (a.zlevel === b.zlevel) {
      if (a.z === b.z) {
        return a.z2 - b.z2;
      }
      return a.z - b.z;
    }
    return a.zlevel - b.zlevel;
  }
  var Storage = function() {
    this._elements = {};
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
  };
  Storage.prototype = {
    constructor: Storage,
    traverse: function(cb, context) {
      for (var i = 0; i < this._roots.length; i++) {
        this._roots[i].traverse(cb, context);
      }
    },
    getDisplayList: function(update, includeIgnore) {
      includeIgnore = includeIgnore || false;
      if (update) {
        this.updateDisplayList(includeIgnore);
      }
      return this._displayList;
    },
    updateDisplayList: function(includeIgnore) {
      this._displayListLen = 0;
      var roots = this._roots;
      var displayList = this._displayList;
      for (var i = 0,
          len = roots.length; i < len; i++) {
        this._updateAndAddDisplayable(roots[i], null, includeIgnore);
      }
      displayList.length = this._displayListLen;
      env.canvasSupported && timsort(displayList, shapeCompareFunc);
    },
    _updateAndAddDisplayable: function(el, clipPaths, includeIgnore) {
      if (el.ignore && !includeIgnore) {
        return;
      }
      el.beforeUpdate();
      if (el.__dirty) {
        el.update();
      }
      el.afterUpdate();
      var clipPath = el.clipPath;
      if (clipPath) {
        clipPath.parent = el;
        clipPath.updateTransform();
        if (clipPaths) {
          clipPaths = clipPaths.slice();
          clipPaths.push(clipPath);
        } else {
          clipPaths = [clipPath];
        }
      }
      if (el.isGroup) {
        var children = el._children;
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          if (el.__dirty) {
            child.__dirty = true;
          }
          this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
        }
        el.__dirty = false;
      } else {
        el.__clipPaths = clipPaths;
        this._displayList[this._displayListLen++] = el;
      }
    },
    addRoot: function(el) {
      if (this._elements[el.id]) {
        return;
      }
      if (el instanceof Group) {
        el.addChildrenToStorage(this);
      }
      this.addToMap(el);
      this._roots.push(el);
    },
    delRoot: function(elId) {
      if (elId == null) {
        for (var i = 0; i < this._roots.length; i++) {
          var root = this._roots[i];
          if (root instanceof Group) {
            root.delChildrenFromStorage(this);
          }
        }
        this._elements = {};
        this._roots = [];
        this._displayList = [];
        this._displayListLen = 0;
        return;
      }
      if (elId instanceof Array) {
        for (var i = 0,
            l = elId.length; i < l; i++) {
          this.delRoot(elId[i]);
        }
        return;
      }
      var el;
      if (typeof(elId) == 'string') {
        el = this._elements[elId];
      } else {
        el = elId;
      }
      var idx = util.indexOf(this._roots, el);
      if (idx >= 0) {
        this.delFromMap(el.id);
        this._roots.splice(idx, 1);
        if (el instanceof Group) {
          el.delChildrenFromStorage(this);
        }
      }
    },
    addToMap: function(el) {
      if (el instanceof Group) {
        el.__storage = this;
      }
      el.dirty();
      this._elements[el.id] = el;
      return this;
    },
    get: function(elId) {
      return this._elements[elId];
    },
    delFromMap: function(elId) {
      var elements = this._elements;
      var el = elements[elId];
      if (el) {
        delete elements[elId];
        if (el instanceof Group) {
          el.__storage = null;
        }
      }
      return this;
    },
    dispose: function() {
      this._elements = this._renderList = this._roots = null;
    },
    displayableSortFunc: shapeCompareFunc
  };
  module.exports = Storage;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/animation/Animation.js", ["../core/util", "../core/event", "./requestAnimationFrame", "./Animator"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var util = $__require('../core/util');
  var Dispatcher = $__require('../core/event').Dispatcher;
  var requestAnimationFrame = $__require('./requestAnimationFrame');
  var Animator = $__require('./Animator');
  var Animation = function(options) {
    options = options || {};
    this.stage = options.stage || {};
    this.onframe = options.onframe || function() {};
    this._clips = [];
    this._running = false;
    this._time = 0;
    Dispatcher.call(this);
  };
  Animation.prototype = {
    constructor: Animation,
    addClip: function(clip) {
      this._clips.push(clip);
    },
    addAnimator: function(animator) {
      animator.animation = this;
      var clips = animator.getClips();
      for (var i = 0; i < clips.length; i++) {
        this.addClip(clips[i]);
      }
    },
    removeClip: function(clip) {
      var idx = util.indexOf(this._clips, clip);
      if (idx >= 0) {
        this._clips.splice(idx, 1);
      }
    },
    removeAnimator: function(animator) {
      var clips = animator.getClips();
      for (var i = 0; i < clips.length; i++) {
        this.removeClip(clips[i]);
      }
      animator.animation = null;
    },
    _update: function() {
      var time = new Date().getTime();
      var delta = time - this._time;
      var clips = this._clips;
      var len = clips.length;
      var deferredEvents = [];
      var deferredClips = [];
      for (var i = 0; i < len; i++) {
        var clip = clips[i];
        var e = clip.step(time);
        if (e) {
          deferredEvents.push(e);
          deferredClips.push(clip);
        }
      }
      for (var i = 0; i < len; ) {
        if (clips[i]._needsRemove) {
          clips[i] = clips[len - 1];
          clips.pop();
          len--;
        } else {
          i++;
        }
      }
      len = deferredEvents.length;
      for (var i = 0; i < len; i++) {
        deferredClips[i].fire(deferredEvents[i]);
      }
      this._time = time;
      this.onframe(delta);
      this.trigger('frame', delta);
      if (this.stage.update) {
        this.stage.update();
      }
    },
    start: function() {
      var self = this;
      this._running = true;
      function step() {
        if (self._running) {
          requestAnimationFrame(step);
          self._update();
        }
      }
      this._time = new Date().getTime();
      requestAnimationFrame(step);
    },
    stop: function() {
      this._running = false;
    },
    clear: function() {
      this._clips = [];
    },
    animate: function(target, options) {
      options = options || {};
      var animator = new Animator(target, options.loop, options.getter, options.setter);
      return animator;
    }
  };
  util.mixin(Animation, Dispatcher);
  module.exports = Animation;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/event.js", ["../mixin/Eventful"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Eventful = $__require('../mixin/Eventful');
  var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;
  function getBoundingClientRect(el) {
    return el.getBoundingClientRect ? el.getBoundingClientRect() : {
      left: 0,
      top: 0
    };
  }
  function clientToLocal(el, e, out) {
    var box = getBoundingClientRect(el);
    out = out || {};
    out.zrX = e.clientX - box.left;
    out.zrY = e.clientY - box.top;
    return out;
  }
  function normalizeEvent(el, e) {
    e = e || window.event;
    if (e.zrX != null) {
      return e;
    }
    var eventType = e.type;
    var isTouch = eventType && eventType.indexOf('touch') >= 0;
    if (!isTouch) {
      clientToLocal(el, e, e);
      e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
    } else {
      var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
      touch && clientToLocal(el, touch, e);
    }
    return e;
  }
  function addEventListener(el, name, handler) {
    if (isDomLevel2) {
      el.addEventListener(name, handler);
    } else {
      el.attachEvent('on' + name, handler);
    }
  }
  function removeEventListener(el, name, handler) {
    if (isDomLevel2) {
      el.removeEventListener(name, handler);
    } else {
      el.detachEvent('on' + name, handler);
    }
  }
  var stop = isDomLevel2 ? function(e) {
    e.preventDefault();
    e.stopPropagation();
    e.cancelBubble = true;
  } : function(e) {
    e.returnValue = false;
    e.cancelBubble = true;
  };
  module.exports = {
    clientToLocal: clientToLocal,
    normalizeEvent: normalizeEvent,
    addEventListener: addEventListener,
    removeEventListener: removeEventListener,
    stop: stop,
    Dispatcher: Eventful
  };
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/GestureMgr.js", ["./event"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var eventUtil = $__require('./event');
  var GestureMgr = function() {
    this._track = [];
  };
  GestureMgr.prototype = {
    constructor: GestureMgr,
    recognize: function(event, target, root) {
      this._doTrack(event, target, root);
      return this._recognize(event);
    },
    clear: function() {
      this._track.length = 0;
      return this;
    },
    _doTrack: function(event, target, root) {
      var touches = event.touches;
      if (!touches) {
        return;
      }
      var trackItem = {
        points: [],
        touches: [],
        target: target,
        event: event
      };
      for (var i = 0,
          len = touches.length; i < len; i++) {
        var touch = touches[i];
        var pos = eventUtil.clientToLocal(root, touch);
        trackItem.points.push([pos.zrX, pos.zrY]);
        trackItem.touches.push(touch);
      }
      this._track.push(trackItem);
    },
    _recognize: function(event) {
      for (var eventName in recognizers) {
        if (recognizers.hasOwnProperty(eventName)) {
          var gestureInfo = recognizers[eventName](this._track, event);
          if (gestureInfo) {
            return gestureInfo;
          }
        }
      }
    }
  };
  function dist(pointPair) {
    var dx = pointPair[1][0] - pointPair[0][0];
    var dy = pointPair[1][1] - pointPair[0][1];
    return Math.sqrt(dx * dx + dy * dy);
  }
  function center(pointPair) {
    return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
  }
  var recognizers = {pinch: function(track, event) {
      var trackLen = track.length;
      if (!trackLen) {
        return;
      }
      var pinchEnd = (track[trackLen - 1] || {}).points;
      var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
      if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
        var pinchScale = dist(pinchEnd) / dist(pinchPre);
        !isFinite(pinchScale) && (pinchScale = 1);
        event.pinchScale = pinchScale;
        var pinchCenter = center(pinchEnd);
        event.pinchX = pinchCenter[0];
        event.pinchY = pinchCenter[1];
        return {
          type: 'pinch',
          target: track[0].target,
          event: event
        };
      }
    }};
  module.exports = GestureMgr;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/dom/HandlerProxy.js", ["../core/event", "../core/util", "../mixin/Eventful", "../core/env", "../core/GestureMgr"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var eventTool = $__require('../core/event');
  var zrUtil = $__require('../core/util');
  var Eventful = $__require('../mixin/Eventful');
  var env = $__require('../core/env');
  var GestureMgr = $__require('../core/GestureMgr');
  var addEventListener = eventTool.addEventListener;
  var removeEventListener = eventTool.removeEventListener;
  var normalizeEvent = eventTool.normalizeEvent;
  var TOUCH_CLICK_DELAY = 300;
  var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove'];
  var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];
  function eventNameFix(name) {
    return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;
  }
  function processGesture(proxy, event, stage) {
    var gestureMgr = proxy._gestureMgr;
    stage === 'start' && gestureMgr.clear();
    var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null), proxy.dom);
    stage === 'end' && gestureMgr.clear();
    if (gestureInfo) {
      var type = gestureInfo.type;
      event.gestureEvent = type;
      proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);
    }
  }
  function setTouchTimer(instance) {
    instance._touching = true;
    clearTimeout(instance._touchTimer);
    instance._touchTimer = setTimeout(function() {
      instance._touching = false;
    }, 700);
  }
  function useTouchEvent() {
    return env.touchEventsSupported;
  }
  var domHandlers = {
    mousemove: function(event) {
      event = normalizeEvent(this.dom, event);
      this.trigger('mousemove', event);
    },
    mouseout: function(event) {
      event = normalizeEvent(this.dom, event);
      var element = event.toElement || event.relatedTarget;
      if (element != this.dom) {
        while (element && element.nodeType != 9) {
          if (element === this.dom) {
            return;
          }
          element = element.parentNode;
        }
      }
      this.trigger('mouseout', event);
    },
    touchstart: function(event) {
      event = normalizeEvent(this.dom, event);
      this._lastTouchMoment = new Date();
      processGesture(this, event, 'start');
      domHandlers.mousemove.call(this, event);
      domHandlers.mousedown.call(this, event);
      setTouchTimer(this);
    },
    touchmove: function(event) {
      event = normalizeEvent(this.dom, event);
      processGesture(this, event, 'change');
      domHandlers.mousemove.call(this, event);
      setTouchTimer(this);
    },
    touchend: function(event) {
      event = normalizeEvent(this.dom, event);
      processGesture(this, event, 'end');
      domHandlers.mouseup.call(this, event);
      if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
        domHandlers.click.call(this, event);
      }
      setTouchTimer(this);
    }
  };
  zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function(name) {
    domHandlers[name] = function(event) {
      event = normalizeEvent(this.dom, event);
      this.trigger(name, event);
    };
  });
  function initDomHandler(instance) {
    for (var i = 0; i < touchHandlerNames.length; i++) {
      var name = touchHandlerNames[i];
      instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
    }
    for (var i = 0; i < mouseHandlerNames.length; i++) {
      var name = mouseHandlerNames[i];
      instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
    }
    function makeMouseHandler(fn, instance) {
      return function() {
        if (instance._touching) {
          return;
        }
        return fn.apply(instance, arguments);
      };
    }
  }
  function HandlerDomProxy(dom) {
    Eventful.call(this);
    this.dom = dom;
    this._touching = false;
    this._touchTimer;
    this._gestureMgr = new GestureMgr();
    this._handlers = {};
    initDomHandler(this);
    if (useTouchEvent()) {
      mountHandlers(touchHandlerNames, this);
    }
    mountHandlers(mouseHandlerNames, this);
    function mountHandlers(handlerNames, instance) {
      zrUtil.each(handlerNames, function(name) {
        addEventListener(dom, eventNameFix(name), instance._handlers[name]);
      }, instance);
    }
  }
  var handlerDomProxyProto = HandlerDomProxy.prototype;
  handlerDomProxyProto.dispose = function() {
    var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
    for (var i = 0; i < handlerNames.length; i++) {
      var name = handlerNames[i];
      removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
    }
  };
  handlerDomProxyProto.setCursor = function(cursorStyle) {
    this.dom.style.cursor = cursorStyle || 'default';
  };
  zrUtil.mixin(HandlerDomProxy, Eventful);
  module.exports = HandlerDomProxy;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/timsort.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var DEFAULT_MIN_MERGE = 32;
  var DEFAULT_MIN_GALLOPING = 7;
  var DEFAULT_TMP_STORAGE_LENGTH = 256;
  function minRunLength(n) {
    var r = 0;
    while (n >= DEFAULT_MIN_MERGE) {
      r |= n & 1;
      n >>= 1;
    }
    return n + r;
  }
  function makeAscendingRun(array, lo, hi, compare) {
    var runHi = lo + 1;
    if (runHi === hi) {
      return 1;
    }
    if (compare(array[runHi++], array[lo]) < 0) {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
        runHi++;
      }
      reverseRun(array, lo, runHi);
    } else {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
        runHi++;
      }
    }
    return runHi - lo;
  }
  function reverseRun(array, lo, hi) {
    hi--;
    while (lo < hi) {
      var t = array[lo];
      array[lo++] = array[hi];
      array[hi--] = t;
    }
  }
  function binaryInsertionSort(array, lo, hi, start, compare) {
    if (start === lo) {
      start++;
    }
    for (; start < hi; start++) {
      var pivot = array[start];
      var left = lo;
      var right = start;
      var mid;
      while (left < right) {
        mid = left + right >>> 1;
        if (compare(pivot, array[mid]) < 0) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }
      var n = start - left;
      switch (n) {
        case 3:
          array[left + 3] = array[left + 2];
        case 2:
          array[left + 2] = array[left + 1];
        case 1:
          array[left + 1] = array[left];
          break;
        default:
          while (n > 0) {
            array[left + n] = array[left + n - 1];
            n--;
          }
      }
      array[left] = pivot;
    }
  }
  function gallopLeft(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;
    if (compare(value, array[start + hint]) > 0) {
      maxOffset = length - hint;
      while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      lastOffset += hint;
      offset += hint;
    } else {
      maxOffset = hint + 1;
      while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    }
    lastOffset++;
    while (lastOffset < offset) {
      var m = lastOffset + (offset - lastOffset >>> 1);
      if (compare(value, array[start + m]) > 0) {
        lastOffset = m + 1;
      } else {
        offset = m;
      }
    }
    return offset;
  }
  function gallopRight(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;
    if (compare(value, array[start + hint]) < 0) {
      maxOffset = hint + 1;
      while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    } else {
      maxOffset = length - hint;
      while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      lastOffset += hint;
      offset += hint;
    }
    lastOffset++;
    while (lastOffset < offset) {
      var m = lastOffset + (offset - lastOffset >>> 1);
      if (compare(value, array[start + m]) < 0) {
        offset = m;
      } else {
        lastOffset = m + 1;
      }
    }
    return offset;
  }
  function TimSort(array, compare) {
    var minGallop = DEFAULT_MIN_GALLOPING;
    var length = 0;
    var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
    var stackLength = 0;
    var runStart;
    var runLength;
    var stackSize = 0;
    length = array.length;
    if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
      tmpStorageLength = length >>> 1;
    }
    var tmp = [];
    stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
    runStart = [];
    runLength = [];
    function pushRun(_runStart, _runLength) {
      runStart[stackSize] = _runStart;
      runLength[stackSize] = _runLength;
      stackSize += 1;
    }
    function mergeRuns() {
      while (stackSize > 1) {
        var n = stackSize - 2;
        if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
          if (runLength[n - 1] < runLength[n + 1]) {
            n--;
          }
        } else if (runLength[n] > runLength[n + 1]) {
          break;
        }
        mergeAt(n);
      }
    }
    function forceMergeRuns() {
      while (stackSize > 1) {
        var n = stackSize - 2;
        if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
          n--;
        }
        mergeAt(n);
      }
    }
    function mergeAt(i) {
      var start1 = runStart[i];
      var length1 = runLength[i];
      var start2 = runStart[i + 1];
      var length2 = runLength[i + 1];
      runLength[i] = length1 + length2;
      if (i === stackSize - 3) {
        runStart[i + 1] = runStart[i + 2];
        runLength[i + 1] = runLength[i + 2];
      }
      stackSize--;
      var k = gallopRight(array[start2], array, start1, length1, 0, compare);
      start1 += k;
      length1 -= k;
      if (length1 === 0) {
        return;
      }
      length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
      if (length2 === 0) {
        return;
      }
      if (length1 <= length2) {
        mergeLow(start1, length1, start2, length2);
      } else {
        mergeHigh(start1, length1, start2, length2);
      }
    }
    function mergeLow(start1, length1, start2, length2) {
      var i = 0;
      for (i = 0; i < length1; i++) {
        tmp[i] = array[start1 + i];
      }
      var cursor1 = 0;
      var cursor2 = start2;
      var dest = start1;
      array[dest++] = array[cursor2++];
      if (--length2 === 0) {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
        return;
      }
      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
        return;
      }
      var _minGallop = minGallop;
      var count1,
          count2,
          exit;
      while (1) {
        count1 = 0;
        count2 = 0;
        exit = false;
        do {
          if (compare(array[cursor2], tmp[cursor1]) < 0) {
            array[dest++] = array[cursor2++];
            count2++;
            count1 = 0;
            if (--length2 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest++] = tmp[cursor1++];
            count1++;
            count2 = 0;
            if (--length1 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < _minGallop);
        if (exit) {
          break;
        }
        do {
          count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
          if (count1 !== 0) {
            for (i = 0; i < count1; i++) {
              array[dest + i] = tmp[cursor1 + i];
            }
            dest += count1;
            cursor1 += count1;
            length1 -= count1;
            if (length1 <= 1) {
              exit = true;
              break;
            }
          }
          array[dest++] = array[cursor2++];
          if (--length2 === 0) {
            exit = true;
            break;
          }
          count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
          if (count2 !== 0) {
            for (i = 0; i < count2; i++) {
              array[dest + i] = array[cursor2 + i];
            }
            dest += count2;
            cursor2 += count2;
            length2 -= count2;
            if (length2 === 0) {
              exit = true;
              break;
            }
          }
          array[dest++] = tmp[cursor1++];
          if (--length1 === 1) {
            exit = true;
            break;
          }
          _minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
        if (exit) {
          break;
        }
        if (_minGallop < 0) {
          _minGallop = 0;
        }
        _minGallop += 2;
      }
      minGallop = _minGallop;
      minGallop < 1 && (minGallop = 1);
      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
      } else if (length1 === 0) {
        throw new Error();
      } else {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
      }
    }
    function mergeHigh(start1, length1, start2, length2) {
      var i = 0;
      for (i = 0; i < length2; i++) {
        tmp[i] = array[start2 + i];
      }
      var cursor1 = start1 + length1 - 1;
      var cursor2 = length2 - 1;
      var dest = start2 + length2 - 1;
      var customCursor = 0;
      var customDest = 0;
      array[dest--] = array[cursor1--];
      if (--length1 === 0) {
        customCursor = dest - (length2 - 1);
        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }
        return;
      }
      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;
        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }
        array[dest] = tmp[cursor2];
        return;
      }
      var _minGallop = minGallop;
      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;
        do {
          if (compare(tmp[cursor2], array[cursor1]) < 0) {
            array[dest--] = array[cursor1--];
            count1++;
            count2 = 0;
            if (--length1 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest--] = tmp[cursor2--];
            count2++;
            count1 = 0;
            if (--length2 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < _minGallop);
        if (exit) {
          break;
        }
        do {
          count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
          if (count1 !== 0) {
            dest -= count1;
            cursor1 -= count1;
            length1 -= count1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;
            for (i = count1 - 1; i >= 0; i--) {
              array[customDest + i] = array[customCursor + i];
            }
            if (length1 === 0) {
              exit = true;
              break;
            }
          }
          array[dest--] = tmp[cursor2--];
          if (--length2 === 1) {
            exit = true;
            break;
          }
          count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
          if (count2 !== 0) {
            dest -= count2;
            cursor2 -= count2;
            length2 -= count2;
            customDest = dest + 1;
            customCursor = cursor2 + 1;
            for (i = 0; i < count2; i++) {
              array[customDest + i] = tmp[customCursor + i];
            }
            if (length2 <= 1) {
              exit = true;
              break;
            }
          }
          array[dest--] = array[cursor1--];
          if (--length1 === 0) {
            exit = true;
            break;
          }
          _minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
        if (exit) {
          break;
        }
        if (_minGallop < 0) {
          _minGallop = 0;
        }
        _minGallop += 2;
      }
      minGallop = _minGallop;
      if (minGallop < 1) {
        minGallop = 1;
      }
      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;
        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }
        array[dest] = tmp[cursor2];
      } else if (length2 === 0) {
        throw new Error();
      } else {
        customCursor = dest - (length2 - 1);
        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }
      }
    }
    this.mergeRuns = mergeRuns;
    this.forceMergeRuns = forceMergeRuns;
    this.pushRun = pushRun;
  }
  function sort(array, compare, lo, hi) {
    if (!lo) {
      lo = 0;
    }
    if (!hi) {
      hi = array.length;
    }
    var remaining = hi - lo;
    if (remaining < 2) {
      return;
    }
    var runLength = 0;
    if (remaining < DEFAULT_MIN_MERGE) {
      runLength = makeAscendingRun(array, lo, hi, compare);
      binaryInsertionSort(array, lo, hi, lo + runLength, compare);
      return;
    }
    var ts = new TimSort(array, compare);
    var minRun = minRunLength(remaining);
    do {
      runLength = makeAscendingRun(array, lo, hi, compare);
      if (runLength < minRun) {
        var force = remaining;
        if (force > minRun) {
          force = minRun;
        }
        binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
        runLength = force;
      }
      ts.pushRun(lo, runLength);
      ts.mergeRuns();
      remaining -= runLength;
      lo += runLength;
    } while (remaining !== 0);
    ts.forceMergeRuns();
  }
  module.exports = sort;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/Pattern.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Pattern = function(image, repeat) {
    this.image = image;
    this.repeat = repeat;
    this.type = 'pattern';
  };
  Pattern.prototype.getCanvasPattern = function(ctx) {
    return this._canvasPattern || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));
  };
  module.exports = Pattern;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/Layer.js", ["./core/util", "./config", "./graphic/Style", "./graphic/Pattern"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var util = $__require('./core/util');
  var config = $__require('./config');
  var Style = $__require('./graphic/Style');
  var Pattern = $__require('./graphic/Pattern');
  function returnFalse() {
    return false;
  }
  function createDom(id, type, painter, dpr) {
    var newDom = document.createElement(type);
    var width = painter.getWidth();
    var height = painter.getHeight();
    var newDomStyle = newDom.style;
    newDomStyle.position = 'absolute';
    newDomStyle.left = 0;
    newDomStyle.top = 0;
    newDomStyle.width = width + 'px';
    newDomStyle.height = height + 'px';
    newDom.width = width * dpr;
    newDom.height = height * dpr;
    newDom.setAttribute('data-zr-dom-id', id);
    return newDom;
  }
  var Layer = function(id, painter, dpr) {
    var dom;
    dpr = dpr || config.devicePixelRatio;
    if (typeof id === 'string') {
      dom = createDom(id, 'canvas', painter, dpr);
    } else if (util.isObject(id)) {
      dom = id;
      id = dom.id;
    }
    this.id = id;
    this.dom = dom;
    var domStyle = dom.style;
    if (domStyle) {
      dom.onselectstart = returnFalse;
      domStyle['-webkit-user-select'] = 'none';
      domStyle['user-select'] = 'none';
      domStyle['-webkit-touch-callout'] = 'none';
      domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
    }
    this.domBack = null;
    this.ctxBack = null;
    this.painter = painter;
    this.config = null;
    this.clearColor = 0;
    this.motionBlur = false;
    this.lastFrameAlpha = 0.7;
    this.dpr = dpr;
  };
  Layer.prototype = {
    constructor: Layer,
    elCount: 0,
    __dirty: true,
    initContext: function() {
      this.ctx = this.dom.getContext('2d');
      var dpr = this.dpr;
      if (dpr != 1) {
        this.ctx.scale(dpr, dpr);
      }
    },
    createBackBuffer: function() {
      var dpr = this.dpr;
      this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);
      this.ctxBack = this.domBack.getContext('2d');
      if (dpr != 1) {
        this.ctxBack.scale(dpr, dpr);
      }
    },
    resize: function(width, height) {
      var dpr = this.dpr;
      var dom = this.dom;
      var domStyle = dom.style;
      var domBack = this.domBack;
      domStyle.width = width + 'px';
      domStyle.height = height + 'px';
      dom.width = width * dpr;
      dom.height = height * dpr;
      if (dpr != 1) {
        this.ctx.scale(dpr, dpr);
      }
      if (domBack) {
        domBack.width = width * dpr;
        domBack.height = height * dpr;
        if (dpr != 1) {
          this.ctxBack.scale(dpr, dpr);
        }
      }
    },
    clear: function(clearAll) {
      var dom = this.dom;
      var ctx = this.ctx;
      var width = dom.width;
      var height = dom.height;
      var clearColor = this.clearColor;
      var haveMotionBLur = this.motionBlur && !clearAll;
      var lastFrameAlpha = this.lastFrameAlpha;
      var dpr = this.dpr;
      if (haveMotionBLur) {
        if (!this.domBack) {
          this.createBackBuffer();
        }
        this.ctxBack.globalCompositeOperation = 'copy';
        this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
      }
      ctx.clearRect(0, 0, width / dpr, height / dpr);
      if (clearColor) {
        var clearColorGradientOrPattern;
        if (clearColor.colorStops) {
          clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
            x: 0,
            y: 0,
            width: width / dpr,
            height: height / dpr
          });
          clearColor.__canvasGradient = clearColorGradientOrPattern;
        } else if (clearColor.image) {
          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
        }
        ctx.save();
        ctx.fillStyle = clearColorGradientOrPattern || clearColor;
        ctx.fillRect(0, 0, width / dpr, height / dpr);
        ctx.restore();
      }
      if (haveMotionBLur) {
        var domBack = this.domBack;
        ctx.save();
        ctx.globalAlpha = lastFrameAlpha;
        ctx.drawImage(domBack, 0, 0, width / dpr, height / dpr);
        ctx.restore();
      }
    }
  };
  module.exports = Layer;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/animation/requestAnimationFrame.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = (typeof window !== 'undefined' && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame)) || function(func) {
    setTimeout(func, 16);
  };
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/Style.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]];
  var Style = function(opts) {
    this.extendFrom(opts);
  };
  function createLinearGradient(ctx, obj, rect) {
    var x = obj.x;
    var x2 = obj.x2;
    var y = obj.y;
    var y2 = obj.y2;
    if (!obj.global) {
      x = x * rect.width + rect.x;
      x2 = x2 * rect.width + rect.x;
      y = y * rect.height + rect.y;
      y2 = y2 * rect.height + rect.y;
    }
    var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
    return canvasGradient;
  }
  function createRadialGradient(ctx, obj, rect) {
    var width = rect.width;
    var height = rect.height;
    var min = Math.min(width, height);
    var x = obj.x;
    var y = obj.y;
    var r = obj.r;
    if (!obj.global) {
      x = x * width + rect.x;
      y = y * height + rect.y;
      r = r * min;
    }
    var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
    return canvasGradient;
  }
  Style.prototype = {
    constructor: Style,
    fill: '#000000',
    stroke: null,
    opacity: 1,
    lineDash: null,
    lineDashOffset: 0,
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    lineWidth: 1,
    strokeNoScale: false,
    text: null,
    textFill: '#000',
    textStroke: null,
    textPosition: 'inside',
    textBaseline: null,
    textAlign: null,
    textVerticalAlign: null,
    textDistance: 5,
    textShadowBlur: 0,
    textShadowOffsetX: 0,
    textShadowOffsetY: 0,
    blend: null,
    bind: function(ctx, el, prevEl) {
      var style = this;
      var prevStyle = prevEl && prevEl.style;
      var firstDraw = !prevStyle;
      for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
        var prop = STYLE_COMMON_PROPS[i];
        var styleName = prop[0];
        if (firstDraw || style[styleName] !== prevStyle[styleName]) {
          ctx[styleName] = style[styleName] || prop[1];
        }
      }
      if ((firstDraw || style.fill !== prevStyle.fill)) {
        ctx.fillStyle = style.fill;
      }
      if ((firstDraw || style.stroke !== prevStyle.stroke)) {
        ctx.strokeStyle = style.stroke;
      }
      if ((firstDraw || style.opacity !== prevStyle.opacity)) {
        ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
      }
      if ((firstDraw || style.blend !== prevStyle.blend)) {
        ctx.globalCompositeOperation = style.blend || 'source-over';
      }
      if (this.hasStroke()) {
        var lineWidth = style.lineWidth;
        ctx.lineWidth = lineWidth / ((this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1);
      }
    },
    hasFill: function() {
      var fill = this.fill;
      return fill != null && fill !== 'none';
    },
    hasStroke: function() {
      var stroke = this.stroke;
      return stroke != null && stroke !== 'none' && this.lineWidth > 0;
    },
    extendFrom: function(otherStyle, overwrite) {
      if (otherStyle) {
        var target = this;
        for (var name in otherStyle) {
          if (otherStyle.hasOwnProperty(name) && (overwrite || !target.hasOwnProperty(name))) {
            target[name] = otherStyle[name];
          }
        }
      }
    },
    set: function(obj, value) {
      if (typeof obj === 'string') {
        this[obj] = value;
      } else {
        this.extendFrom(obj, true);
      }
    },
    clone: function() {
      var newStyle = new this.constructor();
      newStyle.extendFrom(this, true);
      return newStyle;
    },
    getGradient: function(ctx, obj, rect) {
      var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
      var canvasGradient = method(ctx, obj, rect);
      var colorStops = obj.colorStops;
      for (var i = 0; i < colorStops.length; i++) {
        canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
      }
      return canvasGradient;
    }
  };
  var styleProto = Style.prototype;
  for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
    var prop = STYLE_COMMON_PROPS[i];
    if (!(prop[0] in styleProto)) {
      styleProto[prop[0]] = prop[1];
    }
  }
  Style.getGradient = styleProto.getGradient;
  module.exports = Style;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/guid.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var idStart = 0x0907;
  module.exports = function() {
    return idStart++;
  };
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/mixin/Eventful.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var arrySlice = Array.prototype.slice;
  var Eventful = function() {
    this._$handlers = {};
  };
  Eventful.prototype = {
    constructor: Eventful,
    one: function(event, handler, context) {
      var _h = this._$handlers;
      if (!handler || !event) {
        return this;
      }
      if (!_h[event]) {
        _h[event] = [];
      }
      for (var i = 0; i < _h[event].length; i++) {
        if (_h[event][i].h === handler) {
          return this;
        }
      }
      _h[event].push({
        h: handler,
        one: true,
        ctx: context || this
      });
      return this;
    },
    on: function(event, handler, context) {
      var _h = this._$handlers;
      if (!handler || !event) {
        return this;
      }
      if (!_h[event]) {
        _h[event] = [];
      }
      for (var i = 0; i < _h[event].length; i++) {
        if (_h[event][i].h === handler) {
          return this;
        }
      }
      _h[event].push({
        h: handler,
        one: false,
        ctx: context || this
      });
      return this;
    },
    isSilent: function(event) {
      var _h = this._$handlers;
      return _h[event] && _h[event].length;
    },
    off: function(event, handler) {
      var _h = this._$handlers;
      if (!event) {
        this._$handlers = {};
        return this;
      }
      if (handler) {
        if (_h[event]) {
          var newList = [];
          for (var i = 0,
              l = _h[event].length; i < l; i++) {
            if (_h[event][i]['h'] != handler) {
              newList.push(_h[event][i]);
            }
          }
          _h[event] = newList;
        }
        if (_h[event] && _h[event].length === 0) {
          delete _h[event];
        }
      } else {
        delete _h[event];
      }
      return this;
    },
    trigger: function(type) {
      if (this._$handlers[type]) {
        var args = arguments;
        var argLen = args.length;
        if (argLen > 3) {
          args = arrySlice.call(args, 1);
        }
        var _h = this._$handlers[type];
        var len = _h.length;
        for (var i = 0; i < len; ) {
          switch (argLen) {
            case 1:
              _h[i]['h'].call(_h[i]['ctx']);
              break;
            case 2:
              _h[i]['h'].call(_h[i]['ctx'], args[1]);
              break;
            case 3:
              _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
              break;
            default:
              _h[i]['h'].apply(_h[i]['ctx'], args);
              break;
          }
          if (_h[i]['one']) {
            _h.splice(i, 1);
            len--;
          } else {
            i++;
          }
        }
      }
      return this;
    },
    triggerWithContext: function(type) {
      if (this._$handlers[type]) {
        var args = arguments;
        var argLen = args.length;
        if (argLen > 4) {
          args = arrySlice.call(args, 1, args.length - 1);
        }
        var ctx = args[args.length - 1];
        var _h = this._$handlers[type];
        var len = _h.length;
        for (var i = 0; i < len; ) {
          switch (argLen) {
            case 1:
              _h[i]['h'].call(ctx);
              break;
            case 2:
              _h[i]['h'].call(ctx, args[1]);
              break;
            case 3:
              _h[i]['h'].call(ctx, args[1], args[2]);
              break;
            default:
              _h[i]['h'].apply(ctx, args);
              break;
          }
          if (_h[i]['one']) {
            _h.splice(i, 1);
            len--;
          } else {
            i++;
          }
        }
      }
      return this;
    }
  };
  module.exports = Eventful;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/mixin/Transformable.js", ["../core/matrix", "../core/vector"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var matrix = $__require('../core/matrix');
  var vector = $__require('../core/vector');
  var mIdentity = matrix.identity;
  var EPSILON = 5e-5;
  function isNotAroundZero(val) {
    return val > EPSILON || val < -EPSILON;
  }
  var Transformable = function(opts) {
    opts = opts || {};
    if (!opts.position) {
      this.position = [0, 0];
    }
    if (opts.rotation == null) {
      this.rotation = 0;
    }
    if (!opts.scale) {
      this.scale = [1, 1];
    }
    this.origin = this.origin || null;
  };
  var transformableProto = Transformable.prototype;
  transformableProto.transform = null;
  transformableProto.needLocalTransform = function() {
    return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
  };
  transformableProto.updateTransform = function() {
    var parent = this.parent;
    var parentHasTransform = parent && parent.transform;
    var needLocalTransform = this.needLocalTransform();
    var m = this.transform;
    if (!(needLocalTransform || parentHasTransform)) {
      m && mIdentity(m);
      return;
    }
    m = m || matrix.create();
    if (needLocalTransform) {
      this.getLocalTransform(m);
    } else {
      mIdentity(m);
    }
    if (parentHasTransform) {
      if (needLocalTransform) {
        matrix.mul(m, parent.transform, m);
      } else {
        matrix.copy(m, parent.transform);
      }
    }
    this.transform = m;
    this.invTransform = this.invTransform || matrix.create();
    matrix.invert(this.invTransform, m);
  };
  transformableProto.getLocalTransform = function(m) {
    m = m || [];
    mIdentity(m);
    var origin = this.origin;
    var scale = this.scale;
    var rotation = this.rotation;
    var position = this.position;
    if (origin) {
      m[4] -= origin[0];
      m[5] -= origin[1];
    }
    matrix.scale(m, m, scale);
    if (rotation) {
      matrix.rotate(m, m, rotation);
    }
    if (origin) {
      m[4] += origin[0];
      m[5] += origin[1];
    }
    m[4] += position[0];
    m[5] += position[1];
    return m;
  };
  transformableProto.setTransform = function(ctx) {
    var m = this.transform;
    if (m) {
      ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    }
  };
  transformableProto.restoreTransform = function(ctx) {
    var m = this.invTransform;
    if (m) {
      ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    }
  };
  var tmpTransform = [];
  transformableProto.decomposeTransform = function() {
    if (!this.transform) {
      return;
    }
    var parent = this.parent;
    var m = this.transform;
    if (parent && parent.transform) {
      matrix.mul(tmpTransform, parent.invTransform, m);
      m = tmpTransform;
    }
    var sx = m[0] * m[0] + m[1] * m[1];
    var sy = m[2] * m[2] + m[3] * m[3];
    var position = this.position;
    var scale = this.scale;
    if (isNotAroundZero(sx - 1)) {
      sx = Math.sqrt(sx);
    }
    if (isNotAroundZero(sy - 1)) {
      sy = Math.sqrt(sy);
    }
    if (m[0] < 0) {
      sx = -sx;
    }
    if (m[3] < 0) {
      sy = -sy;
    }
    position[0] = m[4];
    position[1] = m[5];
    scale[0] = sx;
    scale[1] = sy;
    this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
  };
  transformableProto.getGlobalScale = function() {
    var m = this.transform;
    if (!m) {
      return [1, 1];
    }
    var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
    var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
    if (m[0] < 0) {
      sx = -sx;
    }
    if (m[3] < 0) {
      sy = -sy;
    }
    return [sx, sy];
  };
  transformableProto.transformCoordToLocal = function(x, y) {
    var v2 = [x, y];
    var invTransform = this.invTransform;
    if (invTransform) {
      vector.applyTransform(v2, v2, invTransform);
    }
    return v2;
  };
  transformableProto.transformCoordToGlobal = function(x, y) {
    var v2 = [x, y];
    var transform = this.transform;
    if (transform) {
      vector.applyTransform(v2, v2, transform);
    }
    return v2;
  };
  module.exports = Transformable;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/animation/easing.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var easing = {
    linear: function(k) {
      return k;
    },
    quadraticIn: function(k) {
      return k * k;
    },
    quadraticOut: function(k) {
      return k * (2 - k);
    },
    quadraticInOut: function(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k;
      }
      return -0.5 * (--k * (k - 2) - 1);
    },
    cubicIn: function(k) {
      return k * k * k;
    },
    cubicOut: function(k) {
      return --k * k * k + 1;
    },
    cubicInOut: function(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k;
      }
      return 0.5 * ((k -= 2) * k * k + 2);
    },
    quarticIn: function(k) {
      return k * k * k * k;
    },
    quarticOut: function(k) {
      return 1 - (--k * k * k * k);
    },
    quarticInOut: function(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k * k;
      }
      return -0.5 * ((k -= 2) * k * k * k - 2);
    },
    quinticIn: function(k) {
      return k * k * k * k * k;
    },
    quinticOut: function(k) {
      return --k * k * k * k * k + 1;
    },
    quinticInOut: function(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k * k * k;
      }
      return 0.5 * ((k -= 2) * k * k * k * k + 2);
    },
    sinusoidalIn: function(k) {
      return 1 - Math.cos(k * Math.PI / 2);
    },
    sinusoidalOut: function(k) {
      return Math.sin(k * Math.PI / 2);
    },
    sinusoidalInOut: function(k) {
      return 0.5 * (1 - Math.cos(Math.PI * k));
    },
    exponentialIn: function(k) {
      return k === 0 ? 0 : Math.pow(1024, k - 1);
    },
    exponentialOut: function(k) {
      return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
    },
    exponentialInOut: function(k) {
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      if ((k *= 2) < 1) {
        return 0.5 * Math.pow(1024, k - 1);
      }
      return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
    },
    circularIn: function(k) {
      return 1 - Math.sqrt(1 - k * k);
    },
    circularOut: function(k) {
      return Math.sqrt(1 - (--k * k));
    },
    circularInOut: function(k) {
      if ((k *= 2) < 1) {
        return -0.5 * (Math.sqrt(1 - k * k) - 1);
      }
      return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    },
    elasticIn: function(k) {
      var s;
      var a = 0.1;
      var p = 0.4;
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }
      return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    },
    elasticOut: function(k) {
      var s;
      var a = 0.1;
      var p = 0.4;
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }
      return (a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1);
    },
    elasticInOut: function(k) {
      var s;
      var a = 0.1;
      var p = 0.4;
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }
      if ((k *= 2) < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      }
      return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
    },
    backIn: function(k) {
      var s = 1.70158;
      return k * k * ((s + 1) * k - s);
    },
    backOut: function(k) {
      var s = 1.70158;
      return --k * k * ((s + 1) * k + s) + 1;
    },
    backInOut: function(k) {
      var s = 1.70158 * 1.525;
      if ((k *= 2) < 1) {
        return 0.5 * (k * k * ((s + 1) * k - s));
      }
      return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    },
    bounceIn: function(k) {
      return 1 - easing.bounceOut(1 - k);
    },
    bounceOut: function(k) {
      if (k < (1 / 2.75)) {
        return 7.5625 * k * k;
      } else if (k < (2 / 2.75)) {
        return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
      } else if (k < (2.5 / 2.75)) {
        return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
      } else {
        return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
      }
    },
    bounceInOut: function(k) {
      if (k < 0.5) {
        return easing.bounceIn(k * 2) * 0.5;
      }
      return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
    }
  };
  module.exports = easing;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/animation/Clip.js", ["./easing"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var easingFuncs = $__require('./easing');
  function Clip(options) {
    this._target = options.target;
    this._life = options.life || 1000;
    this._delay = options.delay || 0;
    this._initialized = false;
    this.loop = options.loop == null ? false : options.loop;
    this.gap = options.gap || 0;
    this.easing = options.easing || 'Linear';
    this.onframe = options.onframe;
    this.ondestroy = options.ondestroy;
    this.onrestart = options.onrestart;
  }
  Clip.prototype = {
    constructor: Clip,
    step: function(time) {
      if (!this._initialized) {
        this._startTime = new Date().getTime() + this._delay;
        this._initialized = true;
      }
      var percent = (time - this._startTime) / this._life;
      if (percent < 0) {
        return;
      }
      percent = Math.min(percent, 1);
      var easing = this.easing;
      var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
      var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
      this.fire('frame', schedule);
      if (percent == 1) {
        if (this.loop) {
          this.restart();
          return 'restart';
        }
        this._needsRemove = true;
        return 'destroy';
      }
      return null;
    },
    restart: function() {
      var time = new Date().getTime();
      var remainder = (time - this._startTime) % this._life;
      this._startTime = new Date().getTime() - remainder + this.gap;
      this._needsRemove = false;
    },
    fire: function(eventType, arg) {
      eventType = 'on' + eventType;
      if (this[eventType]) {
        this[eventType](this._target, arg);
      }
    }
  };
  module.exports = Clip;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/tool/color.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var kCSSColorTable = {
    'transparent': [0, 0, 0, 0],
    'aliceblue': [240, 248, 255, 1],
    'antiquewhite': [250, 235, 215, 1],
    'aqua': [0, 255, 255, 1],
    'aquamarine': [127, 255, 212, 1],
    'azure': [240, 255, 255, 1],
    'beige': [245, 245, 220, 1],
    'bisque': [255, 228, 196, 1],
    'black': [0, 0, 0, 1],
    'blanchedalmond': [255, 235, 205, 1],
    'blue': [0, 0, 255, 1],
    'blueviolet': [138, 43, 226, 1],
    'brown': [165, 42, 42, 1],
    'burlywood': [222, 184, 135, 1],
    'cadetblue': [95, 158, 160, 1],
    'chartreuse': [127, 255, 0, 1],
    'chocolate': [210, 105, 30, 1],
    'coral': [255, 127, 80, 1],
    'cornflowerblue': [100, 149, 237, 1],
    'cornsilk': [255, 248, 220, 1],
    'crimson': [220, 20, 60, 1],
    'cyan': [0, 255, 255, 1],
    'darkblue': [0, 0, 139, 1],
    'darkcyan': [0, 139, 139, 1],
    'darkgoldenrod': [184, 134, 11, 1],
    'darkgray': [169, 169, 169, 1],
    'darkgreen': [0, 100, 0, 1],
    'darkgrey': [169, 169, 169, 1],
    'darkkhaki': [189, 183, 107, 1],
    'darkmagenta': [139, 0, 139, 1],
    'darkolivegreen': [85, 107, 47, 1],
    'darkorange': [255, 140, 0, 1],
    'darkorchid': [153, 50, 204, 1],
    'darkred': [139, 0, 0, 1],
    'darksalmon': [233, 150, 122, 1],
    'darkseagreen': [143, 188, 143, 1],
    'darkslateblue': [72, 61, 139, 1],
    'darkslategray': [47, 79, 79, 1],
    'darkslategrey': [47, 79, 79, 1],
    'darkturquoise': [0, 206, 209, 1],
    'darkviolet': [148, 0, 211, 1],
    'deeppink': [255, 20, 147, 1],
    'deepskyblue': [0, 191, 255, 1],
    'dimgray': [105, 105, 105, 1],
    'dimgrey': [105, 105, 105, 1],
    'dodgerblue': [30, 144, 255, 1],
    'firebrick': [178, 34, 34, 1],
    'floralwhite': [255, 250, 240, 1],
    'forestgreen': [34, 139, 34, 1],
    'fuchsia': [255, 0, 255, 1],
    'gainsboro': [220, 220, 220, 1],
    'ghostwhite': [248, 248, 255, 1],
    'gold': [255, 215, 0, 1],
    'goldenrod': [218, 165, 32, 1],
    'gray': [128, 128, 128, 1],
    'green': [0, 128, 0, 1],
    'greenyellow': [173, 255, 47, 1],
    'grey': [128, 128, 128, 1],
    'honeydew': [240, 255, 240, 1],
    'hotpink': [255, 105, 180, 1],
    'indianred': [205, 92, 92, 1],
    'indigo': [75, 0, 130, 1],
    'ivory': [255, 255, 240, 1],
    'khaki': [240, 230, 140, 1],
    'lavender': [230, 230, 250, 1],
    'lavenderblush': [255, 240, 245, 1],
    'lawngreen': [124, 252, 0, 1],
    'lemonchiffon': [255, 250, 205, 1],
    'lightblue': [173, 216, 230, 1],
    'lightcoral': [240, 128, 128, 1],
    'lightcyan': [224, 255, 255, 1],
    'lightgoldenrodyellow': [250, 250, 210, 1],
    'lightgray': [211, 211, 211, 1],
    'lightgreen': [144, 238, 144, 1],
    'lightgrey': [211, 211, 211, 1],
    'lightpink': [255, 182, 193, 1],
    'lightsalmon': [255, 160, 122, 1],
    'lightseagreen': [32, 178, 170, 1],
    'lightskyblue': [135, 206, 250, 1],
    'lightslategray': [119, 136, 153, 1],
    'lightslategrey': [119, 136, 153, 1],
    'lightsteelblue': [176, 196, 222, 1],
    'lightyellow': [255, 255, 224, 1],
    'lime': [0, 255, 0, 1],
    'limegreen': [50, 205, 50, 1],
    'linen': [250, 240, 230, 1],
    'magenta': [255, 0, 255, 1],
    'maroon': [128, 0, 0, 1],
    'mediumaquamarine': [102, 205, 170, 1],
    'mediumblue': [0, 0, 205, 1],
    'mediumorchid': [186, 85, 211, 1],
    'mediumpurple': [147, 112, 219, 1],
    'mediumseagreen': [60, 179, 113, 1],
    'mediumslateblue': [123, 104, 238, 1],
    'mediumspringgreen': [0, 250, 154, 1],
    'mediumturquoise': [72, 209, 204, 1],
    'mediumvioletred': [199, 21, 133, 1],
    'midnightblue': [25, 25, 112, 1],
    'mintcream': [245, 255, 250, 1],
    'mistyrose': [255, 228, 225, 1],
    'moccasin': [255, 228, 181, 1],
    'navajowhite': [255, 222, 173, 1],
    'navy': [0, 0, 128, 1],
    'oldlace': [253, 245, 230, 1],
    'olive': [128, 128, 0, 1],
    'olivedrab': [107, 142, 35, 1],
    'orange': [255, 165, 0, 1],
    'orangered': [255, 69, 0, 1],
    'orchid': [218, 112, 214, 1],
    'palegoldenrod': [238, 232, 170, 1],
    'palegreen': [152, 251, 152, 1],
    'paleturquoise': [175, 238, 238, 1],
    'palevioletred': [219, 112, 147, 1],
    'papayawhip': [255, 239, 213, 1],
    'peachpuff': [255, 218, 185, 1],
    'peru': [205, 133, 63, 1],
    'pink': [255, 192, 203, 1],
    'plum': [221, 160, 221, 1],
    'powderblue': [176, 224, 230, 1],
    'purple': [128, 0, 128, 1],
    'red': [255, 0, 0, 1],
    'rosybrown': [188, 143, 143, 1],
    'royalblue': [65, 105, 225, 1],
    'saddlebrown': [139, 69, 19, 1],
    'salmon': [250, 128, 114, 1],
    'sandybrown': [244, 164, 96, 1],
    'seagreen': [46, 139, 87, 1],
    'seashell': [255, 245, 238, 1],
    'sienna': [160, 82, 45, 1],
    'silver': [192, 192, 192, 1],
    'skyblue': [135, 206, 235, 1],
    'slateblue': [106, 90, 205, 1],
    'slategray': [112, 128, 144, 1],
    'slategrey': [112, 128, 144, 1],
    'snow': [255, 250, 250, 1],
    'springgreen': [0, 255, 127, 1],
    'steelblue': [70, 130, 180, 1],
    'tan': [210, 180, 140, 1],
    'teal': [0, 128, 128, 1],
    'thistle': [216, 191, 216, 1],
    'tomato': [255, 99, 71, 1],
    'turquoise': [64, 224, 208, 1],
    'violet': [238, 130, 238, 1],
    'wheat': [245, 222, 179, 1],
    'white': [255, 255, 255, 1],
    'whitesmoke': [245, 245, 245, 1],
    'yellow': [255, 255, 0, 1],
    'yellowgreen': [154, 205, 50, 1]
  };
  function clampCssByte(i) {
    i = Math.round(i);
    return i < 0 ? 0 : i > 255 ? 255 : i;
  }
  function clampCssAngle(i) {
    i = Math.round(i);
    return i < 0 ? 0 : i > 360 ? 360 : i;
  }
  function clampCssFloat(f) {
    return f < 0 ? 0 : f > 1 ? 1 : f;
  }
  function parseCssInt(str) {
    if (str.length && str.charAt(str.length - 1) === '%') {
      return clampCssByte(parseFloat(str) / 100 * 255);
    }
    return clampCssByte(parseInt(str, 10));
  }
  function parseCssFloat(str) {
    if (str.length && str.charAt(str.length - 1) === '%') {
      return clampCssFloat(parseFloat(str) / 100);
    }
    return clampCssFloat(parseFloat(str));
  }
  function cssHueToRgb(m1, m2, h) {
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
    if (h * 6 < 1) {
      return m1 + (m2 - m1) * h * 6;
    }
    if (h * 2 < 1) {
      return m2;
    }
    if (h * 3 < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }
    return m1;
  }
  function lerp(a, b, p) {
    return a + (b - a) * p;
  }
  function parse(colorStr) {
    if (!colorStr) {
      return;
    }
    colorStr = colorStr + '';
    var str = colorStr.replace(/ /g, '').toLowerCase();
    if (str in kCSSColorTable) {
      return kCSSColorTable[str].slice();
    }
    if (str.charAt(0) === '#') {
      if (str.length === 4) {
        var iv = parseInt(str.substr(1), 16);
        if (!(iv >= 0 && iv <= 0xfff)) {
          return;
        }
        return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8), (iv & 0xf0) | ((iv & 0xf0) >> 4), (iv & 0xf) | ((iv & 0xf) << 4), 1];
      } else if (str.length === 7) {
        var iv = parseInt(str.substr(1), 16);
        if (!(iv >= 0 && iv <= 0xffffff)) {
          return;
        }
        return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1];
      }
      return;
    }
    var op = str.indexOf('('),
        ep = str.indexOf(')');
    if (op !== -1 && ep + 1 === str.length) {
      var fname = str.substr(0, op);
      var params = str.substr(op + 1, ep - (op + 1)).split(',');
      var alpha = 1;
      switch (fname) {
        case 'rgba':
          if (params.length !== 4) {
            return;
          }
          alpha = parseCssFloat(params.pop());
        case 'rgb':
          if (params.length !== 3) {
            return;
          }
          return [parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha];
        case 'hsla':
          if (params.length !== 4) {
            return;
          }
          params[3] = parseCssFloat(params[3]);
          return hsla2rgba(params);
        case 'hsl':
          if (params.length !== 3) {
            return;
          }
          return hsla2rgba(params);
        default:
          return;
      }
    }
    return;
  }
  function hsla2rgba(hsla) {
    var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;
    var s = parseCssFloat(hsla[1]);
    var l = parseCssFloat(hsla[2]);
    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
    var m1 = l * 2 - m2;
    var rgba = [clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)];
    if (hsla.length === 4) {
      rgba[3] = hsla[3];
    }
    return rgba;
  }
  function rgba2hsla(rgba) {
    if (!rgba) {
      return;
    }
    var R = rgba[0] / 255;
    var G = rgba[1] / 255;
    var B = rgba[2] / 255;
    var vMin = Math.min(R, G, B);
    var vMax = Math.max(R, G, B);
    var delta = vMax - vMin;
    var L = (vMax + vMin) / 2;
    var H;
    var S;
    if (delta === 0) {
      H = 0;
      S = 0;
    } else {
      if (L < 0.5) {
        S = delta / (vMax + vMin);
      } else {
        S = delta / (2 - vMax - vMin);
      }
      var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
      var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
      var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;
      if (R === vMax) {
        H = deltaB - deltaG;
      } else if (G === vMax) {
        H = (1 / 3) + deltaR - deltaB;
      } else if (B === vMax) {
        H = (2 / 3) + deltaG - deltaR;
      }
      if (H < 0) {
        H += 1;
      }
      if (H > 1) {
        H -= 1;
      }
    }
    var hsla = [H * 360, S, L];
    if (rgba[3] != null) {
      hsla.push(rgba[3]);
    }
    return hsla;
  }
  function lift(color, level) {
    var colorArr = parse(color);
    if (colorArr) {
      for (var i = 0; i < 3; i++) {
        if (level < 0) {
          colorArr[i] = colorArr[i] * (1 - level) | 0;
        } else {
          colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;
        }
      }
      return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
    }
  }
  function toHex(color, level) {
    var colorArr = parse(color);
    if (colorArr) {
      return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);
    }
  }
  function fastMapToColor(normalizedValue, colors, out) {
    if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
      return;
    }
    out = out || [0, 0, 0, 0];
    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = colors[leftIndex];
    var rightColor = colors[rightIndex];
    var dv = value - leftIndex;
    out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));
    out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));
    out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));
    out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));
    return out;
  }
  function mapToColor(normalizedValue, colors, fullOutput) {
    if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
      return;
    }
    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = parse(colors[leftIndex]);
    var rightColor = parse(colors[rightIndex]);
    var dv = value - leftIndex;
    var color = stringify([clampCssByte(lerp(leftColor[0], rightColor[0], dv)), clampCssByte(lerp(leftColor[1], rightColor[1], dv)), clampCssByte(lerp(leftColor[2], rightColor[2], dv)), clampCssFloat(lerp(leftColor[3], rightColor[3], dv))], 'rgba');
    return fullOutput ? {
      color: color,
      leftIndex: leftIndex,
      rightIndex: rightIndex,
      value: value
    } : color;
  }
  function modifyHSL(color, h, s, l) {
    color = parse(color);
    if (color) {
      color = rgba2hsla(color);
      h != null && (color[0] = clampCssAngle(h));
      s != null && (color[1] = parseCssFloat(s));
      l != null && (color[2] = parseCssFloat(l));
      return stringify(hsla2rgba(color), 'rgba');
    }
  }
  function modifyAlpha(color, alpha) {
    color = parse(color);
    if (color && alpha != null) {
      color[3] = clampCssFloat(alpha);
      return stringify(color, 'rgba');
    }
  }
  function stringify(arrColor, type) {
    var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
    if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
      colorStr += ',' + arrColor[3];
    }
    return type + '(' + colorStr + ')';
  }
  module.exports = {
    parse: parse,
    lift: lift,
    toHex: toHex,
    fastMapToColor: fastMapToColor,
    mapToColor: mapToColor,
    modifyHSL: modifyHSL,
    modifyAlpha: modifyAlpha,
    stringify: stringify
  };
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/animation/Animator.js", ["./Clip", "../tool/color", "../core/util"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Clip = $__require('./Clip');
  var color = $__require('../tool/color');
  var util = $__require('../core/util');
  var isArrayLike = util.isArrayLike;
  var arraySlice = Array.prototype.slice;
  function defaultGetter(target, key) {
    return target[key];
  }
  function defaultSetter(target, key, value) {
    target[key] = value;
  }
  function interpolateNumber(p0, p1, percent) {
    return (p1 - p0) * percent + p0;
  }
  function interpolateString(p0, p1, percent) {
    return percent > 0.5 ? p1 : p0;
  }
  function interpolateArray(p0, p1, percent, out, arrDim) {
    var len = p0.length;
    if (arrDim == 1) {
      for (var i = 0; i < len; i++) {
        out[i] = interpolateNumber(p0[i], p1[i], percent);
      }
    } else {
      var len2 = p0[0].length;
      for (var i = 0; i < len; i++) {
        for (var j = 0; j < len2; j++) {
          out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
        }
      }
    }
  }
  function fillArr(arr0, arr1, arrDim) {
    var arr0Len = arr0.length;
    var arr1Len = arr1.length;
    if (arr0Len !== arr1Len) {
      var isPreviousLarger = arr0Len > arr1Len;
      if (isPreviousLarger) {
        arr0.length = arr1Len;
      } else {
        for (var i = arr0Len; i < arr1Len; i++) {
          arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
        }
      }
    }
    var len2 = arr0[0] && arr0[0].length;
    for (var i = 0; i < arr0.length; i++) {
      if (arrDim === 1) {
        if (isNaN(arr0[i])) {
          arr0[i] = arr1[i];
        }
      } else {
        for (var j = 0; j < len2; j++) {
          if (isNaN(arr0[i][j])) {
            arr0[i][j] = arr1[i][j];
          }
        }
      }
    }
  }
  function isArraySame(arr0, arr1, arrDim) {
    if (arr0 === arr1) {
      return true;
    }
    var len = arr0.length;
    if (len !== arr1.length) {
      return false;
    }
    if (arrDim === 1) {
      for (var i = 0; i < len; i++) {
        if (arr0[i] !== arr1[i]) {
          return false;
        }
      }
    } else {
      var len2 = arr0[0].length;
      for (var i = 0; i < len; i++) {
        for (var j = 0; j < len2; j++) {
          if (arr0[i][j] !== arr1[i][j]) {
            return false;
          }
        }
      }
    }
    return true;
  }
  function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
    var len = p0.length;
    if (arrDim == 1) {
      for (var i = 0; i < len; i++) {
        out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
      }
    } else {
      var len2 = p0[0].length;
      for (var i = 0; i < len; i++) {
        for (var j = 0; j < len2; j++) {
          out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
        }
      }
    }
  }
  function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
  function cloneValue(value) {
    if (isArrayLike(value)) {
      var len = value.length;
      if (isArrayLike(value[0])) {
        var ret = [];
        for (var i = 0; i < len; i++) {
          ret.push(arraySlice.call(value[i]));
        }
        return ret;
      }
      return arraySlice.call(value);
    }
    return value;
  }
  function rgba2String(rgba) {
    rgba[0] = Math.floor(rgba[0]);
    rgba[1] = Math.floor(rgba[1]);
    rgba[2] = Math.floor(rgba[2]);
    return 'rgba(' + rgba.join(',') + ')';
  }
  function createTrackClip(animator, easing, oneTrackDone, keyframes, propName) {
    var getter = animator._getter;
    var setter = animator._setter;
    var useSpline = easing === 'spline';
    var trackLen = keyframes.length;
    if (!trackLen) {
      return;
    }
    var firstVal = keyframes[0].value;
    var isValueArray = isArrayLike(firstVal);
    var isValueColor = false;
    var isValueString = false;
    var arrDim = (isValueArray && isArrayLike(firstVal[0])) ? 2 : 1;
    var trackMaxTime;
    keyframes.sort(function(a, b) {
      return a.time - b.time;
    });
    trackMaxTime = keyframes[trackLen - 1].time;
    var kfPercents = [];
    var kfValues = [];
    var prevValue = keyframes[0].value;
    var isAllValueEqual = true;
    for (var i = 0; i < trackLen; i++) {
      kfPercents.push(keyframes[i].time / trackMaxTime);
      var value = keyframes[i].value;
      if (!((isValueArray && isArraySame(value, prevValue, arrDim)) || (!isValueArray && value === prevValue))) {
        isAllValueEqual = false;
      }
      prevValue = value;
      if (typeof value == 'string') {
        var colorArray = color.parse(value);
        if (colorArray) {
          value = colorArray;
          isValueColor = true;
        } else {
          isValueString = true;
        }
      }
      kfValues.push(value);
    }
    if (isAllValueEqual) {
      return;
    }
    var lastValue = kfValues[trackLen - 1];
    for (var i = 0; i < trackLen - 1; i++) {
      if (isValueArray) {
        fillArr(kfValues[i], lastValue, arrDim);
      } else {
        if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
          kfValues[i] = lastValue;
        }
      }
    }
    isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);
    var lastFrame = 0;
    var lastFramePercent = 0;
    var start;
    var w;
    var p0;
    var p1;
    var p2;
    var p3;
    if (isValueColor) {
      var rgba = [0, 0, 0, 0];
    }
    var onframe = function(target, percent) {
      var frame;
      if (percent < lastFramePercent) {
        start = Math.min(lastFrame + 1, trackLen - 1);
        for (frame = start; frame >= 0; frame--) {
          if (kfPercents[frame] <= percent) {
            break;
          }
        }
        frame = Math.min(frame, trackLen - 2);
      } else {
        for (frame = lastFrame; frame < trackLen; frame++) {
          if (kfPercents[frame] > percent) {
            break;
          }
        }
        frame = Math.min(frame - 1, trackLen - 2);
      }
      lastFrame = frame;
      lastFramePercent = percent;
      var range = (kfPercents[frame + 1] - kfPercents[frame]);
      if (range === 0) {
        return;
      } else {
        w = (percent - kfPercents[frame]) / range;
      }
      if (useSpline) {
        p1 = kfValues[frame];
        p0 = kfValues[frame === 0 ? frame : frame - 1];
        p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
        p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
        if (isValueArray) {
          catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
        } else {
          var value;
          if (isValueColor) {
            value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
            value = rgba2String(rgba);
          } else if (isValueString) {
            return interpolateString(p1, p2, w);
          } else {
            value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
          }
          setter(target, propName, value);
        }
      } else {
        if (isValueArray) {
          interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
        } else {
          var value;
          if (isValueColor) {
            interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
            value = rgba2String(rgba);
          } else if (isValueString) {
            return interpolateString(kfValues[frame], kfValues[frame + 1], w);
          } else {
            value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
          }
          setter(target, propName, value);
        }
      }
    };
    var clip = new Clip({
      target: animator._target,
      life: trackMaxTime,
      loop: animator._loop,
      delay: animator._delay,
      onframe: onframe,
      ondestroy: oneTrackDone
    });
    if (easing && easing !== 'spline') {
      clip.easing = easing;
    }
    return clip;
  }
  var Animator = function(target, loop, getter, setter) {
    this._tracks = {};
    this._target = target;
    this._loop = loop || false;
    this._getter = getter || defaultGetter;
    this._setter = setter || defaultSetter;
    this._clipCount = 0;
    this._delay = 0;
    this._doneList = [];
    this._onframeList = [];
    this._clipList = [];
  };
  Animator.prototype = {
    when: function(time, props) {
      var tracks = this._tracks;
      for (var propName in props) {
        if (!tracks[propName]) {
          tracks[propName] = [];
          var value = this._getter(this._target, propName);
          if (value == null) {
            continue;
          }
          if (time !== 0) {
            tracks[propName].push({
              time: 0,
              value: cloneValue(value)
            });
          }
        }
        tracks[propName].push({
          time: time,
          value: props[propName]
        });
      }
      return this;
    },
    during: function(callback) {
      this._onframeList.push(callback);
      return this;
    },
    _doneCallback: function() {
      this._tracks = {};
      this._clipList.length = 0;
      var doneList = this._doneList;
      var len = doneList.length;
      for (var i = 0; i < len; i++) {
        doneList[i].call(this);
      }
    },
    start: function(easing) {
      var self = this;
      var clipCount = 0;
      var oneTrackDone = function() {
        clipCount--;
        if (!clipCount) {
          self._doneCallback();
        }
      };
      var lastClip;
      for (var propName in this._tracks) {
        var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName);
        if (clip) {
          this._clipList.push(clip);
          clipCount++;
          if (this.animation) {
            this.animation.addClip(clip);
          }
          lastClip = clip;
        }
      }
      if (lastClip) {
        var oldOnFrame = lastClip.onframe;
        lastClip.onframe = function(target, percent) {
          oldOnFrame(target, percent);
          for (var i = 0; i < self._onframeList.length; i++) {
            self._onframeList[i](target, percent);
          }
        };
      }
      if (!clipCount) {
        this._doneCallback();
      }
      return this;
    },
    stop: function(forwardToLast) {
      var clipList = this._clipList;
      var animation = this.animation;
      for (var i = 0; i < clipList.length; i++) {
        var clip = clipList[i];
        if (forwardToLast) {
          clip.onframe(this._target, 1);
        }
        animation && animation.removeClip(clip);
      }
      clipList.length = 0;
    },
    delay: function(time) {
      this._delay = time;
      return this;
    },
    done: function(cb) {
      if (cb) {
        this._doneList.push(cb);
      }
      return this;
    },
    getClips: function() {
      return this._clipList;
    }
  };
  module.exports = Animator;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/mixin/Animatable.js", ["../animation/Animator", "../core/util", "../core/log"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Animator = $__require('../animation/Animator');
  var util = $__require('../core/util');
  var isString = util.isString;
  var isFunction = util.isFunction;
  var isObject = util.isObject;
  var log = $__require('../core/log');
  var Animatable = function() {
    this.animators = [];
  };
  Animatable.prototype = {
    constructor: Animatable,
    animate: function(path, loop) {
      var target;
      var animatingShape = false;
      var el = this;
      var zr = this.__zr;
      if (path) {
        var pathSplitted = path.split('.');
        var prop = el;
        animatingShape = pathSplitted[0] === 'shape';
        for (var i = 0,
            l = pathSplitted.length; i < l; i++) {
          if (!prop) {
            continue;
          }
          prop = prop[pathSplitted[i]];
        }
        if (prop) {
          target = prop;
        }
      } else {
        target = el;
      }
      if (!target) {
        log('Property "' + path + '" is not existed in element ' + el.id);
        return;
      }
      var animators = el.animators;
      var animator = new Animator(target, loop);
      animator.during(function(target) {
        el.dirty(animatingShape);
      }).done(function() {
        animators.splice(util.indexOf(animators, animator), 1);
      });
      animators.push(animator);
      if (zr) {
        zr.animation.addAnimator(animator);
      }
      return animator;
    },
    stopAnimation: function(forwardToLast) {
      var animators = this.animators;
      var len = animators.length;
      for (var i = 0; i < len; i++) {
        animators[i].stop(forwardToLast);
      }
      animators.length = 0;
      return this;
    },
    animateTo: function(target, time, delay, easing, callback) {
      if (isString(delay)) {
        callback = easing;
        easing = delay;
        delay = 0;
      } else if (isFunction(easing)) {
        callback = easing;
        easing = 'linear';
        delay = 0;
      } else if (isFunction(delay)) {
        callback = delay;
        delay = 0;
      } else if (isFunction(time)) {
        callback = time;
        time = 500;
      } else if (!time) {
        time = 500;
      }
      this.stopAnimation();
      this._animateToShallow('', this, target, time, delay, easing, callback);
      var animators = this.animators.slice();
      var count = animators.length;
      function done() {
        count--;
        if (!count) {
          callback && callback();
        }
      }
      if (!count) {
        callback && callback();
      }
      for (var i = 0; i < animators.length; i++) {
        animators[i].done(done).start(easing);
      }
    },
    _animateToShallow: function(path, source, target, time, delay) {
      var objShallow = {};
      var propertyCount = 0;
      for (var name in target) {
        if (source[name] != null) {
          if (isObject(target[name]) && !util.isArrayLike(target[name])) {
            this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);
          } else {
            objShallow[name] = target[name];
            propertyCount++;
          }
        } else if (target[name] != null) {
          if (!path) {
            this.attr(name, target[name]);
          } else {
            var props = {};
            props[path] = {};
            props[path][name] = target[name];
            this.attr(props);
          }
        }
      }
      if (propertyCount > 0) {
        this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
      }
      return this;
    }
  };
  module.exports = Animatable;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/Element.js", ["./core/guid", "./mixin/Eventful", "./mixin/Transformable", "./mixin/Animatable", "./core/util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var guid = $__require('./core/guid');
  var Eventful = $__require('./mixin/Eventful');
  var Transformable = $__require('./mixin/Transformable');
  var Animatable = $__require('./mixin/Animatable');
  var zrUtil = $__require('./core/util');
  var Element = function(opts) {
    Transformable.call(this, opts);
    Eventful.call(this, opts);
    Animatable.call(this, opts);
    this.id = opts.id || guid();
  };
  Element.prototype = {
    type: 'element',
    name: '',
    __zr: null,
    ignore: false,
    clipPath: null,
    drift: function(dx, dy) {
      switch (this.draggable) {
        case 'horizontal':
          dy = 0;
          break;
        case 'vertical':
          dx = 0;
          break;
      }
      var m = this.transform;
      if (!m) {
        m = this.transform = [1, 0, 0, 1, 0, 0];
      }
      m[4] += dx;
      m[5] += dy;
      this.decomposeTransform();
      this.dirty(false);
    },
    beforeUpdate: function() {},
    afterUpdate: function() {},
    update: function() {
      this.updateTransform();
    },
    traverse: function(cb, context) {},
    attrKV: function(key, value) {
      if (key === 'position' || key === 'scale' || key === 'origin') {
        if (value) {
          var target = this[key];
          if (!target) {
            target = this[key] = [];
          }
          target[0] = value[0];
          target[1] = value[1];
        }
      } else {
        this[key] = value;
      }
    },
    hide: function() {
      this.ignore = true;
      this.__zr && this.__zr.refresh();
    },
    show: function() {
      this.ignore = false;
      this.__zr && this.__zr.refresh();
    },
    attr: function(key, value) {
      if (typeof key === 'string') {
        this.attrKV(key, value);
      } else if (zrUtil.isObject(key)) {
        for (var name in key) {
          if (key.hasOwnProperty(name)) {
            this.attrKV(name, key[name]);
          }
        }
      }
      this.dirty(false);
      return this;
    },
    setClipPath: function(clipPath) {
      var zr = this.__zr;
      if (zr) {
        clipPath.addSelfToZr(zr);
      }
      if (this.clipPath && this.clipPath !== clipPath) {
        this.removeClipPath();
      }
      this.clipPath = clipPath;
      clipPath.__zr = zr;
      clipPath.__clipTarget = this;
      this.dirty(false);
    },
    removeClipPath: function() {
      var clipPath = this.clipPath;
      if (clipPath) {
        if (clipPath.__zr) {
          clipPath.removeSelfFromZr(clipPath.__zr);
        }
        clipPath.__zr = null;
        clipPath.__clipTarget = null;
        this.clipPath = null;
        this.dirty(false);
      }
    },
    addSelfToZr: function(zr) {
      this.__zr = zr;
      var animators = this.animators;
      if (animators) {
        for (var i = 0; i < animators.length; i++) {
          zr.animation.addAnimator(animators[i]);
        }
      }
      if (this.clipPath) {
        this.clipPath.addSelfToZr(zr);
      }
    },
    removeSelfFromZr: function(zr) {
      this.__zr = null;
      var animators = this.animators;
      if (animators) {
        for (var i = 0; i < animators.length; i++) {
          zr.animation.removeAnimator(animators[i]);
        }
      }
      if (this.clipPath) {
        this.clipPath.removeSelfFromZr(zr);
      }
    }
  };
  zrUtil.mixin(Element, Animatable);
  zrUtil.mixin(Element, Transformable);
  zrUtil.mixin(Element, Eventful);
  module.exports = Element;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/contain/text.js", ["../core/util", "../core/BoundingRect"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var textWidthCache = {};
  var textWidthCacheCounter = 0;
  var TEXT_CACHE_MAX = 5000;
  var util = $__require('../core/util');
  var BoundingRect = $__require('../core/BoundingRect');
  var retrieve = util.retrieve;
  function getTextWidth(text, textFont) {
    var key = text + ':' + textFont;
    if (textWidthCache[key]) {
      return textWidthCache[key];
    }
    var textLines = (text + '').split('\n');
    var width = 0;
    for (var i = 0,
        l = textLines.length; i < l; i++) {
      width = Math.max(textContain.measureText(textLines[i], textFont).width, width);
    }
    if (textWidthCacheCounter > TEXT_CACHE_MAX) {
      textWidthCacheCounter = 0;
      textWidthCache = {};
    }
    textWidthCacheCounter++;
    textWidthCache[key] = width;
    return width;
  }
  function getTextRect(text, textFont, textAlign, textBaseline) {
    var textLineLen = ((text || '') + '').split('\n').length;
    var width = getTextWidth(text, textFont);
    var lineHeight = getTextWidth('', textFont);
    var height = textLineLen * lineHeight;
    var rect = new BoundingRect(0, 0, width, height);
    rect.lineHeight = lineHeight;
    switch (textBaseline) {
      case 'bottom':
      case 'alphabetic':
        rect.y -= lineHeight;
        break;
      case 'middle':
        rect.y -= lineHeight / 2;
        break;
    }
    switch (textAlign) {
      case 'end':
      case 'right':
        rect.x -= rect.width;
        break;
      case 'center':
        rect.x -= rect.width / 2;
        break;
    }
    return rect;
  }
  function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {
    var x = rect.x;
    var y = rect.y;
    var height = rect.height;
    var width = rect.width;
    var textHeight = textRect.height;
    var halfHeight = height / 2 - textHeight / 2;
    var textAlign = 'left';
    switch (textPosition) {
      case 'left':
        x -= distance;
        y += halfHeight;
        textAlign = 'right';
        break;
      case 'right':
        x += distance + width;
        y += halfHeight;
        textAlign = 'left';
        break;
      case 'top':
        x += width / 2;
        y -= distance + textHeight;
        textAlign = 'center';
        break;
      case 'bottom':
        x += width / 2;
        y += height + distance;
        textAlign = 'center';
        break;
      case 'inside':
        x += width / 2;
        y += halfHeight;
        textAlign = 'center';
        break;
      case 'insideLeft':
        x += distance;
        y += halfHeight;
        textAlign = 'left';
        break;
      case 'insideRight':
        x += width - distance;
        y += halfHeight;
        textAlign = 'right';
        break;
      case 'insideTop':
        x += width / 2;
        y += distance;
        textAlign = 'center';
        break;
      case 'insideBottom':
        x += width / 2;
        y += height - textHeight - distance;
        textAlign = 'center';
        break;
      case 'insideTopLeft':
        x += distance;
        y += distance;
        textAlign = 'left';
        break;
      case 'insideTopRight':
        x += width - distance;
        y += distance;
        textAlign = 'right';
        break;
      case 'insideBottomLeft':
        x += distance;
        y += height - textHeight - distance;
        break;
      case 'insideBottomRight':
        x += width - distance;
        y += height - textHeight - distance;
        textAlign = 'right';
        break;
    }
    return {
      x: x,
      y: y,
      textAlign: textAlign,
      textBaseline: 'top'
    };
  }
  function truncateText(text, containerWidth, textFont, ellipsis, options) {
    if (!containerWidth) {
      return '';
    }
    options = options || {};
    ellipsis = retrieve(ellipsis, '...');
    var maxIterations = retrieve(options.maxIterations, 2);
    var minChar = retrieve(options.minChar, 0);
    var cnCharWidth = getTextWidth('', textFont);
    var ascCharWidth = getTextWidth('a', textFont);
    var placeholder = retrieve(options.placeholder, '');
    var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
    for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
      contentWidth -= ascCharWidth;
    }
    var ellipsisWidth = getTextWidth(ellipsis);
    if (ellipsisWidth > contentWidth) {
      ellipsis = '';
      ellipsisWidth = 0;
    }
    contentWidth = containerWidth - ellipsisWidth;
    var textLines = (text + '').split('\n');
    for (var i = 0,
        len = textLines.length; i < len; i++) {
      var textLine = textLines[i];
      var lineWidth = getTextWidth(textLine, textFont);
      if (lineWidth <= containerWidth) {
        continue;
      }
      for (var j = 0; ; j++) {
        if (lineWidth <= contentWidth || j >= maxIterations) {
          textLine += ellipsis;
          break;
        }
        var subLength = j === 0 ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
        textLine = textLine.substr(0, subLength);
        lineWidth = getTextWidth(textLine, textFont);
      }
      if (textLine === '') {
        textLine = placeholder;
      }
      textLines[i] = textLine;
    }
    return textLines.join('\n');
  }
  function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
    var width = 0;
    var i = 0;
    for (var len = text.length; i < len && width < contentWidth; i++) {
      var charCode = text.charCodeAt(i);
      width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;
    }
    return i;
  }
  var textContain = {
    getWidth: getTextWidth,
    getBoundingRect: getTextRect,
    adjustTextPositionOnRect: adjustTextPositionOnRect,
    truncateText: truncateText,
    measureText: function(text, textFont) {
      var ctx = util.getContext();
      ctx.font = textFont || '12px sans-serif';
      return ctx.measureText(text);
    }
  };
  module.exports = textContain;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/mixin/RectText.js", ["../../contain/text", "../../core/BoundingRect"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var textContain = $__require('../../contain/text');
  var BoundingRect = $__require('../../core/BoundingRect');
  var tmpRect = new BoundingRect();
  var RectText = function() {};
  function parsePercent(value, maxValue) {
    if (typeof value === 'string') {
      if (value.lastIndexOf('%') >= 0) {
        return parseFloat(value) / 100 * maxValue;
      }
      return parseFloat(value);
    }
    return value;
  }
  function setTransform(ctx, m) {
    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
  }
  RectText.prototype = {
    constructor: RectText,
    drawRectText: function(ctx, rect, textRect) {
      var style = this.style;
      var text = style.text;
      text != null && (text += '');
      if (!text) {
        return;
      }
      ctx.save();
      var x;
      var y;
      var textPosition = style.textPosition;
      var distance = style.textDistance;
      var align = style.textAlign;
      var font = style.textFont || style.font;
      var baseline = style.textBaseline;
      var verticalAlign = style.textVerticalAlign;
      textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
      var transform = this.transform;
      if (transform) {
        tmpRect.copy(rect);
        tmpRect.applyTransform(transform);
        rect = tmpRect;
      }
      if (textPosition instanceof Array) {
        x = rect.x + parsePercent(textPosition[0], rect.width);
        y = rect.y + parsePercent(textPosition[1], rect.height);
        align = align || 'left';
        baseline = baseline || 'top';
        if (verticalAlign) {
          switch (verticalAlign) {
            case 'middle':
              y -= textRect.height / 2 - textRect.lineHeight / 2;
              break;
            case 'bottom':
              y -= textRect.height - textRect.lineHeight / 2;
              break;
            default:
              y += textRect.lineHeight / 2;
          }
          baseline = 'middle';
        }
      } else {
        var res = textContain.adjustTextPositionOnRect(textPosition, rect, textRect, distance);
        x = res.x;
        y = res.y;
        align = align || res.textAlign;
        baseline = baseline || res.textBaseline;
      }
      ctx.textAlign = align || 'left';
      ctx.textBaseline = baseline || 'alphabetic';
      var textFill = style.textFill;
      var textStroke = style.textStroke;
      textFill && (ctx.fillStyle = textFill);
      textStroke && (ctx.strokeStyle = textStroke);
      ctx.font = font;
      ctx.shadowBlur = style.textShadowBlur;
      ctx.shadowColor = style.textShadowColor || 'transparent';
      ctx.shadowOffsetX = style.textShadowOffsetX;
      ctx.shadowOffsetY = style.textShadowOffsetY;
      var textLines = text.split('\n');
      for (var i = 0; i < textLines.length; i++) {
        textFill && ctx.fillText(textLines[i], x, y);
        textStroke && ctx.strokeText(textLines[i], x, y);
        y += textRect.lineHeight;
      }
      ctx.restore();
    }
  };
  module.exports = RectText;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/Displayable.js", ["../core/util", "./Style", "../Element", "./mixin/RectText"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var zrUtil = $__require('../core/util');
  var Style = $__require('./Style');
  var Element = $__require('../Element');
  var RectText = $__require('./mixin/RectText');
  function Displayable(opts) {
    opts = opts || {};
    Element.call(this, opts);
    for (var name in opts) {
      if (opts.hasOwnProperty(name) && name !== 'style') {
        this[name] = opts[name];
      }
    }
    this.style = new Style(opts.style);
    this._rect = null;
    this.__clipPaths = [];
  }
  Displayable.prototype = {
    constructor: Displayable,
    type: 'displayable',
    __dirty: true,
    invisible: false,
    z: 0,
    z2: 0,
    zlevel: 0,
    draggable: false,
    dragging: false,
    silent: false,
    culling: false,
    cursor: 'pointer',
    rectHover: false,
    progressive: -1,
    beforeBrush: function(ctx) {},
    afterBrush: function(ctx) {},
    brush: function(ctx, prevEl) {},
    getBoundingRect: function() {},
    contain: function(x, y) {
      return this.rectContain(x, y);
    },
    traverse: function(cb, context) {
      cb.call(context, this);
    },
    rectContain: function(x, y) {
      var coord = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      return rect.contain(coord[0], coord[1]);
    },
    dirty: function() {
      this.__dirty = true;
      this._rect = null;
      this.__zr && this.__zr.refresh();
    },
    animateStyle: function(loop) {
      return this.animate('style', loop);
    },
    attrKV: function(key, value) {
      if (key !== 'style') {
        Element.prototype.attrKV.call(this, key, value);
      } else {
        this.style.set(value);
      }
    },
    setStyle: function(key, value) {
      this.style.set(key, value);
      this.dirty(false);
      return this;
    },
    useStyle: function(obj) {
      this.style = new Style(obj);
      this.dirty(false);
      return this;
    }
  };
  zrUtil.inherits(Displayable, Element);
  zrUtil.mixin(Displayable, RectText);
  module.exports = Displayable;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/vector.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
  var vector = {
    create: function(x, y) {
      var out = new ArrayCtor(2);
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      out[0] = x;
      out[1] = y;
      return out;
    },
    copy: function(out, v) {
      out[0] = v[0];
      out[1] = v[1];
      return out;
    },
    clone: function(v) {
      var out = new ArrayCtor(2);
      out[0] = v[0];
      out[1] = v[1];
      return out;
    },
    set: function(out, a, b) {
      out[0] = a;
      out[1] = b;
      return out;
    },
    add: function(out, v1, v2) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      return out;
    },
    scaleAndAdd: function(out, v1, v2, a) {
      out[0] = v1[0] + v2[0] * a;
      out[1] = v1[1] + v2[1] * a;
      return out;
    },
    sub: function(out, v1, v2) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      return out;
    },
    len: function(v) {
      return Math.sqrt(this.lenSquare(v));
    },
    lenSquare: function(v) {
      return v[0] * v[0] + v[1] * v[1];
    },
    mul: function(out, v1, v2) {
      out[0] = v1[0] * v2[0];
      out[1] = v1[1] * v2[1];
      return out;
    },
    div: function(out, v1, v2) {
      out[0] = v1[0] / v2[0];
      out[1] = v1[1] / v2[1];
      return out;
    },
    dot: function(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    },
    scale: function(out, v, s) {
      out[0] = v[0] * s;
      out[1] = v[1] * s;
      return out;
    },
    normalize: function(out, v) {
      var d = vector.len(v);
      if (d === 0) {
        out[0] = 0;
        out[1] = 0;
      } else {
        out[0] = v[0] / d;
        out[1] = v[1] / d;
      }
      return out;
    },
    distance: function(v1, v2) {
      return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
    },
    distanceSquare: function(v1, v2) {
      return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
    },
    negate: function(out, v) {
      out[0] = -v[0];
      out[1] = -v[1];
      return out;
    },
    lerp: function(out, v1, v2, t) {
      out[0] = v1[0] + t * (v2[0] - v1[0]);
      out[1] = v1[1] + t * (v2[1] - v1[1]);
      return out;
    },
    applyTransform: function(out, v, m) {
      var x = v[0];
      var y = v[1];
      out[0] = m[0] * x + m[2] * y + m[4];
      out[1] = m[1] * x + m[3] * y + m[5];
      return out;
    },
    min: function(out, v1, v2) {
      out[0] = Math.min(v1[0], v2[0]);
      out[1] = Math.min(v1[1], v2[1]);
      return out;
    },
    max: function(out, v1, v2) {
      out[0] = Math.max(v1[0], v2[0]);
      out[1] = Math.max(v1[1], v2[1]);
      return out;
    }
  };
  vector.length = vector.len;
  vector.lengthSquare = vector.lenSquare;
  vector.dist = vector.distance;
  vector.distSquare = vector.distanceSquare;
  module.exports = vector;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/matrix.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
  var matrix = {
    create: function() {
      var out = new ArrayCtor(6);
      matrix.identity(out);
      return out;
    },
    identity: function(out) {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      out[4] = 0;
      out[5] = 0;
      return out;
    },
    copy: function(out, m) {
      out[0] = m[0];
      out[1] = m[1];
      out[2] = m[2];
      out[3] = m[3];
      out[4] = m[4];
      out[5] = m[5];
      return out;
    },
    mul: function(out, m1, m2) {
      var out0 = m1[0] * m2[0] + m1[2] * m2[1];
      var out1 = m1[1] * m2[0] + m1[3] * m2[1];
      var out2 = m1[0] * m2[2] + m1[2] * m2[3];
      var out3 = m1[1] * m2[2] + m1[3] * m2[3];
      var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
      var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
      out[0] = out0;
      out[1] = out1;
      out[2] = out2;
      out[3] = out3;
      out[4] = out4;
      out[5] = out5;
      return out;
    },
    translate: function(out, a, v) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[4] = a[4] + v[0];
      out[5] = a[5] + v[1];
      return out;
    },
    rotate: function(out, a, rad) {
      var aa = a[0];
      var ac = a[2];
      var atx = a[4];
      var ab = a[1];
      var ad = a[3];
      var aty = a[5];
      var st = Math.sin(rad);
      var ct = Math.cos(rad);
      out[0] = aa * ct + ab * st;
      out[1] = -aa * st + ab * ct;
      out[2] = ac * ct + ad * st;
      out[3] = -ac * st + ct * ad;
      out[4] = ct * atx + st * aty;
      out[5] = ct * aty - st * atx;
      return out;
    },
    scale: function(out, a, v) {
      var vx = v[0];
      var vy = v[1];
      out[0] = a[0] * vx;
      out[1] = a[1] * vy;
      out[2] = a[2] * vx;
      out[3] = a[3] * vy;
      out[4] = a[4] * vx;
      out[5] = a[5] * vy;
      return out;
    },
    invert: function(out, a) {
      var aa = a[0];
      var ac = a[2];
      var atx = a[4];
      var ab = a[1];
      var ad = a[3];
      var aty = a[5];
      var det = aa * ad - ab * ac;
      if (!det) {
        return null;
      }
      det = 1.0 / det;
      out[0] = ad * det;
      out[1] = -ab * det;
      out[2] = -ac * det;
      out[3] = aa * det;
      out[4] = (ac * aty - ad * atx) * det;
      out[5] = (ab * atx - aa * aty) * det;
      return out;
    }
  };
  module.exports = matrix;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/BoundingRect.js", ["./vector", "./matrix"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var vec2 = $__require('./vector');
  var matrix = $__require('./matrix');
  var v2ApplyTransform = vec2.applyTransform;
  var mathMin = Math.min;
  var mathAbs = Math.abs;
  var mathMax = Math.max;
  function BoundingRect(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  BoundingRect.prototype = {
    constructor: BoundingRect,
    union: function(other) {
      var x = mathMin(other.x, this.x);
      var y = mathMin(other.y, this.y);
      this.width = mathMax(other.x + other.width, this.x + this.width) - x;
      this.height = mathMax(other.y + other.height, this.y + this.height) - y;
      this.x = x;
      this.y = y;
    },
    applyTransform: (function() {
      var min = [];
      var max = [];
      return function(m) {
        if (!m) {
          return;
        }
        min[0] = this.x;
        min[1] = this.y;
        max[0] = this.x + this.width;
        max[1] = this.y + this.height;
        v2ApplyTransform(min, min, m);
        v2ApplyTransform(max, max, m);
        this.x = mathMin(min[0], max[0]);
        this.y = mathMin(min[1], max[1]);
        this.width = mathAbs(max[0] - min[0]);
        this.height = mathAbs(max[1] - min[1]);
      };
    })(),
    calculateTransform: function(b) {
      var a = this;
      var sx = b.width / a.width;
      var sy = b.height / a.height;
      var m = matrix.create();
      matrix.translate(m, m, [-a.x, -a.y]);
      matrix.scale(m, m, [sx, sy]);
      matrix.translate(m, m, [b.x, b.y]);
      return m;
    },
    intersect: function(b) {
      var a = this;
      var ax0 = a.x;
      var ax1 = a.x + a.width;
      var ay0 = a.y;
      var ay1 = a.y + a.height;
      var bx0 = b.x;
      var bx1 = b.x + b.width;
      var by0 = b.y;
      var by1 = b.y + b.height;
      return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
    },
    contain: function(x, y) {
      var rect = this;
      return x >= rect.x && x <= (rect.x + rect.width) && y >= rect.y && y <= (rect.y + rect.height);
    },
    clone: function() {
      return new BoundingRect(this.x, this.y, this.width, this.height);
    },
    copy: function(other) {
      this.x = other.x;
      this.y = other.y;
      this.width = other.width;
      this.height = other.height;
    }
  };
  module.exports = BoundingRect;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/util.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var BUILTIN_OBJECT = {
    '[object Function]': 1,
    '[object RegExp]': 1,
    '[object Date]': 1,
    '[object Error]': 1,
    '[object CanvasGradient]': 1,
    '[object CanvasPattern]': 1,
    '[object Image]': 1
  };
  var objToString = Object.prototype.toString;
  var arrayProto = Array.prototype;
  var nativeForEach = arrayProto.forEach;
  var nativeFilter = arrayProto.filter;
  var nativeSlice = arrayProto.slice;
  var nativeMap = arrayProto.map;
  var nativeReduce = arrayProto.reduce;
  function clone(source) {
    if (typeof source == 'object' && source !== null) {
      var result = source;
      if (source instanceof Array) {
        result = [];
        for (var i = 0,
            len = source.length; i < len; i++) {
          result[i] = clone(source[i]);
        }
      } else if (!isBuildInObject(source) && !isDom(source)) {
        result = {};
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            result[key] = clone(source[key]);
          }
        }
      }
      return result;
    }
    return source;
  }
  function merge(target, source, overwrite) {
    if (!isObject(source) || !isObject(target)) {
      return overwrite ? clone(source) : target;
    }
    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        var targetProp = target[key];
        var sourceProp = source[key];
        if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuildInObject(sourceProp) && !isBuildInObject(targetProp)) {
          merge(targetProp, sourceProp, overwrite);
        } else if (overwrite || !(key in target)) {
          target[key] = clone(source[key], true);
        }
      }
    }
    return target;
  }
  function mergeAll(targetAndSources, overwrite) {
    var result = targetAndSources[0];
    for (var i = 1,
        len = targetAndSources.length; i < len; i++) {
      result = merge(result, targetAndSources[i], overwrite);
    }
    return result;
  }
  function extend(target, source) {
    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        target[key] = source[key];
      }
    }
    return target;
  }
  function defaults(target, source, overlay) {
    for (var key in source) {
      if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
        target[key] = source[key];
      }
    }
    return target;
  }
  function createCanvas() {
    return document.createElement('canvas');
  }
  var _ctx;
  function getContext() {
    if (!_ctx) {
      _ctx = util.createCanvas().getContext('2d');
    }
    return _ctx;
  }
  function indexOf(array, value) {
    if (array) {
      if (array.indexOf) {
        return array.indexOf(value);
      }
      for (var i = 0,
          len = array.length; i < len; i++) {
        if (array[i] === value) {
          return i;
        }
      }
    }
    return -1;
  }
  function inherits(clazz, baseClazz) {
    var clazzPrototype = clazz.prototype;
    function F() {}
    F.prototype = baseClazz.prototype;
    clazz.prototype = new F();
    for (var prop in clazzPrototype) {
      clazz.prototype[prop] = clazzPrototype[prop];
    }
    clazz.prototype.constructor = clazz;
    clazz.superClass = baseClazz;
  }
  function mixin(target, source, overlay) {
    target = 'prototype' in target ? target.prototype : target;
    source = 'prototype' in source ? source.prototype : source;
    defaults(target, source, overlay);
  }
  function isArrayLike(data) {
    if (!data) {
      return;
    }
    if (typeof data == 'string') {
      return false;
    }
    return typeof data.length == 'number';
  }
  function each(obj, cb, context) {
    if (!(obj && cb)) {
      return;
    }
    if (obj.forEach && obj.forEach === nativeForEach) {
      obj.forEach(cb, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0,
          len = obj.length; i < len; i++) {
        cb.call(context, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          cb.call(context, obj[key], key, obj);
        }
      }
    }
  }
  function map(obj, cb, context) {
    if (!(obj && cb)) {
      return;
    }
    if (obj.map && obj.map === nativeMap) {
      return obj.map(cb, context);
    } else {
      var result = [];
      for (var i = 0,
          len = obj.length; i < len; i++) {
        result.push(cb.call(context, obj[i], i, obj));
      }
      return result;
    }
  }
  function reduce(obj, cb, memo, context) {
    if (!(obj && cb)) {
      return;
    }
    if (obj.reduce && obj.reduce === nativeReduce) {
      return obj.reduce(cb, memo, context);
    } else {
      for (var i = 0,
          len = obj.length; i < len; i++) {
        memo = cb.call(context, memo, obj[i], i, obj);
      }
      return memo;
    }
  }
  function filter(obj, cb, context) {
    if (!(obj && cb)) {
      return;
    }
    if (obj.filter && obj.filter === nativeFilter) {
      return obj.filter(cb, context);
    } else {
      var result = [];
      for (var i = 0,
          len = obj.length; i < len; i++) {
        if (cb.call(context, obj[i], i, obj)) {
          result.push(obj[i]);
        }
      }
      return result;
    }
  }
  function find(obj, cb, context) {
    if (!(obj && cb)) {
      return;
    }
    for (var i = 0,
        len = obj.length; i < len; i++) {
      if (cb.call(context, obj[i], i, obj)) {
        return obj[i];
      }
    }
  }
  function bind(func, context) {
    var args = nativeSlice.call(arguments, 2);
    return function() {
      return func.apply(context, args.concat(nativeSlice.call(arguments)));
    };
  }
  function curry(func) {
    var args = nativeSlice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(nativeSlice.call(arguments)));
    };
  }
  function isArray(value) {
    return objToString.call(value) === '[object Array]';
  }
  function isFunction(value) {
    return typeof value === 'function';
  }
  function isString(value) {
    return objToString.call(value) === '[object String]';
  }
  function isObject(value) {
    var type = typeof value;
    return type === 'function' || (!!value && type == 'object');
  }
  function isBuildInObject(value) {
    return !!BUILTIN_OBJECT[objToString.call(value)];
  }
  function isDom(value) {
    return value && value.nodeType === 1 && typeof(value.nodeName) == 'string';
  }
  function retrieve(values) {
    for (var i = 0,
        len = arguments.length; i < len; i++) {
      if (arguments[i] != null) {
        return arguments[i];
      }
    }
  }
  function slice() {
    return Function.call.apply(nativeSlice, arguments);
  }
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  var util = {
    inherits: inherits,
    mixin: mixin,
    clone: clone,
    merge: merge,
    mergeAll: mergeAll,
    extend: extend,
    defaults: defaults,
    getContext: getContext,
    createCanvas: createCanvas,
    indexOf: indexOf,
    slice: slice,
    find: find,
    isArrayLike: isArrayLike,
    each: each,
    map: map,
    reduce: reduce,
    filter: filter,
    bind: bind,
    curry: curry,
    isArray: isArray,
    isString: isString,
    isObject: isObject,
    isFunction: isFunction,
    isBuildInObject: isBuildInObject,
    isDom: isDom,
    retrieve: retrieve,
    assert: assert,
    noop: function() {}
  };
  module.exports = util;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/LRU.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var LinkedList = function() {
    this.head = null;
    this.tail = null;
    this._len = 0;
  };
  var linkedListProto = LinkedList.prototype;
  linkedListProto.insert = function(val) {
    var entry = new Entry(val);
    this.insertEntry(entry);
    return entry;
  };
  linkedListProto.insertEntry = function(entry) {
    if (!this.head) {
      this.head = this.tail = entry;
    } else {
      this.tail.next = entry;
      entry.prev = this.tail;
      this.tail = entry;
    }
    this._len++;
  };
  linkedListProto.remove = function(entry) {
    var prev = entry.prev;
    var next = entry.next;
    if (prev) {
      prev.next = next;
    } else {
      this.head = next;
    }
    if (next) {
      next.prev = prev;
    } else {
      this.tail = prev;
    }
    entry.next = entry.prev = null;
    this._len--;
  };
  linkedListProto.len = function() {
    return this._len;
  };
  var Entry = function(val) {
    this.value = val;
    this.next;
    this.prev;
  };
  var LRU = function(maxSize) {
    this._list = new LinkedList();
    this._map = {};
    this._maxSize = maxSize || 10;
  };
  var LRUProto = LRU.prototype;
  LRUProto.put = function(key, value) {
    var list = this._list;
    var map = this._map;
    if (map[key] == null) {
      var len = list.len();
      if (len >= this._maxSize && len > 0) {
        var leastUsedEntry = list.head;
        list.remove(leastUsedEntry);
        delete map[leastUsedEntry.key];
      }
      var entry = list.insert(value);
      entry.key = key;
      map[key] = entry;
    }
  };
  LRUProto.get = function(key) {
    var entry = this._map[key];
    var list = this._list;
    if (entry != null) {
      if (entry !== list.tail) {
        list.remove(entry);
        list.insertEntry(entry);
      }
      return entry.value;
    }
  };
  LRUProto.clear = function() {
    this._list.clear();
    this._map = {};
  };
  module.exports = LRU;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/graphic/Image.js", ["./Displayable", "../core/BoundingRect", "../core/util", "../core/LRU"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Displayable = $__require('./Displayable');
  var BoundingRect = $__require('../core/BoundingRect');
  var zrUtil = $__require('../core/util');
  var LRU = $__require('../core/LRU');
  var globalImageCache = new LRU(50);
  function ZImage(opts) {
    Displayable.call(this, opts);
  }
  ZImage.prototype = {
    constructor: ZImage,
    type: 'image',
    brush: function(ctx, prevEl) {
      var style = this.style;
      var src = style.image;
      var image;
      style.bind(ctx, this, prevEl);
      if (typeof src === 'string') {
        image = this._image;
      } else {
        image = src;
      }
      if (!image && src) {
        var cachedImgObj = globalImageCache.get(src);
        if (!cachedImgObj) {
          image = new Image();
          image.onload = function() {
            image.onload = null;
            for (var i = 0; i < cachedImgObj.pending.length; i++) {
              cachedImgObj.pending[i].dirty();
            }
          };
          cachedImgObj = {
            image: image,
            pending: [this]
          };
          image.src = src;
          globalImageCache.put(src, cachedImgObj);
          this._image = image;
          return;
        } else {
          image = cachedImgObj.image;
          this._image = image;
          if (!image.width || !image.height) {
            cachedImgObj.pending.push(this);
            return;
          }
        }
      }
      if (image) {
        var width = style.width || image.width;
        var height = style.height || image.height;
        var x = style.x || 0;
        var y = style.y || 0;
        if (!image.width || !image.height) {
          return;
        }
        this.setTransform(ctx);
        if (style.sWidth && style.sHeight) {
          var sx = style.sx || 0;
          var sy = style.sy || 0;
          ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
        } else if (style.sx && style.sy) {
          var sx = style.sx;
          var sy = style.sy;
          var sWidth = width - sx;
          var sHeight = height - sy;
          ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
        } else {
          ctx.drawImage(image, x, y, width, height);
        }
        if (style.width == null) {
          style.width = width;
        }
        if (style.height == null) {
          style.height = height;
        }
        this.restoreTransform(ctx);
        if (style.text != null) {
          this.drawRectText(ctx, this.getBoundingRect());
        }
      }
    },
    getBoundingRect: function() {
      var style = this.style;
      if (!this._rect) {
        this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
      }
      return this._rect;
    }
  };
  zrUtil.inherits(ZImage, Displayable);
  module.exports = ZImage;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/Painter.js", ["./config", "./core/util", "./core/log", "./core/BoundingRect", "./core/timsort", "./Layer", "./animation/requestAnimationFrame", "./graphic/Image"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var config = $__require('./config');
  var util = $__require('./core/util');
  var log = $__require('./core/log');
  var BoundingRect = $__require('./core/BoundingRect');
  var timsort = $__require('./core/timsort');
  var Layer = $__require('./Layer');
  var requestAnimationFrame = $__require('./animation/requestAnimationFrame');
  var MAX_PROGRESSIVE_LAYER_NUMBER = 5;
  function parseInt10(val) {
    return parseInt(val, 10);
  }
  function isLayerValid(layer) {
    if (!layer) {
      return false;
    }
    if (layer.isBuildin) {
      return true;
    }
    if (typeof(layer.resize) !== 'function' || typeof(layer.refresh) !== 'function') {
      return false;
    }
    return true;
  }
  function preProcessLayer(layer) {
    layer.__unusedCount++;
  }
  function postProcessLayer(layer) {
    if (layer.__unusedCount == 1) {
      layer.clear();
    }
  }
  var tmpRect = new BoundingRect(0, 0, 0, 0);
  var viewRect = new BoundingRect(0, 0, 0, 0);
  function isDisplayableCulled(el, width, height) {
    tmpRect.copy(el.getBoundingRect());
    if (el.transform) {
      tmpRect.applyTransform(el.transform);
    }
    viewRect.width = width;
    viewRect.height = height;
    return !tmpRect.intersect(viewRect);
  }
  function isClipPathChanged(clipPaths, prevClipPaths) {
    if (clipPaths == prevClipPaths) {
      return false;
    }
    if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {
      return true;
    }
    for (var i = 0; i < clipPaths.length; i++) {
      if (clipPaths[i] !== prevClipPaths[i]) {
        return true;
      }
    }
  }
  function doClip(clipPaths, ctx) {
    for (var i = 0; i < clipPaths.length; i++) {
      var clipPath = clipPaths[i];
      var m;
      if (clipPath.transform) {
        m = clipPath.transform;
        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      }
      var path = clipPath.path;
      path.beginPath(ctx);
      clipPath.buildPath(path, clipPath.shape);
      ctx.clip();
      if (clipPath.transform) {
        m = clipPath.invTransform;
        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      }
    }
  }
  function createRoot(width, height) {
    var domRoot = document.createElement('div');
    var domRootStyle = domRoot.style;
    domRootStyle.position = 'relative';
    domRootStyle.overflow = 'hidden';
    domRootStyle.width = width + 'px';
    domRootStyle.height = height + 'px';
    return domRoot;
  }
  var Painter = function(root, storage, opts) {
    var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === 'CANVAS';
    opts = opts || {};
    this.dpr = opts.devicePixelRatio || config.devicePixelRatio;
    this._singleCanvas = singleCanvas;
    this.root = root;
    var rootStyle = root.style;
    if (rootStyle) {
      rootStyle['-webkit-tap-highlight-color'] = 'transparent';
      rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';
      root.innerHTML = '';
    }
    this.storage = storage;
    var zlevelList = this._zlevelList = [];
    var layers = this._layers = {};
    this._layerConfig = {};
    if (!singleCanvas) {
      this._width = this._getWidth();
      this._height = this._getHeight();
      var domRoot = this._domRoot = createRoot(this._width, this._height);
      root.appendChild(domRoot);
    } else {
      var width = root.width;
      var height = root.height;
      this._width = width;
      this._height = height;
      var mainLayer = new Layer(root, this, 1);
      mainLayer.initContext();
      layers[0] = mainLayer;
      zlevelList.push(0);
    }
    this.pathToImage = this._createPathToImage();
    this._progressiveLayers = [];
    this._hoverlayer;
    this._hoverElements = [];
  };
  Painter.prototype = {
    constructor: Painter,
    isSingleCanvas: function() {
      return this._singleCanvas;
    },
    getViewportRoot: function() {
      return this._singleCanvas ? this._layers[0].dom : this._domRoot;
    },
    refresh: function(paintAll) {
      var list = this.storage.getDisplayList(true);
      var zlevelList = this._zlevelList;
      this._paintList(list, paintAll);
      for (var i = 0; i < zlevelList.length; i++) {
        var z = zlevelList[i];
        var layer = this._layers[z];
        if (!layer.isBuildin && layer.refresh) {
          layer.refresh();
        }
      }
      this.refreshHover();
      if (this._progressiveLayers.length) {
        this._startProgessive();
      }
      return this;
    },
    addHover: function(el, hoverStyle) {
      if (el.__hoverMir) {
        return;
      }
      var elMirror = new el.constructor({
        style: el.style,
        shape: el.shape
      });
      elMirror.__from = el;
      el.__hoverMir = elMirror;
      elMirror.setStyle(hoverStyle);
      this._hoverElements.push(elMirror);
    },
    removeHover: function(el) {
      var elMirror = el.__hoverMir;
      var hoverElements = this._hoverElements;
      var idx = util.indexOf(hoverElements, elMirror);
      if (idx >= 0) {
        hoverElements.splice(idx, 1);
      }
      el.__hoverMir = null;
    },
    clearHover: function(el) {
      var hoverElements = this._hoverElements;
      for (var i = 0; i < hoverElements.length; i++) {
        var from = hoverElements[i].__from;
        if (from) {
          from.__hoverMir = null;
        }
      }
      hoverElements.length = 0;
    },
    refreshHover: function() {
      var hoverElements = this._hoverElements;
      var len = hoverElements.length;
      var hoverLayer = this._hoverlayer;
      hoverLayer && hoverLayer.clear();
      if (!len) {
        return;
      }
      timsort(hoverElements, this.storage.displayableSortFunc);
      if (!hoverLayer) {
        hoverLayer = this._hoverlayer = this.getLayer(1e5);
      }
      var scope = {};
      hoverLayer.ctx.save();
      for (var i = 0; i < len; ) {
        var el = hoverElements[i];
        var originalEl = el.__from;
        if (!(originalEl && originalEl.__zr)) {
          hoverElements.splice(i, 1);
          originalEl.__hoverMir = null;
          len--;
          continue;
        }
        i++;
        if (!originalEl.invisible) {
          el.transform = originalEl.transform;
          el.invTransform = originalEl.invTransform;
          el.__clipPaths = originalEl.__clipPaths;
          this._doPaintEl(el, hoverLayer, true, scope);
        }
      }
      hoverLayer.ctx.restore();
    },
    _startProgessive: function() {
      var self = this;
      if (!self._furtherProgressive) {
        return;
      }
      var token = self._progressiveToken = +new Date();
      self._progress++;
      requestAnimationFrame(step);
      function step() {
        if (token === self._progressiveToken && self.storage) {
          self._doPaintList(self.storage.getDisplayList());
          if (self._furtherProgressive) {
            self._progress++;
            requestAnimationFrame(step);
          } else {
            self._progressiveToken = -1;
          }
        }
      }
    },
    _clearProgressive: function() {
      this._progressiveToken = -1;
      this._progress = 0;
      util.each(this._progressiveLayers, function(layer) {
        layer.__dirty && layer.clear();
      });
    },
    _paintList: function(list, paintAll) {
      if (paintAll == null) {
        paintAll = false;
      }
      this._updateLayerStatus(list);
      this._clearProgressive();
      this.eachBuildinLayer(preProcessLayer);
      this._doPaintList(list, paintAll);
      this.eachBuildinLayer(postProcessLayer);
    },
    _doPaintList: function(list, paintAll) {
      var currentLayer;
      var currentZLevel;
      var ctx;
      var scope;
      var progressiveLayerIdx = 0;
      var currentProgressiveLayer;
      var width = this._width;
      var height = this._height;
      var layerProgress;
      var frame = this._progress;
      function flushProgressiveLayer(layer) {
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        currentLayer.__dirty = true;
        ctx.drawImage(layer.dom, 0, 0, width, height);
        ctx.restore();
        currentLayer.ctx.restore();
      }
      for (var i = 0,
          l = list.length; i < l; i++) {
        var el = list[i];
        var elZLevel = this._singleCanvas ? 0 : el.zlevel;
        var elFrame = el.__frame;
        if (elFrame < 0 && currentProgressiveLayer) {
          flushProgressiveLayer(currentProgressiveLayer);
          currentProgressiveLayer = null;
        }
        if (currentZLevel !== elZLevel) {
          if (ctx) {
            ctx.restore();
          }
          scope = {};
          currentZLevel = elZLevel;
          currentLayer = this.getLayer(currentZLevel);
          if (!currentLayer.isBuildin) {
            log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);
          }
          ctx = currentLayer.ctx;
          ctx.save();
          currentLayer.__unusedCount = 0;
          if (currentLayer.__dirty || paintAll) {
            currentLayer.clear();
          }
        }
        if (!(currentLayer.__dirty || paintAll)) {
          continue;
        }
        if (elFrame >= 0) {
          if (!currentProgressiveLayer) {
            currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];
            currentProgressiveLayer.ctx.save();
            currentProgressiveLayer.renderScope = {};
            if (currentProgressiveLayer && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)) {
              i = currentProgressiveLayer.__nextIdxNotProg - 1;
              continue;
            }
            layerProgress = currentProgressiveLayer.__progress;
            if (!currentProgressiveLayer.__dirty) {
              frame = layerProgress;
            }
            currentProgressiveLayer.__progress = frame + 1;
          }
          if (elFrame === frame) {
            this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
          }
        } else {
          this._doPaintEl(el, currentLayer, paintAll, scope);
        }
        el.__dirty = false;
      }
      if (currentProgressiveLayer) {
        flushProgressiveLayer(currentProgressiveLayer);
      }
      ctx && ctx.restore();
      this._furtherProgressive = false;
      util.each(this._progressiveLayers, function(layer) {
        if (layer.__maxProgress >= layer.__progress) {
          this._furtherProgressive = true;
        }
      }, this);
    },
    _doPaintEl: function(el, currentLayer, forcePaint, scope) {
      var ctx = currentLayer.ctx;
      if ((currentLayer.__dirty || forcePaint) && !el.invisible && el.style.opacity !== 0 && el.scale[0] && el.scale[1] && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
        var clipPaths = el.__clipPaths;
        if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {
          if (scope.prevElClipPaths) {
            scope.prevClipLayer.ctx.restore();
            scope.prevClipLayer = scope.prevElClipPaths = null;
            scope.prevEl = null;
          }
          if (clipPaths) {
            ctx.save();
            doClip(clipPaths, ctx);
            scope.prevClipLayer = currentLayer;
            scope.prevElClipPaths = clipPaths;
          }
        }
        el.beforeBrush && el.beforeBrush(ctx);
        el.brush(ctx, scope.prevEl || null);
        scope.prevEl = el;
        el.afterBrush && el.afterBrush(ctx);
      }
    },
    getLayer: function(zlevel) {
      if (this._singleCanvas) {
        return this._layers[0];
      }
      var layer = this._layers[zlevel];
      if (!layer) {
        layer = new Layer('zr_' + zlevel, this, this.dpr);
        layer.isBuildin = true;
        if (this._layerConfig[zlevel]) {
          util.merge(layer, this._layerConfig[zlevel], true);
        }
        this.insertLayer(zlevel, layer);
        layer.initContext();
      }
      return layer;
    },
    insertLayer: function(zlevel, layer) {
      var layersMap = this._layers;
      var zlevelList = this._zlevelList;
      var len = zlevelList.length;
      var prevLayer = null;
      var i = -1;
      var domRoot = this._domRoot;
      if (layersMap[zlevel]) {
        log('ZLevel ' + zlevel + ' has been used already');
        return;
      }
      if (!isLayerValid(layer)) {
        log('Layer of zlevel ' + zlevel + ' is not valid');
        return;
      }
      if (len > 0 && zlevel > zlevelList[0]) {
        for (i = 0; i < len - 1; i++) {
          if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
            break;
          }
        }
        prevLayer = layersMap[zlevelList[i]];
      }
      zlevelList.splice(i + 1, 0, zlevel);
      if (prevLayer) {
        var prevDom = prevLayer.dom;
        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer.dom);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer.dom, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer.dom);
        }
      }
      layersMap[zlevel] = layer;
    },
    eachLayer: function(cb, context) {
      var zlevelList = this._zlevelList;
      var z;
      var i;
      for (i = 0; i < zlevelList.length; i++) {
        z = zlevelList[i];
        cb.call(context, this._layers[z], z);
      }
    },
    eachBuildinLayer: function(cb, context) {
      var zlevelList = this._zlevelList;
      var layer;
      var z;
      var i;
      for (i = 0; i < zlevelList.length; i++) {
        z = zlevelList[i];
        layer = this._layers[z];
        if (layer.isBuildin) {
          cb.call(context, layer, z);
        }
      }
    },
    eachOtherLayer: function(cb, context) {
      var zlevelList = this._zlevelList;
      var layer;
      var z;
      var i;
      for (i = 0; i < zlevelList.length; i++) {
        z = zlevelList[i];
        layer = this._layers[z];
        if (!layer.isBuildin) {
          cb.call(context, layer, z);
        }
      }
    },
    getLayers: function() {
      return this._layers;
    },
    _updateLayerStatus: function(list) {
      var layers = this._layers;
      var progressiveLayers = this._progressiveLayers;
      var elCountsLastFrame = {};
      var progressiveElCountsLastFrame = {};
      this.eachBuildinLayer(function(layer, z) {
        elCountsLastFrame[z] = layer.elCount;
        layer.elCount = 0;
        layer.__dirty = false;
      });
      util.each(progressiveLayers, function(layer, idx) {
        progressiveElCountsLastFrame[idx] = layer.elCount;
        layer.elCount = 0;
        layer.__dirty = false;
      });
      var progressiveLayerCount = 0;
      var currentProgressiveLayer;
      var lastProgressiveKey;
      var frameCount = 0;
      for (var i = 0,
          l = list.length; i < l; i++) {
        var el = list[i];
        var zlevel = this._singleCanvas ? 0 : el.zlevel;
        var layer = layers[zlevel];
        var elProgress = el.progressive;
        if (layer) {
          layer.elCount++;
          layer.__dirty = layer.__dirty || el.__dirty;
        }
        if (elProgress >= 0) {
          if (lastProgressiveKey !== elProgress) {
            lastProgressiveKey = elProgress;
            frameCount++;
          }
          var elFrame = el.__frame = frameCount - 1;
          if (!currentProgressiveLayer) {
            var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
            currentProgressiveLayer = progressiveLayers[idx];
            if (!currentProgressiveLayer) {
              currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);
              currentProgressiveLayer.initContext();
            }
            currentProgressiveLayer.__maxProgress = 0;
          }
          currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
          currentProgressiveLayer.elCount++;
          currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);
          if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
            layer.__dirty = true;
          }
        } else {
          el.__frame = -1;
          if (currentProgressiveLayer) {
            currentProgressiveLayer.__nextIdxNotProg = i;
            progressiveLayerCount++;
            currentProgressiveLayer = null;
          }
        }
      }
      if (currentProgressiveLayer) {
        progressiveLayerCount++;
        currentProgressiveLayer.__nextIdxNotProg = i;
      }
      this.eachBuildinLayer(function(layer, z) {
        if (elCountsLastFrame[z] !== layer.elCount) {
          layer.__dirty = true;
        }
      });
      progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
      util.each(progressiveLayers, function(layer, idx) {
        if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
          el.__dirty = true;
        }
        if (layer.__dirty) {
          layer.__progress = 0;
        }
      });
    },
    clear: function() {
      this.eachBuildinLayer(this._clearLayer);
      return this;
    },
    _clearLayer: function(layer) {
      layer.clear();
    },
    configLayer: function(zlevel, config) {
      if (config) {
        var layerConfig = this._layerConfig;
        if (!layerConfig[zlevel]) {
          layerConfig[zlevel] = config;
        } else {
          util.merge(layerConfig[zlevel], config, true);
        }
        var layer = this._layers[zlevel];
        if (layer) {
          util.merge(layer, layerConfig[zlevel], true);
        }
      }
    },
    delLayer: function(zlevel) {
      var layers = this._layers;
      var zlevelList = this._zlevelList;
      var layer = layers[zlevel];
      if (!layer) {
        return;
      }
      layer.dom.parentNode.removeChild(layer.dom);
      delete layers[zlevel];
      zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
    },
    resize: function(width, height) {
      var domRoot = this._domRoot;
      domRoot.style.display = 'none';
      width = width || this._getWidth();
      height = height || this._getHeight();
      domRoot.style.display = '';
      if (this._width != width || height != this._height) {
        domRoot.style.width = width + 'px';
        domRoot.style.height = height + 'px';
        for (var id in this._layers) {
          this._layers[id].resize(width, height);
        }
        this.refresh(true);
      }
      this._width = width;
      this._height = height;
      return this;
    },
    clearLayer: function(zlevel) {
      var layer = this._layers[zlevel];
      if (layer) {
        layer.clear();
      }
    },
    dispose: function() {
      this.root.innerHTML = '';
      this.root = this.storage = this._domRoot = this._layers = null;
    },
    getRenderedCanvas: function(opts) {
      opts = opts || {};
      if (this._singleCanvas) {
        return this._layers[0].dom;
      }
      var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
      imageLayer.initContext();
      imageLayer.clearColor = opts.backgroundColor;
      imageLayer.clear();
      var displayList = this.storage.getDisplayList(true);
      var scope = {};
      for (var i = 0; i < displayList.length; i++) {
        var el = displayList[i];
        this._doPaintEl(el, imageLayer, true, scope);
      }
      return imageLayer.dom;
    },
    getWidth: function() {
      return this._width;
    },
    getHeight: function() {
      return this._height;
    },
    _getWidth: function() {
      var root = this.root;
      var stl = document.defaultView.getComputedStyle(root);
      return ((root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width)) - (parseInt10(stl.paddingLeft) || 0) - (parseInt10(stl.paddingRight) || 0)) | 0;
    },
    _getHeight: function() {
      var root = this.root;
      var stl = document.defaultView.getComputedStyle(root);
      return ((root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height)) - (parseInt10(stl.paddingTop) || 0) - (parseInt10(stl.paddingBottom) || 0)) | 0;
    },
    _pathToImage: function(id, path, width, height, dpr) {
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.clearRect(0, 0, width * dpr, height * dpr);
      var pathTransform = {
        position: path.position,
        rotation: path.rotation,
        scale: path.scale
      };
      path.position = [0, 0, 0];
      path.rotation = 0;
      path.scale = [1, 1];
      if (path) {
        path.brush(ctx);
      }
      var ImageShape = $__require('./graphic/Image');
      var imgShape = new ImageShape({
        id: id,
        style: {
          x: 0,
          y: 0,
          image: canvas
        }
      });
      if (pathTransform.position != null) {
        imgShape.position = path.position = pathTransform.position;
      }
      if (pathTransform.rotation != null) {
        imgShape.rotation = path.rotation = pathTransform.rotation;
      }
      if (pathTransform.scale != null) {
        imgShape.scale = path.scale = pathTransform.scale;
      }
      return imgShape;
    },
    _createPathToImage: function() {
      var me = this;
      return function(id, e, width, height) {
        return me._pathToImage(id, e, width, height, me.dpr);
      };
    }
  };
  module.exports = Painter;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/zrender.js", ["./core/guid", "./core/env", "./Handler", "./Storage", "./animation/Animation", "./dom/HandlerProxy", "./Painter"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var guid = $__require('./core/guid');
  var env = $__require('./core/env');
  var Handler = $__require('./Handler');
  var Storage = $__require('./Storage');
  var Animation = $__require('./animation/Animation');
  var HandlerProxy = $__require('./dom/HandlerProxy');
  var useVML = !env.canvasSupported;
  var painterCtors = {canvas: $__require('./Painter')};
  var instances = {};
  var zrender = {};
  zrender.version = '3.1.2';
  zrender.init = function(dom, opts) {
    var zr = new ZRender(guid(), dom, opts);
    instances[zr.id] = zr;
    return zr;
  };
  zrender.dispose = function(zr) {
    if (zr) {
      zr.dispose();
    } else {
      for (var key in instances) {
        instances[key].dispose();
      }
      instances = {};
    }
    return zrender;
  };
  zrender.getInstance = function(id) {
    return instances[id];
  };
  zrender.registerPainter = function(name, Ctor) {
    painterCtors[name] = Ctor;
  };
  function delInstance(id) {
    delete instances[id];
  }
  var ZRender = function(id, dom, opts) {
    opts = opts || {};
    this.dom = dom;
    this.id = id;
    var self = this;
    var storage = new Storage();
    var rendererType = opts.renderer;
    if (useVML) {
      if (!painterCtors.vml) {
        throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
      }
      rendererType = 'vml';
    } else if (!rendererType || !painterCtors[rendererType]) {
      rendererType = 'canvas';
    }
    var painter = new painterCtors[rendererType](dom, storage, opts);
    this.storage = storage;
    this.painter = painter;
    var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
    this.handler = new Handler(storage, painter, handerProxy);
    this.animation = new Animation({stage: {update: function() {
          if (self._needsRefresh) {
            self.refreshImmediately();
          }
          if (self._needsRefreshHover) {
            self.refreshHoverImmediately();
          }
        }}});
    this.animation.start();
    this._needsRefresh;
    var oldDelFromMap = storage.delFromMap;
    var oldAddToMap = storage.addToMap;
    storage.delFromMap = function(elId) {
      var el = storage.get(elId);
      oldDelFromMap.call(storage, elId);
      el && el.removeSelfFromZr(self);
    };
    storage.addToMap = function(el) {
      oldAddToMap.call(storage, el);
      el.addSelfToZr(self);
    };
  };
  ZRender.prototype = {
    constructor: ZRender,
    getId: function() {
      return this.id;
    },
    add: function(el) {
      this.storage.addRoot(el);
      this._needsRefresh = true;
    },
    remove: function(el) {
      this.storage.delRoot(el);
      this._needsRefresh = true;
    },
    configLayer: function(zLevel, config) {
      this.painter.configLayer(zLevel, config);
      this._needsRefresh = true;
    },
    refreshImmediately: function() {
      this._needsRefresh = false;
      this.painter.refresh();
      this._needsRefresh = false;
    },
    refresh: function() {
      this._needsRefresh = true;
    },
    addHover: function(el, style) {
      if (this.painter.addHover) {
        this.painter.addHover(el, style);
        this.refreshHover();
      }
    },
    removeHover: function(el) {
      if (this.painter.removeHover) {
        this.painter.removeHover(el);
        this.refreshHover();
      }
    },
    clearHover: function() {
      if (this.painter.clearHover) {
        this.painter.clearHover();
        this.refreshHover();
      }
    },
    refreshHover: function() {
      this._needsRefreshHover = true;
    },
    refreshHoverImmediately: function() {
      this._needsRefreshHover = false;
      this.painter.refreshHover && this.painter.refreshHover();
    },
    resize: function() {
      this.painter.resize();
      this.handler.resize();
    },
    clearAnimation: function() {
      this.animation.clear();
    },
    getWidth: function() {
      return this.painter.getWidth();
    },
    getHeight: function() {
      return this.painter.getHeight();
    },
    pathToImage: function(e, width, height) {
      var id = guid();
      return this.painter.pathToImage(id, e, width, height);
    },
    setCursorStyle: function(cursorStyle) {
      this.handler.setCursorStyle(cursorStyle);
    },
    on: function(eventName, eventHandler, context) {
      this.handler.on(eventName, eventHandler, context);
    },
    off: function(eventName, eventHandler) {
      this.handler.off(eventName, eventHandler);
    },
    trigger: function(eventName, event) {
      this.handler.trigger(eventName, event);
    },
    clear: function() {
      this.storage.delRoot();
      this.painter.clear();
    },
    dispose: function() {
      this.animation.stop();
      this.clear();
      this.storage.dispose();
      this.painter.dispose();
      this.handler.dispose();
      this.animation = this.storage = this.painter = this.handler = null;
      delInstance(this.id);
    }
  };
  module.exports = zrender;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/config.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var dpr = 1;
  if (typeof window !== 'undefined') {
    dpr = Math.max(window.devicePixelRatio || 1, 1);
  }
  var config = {
    debugMode: 0,
    devicePixelRatio: dpr
  };
  module.exports = config;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/log.js", ["../config"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var config = $__require('../config');
  module.exports = function() {
    if (config.debugMode === 0) {
      return;
    } else if (config.debugMode == 1) {
      for (var k in arguments) {
        throw new Error(arguments[k]);
      }
    } else if (config.debugMode > 1) {
      for (var k in arguments) {
        console.log(arguments[k]);
      }
    }
  };
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/core/env.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var env = {};
  if (typeof navigator === 'undefined') {
    env = {
      browser: {},
      os: {},
      node: true,
      canvasSupported: true
    };
  } else {
    env = detect(navigator.userAgent);
  }
  module.exports = env;
  function detect(ua) {
    var os = {};
    var browser = {};
    var firefox = ua.match(/Firefox\/([\d.]+)/);
    var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
    var edge = ua.match(/Edge\/([\d.]+)/);
    if (firefox)
      browser.firefox = true, browser.version = firefox[1];
    if (ie) {
      browser.ie = true;
      browser.version = ie[1];
    }
    if (ie) {
      browser.ie = true;
      browser.version = ie[1];
    }
    if (edge) {
      browser.edge = true;
      browser.version = edge[1];
    }
    return {
      browser: browser,
      os: os,
      node: false,
      canvasSupported: document.createElement('canvas').getContext ? true : false,
      touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
      pointerEventsSupported: 'onpointerdown' in window && (browser.edge || (browser.ie && browser.version >= 10))
    };
  }
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/vml/core.js", ["../core/env"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  if (!$__require('../core/env').canvasSupported) {
    var urn = 'urn:schemas-microsoft-com:vml';
    var createNode;
    var win = window;
    var doc = win.document;
    var vmlInited = false;
    try {
      !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);
      createNode = function(tagName) {
        return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
      };
    } catch (e) {
      createNode = function(tagName) {
        return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
      };
    }
    var initVML = function() {
      if (vmlInited) {
        return;
      }
      vmlInited = true;
      var styleSheets = doc.styleSheets;
      if (styleSheets.length < 31) {
        doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
      } else {
        styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
      }
    };
    module.exports = {
      doc: doc,
      initVML: initVML,
      createNode: createNode
    };
  }
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2/lib/vml/Painter.js", ["../core/log", "./core"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var zrLog = $__require('../core/log');
  var vmlCore = $__require('./core');
  function parseInt10(val) {
    return parseInt(val, 10);
  }
  function VMLPainter(root, storage) {
    vmlCore.initVML();
    this.root = root;
    this.storage = storage;
    var vmlViewport = document.createElement('div');
    var vmlRoot = document.createElement('div');
    vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
    vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
    root.appendChild(vmlViewport);
    this._vmlRoot = vmlRoot;
    this._vmlViewport = vmlViewport;
    this.resize();
    var oldDelFromMap = storage.delFromMap;
    var oldAddToMap = storage.addToMap;
    storage.delFromMap = function(elId) {
      var el = storage.get(elId);
      oldDelFromMap.call(storage, elId);
      if (el) {
        el.onRemove && el.onRemove(vmlRoot);
      }
    };
    storage.addToMap = function(el) {
      el.onAdd && el.onAdd(vmlRoot);
      oldAddToMap.call(storage, el);
    };
    this._firstPaint = true;
  }
  VMLPainter.prototype = {
    constructor: VMLPainter,
    getViewportRoot: function() {
      return this._vmlViewport;
    },
    refresh: function() {
      var list = this.storage.getDisplayList(true, true);
      this._paintList(list);
    },
    _paintList: function(list) {
      var vmlRoot = this._vmlRoot;
      for (var i = 0; i < list.length; i++) {
        var el = list[i];
        if (el.invisible || el.ignore) {
          if (!el.__alreadyNotVisible) {
            el.onRemove(vmlRoot);
          }
          el.__alreadyNotVisible = true;
        } else {
          if (el.__alreadyNotVisible) {
            el.onAdd(vmlRoot);
          }
          el.__alreadyNotVisible = false;
          if (el.__dirty) {
            el.beforeBrush && el.beforeBrush();
            (el.brushVML || el.brush).call(el, vmlRoot);
            el.afterBrush && el.afterBrush();
          }
        }
        el.__dirty = false;
      }
      if (this._firstPaint) {
        this._vmlViewport.appendChild(vmlRoot);
        this._firstPaint = false;
      }
    },
    resize: function() {
      var width = this._getWidth();
      var height = this._getHeight();
      if (this._width != width && this._height != height) {
        this._width = width;
        this._height = height;
        var vmlViewportStyle = this._vmlViewport.style;
        vmlViewportStyle.width = width + 'px';
        vmlViewportStyle.height = height + 'px';
      }
    },
    dispose: function() {
      this.root.innerHTML = '';
      this._vmlRoot = this._vmlViewport = this.storage = null;
    },
    getWidth: function() {
      return this._width;
    },
    getHeight: function() {
      return this._height;
    },
    clear: function() {
      this.root.removeChild(this.vmlViewport);
    },
    _getWidth: function() {
      var root = this.root;
      var stl = root.currentStyle;
      return ((root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight)) | 0;
    },
    _getHeight: function() {
      var root = this.root;
      var stl = root.currentStyle;
      return ((root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom)) | 0;
    }
  };
  function createMethodNotSupport(method) {
    return function() {
      zrLog('In IE8.0 VML mode painter not support method "' + method + '"');
    };
  }
  var notSupportedMethods = ['getLayer', 'insertLayer', 'eachLayer', 'eachBuildinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'];
  for (var i = 0; i < notSupportedMethods.length; i++) {
    var name = notSupportedMethods[i];
    VMLPainter.prototype[name] = createMethodNotSupport(name);
  }
  module.exports = VMLPainter;
  return module.exports;
});

System.registerDynamic("npm:zrender@3.1.2.json", [], false, function() {
  return {
    "main": "lib/zrender.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      },
      "src/animation/easing.js": {
        "format": "amd"
      },
      "src/animation/requestAnimationFrame.js": {
        "format": "amd"
      },
      "src/config.js": {
        "format": "amd"
      },
      "src/contain/line.js": {
        "format": "amd"
      },
      "src/contain/util.js": {
        "format": "amd"
      },
      "src/contain/windingLine.js": {
        "format": "amd"
      },
      "src/core/LRU.js": {
        "format": "amd"
      },
      "src/core/arrayDiff.js": {
        "format": "amd"
      },
      "src/core/env.js": {
        "format": "amd"
      },
      "src/core/guid.js": {
        "format": "amd"
      },
      "src/core/matrix.js": {
        "format": "amd"
      },
      "src/core/timsort.js": {
        "format": "amd"
      },
      "src/core/util.js": {
        "format": "amd"
      },
      "src/core/vector.js": {
        "format": "amd"
      },
      "src/graphic/Gradient.js": {
        "format": "amd"
      },
      "src/graphic/Pattern.js": {
        "format": "amd"
      },
      "src/graphic/Style.js": {
        "format": "amd"
      },
      "src/graphic/helper/roundRect.js": {
        "format": "amd"
      },
      "src/mixin/Draggable.js": {
        "format": "amd"
      },
      "src/mixin/Eventful.js": {
        "format": "amd"
      },
      "src/svg/core.js": {
        "format": "amd"
      },
      "src/tool/color.js": {
        "format": "amd"
      }
    }
  };
});

System.registerDynamic("npm:zrender@3.1.2/lib/vml/vml.js", ["./graphic", "../zrender", "./Painter"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('./graphic');
  $__require('../zrender').registerPainter('vml', $__require('./Painter'));
  return module.exports;
});

System.registerDynamic("npm:echarts@3.2.2.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      },
      "extension/dataTool/quantile.js": {
        "format": "amd"
      },
      "extension/echarts.js": {
        "format": "amd"
      },
      "src/CoordinateSystem.js": {
        "format": "amd"
      },
      "src/action/roamHelper.js": {
        "format": "amd"
      },
      "src/chart/boxplot/boxplotVisual.js": {
        "format": "amd"
      },
      "src/chart/candlestick/candlestickLayout.js": {
        "format": "amd"
      },
      "src/chart/candlestick/candlestickVisual.js": {
        "format": "amd"
      },
      "src/chart/graph/backwardCompat.js": {
        "format": "amd"
      },
      "src/chart/graph/categoryFilter.js": {
        "format": "amd"
      },
      "src/chart/graph/categoryVisual.js": {
        "format": "amd"
      },
      "src/chart/graph/edgeVisual.js": {
        "format": "amd"
      },
      "src/chart/lines/linesLayout.js": {
        "format": "amd"
      },
      "src/chart/map/mapVisual.js": {
        "format": "amd"
      },
      "src/chart/parallel/parallelVisual.js": {
        "format": "amd"
      },
      "src/chart/radar/radarLayout.js": {
        "format": "amd"
      },
      "src/chart/themeRiver/themeRiverVisual.js": {
        "format": "amd"
      },
      "src/component/helper/sliderMove.js": {
        "format": "amd"
      },
      "src/component/legend/legendFilter.js": {
        "format": "amd"
      },
      "src/component/toolbox/featureManager.js": {
        "format": "amd"
      },
      "src/data/DataDiffer.js": {
        "format": "amd"
      },
      "src/layout/points.js": {
        "format": "amd"
      },
      "src/model/globalDefault.js": {
        "format": "amd"
      },
      "src/model/mixin/boxLayout.js": {
        "format": "amd"
      },
      "src/model/mixin/colorPalette.js": {
        "format": "amd"
      },
      "src/processor/*": {
        "format": "amd"
      },
      "src/util/number.js": {
        "format": "amd"
      },
      "src/util/throttle.js": {
        "format": "amd"
      },
      "src/visual/dataColor.js": {
        "format": "amd"
      },
      "src/visual/symbol.js": {
        "format": "amd"
      }
    },
    "map": {
      "./extension/dataTool": "./extension/dataTool/index.js",
      "echarts": "."
    }
  };
});

System.registerDynamic("npm:echarts@3.2.2/index.js", ["./lib/echarts", "./lib/chart/line", "./lib/chart/bar", "./lib/chart/pie", "./lib/chart/scatter", "./lib/chart/radar", "./lib/chart/map", "./lib/chart/treemap", "./lib/chart/graph", "./lib/chart/gauge", "./lib/chart/funnel", "./lib/chart/parallel", "./lib/chart/sankey", "./lib/chart/boxplot", "./lib/chart/candlestick", "./lib/chart/effectScatter", "./lib/chart/lines", "./lib/chart/heatmap", "./lib/component/grid", "./lib/component/legend", "./lib/component/tooltip", "./lib/component/polar", "./lib/component/geo", "./lib/component/parallel", "./lib/component/singleAxis", "./lib/component/brush", "./lib/component/title", "./lib/component/dataZoom", "./lib/component/visualMap", "./lib/component/markPoint", "./lib/component/markLine", "./lib/component/markArea", "./lib/component/timeline", "./lib/component/toolbox", "zrender/lib/vml/vml", "process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./lib/echarts');
  $__require('./lib/chart/line');
  $__require('./lib/chart/bar');
  $__require('./lib/chart/pie');
  $__require('./lib/chart/scatter');
  $__require('./lib/chart/radar');
  $__require('./lib/chart/map');
  $__require('./lib/chart/treemap');
  $__require('./lib/chart/graph');
  $__require('./lib/chart/gauge');
  $__require('./lib/chart/funnel');
  $__require('./lib/chart/parallel');
  $__require('./lib/chart/sankey');
  $__require('./lib/chart/boxplot');
  $__require('./lib/chart/candlestick');
  $__require('./lib/chart/effectScatter');
  $__require('./lib/chart/lines');
  $__require('./lib/chart/heatmap');
  $__require('./lib/component/grid');
  $__require('./lib/component/legend');
  $__require('./lib/component/tooltip');
  $__require('./lib/component/polar');
  $__require('./lib/component/geo');
  $__require('./lib/component/parallel');
  $__require('./lib/component/singleAxis');
  $__require('./lib/component/brush');
  $__require('./lib/component/title');
  $__require('./lib/component/dataZoom');
  $__require('./lib/component/visualMap');
  $__require('./lib/component/markPoint');
  $__require('./lib/component/markLine');
  $__require('./lib/component/markArea');
  $__require('./lib/component/timeline');
  $__require('./lib/component/toolbox');
  $__require('zrender/lib/vml/vml');
  return module.exports;
});

System.registerDynamic("npm:influx-ql@0.1.4/lib/internal.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  const map = new WeakMap();
  module.exports = function internal(object) {
    if (!map.has(object)) {
      map.set(object, {});
    }
    return map.get(object);
  };
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-util@0.2.0-alpha/isBufferBrowser.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
  };
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-util@0.2.0-alpha.json", [], false, function() {
  return {
    "main": "./util.js",
    "map": {
      "./isBuffer.js": {
        "~node": "./isBufferBrowser.js"
      }
    }
  };
});

System.registerDynamic("github:jspm/nodelibs-util@0.2.0-alpha/util.js", ["process", "./isBuffer.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var process = $__require('process');
  var formatRegExp = /%[sdj%]/g;
  exports.format = function(f) {
    if (!isString(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(' ');
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
      if (x === '%%')
        return '%';
      if (i >= len)
        return x;
      switch (x) {
        case '%s':
          return String(args[i++]);
        case '%d':
          return Number(args[i++]);
        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }
        default:
          return x;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }
    return str;
  };
  exports.deprecate = function(fn, msg) {
    if (isUndefined(global.process)) {
      return function() {
        return exports.deprecate(fn, msg).apply(this, arguments);
      };
    }
    if (process.noDeprecation === true) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (process.throwDeprecation) {
          throw new Error(msg);
        } else if (process.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  };
  var debugs = {};
  var debugEnviron;
  exports.debuglog = function(set) {
    if (isUndefined(debugEnviron))
      debugEnviron = process.env.NODE_DEBUG || '';
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
        var pid = process.pid;
        debugs[set] = function() {
          var msg = exports.format.apply(exports, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function() {};
      }
    }
    return debugs[set];
  };
  function inspect(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      exports._extend(ctx, opts);
    }
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (isUndefined(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  exports.inspect = inspect;
  inspect.colors = {
    'bold': [1, 22],
    'italic': [3, 23],
    'underline': [4, 24],
    'inverse': [7, 27],
    'white': [37, 39],
    'grey': [90, 39],
    'black': [30, 39],
    'blue': [34, 39],
    'cyan': [36, 39],
    'green': [32, 39],
    'magenta': [35, 39],
    'red': [31, 39],
    'yellow': [33, 39]
  };
  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    'regexp': 'red'
  };
  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];
    if (style) {
      return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }
  function stylizeNoColor(str, styleType) {
    return str;
  }
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);
    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    }
    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
      return formatError(value);
    }
    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }
      if (isError(value)) {
        return formatError(value);
      }
    }
    var base = '',
        array = false,
        braces = ['{', '}'];
    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    }
    if (isFunction(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    }
    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    }
    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    }
    if (isError(value)) {
      base = ' ' + formatError(value);
    }
    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }
    ctx.seen.push(value);
    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }
    if (isNumber(value))
      return ctx.stylize('' + value, 'number');
    if (isBoolean(value))
      return ctx.stylize('' + value, 'boolean');
    if (isNull(value))
      return ctx.stylize('null', 'null');
  }
  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i = 0,
        l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push('');
      }
    }
    keys.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name,
        str,
        desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
      name = '[' + key + ']';
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function(line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function(line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify('' + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }
    return name + ': ' + str;
  }
  function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0)
        numLinesEst++;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);
    if (length > 60) {
      return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    }
    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }
  function isArray(ar) {
    return Array.isArray(ar);
  }
  exports.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }
  exports.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === 'number';
  }
  exports.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === 'string';
  }
  exports.isString = isString;
  function isSymbol(arg) {
    return typeof arg === 'symbol';
  }
  exports.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports.isUndefined = isUndefined;
  function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
  }
  exports.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  exports.isObject = isObject;
  function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
  }
  exports.isDate = isDate;
  function isError(e) {
    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
  }
  exports.isError = isError;
  function isFunction(arg) {
    return typeof arg === 'function';
  }
  exports.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
  }
  exports.isPrimitive = isPrimitive;
  exports.isBuffer = $__require('./isBuffer.js');
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
  }
  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  function timestamp() {
    var d = new Date();
    var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
    return [d.getDate(), months[d.getMonth()], time].join(' ');
  }
  exports.log = function() {
    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
  };
  if (typeof Object.create === 'function') {
    exports.inherits = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }});
    };
  } else {
    exports.inherits = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  exports._extend = function(origin, add) {
    if (!add || !isObject(add))
      return origin;
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  };
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  return module.exports;
});

System.registerDynamic("npm:influx-ql@0.1.4.json", [], false, function() {
  return {
    "main": "lib/ql.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:influx-ql@0.1.4/lib/ql.js", ["./internal", "util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  const internal = $__require('./internal');
  const util = $__require('util');
  function validate(data, keys) {
    const notSetKeys = [];
    keys.forEach((key) => {
      if (!data[key]) {
        notSetKeys.push(key);
      }
    });
    if (notSetKeys.length) {
      throw new Error(`${notSetKeys.join(',')} can not be null`);
    }
  }
  function getTimeCondition(time, type) {
    let timeDesc = '';
    if (time.charAt(0) === '-') {
      timeDesc = `now() - ${time.substring(1)}`;
    } else if (/\d{4}-\d{2}-\d{2}/.test(time)) {
      timeDesc = `'${time}'`;
    } else {
      timeDesc = time;
    }
    return `time ${type} ${timeDesc}`;
  }
  function addToArray(arr, args) {
    if (args && args.length) {
      arr.push.apply(arr, args);
    }
  }
  function removeFromArray(arr, args) {
    return arr.filter((item) => !~args.indexOf(item));
  }
  function convert(field) {
    if (/[\s-]/.test(field)) {
      return `"${field}"`;
    }
    return field;
  }
  function getFrom(data) {
    const arr = [];
    if (data.db) {
      arr.push(convert(data.db));
      arr.push(data.rp);
    }
    arr.push(convert(data.measurement));
    return `from ${arr.join('.')}`;
  }
  function getQL(data) {
    validate(data, ['measurement']);
    const arr = [];
    arr.push(getFrom(data));
    const conditions = data.conditions.slice();
    const groups = data.groups;
    if (data.start) {
      conditions.push(getTimeCondition(data.start, '>='));
    }
    if (data.end) {
      conditions.push(getTimeCondition(data.end, '<='));
    }
    if (conditions.length) {
      arr.push(`where ${conditions.sort().join(' and ')}`);
    }
    if (groups && groups.length) {
      arr.push(`group by ${groups.sort().join(',')}`);
      if (util.isNumber(data.fill)) {
        arr.push(`fill(${data.fill})`);
      }
    }
    if (data.order) {
      arr.push(`order by time ${data.order}`);
    }
    if (data.limit) {
      arr.push(`limit ${data.limit}`);
    }
    if (data.slimit) {
      arr.push(`slimit ${data.slimit}`);
    }
    if (data.offset) {
      arr.push(`offset ${data.offset}`);
    }
    return arr.join(' ');
  }
  function showKeys(type, measurement) {
    let ql = `show ${type} keys`;
    if (measurement) {
      ql = `${ql} from ${convert(measurement)}`;
    }
    return ql;
  }
  class QL {
    constructor(db) {
      const data = internal(this);
      data.fields = [];
      data.conditions = [];
      data.calculations = [];
      data.groups = [];
      data.rp = '"default"';
      data.db = db;
    }
    set RP(v) {
      internal(this).rp = v;
      return this;
    }
    get RP() {
      return internal(this).rp;
    }
    set measurement(v) {
      internal(this).measurement = v;
      return this;
    }
    get measurement() {
      return internal(this).measurement;
    }
    set start(v) {
      internal(this).start = v;
      return this;
    }
    get start() {
      return internal(this).start;
    }
    set end(v) {
      internal(this).end = v;
      return this;
    }
    get end() {
      return internal(this).end;
    }
    set limit(v) {
      internal(this).limit = v;
      return this;
    }
    get limit() {
      return internal(this).limit;
    }
    set slimit(v) {
      internal(this).slimit = v;
      return this;
    }
    get slimit() {
      return internal(this).slimit;
    }
    set fill(v) {
      internal(this).fill = v;
      return this;
    }
    get fill() {
      return internal(this).fill;
    }
    set into(v) {
      internal(this).into = v;
      return this;
    }
    get into() {
      return internal(this).into;
    }
    set order(v) {
      internal(this).order = v;
      return this;
    }
    get order() {
      return internal(this).order;
    }
    set offset(v) {
      internal(this).offset = v;
      return this;
    }
    get offset() {
      return internal(this).offset;
    }
    addField() {
      const args = Array.from(arguments).map(convert);
      addToArray(internal(this).fields, args);
      return this;
    }
    removeField() {
      const data = internal(this);
      data.fields = removeFromArray(data.fields, Array.from(arguments));
      return this;
    }
    addCondition() {
      addToArray(internal(this).conditions, Array.from(arguments));
      return this;
    }
    removeCondition() {
      const data = internal(this);
      data.conditions = removeFromArray(data.conditions, Array.from(arguments));
      return this;
    }
    removeAllCondition() {
      internal(this).conditions.length = 0;
      return this;
    }
    condition(k, v) {
      if (util.isObject(k)) {
        const target = k;
        const keys = Object.keys(target);
        keys.forEach((key) => this.condition(key, target[key]));
        return this;
      }
      if (k && v) {
        const key = convert(k);
        if (util.isArray(v)) {
          const arr = [];
          v.forEach((_v) => {
            let tmp = _v;
            if (util.isString(tmp)) {
              tmp = `'${tmp}'`;
            }
            arr.push(`${key} = ${tmp}`);
          });
          this.addCondition(`(${arr.join(' or ')})`);
        } else {
          let tmp = v;
          if (util.isString(tmp)) {
            tmp = `'${tmp}'`;
          }
          this.addCondition(`${key} = ${tmp}`);
        }
      } else if (k) {
        this.addCondition(k);
      }
      return this;
    }
    tag(k, v) {
      return this.condition(k, v);
    }
    field(k, v) {
      return this.condition(k, v);
    }
    addCalculate(type, field) {
      if (type && field) {
        internal(this).calculations.push(`${type}(${field})`);
      }
      return this;
    }
    removeCalculate(type, field) {
      if (type && field) {
        const data = internal(this);
        data.calculations = removeFromArray(data.calculations, `${type}(${field})`);
      }
      return this;
    }
    removeAllCalculate() {
      internal(this).calculations.length = 0;
      return this;
    }
    addGroup() {
      const args = Array.from(arguments).map(convert);
      addToArray(internal(this).groups, args);
      return this;
    }
    removeGroup() {
      const args = Array.from(arguments).map(convert);
      const data = internal(this);
      data.groups = removeFromArray(data.groups, args);
      return this;
    }
    toSelect() {
      const data = internal(this);
      const arr = ['select'];
      const fields = data.fields;
      const calculations = data.calculations;
      if (calculations && calculations.length) {
        arr.push(calculations.sort().join(','));
      } else if (fields && fields.length) {
        arr.push(fields.sort().join(','));
      } else {
        arr.push('*');
      }
      if (data.into) {
        arr.push(`into ${convert(data.into)}`);
      }
      arr.push(getQL(data));
      return arr.join(' ');
    }
    static createDatabase(db) {
      return `create database ${convert(db)}`;
    }
    static createDatabaseNotExists(db) {
      return `create database if not exists ${convert(db)}`;
    }
    static dropDatabase(db) {
      return `drop database ${convert(db)}`;
    }
    static showDatabases() {
      return 'show databases';
    }
    static showRetentionPolicies(db) {
      return `show retention policies on ${convert(db)}`;
    }
    static showMeasurements() {
      return 'show measurements';
    }
    static showTagKeys(measurement) {
      return showKeys('tag', measurement);
    }
    static showFieldKeys(measurement) {
      return showKeys('field', measurement);
    }
    static showSeries(measurement) {
      let ql = 'show series';
      if (measurement) {
        ql = `${ql} from ${convert(measurement)}`;
      }
      return ql;
    }
  }
  module.exports = QL;
  return module.exports;
});

System.registerDynamic("npm:lodash@4.14.1/lodash.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  ;
  (function() {
    var undefined;
    var VERSION = '4.14.1';
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = 'Expected a function';
    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    var PLACEHOLDER = '__lodash_placeholder__';
    var BIND_FLAG = 1,
        BIND_KEY_FLAG = 2,
        CURRY_BOUND_FLAG = 4,
        CURRY_FLAG = 8,
        CURRY_RIGHT_FLAG = 16,
        PARTIAL_FLAG = 32,
        PARTIAL_RIGHT_FLAG = 64,
        ARY_FLAG = 128,
        REARG_FLAG = 256,
        FLIP_FLAG = 512;
    var UNORDERED_COMPARE_FLAG = 1,
        PARTIAL_COMPARE_FLAG = 2;
    var DEFAULT_TRUNC_LENGTH = 30,
        DEFAULT_TRUNC_OMISSION = '...';
    var HOT_COUNT = 150,
        HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1,
        LAZY_MAP_FLAG = 2,
        LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 1.7976931348623157e+308,
        NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [['ary', ARY_FLAG], ['bind', BIND_FLAG], ['bindKey', BIND_KEY_FLAG], ['curry', CURRY_FLAG], ['curryRight', CURRY_RIGHT_FLAG], ['flip', FLIP_FLAG], ['partial', PARTIAL_FLAG], ['partialRight', PARTIAL_RIGHT_FLAG], ['rearg', REARG_FLAG]];
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        weakMapTag = '[object WeakMap]',
        weakSetTag = '[object WeakSet]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    var reEmptyStringLeading = /\b__p \+= '';/g,
        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
        reUnescapedHtml = /[&<>"'`]/g,
        reHasEscapedHtml = RegExp(reEscapedHtml.source),
        reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g,
        reEvaluate = /<%([\s\S]+?)%>/g,
        reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        reLeadingDot = /^\./,
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
        reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrim = /^\s+|\s+$/g,
        reTrimStart = /^\s+/,
        reTrimEnd = /\s+$/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
        reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
        reSplitDetails = /,? & /;
    var reBasicWord = /[a-zA-Z0-9]+/g;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reHasHexPrefix = /^0x/i;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
        rsComboSymbolsRange = '\\u20d0-\\u20f0',
        rsDingbatRange = '\\u2700-\\u27bf',
        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange = '\\u2000-\\u206f',
        rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange = '\\ufe0e\\ufe0f',
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]",
        rsAstral = '[' + rsAstralRange + ']',
        rsBreak = '[' + rsBreakRange + ']',
        rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
        rsDigits = '\\d+',
        rsDingbat = '[' + rsDingbatRange + ']',
        rsLower = '[' + rsLowerRange + ']',
        rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper = '[' + rsUpperRange + ']',
        rsZWJ = '\\u200d';
    var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
        rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
        rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
        rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
    var reApos = RegExp(rsApos, 'g');
    var reComboMark = RegExp(rsCombo, 'g');
    var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
    var reComplexWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')', rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr, rsUpper + '+' + rsOptUpperContr, rsDigits, rsEmoji].join('|'), 'g');
    var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
    var reHasComplexWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = ['Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object', 'Promise', 'Reflect', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      '\xc0': 'A',
      '\xc1': 'A',
      '\xc2': 'A',
      '\xc3': 'A',
      '\xc4': 'A',
      '\xc5': 'A',
      '\xe0': 'a',
      '\xe1': 'a',
      '\xe2': 'a',
      '\xe3': 'a',
      '\xe4': 'a',
      '\xe5': 'a',
      '\xc7': 'C',
      '\xe7': 'c',
      '\xd0': 'D',
      '\xf0': 'd',
      '\xc8': 'E',
      '\xc9': 'E',
      '\xca': 'E',
      '\xcb': 'E',
      '\xe8': 'e',
      '\xe9': 'e',
      '\xea': 'e',
      '\xeb': 'e',
      '\xcC': 'I',
      '\xcd': 'I',
      '\xce': 'I',
      '\xcf': 'I',
      '\xeC': 'i',
      '\xed': 'i',
      '\xee': 'i',
      '\xef': 'i',
      '\xd1': 'N',
      '\xf1': 'n',
      '\xd2': 'O',
      '\xd3': 'O',
      '\xd4': 'O',
      '\xd5': 'O',
      '\xd6': 'O',
      '\xd8': 'O',
      '\xf2': 'o',
      '\xf3': 'o',
      '\xf4': 'o',
      '\xf5': 'o',
      '\xf6': 'o',
      '\xf8': 'o',
      '\xd9': 'U',
      '\xda': 'U',
      '\xdb': 'U',
      '\xdc': 'U',
      '\xf9': 'u',
      '\xfa': 'u',
      '\xfb': 'u',
      '\xfc': 'u',
      '\xdd': 'Y',
      '\xfd': 'y',
      '\xff': 'y',
      '\xc6': 'Ae',
      '\xe6': 'ae',
      '\xde': 'Th',
      '\xfe': 'th',
      '\xdf': 'ss'
    };
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
      '`': '&#96;'
    };
    var htmlUnescapes = {
      '&amp;': '&',
      '&lt;': '<',
      '&gt;': '>',
      '&quot;': '"',
      '&#39;': "'",
      '&#96;': '`'
    };
    var stringEscapes = {
      '\\': '\\',
      "'": "'",
      '\n': 'n',
      '\r': 'r',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };
    var freeParseFloat = parseFloat,
        freeParseInt = parseInt;
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function('return this')();
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = (function() {
      try {
        return freeProcess && freeProcess.binding('util');
      } catch (e) {}
    }());
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
        nodeIsDate = nodeUtil && nodeUtil.isDate,
        nodeIsMap = nodeUtil && nodeUtil.isMap,
        nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
        nodeIsSet = nodeUtil && nodeUtil.isSet,
        nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1,
          length = array ? array.length : 0;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array ? array.length : 0;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array ? array.length : 0;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = 0,
          result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1,
          length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array ? array.length : 0,
          result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1,
          length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);
      while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1,
          length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1,
          length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array ? array.length : 0;
      return length ? (baseSum(array, iteratee) / length) : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result,
          index = -1,
          length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined) {
          result = result === undefined ? current : (result + current);
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1,
          length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length,
          result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          result++;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return '\\' + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }
      return result;
    }
    function iteratorToArray(iterator) {
      var data,
          result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1,
          result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index = -1,
          result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function stringSize(string) {
      if (!(string && reHasComplexSymbol.test(string))) {
        return string.length;
      }
      var result = reComplexSymbol.lastIndex = 0;
      while (reComplexSymbol.test(string)) {
        result++;
      }
      return result;
    }
    function stringToArray(string) {
      return string.match(reComplexSymbol);
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function runInContext(context) {
      context = context ? _.defaults({}, context, _.pick(root, contextProps)) : root;
      var Array = context.Array,
          Date = context.Date,
          Error = context.Error,
          Math = context.Math,
          RegExp = context.RegExp,
          TypeError = context.TypeError;
      var arrayProto = context.Array.prototype,
          objectProto = context.Object.prototype,
          stringProto = context.String.prototype;
      var coreJsData = context['__core-js_shared__'];
      var maskSrcKey = (function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
        return uid ? ('Symbol(src)_1.' + uid) : '';
      }());
      var funcToString = context.Function.prototype.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var objectCtorString = funcToString.call(Object);
      var objectToString = objectProto.toString;
      var oldDash = root._;
      var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
      var Buffer = moduleExports ? context.Buffer : undefined,
          Reflect = context.Reflect,
          Symbol = context.Symbol,
          Uint8Array = context.Uint8Array,
          enumerate = Reflect ? Reflect.enumerate : undefined,
          iteratorSymbol = Symbol ? Symbol.iterator : undefined,
          objectCreate = context.Object.create,
          propertyIsEnumerable = objectProto.propertyIsEnumerable,
          splice = arrayProto.splice,
          spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
      var clearTimeout = function(id) {
        return context.clearTimeout.call(root, id);
      },
          setTimeout = function(func, wait) {
            return context.setTimeout.call(root, func, wait);
          };
      var nativeCeil = Math.ceil,
          nativeFloor = Math.floor,
          nativeGetPrototype = Object.getPrototypeOf,
          nativeGetSymbols = Object.getOwnPropertySymbols,
          nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
          nativeIsFinite = context.isFinite,
          nativeJoin = arrayProto.join,
          nativeKeys = Object.keys,
          nativeMax = Math.max,
          nativeMin = Math.min,
          nativeParseInt = context.parseInt,
          nativeRandom = Math.random,
          nativeReplace = stringProto.replace,
          nativeReverse = arrayProto.reverse,
          nativeSplit = stringProto.split;
      var DataView = getNative(context, 'DataView'),
          Map = getNative(context, 'Map'),
          Promise = getNative(context, 'Promise'),
          Set = getNative(context, 'Set'),
          WeakMap = getNative(context, 'WeakMap'),
          nativeCreate = getNative(context.Object, 'create');
      var defineProperty = (function() {
        var func = getNative(context.Object, 'defineProperty'),
            name = getNative.name;
        return (name && name.length > 2) ? func : undefined;
      }());
      var metaMap = WeakMap && new WeakMap;
      var nonEnumShadows = !propertyIsEnumerable.call({'valueOf': 1}, 'valueOf');
      var realNames = {};
      var dataViewCtorString = toSource(DataView),
          mapCtorString = toSource(Map),
          promiseCtorString = toSource(Promise),
          setCtorString = toSource(Set),
          weakMapCtorString = toSource(WeakMap);
      var symbolProto = Symbol ? Symbol.prototype : undefined,
          symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
          symbolToString = symbolProto ? symbolProto.toString : undefined;
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, '__wrapped__')) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      function baseLodash() {}
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined;
      }
      lodash.templateSettings = {
        'escape': reEscape,
        'evaluate': reEvaluate,
        'interpolate': reInterpolate,
        'variable': '',
        'imports': {'_': lodash}
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result = new LazyWrapper(this.__wrapped__);
        result.__actions__ = copyArray(this.__actions__);
        result.__dir__ = this.__dir__;
        result.__filtered__ = this.__filtered__;
        result.__iteratees__ = copyArray(this.__iteratees__);
        result.__takeCount__ = this.__takeCount__;
        result.__views__ = copyArray(this.__views__);
        return result;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result = new LazyWrapper(this);
          result.__dir__ = -1;
          result.__filtered__ = true;
        } else {
          result = this.clone();
          result.__dir__ *= -1;
        }
        return result;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(),
            dir = this.__dir__,
            isArr = isArray(array),
            isRight = dir < 0,
            arrLength = isArr ? array.length : 0,
            view = getView(0, arrLength, this.__views__),
            start = view.start,
            end = view.end,
            length = end - start,
            index = isRight ? end : (start - 1),
            iteratees = this.__iteratees__,
            iterLength = iteratees.length,
            resIndex = 0,
            takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result = [];
        outer: while (length-- && resIndex < takeCount) {
          index += dir;
          var iterIndex = -1,
              value = array[index];
          while (++iterIndex < iterLength) {
            var data = iteratees[iterIndex],
                iteratee = data.iteratee,
                type = data.type,
                computed = iteratee(value);
            if (type == LAZY_MAP_FLAG) {
              value = computed;
            } else if (!computed) {
              if (type == LAZY_FILTER_FLAG) {
                continue outer;
              } else {
                break outer;
              }
            }
          }
          result[resIndex++] = value;
        }
        return result;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1,
            length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }
      function hashDelete(key) {
        return this.has(key) && delete this.__data__[key];
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? undefined : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype['delete'] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1,
            length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
      }
      function listCacheDelete(key) {
        var data = this.__data__,
            index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__,
            index = assocIndexOf(data, key);
        return index < 0 ? undefined : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__,
            index = assocIndexOf(data, key);
        if (index < 0) {
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype['delete'] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1,
            length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.__data__ = {
          'hash': new Hash,
          'map': new (Map || ListCache),
          'string': new Hash
        };
      }
      function mapCacheDelete(key) {
        return getMapData(this, key)['delete'](key);
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        getMapData(this, key).set(key, value);
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype['delete'] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values) {
        var index = -1,
            length = values ? values.length : 0;
        this.__data__ = new MapCache;
        while (++index < length) {
          this.add(values[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        this.__data__ = new ListCache(entries);
      }
      function stackClear() {
        this.__data__ = new ListCache;
      }
      function stackDelete(key) {
        return this.__data__['delete'](key);
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var cache = this.__data__;
        if (cache instanceof ListCache) {
          var pairs = cache.__data__;
          if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
            pairs.push([key, value]);
            return this;
          }
          cache = this.__data__ = new MapCache(pairs);
        }
        cache.set(key, value);
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype['delete'] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function assignInDefaults(objValue, srcValue, key, object) {
        if (objValue === undefined || (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
          return srcValue;
        }
        return objValue;
      }
      function assignMergeValue(object, key, value) {
        if ((value !== undefined && !eq(object[key], value)) || (typeof key == 'number' && value === undefined && !(key in object))) {
          object[key] = value;
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || (value === undefined && !(key in object))) {
          object[key] = value;
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee, accumulator) {
        baseEach(collection, function(value, key, collection) {
          setter(accumulator, value, iteratee(value), collection);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAt(object, paths) {
        var index = -1,
            isNil = object == null,
            length = paths.length,
            result = Array(length);
        while (++index < length) {
          result[index] = isNil ? undefined : get(object, paths[index]);
        }
        return result;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
        var result;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== undefined) {
          return result;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value),
              isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
            if (isHostObject(value)) {
              return object ? value : {};
            }
            result = initCloneObject(isFunc ? {} : value);
            if (!isDeep) {
              return copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, baseClone, isDeep);
          }
        }
        stack || (stack = new Stack);
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (!isArr) {
          var props = isFull ? getAllKeys(value) : keys(value);
        }
        arrayEach(props || value, function(subValue, key) {
          if (props) {
            key = subValue;
            subValue = value[key];
          }
          assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
        });
        return result;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        var index = length;
        while (index--) {
          var key = props[index],
              predicate = source[key],
              value = object[key];
          if ((value === undefined && !(key in Object(object))) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseCreate(proto) {
        return isObject(proto) ? objectCreate(proto) : {};
      }
      function baseDelay(func, wait, args) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return setTimeout(function() {
          func.apply(undefined, args);
        }, wait);
      }
      function baseDifference(array, values, iteratee, comparator) {
        var index = -1,
            includes = arrayIncludes,
            isCommon = true,
            length = array.length,
            result = [],
            valuesLength = values.length;
        if (!length) {
          return result;
        }
        if (iteratee) {
          values = arrayMap(values, baseUnary(iteratee));
        }
        if (comparator) {
          includes = arrayIncludesWith;
          isCommon = false;
        } else if (values.length >= LARGE_ARRAY_SIZE) {
          includes = cacheHas;
          isCommon = false;
          values = new SetCache(values);
        }
        outer: while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value) : value;
          value = (comparator || value !== 0) ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
        return result;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result = true;
        baseEach(collection, function(value, index, collection) {
          result = !!predicate(value, index, collection);
          return result;
        });
        return result;
      }
      function baseExtremum(array, iteratee, comparator) {
        var index = -1,
            length = array.length;
        while (++index < length) {
          var value = array[index],
              current = iteratee(value);
          if (current != null && (computed === undefined ? (current === current && !isSymbol(current)) : comparator(current, computed))) {
            var computed = current,
                result = value;
          }
        }
        return result;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : (length + start);
        }
        end = (end === undefined || end > length) ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result = [];
        baseEach(collection, function(value, index, collection) {
          if (predicate(value, index, collection)) {
            result.push(value);
          }
        });
        return result;
      }
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1,
            length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      function baseForOwnRight(object, iteratee) {
        return object && baseForRight(object, iteratee, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path) {
        path = isKey(path, object) ? [path] : castPath(path);
        var index = 0,
            length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return (index && index == length) ? object : undefined;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      function baseGetTag(value) {
        return objectToString.call(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && (hasOwnProperty.call(object, key) || (typeof object == 'object' && key in object && getPrototype(object) === null));
      }
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee, comparator) {
        var includes = comparator ? arrayIncludesWith : arrayIncludes,
            length = arrays[0].length,
            othLength = arrays.length,
            othIndex = othLength,
            caches = Array(othLength),
            maxLength = Infinity,
            result = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee) {
            array = arrayMap(array, baseUnary(iteratee));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120)) ? new SetCache(othIndex && array) : undefined;
        }
        array = arrays[0];
        var index = -1,
            seen = caches[0];
        outer: while (++index < length && result.length < maxLength) {
          var value = array[index],
              computed = iteratee ? iteratee(value) : value;
          value = (comparator || value !== 0) ? value : 0;
          if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
            othIndex = othLength;
            while (--othIndex) {
              var cache = caches[othIndex];
              if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
        return result;
      }
      function baseInverter(object, setter, iteratee, accumulator) {
        baseForOwn(object, function(value, key, object) {
          setter(accumulator, iteratee(value), key, object);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        if (!isKey(path, object)) {
          path = castPath(path);
          object = parent(object, path);
          path = last(path);
        }
        var func = object == null ? object : object[toKey(path)];
        return func == null ? undefined : apply(func, object, args);
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && objectToString.call(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && objectToString.call(value) == dateTag;
      }
      function baseIsEqual(value, other, customizer, bitmask, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
      }
      function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
        var objIsArr = isArray(object),
            othIsArr = isArray(other),
            objTag = arrayTag,
            othTag = arrayTag;
        if (!objIsArr) {
          objTag = getTag(object);
          objTag = objTag == argsTag ? objectTag : objTag;
        }
        if (!othIsArr) {
          othTag = getTag(other);
          othTag = othTag == argsTag ? objectTag : othTag;
        }
        var objIsObj = objTag == objectTag && !isHostObject(object),
            othIsObj = othTag == objectTag && !isHostObject(other),
            isSameTag = objTag == othTag;
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack);
          return (objIsArr || isTypedArray(object)) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
        }
        if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
              othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object,
                othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length,
            length = index,
            noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0],
              objValue = object[key],
              srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack;
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObject(value) && objectToString.call(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
      }
      function baseIteratee(value) {
        if (typeof value == 'function') {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == 'object') {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      var baseKeys = overArg(nativeKeys, Object);
      function baseKeysIn(object) {
        object = object == null ? object : Object(object);
        var result = [];
        for (var key in object) {
          result.push(key);
        }
        return result;
      }
      if (enumerate && !propertyIsEnumerable.call({'valueOf': 1}, 'valueOf')) {
        baseKeysIn = function(object) {
          return iteratorToArray(enumerate(object));
        };
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee) {
        var index = -1,
            result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection) {
          result[++index] = iteratee(value, key, collection);
        });
        return result;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return (objValue === undefined && objValue === srcValue) ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        if (!(isArray(source) || isTypedArray(source))) {
          var props = keysIn(source);
        }
        arrayEach(props || source, function(srcValue, key) {
          if (props) {
            key = srcValue;
            srcValue = source[key];
          }
          if (isObject(srcValue)) {
            stack || (stack = new Stack);
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(object[key], srcValue, (key + ''), object, source, stack) : undefined;
            if (newValue === undefined) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        });
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = object[key],
            srcValue = source[key],
            stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, (key + ''), object, source, stack) : undefined;
        var isCommon = newValue === undefined;
        if (isCommon) {
          newValue = srcValue;
          if (isArray(srcValue) || isTypedArray(srcValue)) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else {
              isCommon = false;
              newValue = baseClone(srcValue, true);
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
              isCommon = false;
              newValue = baseClone(srcValue, true);
            } else {
              newValue = objValue;
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack['delete'](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined;
      }
      function baseOrderBy(collection, iteratees, orders) {
        var index = -1;
        iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
        var result = baseMap(collection, function(value, key, collection) {
          var criteria = arrayMap(iteratees, function(iteratee) {
            return iteratee(value);
          });
          return {
            'criteria': criteria,
            'index': ++index,
            'value': value
          };
        });
        return baseSortBy(result, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, props) {
        object = Object(object);
        return basePickBy(object, props, function(value, key) {
          return key in object;
        });
      }
      function basePickBy(object, props, predicate) {
        var index = -1,
            length = props.length,
            result = {};
        while (++index < length) {
          var key = props[index],
              value = object[key];
          if (predicate(value, key)) {
            result[key] = value;
          }
        }
        return result;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values, iteratee, comparator) {
        var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
            index = -1,
            length = values.length,
            seen = array;
        if (array === values) {
          values = copyArray(values);
        }
        if (iteratee) {
          seen = arrayMap(array, baseUnary(iteratee));
        }
        while (++index < length) {
          var fromIndex = 0,
              value = values[index],
              computed = iteratee ? iteratee(value) : value;
          while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0,
            lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else if (!isKey(index, array)) {
              var path = castPath(index),
                  object = parent(array, path);
              if (object != null) {
                delete object[toKey(last(path))];
              }
            } else {
              delete array[toKey(index)];
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1,
            length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
            result = Array(length);
        while (length--) {
          result[fromRight ? length : ++index] = start;
          start += step;
        }
        return result;
      }
      function baseRepeat(string, n) {
        var result = '';
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result;
        }
        do {
          if (n % 2) {
            result += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result;
      }
      function baseRest(func, start) {
        start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
        return function() {
          var args = arguments,
              index = -1,
              length = nativeMax(args.length - start, 0),
              array = Array(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = array;
          return apply(func, this, otherArgs);
        };
      }
      function baseSet(object, path, value, customizer) {
        path = isKey(path, object) ? [path] : castPath(path);
        var index = -1,
            length = path.length,
            lastIndex = length - 1,
            nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]);
          if (isObject(nested)) {
            var newValue = value;
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined;
              if (newValue === undefined) {
                newValue = objValue == null ? (isIndex(path[index + 1]) ? [] : {}) : objValue;
              }
            }
            assignValue(nested, key, newValue);
          }
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      function baseSlice(array, start, end) {
        var index = -1,
            length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : (length + start);
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : ((end - start) >>> 0);
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array[index + start];
        }
        return result;
      }
      function baseSome(collection, predicate) {
        var result;
        baseEach(collection, function(value, index, collection) {
          result = predicate(value, index, collection);
          return !result;
        });
        return !!result;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0,
            high = array ? array.length : low;
        if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = (low + high) >>> 1,
                computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? (computed <= value) : (computed < value))) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee, retHighest) {
        value = iteratee(value);
        var low = 0,
            high = array ? array.length : 0,
            valIsNaN = value !== value,
            valIsNull = value === null,
            valIsSymbol = isSymbol(value),
            valIsUndefined = value === undefined;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2),
              computed = iteratee(array[mid]),
              othIsDefined = computed !== undefined,
              othIsNull = computed === null,
              othIsReflexive = computed === computed,
              othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? (computed <= value) : (computed < value);
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee) {
        var index = -1,
            length = array.length,
            resIndex = 0,
            result = [];
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result;
      }
      function baseToNumber(value) {
        if (typeof value == 'number') {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == 'string') {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : '';
        }
        var result = (value + '');
        return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
      }
      function baseUniq(array, iteratee, comparator) {
        var index = -1,
            includes = arrayIncludes,
            length = array.length,
            isCommon = true,
            result = [],
            seen = result;
        if (comparator) {
          isCommon = false;
          includes = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set = iteratee ? null : createSet(array);
          if (set) {
            return setToArray(set);
          }
          isCommon = false;
          includes = cacheHas;
          seen = new SetCache;
        } else {
          seen = iteratee ? [] : result;
        }
        outer: while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value) : value;
          value = (comparator || value !== 0) ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
        return result;
      }
      function baseUnset(object, path) {
        path = isKey(path, object) ? [path] : castPath(path);
        object = parent(object, path);
        var key = toKey(last(path));
        return !(object != null && baseHas(object, key)) || delete object[key];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length,
            index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
        return isDrop ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
      }
      function baseWrapperValue(value, actions) {
        var result = value;
        if (result instanceof LazyWrapper) {
          result = result.value();
        }
        return arrayReduce(actions, function(result, action) {
          return action.func.apply(action.thisArg, arrayPush([result], action.args));
        }, result);
      }
      function baseXor(arrays, iteratee, comparator) {
        var index = -1,
            length = arrays.length;
        while (++index < length) {
          var result = result ? arrayPush(baseDifference(result, arrays[index], iteratee, comparator), baseDifference(arrays[index], result, iteratee, comparator)) : arrays[index];
        }
        return (result && result.length) ? baseUniq(result, iteratee, comparator) : [];
      }
      function baseZipObject(props, values, assignFunc) {
        var index = -1,
            length = props.length,
            valsLength = values.length,
            result = {};
        while (++index < length) {
          var value = index < valsLength ? values[index] : undefined;
          assignFunc(result, props[index], value);
        }
        return result;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == 'function' ? value : identity;
      }
      function castPath(value) {
        return isArray(value) ? value : stringToPath(value);
      }
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined ? length : end;
        return (!start && end >= length) ? array : baseSlice(array, start, end);
      }
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var result = new buffer.constructor(buffer.length);
        buffer.copy(result);
        return result;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array(result).set(new Uint8Array(arrayBuffer));
        return result;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneMap(map, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
        return arrayReduce(array, addMapEntry, new map.constructor);
      }
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      function cloneSet(set, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
        return arrayReduce(array, addSetEntry, new set.constructor);
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined,
              valIsNull = value === null,
              valIsReflexive = value === value,
              valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined,
              othIsNull = other === null,
              othIsReflexive = other === other,
              othIsSymbol = isSymbol(other);
          if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) || (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) || (valIsNull && othIsDefined && othIsReflexive) || (!valIsDefined && othIsReflexive) || !valIsReflexive) {
            return 1;
          }
          if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) || (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) || (othIsNull && valIsDefined && valIsReflexive) || (!othIsDefined && valIsReflexive) || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
        while (++index < length) {
          var result = compareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            var order = orders[index];
            return result * (order == 'desc' ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1,
            argsLength = args.length,
            holdersLength = holders.length,
            leftIndex = -1,
            leftLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result = Array(leftLength + rangeLength),
            isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result[leftIndex++] = args[argsIndex++];
        }
        return result;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1,
            argsLength = args.length,
            holdersIndex = -1,
            holdersLength = holders.length,
            rightIndex = -1,
            rightLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result = Array(rangeLength + rightLength),
            isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result;
      }
      function copyArray(source, array) {
        var index = -1,
            length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        object || (object = {});
        var index = -1,
            length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
          assignValue(object, key, newValue === undefined ? source[key] : newValue);
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator,
              accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined,
              guard = length > 2 ? sources[2] : undefined;
          customizer = (assigner.length > 3 && typeof customizer == 'function') ? (length--, customizer) : undefined;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length,
              index = fromRight ? length : -1,
              iterable = Object(collection);
          while ((fromRight ? index-- : ++index < length)) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1,
              iterable = Object(object),
              props = keysFunc(object),
              length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & BIND_FLAG,
            Ctor = createCtor(func);
        function wrapper() {
          var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = reHasComplexSymbol.test(string) ? stringToArray(string) : undefined;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor;
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype),
              result = Ctor.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length,
              args = Array(length),
              index = length,
              placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder) ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
          }
          var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object(collection);
          if (!isArrayLike(collection)) {
            var iteratee = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
        };
      }
      function createFlow(fromRight) {
        return baseRest(function(funcs) {
          funcs = baseFlatten(funcs, 1);
          var length = funcs.length,
              index = length,
              prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func),
                data = funcName == 'wrapper' ? getData(func) : undefined;
            if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments,
                value = args[0];
            if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
              return wrapper.plant(value).value();
            }
            var index = 0,
                result = length ? funcs[index].apply(this, args) : value;
            while (++index < length) {
              result = funcs[index].call(this, result);
            }
            return result;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
        var isAry = bitmask & ARY_FLAG,
            isBind = bitmask & BIND_FLAG,
            isBindKey = bitmask & BIND_KEY_FLAG,
            isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),
            isFlip = bitmask & FLIP_FLAG,
            Ctor = isBindKey ? undefined : createCtor(func);
        function wrapper() {
          var length = arguments.length,
              args = Array(length),
              index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper),
                holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
          }
          var thisBinding = isBind ? thisArg : this,
              fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary < length) {
            args.length = ary;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee) {
          return baseInverter(object, setter, toIteratee(iteratee), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result;
          if (value === undefined && other === undefined) {
            return defaultValue;
          }
          if (value !== undefined) {
            result = value;
          }
          if (other !== undefined) {
            if (result === undefined) {
              return other;
            }
            if (typeof value == 'string' || typeof other == 'string') {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result = operator(value, other);
          }
          return result;
        };
      }
      function createOver(arrayFunc) {
        return baseRest(function(iteratees) {
          iteratees = (iteratees.length == 1 && isArray(iteratees[0])) ? arrayMap(iteratees[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(iteratees, 1), baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee) {
              return apply(iteratee, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined ? ' ' : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return reHasComplexSymbol.test(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & BIND_FLAG,
            Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1,
              argsLength = arguments.length,
              leftIndex = -1,
              leftLength = partials.length,
              args = Array(leftLength + argsLength),
              fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
            end = step = undefined;
          }
          start = toFinite(start);
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == 'string' && typeof other == 'string')) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
        var isCurry = bitmask & CURRY_FLAG,
            newHolders = isCurry ? holders : undefined,
            newHoldersRight = isCurry ? undefined : holders,
            newPartials = isCurry ? partials : undefined,
            newPartialsRight = isCurry ? undefined : partials;
        bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
        bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
        if (!(bitmask & CURRY_BOUND_FLAG)) {
          bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
        }
        var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity];
        var result = wrapFunc.apply(undefined, newData);
        if (isLaziable(func)) {
          setData(result, newData);
        }
        result.placeholder = placeholder;
        return setWrapToString(result, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = nativeMin(toInteger(precision), 292);
          if (precision) {
            var pair = (toString(number) + 'e').split('e'),
                value = func(pair[0] + 'e' + (+pair[1] + precision));
            pair = (toString(value) + 'e').split('e');
            return +(pair[0] + 'e' + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set && (1 / setToArray(new Set([, -0]))[1]) == INFINITY) ? noop : function(values) {
        return new Set(values);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
        var isBindKey = bitmask & BIND_KEY_FLAG;
        if (!isBindKey && typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
          partials = holders = undefined;
        }
        ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
        arity = arity === undefined ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials,
              holdersRight = holders;
          partials = holders = undefined;
        }
        var data = isBindKey ? undefined : getData(func);
        var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] == null ? (isBindKey ? 0 : func.length) : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
          bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == BIND_FLAG) {
          var result = createBind(func, bitmask, thisArg);
        } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
          result = createCurry(func, bitmask, arity);
        } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
          result = createPartial(func, bitmask, thisArg, partials);
        } else {
          result = createHybrid.apply(undefined, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result, newData), func, bitmask);
      }
      function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
            arrLength = array.length,
            othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var stacked = stack.get(array);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var index = -1,
            result = true,
            seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index],
              othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue, othIndex) {
              if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                return seen.add(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
            result = false;
            break;
          }
        }
        stack['delete'](array);
        stack['delete'](other);
        return result;
      }
      function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
        switch (tag) {
          case dataViewTag:
            if ((object.byteLength != other.byteLength) || (object.byteOffset != other.byteOffset)) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if ((object.byteLength != other.byteLength) || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == (other + '');
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= UNORDERED_COMPARE_FLAG;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
            stack['delete'](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
            objProps = keys(object),
            objLength = objProps.length,
            othProps = keys(other),
            othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : baseHas(other, key))) {
            return false;
          }
        }
        var stacked = stack.get(object);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key],
              othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack)) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == 'constructor');
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor,
              othCtor = other.constructor;
          if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack['delete'](object);
        stack['delete'](other);
        return result;
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result = (func.name + ''),
            array = realNames[result],
            length = hasOwnProperty.call(realNames, result) ? array.length : 0;
        while (length--) {
          var data = array[length],
              otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result;
      }
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result = lodash.iteratee || iteratee;
        result = result === iteratee ? baseIteratee : result;
        return arguments.length ? result(arguments[0], arguments[1]) : result;
      }
      var getLength = baseProperty('length');
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
      }
      function getMatchData(object) {
        var result = keys(object),
            length = result.length;
        while (length--) {
          var key = result[length],
              value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined;
      }
      var getPrototype = overArg(nativeGetPrototype, Object);
      var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }
        return result;
      };
      var getTag = baseGetTag;
      if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) || (Map && getTag(new Map) != mapTag) || (Promise && getTag(Promise.resolve()) != promiseTag) || (Set && getTag(new Set) != setTag) || (WeakMap && getTag(new WeakMap) != weakMapTag)) {
        getTag = function(value) {
          var result = objectToString.call(value),
              Ctor = result == objectTag ? value.constructor : undefined,
              ctorString = Ctor ? toSource(Ctor) : undefined;
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      function getView(start, end, transforms) {
        var index = -1,
            length = transforms.length;
        while (++index < length) {
          var data = transforms[index],
              size = data.size;
          switch (data.type) {
            case 'drop':
              start += size;
              break;
            case 'dropRight':
              end -= size;
              break;
            case 'take':
              end = nativeMin(end, start + size);
              break;
            case 'takeRight':
              start = nativeMax(start, end - size);
              break;
          }
        }
        return {
          'start': start,
          'end': end
        };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = isKey(path, object) ? [path] : castPath(path);
        var result,
            index = -1,
            length = path.length;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result) {
          return result;
        }
        var length = object ? object.length : 0;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isString(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length,
            result = array.constructor(length);
        if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      function initCloneObject(object) {
        return (typeof object.constructor == 'function' && !isPrototype(object)) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, cloneFunc, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return cloneMap(object, isDeep, cloneFunc);
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return cloneSet(object, isDeep, cloneFunc);
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function indexKeys(object) {
        var length = object ? object.length : undefined;
        if (isLength(length) && (isArray(object) || isString(object) || isArguments(object))) {
          return baseTimes(length, String);
        }
        return null;
      }
      function insertWrapDetails(source, details) {
        var length = details.length,
            lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
        details = details.join(length > 2 ? ', ' : ' ');
        return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || (object != null && value in Object(object));
      }
      function isKeyable(value) {
        var type = typeof value;
        return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean') ? (value !== '__proto__') : (value === null);
      }
      function isLaziable(func) {
        var funcName = getFuncName(func),
            other = lodash[funcName];
        if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && (maskSrcKey in func);
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor,
            proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined || (key in Object(object)));
        };
      }
      function mergeData(data, source) {
        var bitmask = data[1],
            srcBitmask = source[1],
            newBitmask = bitmask | srcBitmask,
            isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);
        var isCombo = ((srcBitmask == ARY_FLAG) && (bitmask == CURRY_FLAG)) || ((srcBitmask == ARY_FLAG) && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) || ((srcBitmask == (ARY_FLAG | REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG));
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function mergeDefaults(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);
          stack['delete'](srcValue);
        }
        return objValue;
      }
      function parent(object, path) {
        return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length,
            length = nativeMin(indexes.length, arrLength),
            oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
        }
        return array;
      }
      var setData = (function() {
        var count = 0,
            lastCalled = 0;
        return function(key, value) {
          var stamp = now(),
              remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return key;
            }
          } else {
            count = 0;
          }
          return baseSetData(key, value);
        };
      }());
      var setWrapToString = !defineProperty ? identity : function(wrapper, reference, bitmask) {
        var source = (reference + '');
        return defineProperty(wrapper, 'toString', {
          'configurable': true,
          'enumerable': false,
          'value': constant(insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)))
        });
      };
      var stringToPath = memoize(function(string) {
        string = toString(string);
        var result = [];
        if (reLeadingDot.test(string)) {
          result.push('');
        }
        string.replace(rePropName, function(match, number, quote, string) {
          result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
        });
        return result;
      });
      function toKey(value) {
        if (typeof value == 'string' || isSymbol(value)) {
          return value;
        }
        var result = (value + '');
        return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {}
          try {
            return (func + '');
          } catch (e) {}
        }
        return '';
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = '_.' + pair[0];
          if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result.__actions__ = copyArray(wrapper.__actions__);
        result.__index__ = wrapper.__index__;
        result.__values__ = wrapper.__values__;
        return result;
      }
      function chunk(array, size, guard) {
        if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
          size = 1;
        } else {
          size = nativeMax(toInteger(size), 0);
        }
        var length = array ? array.length : 0;
        if (!length || size < 1) {
          return [];
        }
        var index = 0,
            resIndex = 0,
            result = Array(nativeCeil(length / size));
        while (index < length) {
          result[resIndex++] = baseSlice(array, index, (index += size));
        }
        return result;
      }
      function compact(array) {
        var index = -1,
            length = array ? array.length : 0,
            resIndex = 0,
            result = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function concat() {
        var length = arguments.length,
            args = Array(length ? length - 1 : 0),
            array = arguments[0],
            index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return length ? arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1)) : [];
      }
      var difference = baseRest(function(array, values) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values) {
        var iteratee = last(values);
        if (isArrayLikeObject(iteratee)) {
          iteratee = undefined;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values) {
        var comparator = last(values);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        n = (guard || n === undefined) ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        n = (guard || n === undefined) ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array ? array.length : 0;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array ? array.length : 0;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array ? array.length : 0;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array ? array.length : 0;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        depth = depth === undefined ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1,
            length = pairs ? pairs.length : 0,
            result = {};
        while (++index < length) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }
        return result;
      }
      function head(array) {
        return (array && array.length) ? array[0] : undefined;
      }
      function indexOf(array, value, fromIndex) {
        var length = array ? array.length : 0;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        return dropRight(array, 1);
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return (mapped.length && mapped[0] === arrays[0]) ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee === last(mapped)) {
          iteratee = undefined;
        } else {
          mapped.pop();
        }
        return (mapped.length && mapped[0] === arrays[0]) ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject);
        if (comparator === last(mapped)) {
          comparator = undefined;
        } else {
          mapped.pop();
        }
        return (mapped.length && mapped[0] === arrays[0]) ? baseIntersection(mapped, undefined, comparator) : [];
      });
      function join(array, separator) {
        return array ? nativeJoin.call(array, separator) : '';
      }
      function last(array) {
        var length = array ? array.length : 0;
        return length ? array[length - 1] : undefined;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array ? array.length : 0;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined) {
          index = toInteger(fromIndex);
          index = (index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)) + 1;
        }
        if (value !== value) {
          return baseFindIndex(array, baseIsNaN, index - 1, true);
        }
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function nth(array, n) {
        return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values) {
        return (array && array.length && values && values.length) ? basePullAll(array, values) : array;
      }
      function pullAllBy(array, values, iteratee) {
        return (array && array.length && values && values.length) ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
      }
      function pullAllWith(array, values, comparator) {
        return (array && array.length && values && values.length) ? basePullAll(array, values, undefined, comparator) : array;
      }
      var pullAt = baseRest(function(array, indexes) {
        indexes = baseFlatten(indexes, 1);
        var length = array ? array.length : 0,
            result = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result;
      });
      function remove(array, predicate) {
        var result = [];
        if (!(array && array.length)) {
          return result;
        }
        var index = -1,
            indexes = [],
            length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result;
      }
      function reverse(array) {
        return array ? nativeReverse.call(array) : array;
      }
      function slice(array, start, end) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array ? array.length : 0;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array ? array.length : 0;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return (array && array.length) ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee) {
        return (array && array.length) ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
      }
      function tail(array) {
        return drop(array, 1);
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = (guard || n === undefined) ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        n = (guard || n === undefined) ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee = last(arrays);
        if (isArrayLikeObject(iteratee)) {
          iteratee = undefined;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
      });
      function uniq(array) {
        return (array && array.length) ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee) {
        return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
      }
      function uniqWith(array, comparator) {
        return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee) {
        if (!(array && array.length)) {
          return [];
        }
        var result = unzip(array);
        if (iteratee == null) {
          return result;
        }
        return arrayMap(result, function(group) {
          return apply(iteratee, undefined, group);
        });
      }
      var without = baseRest(function(array, values) {
        return isArrayLikeObject(array) ? baseDifference(array, values) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee = last(arrays);
        if (isArrayLikeObject(iteratee)) {
          iteratee = undefined;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values) {
        return baseZipObject(props || [], values || [], assignValue);
      }
      function zipObjectDeep(props, values) {
        return baseZipObject(props || [], values || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length,
            iteratee = length > 1 ? arrays[length - 1] : undefined;
        iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
        return unzipWith(arrays, iteratee);
      });
      function chain(value) {
        var result = lodash(value);
        result.__chain__ = true;
        return result;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = baseRest(function(paths) {
        paths = baseFlatten(paths, 1);
        var length = paths.length,
            start = length ? paths[0] : 0,
            value = this.__wrapped__,
            interceptor = function(object) {
              return baseAt(object, paths);
            };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          'func': thru,
          'args': [interceptor],
          'thisArg': undefined
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length,
            value = done ? undefined : this.__values__[this.__index__++];
        return {
          'done': done,
          'value': value
        };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result,
            parent = this;
        while (parent instanceof baseLodash) {
          var clone = wrapperClone(parent);
          clone.__index__ = 0;
          clone.__values__ = undefined;
          if (result) {
            previous.__wrapped__ = clone;
          } else {
            result = clone;
          }
          var previous = clone;
          parent = parent.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            'func': thru,
            'args': [reverse],
            'thisArg': undefined
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result, value, key) {
        hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee) {
        return baseFlatten(map(collection, iteratee), 1);
      }
      function flatMapDeep(collection, iteratee) {
        return baseFlatten(map(collection, iteratee), INFINITY);
      }
      function flatMapDepth(collection, iteratee, depth) {
        depth = depth === undefined ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee), depth);
      }
      function forEach(collection, iteratee) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee, 3));
      }
      function forEachRight(collection, iteratee) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee, 3));
      }
      var groupBy = createAggregator(function(result, value, key) {
        if (hasOwnProperty.call(result, key)) {
          result[key].push(value);
        } else {
          result[key] = [value];
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1) : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1,
            isFunc = typeof path == 'function',
            isProp = isKey(path),
            result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value) {
          var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
          result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);
        });
        return result;
      });
      var keyBy = createAggregator(function(result, value, key) {
        result[key] = value;
      });
      function map(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result, value, key) {
        result[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce,
            initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce,
            initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var array = isArrayLike(collection) ? collection : values(collection),
            length = array.length;
        return length > 0 ? array[baseRandom(0, length - 1)] : undefined;
      }
      function sampleSize(collection, n, guard) {
        var index = -1,
            result = toArray(collection),
            length = result.length,
            lastIndex = length - 1;
        if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
          n = 1;
        } else {
          n = baseClamp(toInteger(n), 0, length);
        }
        while (++index < n) {
          var rand = baseRandom(index, lastIndex),
              value = result[rand];
          result[rand] = result[index];
          result[index] = value;
        }
        result.length = n;
        return result;
      }
      function shuffle(collection) {
        return sampleSize(collection, MAX_ARRAY_LENGTH);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          var result = collection.length;
          return (result && isString(collection)) ? stringSize(collection) : result;
        }
        if (isObjectLike(collection)) {
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
        }
        return keys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      function now() {
        return Date.now();
      }
      function after(n, func) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined : n;
        n = (func && n == null) ? func.length : n;
        return createWrap(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
      }
      function before(n, func) {
        var result;
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined;
          }
          return result;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = BIND_FLAG | BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined : arity;
        var result = createWrap(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curry.placeholder;
        return result;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined : arity;
        var result = createWrap(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curryRight.placeholder;
        return result;
      }
      function debounce(func, wait, options) {
        var lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = 'maxWait' in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs,
              thisArg = lastThis;
          lastArgs = lastThis = undefined;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              result = wait - timeSinceLastCall;
          return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;
          return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined;
          return result;
        }
        function cancel() {
          if (timerId !== undefined) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined;
        }
        function flush() {
          return timerId === undefined ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(),
              isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result);
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache);
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = baseRest(function(func, transforms) {
        transforms = (transforms.length == 1 && isArray(transforms[0])) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1,
              length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, PARTIAL_FLAG, undefined, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);
      });
      var rearg = baseRest(function(func, indexes) {
        return createWrap(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes, 1));
      });
      function rest(func, start) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        start = start === undefined ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start],
              otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true,
            trailing = true;
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = 'leading' in options ? !!options.leading : leading;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          'leading': leading,
          'maxWait': wait,
          'trailing': trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        wrapper = wrapper == null ? identity : wrapper;
        return partial(wrapper, value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, false, true);
      }
      function cloneWith(value, customizer) {
        return baseClone(value, false, true, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, true, true);
      }
      function cloneDeepWith(value, customizer) {
        return baseClone(value, true, true, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || (value !== value && other !== other);
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      function isArguments(value) {
        return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
      }
      var isArray = Array.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(getLength(value)) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || (isObjectLike(value) && objectToString.call(value) == boolTag);
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (isArrayLike(value) && (isArray(value) || isString(value) || isFunction(value.splice) || isArguments(value) || isBuffer(value))) {
          return !value.length;
        }
        if (isObjectLike(value)) {
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return !(nonEnumShadows && keys(value).length);
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined;
        var result = customizer ? customizer(value, other) : undefined;
        return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        return (objectToString.call(value) == errorTag) || (typeof value.message == 'string' && typeof value.name == 'string');
      }
      function isFinite(value) {
        return typeof value == 'number' && nativeIsFinite(value);
      }
      function isFunction(value) {
        var tag = isObject(value) ? objectToString.call(value) : '';
        return tag == funcTag || tag == genTag;
      }
      function isInteger(value) {
        return typeof value == 'number' && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == 'object' || type == 'function');
      }
      function isObjectLike(value) {
        return !!value && typeof value == 'object';
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error('This method is not supported with core-js. Try https://github.com/es-shims.');
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == 'number' || (isObjectLike(value) && objectToString.call(value) == numberTag);
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
        return (typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == 'string' || (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
      }
      function isSymbol(value) {
        return typeof value == 'symbol' || (isObjectLike(value) && objectToString.call(value) == symbolTag);
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && objectToString.call(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (iteratorSymbol && value[iteratorSymbol]) {
          return iteratorToArray(value[iteratorSymbol]());
        }
        var tag = getTag(value),
            func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = (value < 0 ? -1 : 1);
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result = toFinite(value),
            remainder = result % 1;
        return result === result ? (remainder ? result - remainder : result) : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == 'number') {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = isFunction(value.valueOf) ? value.valueOf() : value;
          value = isObject(other) ? (other + '') : other;
        }
        if (typeof value != 'string') {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, '');
        var isBinary = reIsBinary.test(value);
        return (isBinary || reIsOctal.test(value)) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : (reIsBadHex.test(value) ? NAN : +value);
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      }
      function toString(value) {
        return value == null ? '' : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keysIn(source), object);
          return;
        }
        for (var key in source) {
          assignValue(object, key, source[key]);
        }
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = baseRest(function(object, paths) {
        return baseAt(object, baseFlatten(paths, 1));
      });
      function create(prototype, properties) {
        var result = baseCreate(prototype);
        return properties ? baseAssign(result, properties) : result;
      }
      var defaults = baseRest(function(args) {
        args.push(undefined, assignInDefaults);
        return apply(assignInWith, undefined, args);
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined, mergeDefaults);
        return apply(mergeWith, undefined, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee) {
        return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
      }
      function forInRight(object, iteratee) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
      }
      function forOwn(object, iteratee) {
        return object && baseForOwn(object, getIteratee(iteratee, 3));
      }
      function forOwnRight(object, iteratee) {
        return object && baseForOwnRight(object, getIteratee(iteratee, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result = object == null ? undefined : baseGet(object, path);
        return result === undefined ? defaultValue : result;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result, value, key) {
        result[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result, value, key) {
        if (hasOwnProperty.call(result, value)) {
          result[value].push(key);
        } else {
          result[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        var isProto = isPrototype(object);
        if (!(isProto || isArrayLike(object))) {
          return baseKeys(object);
        }
        var indexes = indexKeys(object),
            skipIndexes = !!indexes,
            result = indexes || [],
            length = result.length;
        for (var key in object) {
          if (baseHas(object, key) && !(skipIndexes && (key == 'length' || isIndex(key, length))) && !(isProto && key == 'constructor')) {
            result.push(key);
          }
        }
        return result;
      }
      function keysIn(object) {
        var index = -1,
            isProto = isPrototype(object),
            props = baseKeysIn(object),
            propsLength = props.length,
            indexes = indexKeys(object),
            skipIndexes = !!indexes,
            result = indexes || [],
            length = result.length;
        while (++index < propsLength) {
          var key = props[index];
          if (!(skipIndexes && (key == 'length' || isIndex(key, length))) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function mapKeys(object, iteratee) {
        var result = {};
        iteratee = getIteratee(iteratee, 3);
        baseForOwn(object, function(value, key, object) {
          result[iteratee(value, key, object)] = value;
        });
        return result;
      }
      function mapValues(object, iteratee) {
        var result = {};
        iteratee = getIteratee(iteratee, 3);
        baseForOwn(object, function(value, key, object) {
          result[key] = iteratee(value, key, object);
        });
        return result;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = baseRest(function(object, props) {
        if (object == null) {
          return {};
        }
        props = arrayMap(baseFlatten(props, 1), toKey);
        return basePick(object, baseDifference(getAllKeysIn(object), props));
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = baseRest(function(object, props) {
        return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
      });
      function pickBy(object, predicate) {
        return object == null ? {} : basePickBy(object, getAllKeysIn(object), getIteratee(predicate));
      }
      function result(object, path, defaultValue) {
        path = isKey(path, object) ? [path] : castPath(path);
        var index = -1,
            length = path.length;
        if (!length) {
          object = undefined;
          length = 1;
        }
        while (++index < length) {
          var value = object == null ? undefined : object[toKey(path[index])];
          if (value === undefined) {
            index = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee, accumulator) {
        var isArr = isArray(object) || isTypedArray(object);
        iteratee = getIteratee(iteratee, 4);
        if (accumulator == null) {
          if (isArr || isObject(object)) {
            var Ctor = object.constructor;
            if (isArr) {
              accumulator = isArray(object) ? new Ctor : [];
            } else {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            }
          } else {
            accumulator = {};
          }
        }
        (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
          return iteratee(accumulator, value, index, object);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object ? baseValues(object, keys(object)) : [];
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined) {
          upper = lower;
          lower = undefined;
        }
        if (upper !== undefined) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined;
        }
        if (floating === undefined) {
          if (typeof upper == 'boolean') {
            floating = upper;
            upper = undefined;
          } else if (typeof lower == 'boolean') {
            floating = lower;
            lower = undefined;
          }
        }
        if (lower === undefined && upper === undefined) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result, word, index) {
        word = word.toLowerCase();
        return result + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
      }
      function endsWith(string, target, position) {
        string = toString(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape(string) {
        string = toString(string);
        return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString(string);
        return (string && reHasRegExpChar.test(string)) ? string.replace(reRegExpChar, '\\$&') : string;
      }
      var kebabCase = createCompounder(function(result, word, index) {
        return result + (index ? '-' : '') + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result, word, index) {
        return result + (index ? ' ' : '') + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst('toLowerCase');
      function pad(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return (createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars));
      }
      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return (length && strLength < length) ? (string + createPadding(length - strLength, chars)) : string;
      }
      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return (length && strLength < length) ? (createPadding(length - strLength, chars) + string) : string;
      }
      function parseInt(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        string = toString(string).replace(reTrim, '');
        return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
      }
      function repeat(string, n, guard) {
        if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string), n);
      }
      function replace() {
        var args = arguments,
            string = toString(args[0]);
        return args.length < 3 ? string : nativeReplace.call(string, args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result, word, index) {
        return result + (index ? '_' : '') + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined;
        }
        limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString(string);
        if (string && (typeof separator == 'string' || (separator != null && !isRegExp(separator)))) {
          separator = baseToString(separator);
          if (separator == '' && reHasComplexSymbol.test(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return nativeSplit.call(string, separator, limit);
      }
      var startCase = createCompounder(function(result, word, index) {
        return result + (index ? ' ' : '') + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString(string);
        position = baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined;
        }
        string = toString(string);
        options = assignInWith({}, options, settings, assignInDefaults);
        var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
            importsKeys = keys(imports),
            importsValues = baseValues(imports, importsKeys);
        var isEscaping,
            isEvaluating,
            index = 0,
            interpolate = options.interpolate || reNoMatch,
            source = "__p += '";
        var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
        var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = options.variable;
        if (!variable) {
          source = 'with (obj) {\n' + source + '\n}\n';
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
        source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
        var result = attempt(function() {
          return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
        });
        result.source = source;
        if (isError(result)) {
          throw result;
        }
        return result;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined)) {
          return string.replace(reTrim, '');
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string),
            chrSymbols = stringToArray(chars),
            start = charsStartIndex(strSymbols, chrSymbols),
            end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join('');
      }
      function trimEnd(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined)) {
          return string.replace(reTrimEnd, '');
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string),
            end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join('');
      }
      function trimStart(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined)) {
          return string.replace(reTrimStart, '');
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string),
            start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join('');
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH,
            omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? toInteger(options.length) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);
        var strLength = string.length;
        if (reHasComplexSymbol.test(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);
        if (separator === undefined) {
          return result + omission;
        }
        if (strSymbols) {
          end += (result.length - end);
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match,
                substring = result;
            if (!separator.global) {
              separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
            }
            separator.lastIndex = 0;
            while ((match = separator.exec(substring))) {
              var newEnd = match.index;
            }
            result = result.slice(0, newEnd === undefined ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result.lastIndexOf(separator);
          if (index > -1) {
            result = result.slice(0, index);
          }
        }
        return result + omission;
      }
      function unescape(string) {
        string = toString(string);
        return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result, word, index) {
        return result + (index ? ' ' : '') + word.toUpperCase();
      });
      var upperFirst = createCaseFirst('toUpperCase');
      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined : pattern;
        if (pattern === undefined) {
          pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined, args);
        } catch (e) {
          return isError(e) ? e : new Error(e);
        }
      });
      var bindAll = baseRest(function(object, methodNames) {
        arrayEach(baseFlatten(methodNames, 1), function(key) {
          key = toKey(key);
          object[key] = bind(object[key], object);
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs ? pairs.length : 0,
            toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, true));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return (value == null || value !== value) ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));
      }
      function matches(source) {
        return baseMatches(baseClone(source, true));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, true));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source),
            methodNames = baseFunctions(source, props);
        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
            isFunc = isFunction(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = copyArray(this.__actions__);
                actions.push({
                  'func': func,
                  'args': arguments,
                  'thisArg': object
                });
                result.__chain__ = chainAll;
                return result;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {}
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return '';
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH,
            length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee = getIteratee(iteratee);
        n -= MAX_ARRAY_LENGTH;
        var result = baseTimes(length, iteratee);
        while (++index < n) {
          iteratee(index);
        }
        return result;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(value));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound('ceil');
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound('floor');
      function max(array) {
        return (array && array.length) ? baseExtremum(array, identity, baseGt) : undefined;
      }
      function maxBy(array, iteratee) {
        return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee) {
        return baseMean(array, getIteratee(iteratee, 2));
      }
      function min(array) {
        return (array && array.length) ? baseExtremum(array, identity, baseLt) : undefined;
      }
      function minBy(array, iteratee) {
        return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound('round');
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return (array && array.length) ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee) {
        return (array && array.length) ? baseSum(array, getIteratee(iteratee, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, (function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }()), {'chain': false});
      lodash.VERSION = VERSION;
      arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(['drop', 'take'], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          var filtered = this.__filtered__;
          if (filtered && !index) {
            return new LazyWrapper(this);
          }
          n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
          var result = this.clone();
          if (filtered) {
            result.__takeCount__ = nativeMin(n, result.__takeCount__);
          } else {
            result.__views__.push({
              'size': nativeMin(n, MAX_ARRAY_LENGTH),
              'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
            });
          }
          return result;
        };
        LazyWrapper.prototype[methodName + 'Right'] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
        var type = index + 1,
            isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee) {
          var result = this.clone();
          result.__iteratees__.push({
            'iteratee': getIteratee(iteratee, 3),
            'type': type
          });
          result.__filtered__ = result.__filtered__ || isFilter;
          return result;
        };
      });
      arrayEach(['head', 'last'], function(methodName, index) {
        var takeName = 'take' + (index ? 'Right' : '');
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(['initial', 'tail'], function(methodName, index) {
        var dropName = 'drop' + (index ? '' : 'Right');
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == 'function') {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result = this;
        if (result.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result);
        }
        if (start < 0) {
          result = result.takeRight(-start);
        } else if (start) {
          result = result.drop(start);
        }
        if (end !== undefined) {
          end = toInteger(end);
          result = end < 0 ? result.dropRight(-end) : result.take(end - start);
        }
        return result;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
            isTaker = /^(?:head|last)$/.test(methodName),
            lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
            retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__,
              args = isTaker ? [1] : arguments,
              isLazy = value instanceof LazyWrapper,
              iteratee = args[0],
              useLazy = isLazy || isArray(value);
          var interceptor = function(value) {
            var result = lodashFunc.apply(lodash, arrayPush([value], args));
            return (isTaker && chainAll) ? result[0] : result;
          };
          if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__,
              isHybrid = !!this.__actions__.length,
              isUnwrapped = retUnwrapped && !chainAll,
              onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result = func.apply(value, args);
            result.__actions__.push({
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            });
            return new LodashWrapper(result, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result = this.thru(interceptor);
          return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
        };
      });
      arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
        var func = arrayProto[methodName],
            chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
            retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value) {
            return func.apply(isArray(value) ? value : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = (lodashFunc.name + ''),
              names = realNames[key] || (realNames[key] = []);
          names.push({
            'name': methodName,
            'func': lodashFunc
          });
        }
      });
      realNames[createHybrid(undefined, BIND_KEY_FLAG).name] = [{
        'name': 'wrapper',
        'func': undefined
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (iteratorSymbol) {
        lodash.prototype[iteratorSymbol] = wrapperToIterator;
      }
      return lodash;
    }
    var _ = runInContext();
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      root._ = _;
      define(function() {
        return _;
      });
    } else if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }.call(this));
  return module.exports;
});

System.registerDynamic("npm:rc-util@3.2.1/lib/createChainedFunction.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function createChainedFunction() {
    var args = arguments;
    return function chainedFunction() {
      for (var i = 0; i < args.length; i++) {
        if (args[i] && args[i].apply) {
          args[i].apply(this, arguments);
        }
      }
    };
  }
  module.exports = createChainedFunction;
  return module.exports;
});

System.registerDynamic("npm:rc-util@3.2.1/lib/Dom/contains.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function contains(root, n) {
    var node = n;
    while (node) {
      if (node === root) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  };
  return module.exports;
});

System.registerDynamic("npm:dom-align@1.4.0/lib/getOffsetParent.js", ["./utils"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _utils = $__require('./utils');
  var _utils2 = _interopRequireDefault(_utils);
  function getOffsetParent(element) {
    var doc = element.ownerDocument;
    var body = doc.body;
    var parent = undefined;
    var positionStyle = _utils2['default'].css(element, 'position');
    var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';
    if (!skipStatic) {
      return element.nodeName.toLowerCase() === 'html' ? null : element.parentNode;
    }
    for (parent = element.parentNode; parent && parent !== body; parent = parent.parentNode) {
      positionStyle = _utils2['default'].css(parent, 'position');
      if (positionStyle !== 'static') {
        return parent;
      }
    }
    return null;
  }
  exports['default'] = getOffsetParent;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:dom-align@1.4.0/lib/getVisibleRectForElement.js", ["./utils", "./getOffsetParent"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _utils = $__require('./utils');
  var _utils2 = _interopRequireDefault(_utils);
  var _getOffsetParent = $__require('./getOffsetParent');
  var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);
  function getVisibleRectForElement(element) {
    var visibleRect = {
      left: 0,
      right: Infinity,
      top: 0,
      bottom: Infinity
    };
    var el = (0, _getOffsetParent2['default'])(element);
    var scrollX = undefined;
    var scrollY = undefined;
    var winSize = undefined;
    var doc = element.ownerDocument;
    var win = doc.defaultView || doc.parentWindow;
    var body = doc.body;
    var documentElement = doc.documentElement;
    while (el) {
      if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) && el !== body && el !== documentElement && _utils2['default'].css(el, 'overflow') !== 'visible') {
        var pos = _utils2['default'].offset(el);
        pos.left += el.clientLeft;
        pos.top += el.clientTop;
        visibleRect.top = Math.max(visibleRect.top, pos.top);
        visibleRect.right = Math.min(visibleRect.right, pos.left + el.clientWidth);
        visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
        visibleRect.left = Math.max(visibleRect.left, pos.left);
      } else if (el === body || el === documentElement) {
        break;
      }
      el = (0, _getOffsetParent2['default'])(el);
    }
    scrollX = _utils2['default'].getWindowScrollLeft(win);
    scrollY = _utils2['default'].getWindowScrollTop(win);
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    winSize = {
      width: _utils2['default'].viewportWidth(win),
      height: _utils2['default'].viewportHeight(win)
    };
    visibleRect.right = Math.min(visibleRect.right, scrollX + winSize.width);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + winSize.height);
    return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
  }
  exports['default'] = getVisibleRectForElement;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:dom-align@1.4.0/lib/adjustForViewport.js", ["./utils"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _utils = $__require('./utils');
  var _utils2 = _interopRequireDefault(_utils);
  function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
    var pos = _utils2['default'].clone(elFuturePos);
    var size = {
      width: elRegion.width,
      height: elRegion.height
    };
    if (overflow.adjustX && pos.left < visibleRect.left) {
      pos.left = visibleRect.left;
    }
    if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
      size.width -= pos.left + size.width - visibleRect.right;
    }
    if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
      pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
    }
    if (overflow.adjustY && pos.top < visibleRect.top) {
      pos.top = visibleRect.top;
    }
    if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
      size.height -= pos.top + size.height - visibleRect.bottom;
    }
    if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
      pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
    }
    return _utils2['default'].mix(pos, size);
  }
  exports['default'] = adjustForViewport;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:dom-align@1.4.0/lib/utils.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
  var getComputedStyleX = undefined;
  function css(el, name, v) {
    var value = v;
    if (typeof name === 'object') {
      for (var i in name) {
        if (name.hasOwnProperty(i)) {
          css(el, i, name[i]);
        }
      }
      return undefined;
    }
    if (typeof value !== 'undefined') {
      if (typeof value === 'number') {
        value = value + 'px';
      }
      el.style[name] = value;
      return undefined;
    }
    return getComputedStyleX(el, name);
  }
  function getClientPosition(elem) {
    var box = undefined;
    var x = undefined;
    var y = undefined;
    var doc = elem.ownerDocument;
    var body = doc.body;
    var docElem = doc && doc.documentElement;
    box = elem.getBoundingClientRect();
    x = box.left;
    y = box.top;
    x -= docElem.clientLeft || body.clientLeft || 0;
    y -= docElem.clientTop || body.clientTop || 0;
    return {
      left: x,
      top: y
    };
  }
  function getScroll(w, top) {
    var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
    var method = 'scroll' + (top ? 'Top' : 'Left');
    if (typeof ret !== 'number') {
      var d = w.document;
      ret = d.documentElement[method];
      if (typeof ret !== 'number') {
        ret = d.body[method];
      }
    }
    return ret;
  }
  function getScrollLeft(w) {
    return getScroll(w);
  }
  function getScrollTop(w) {
    return getScroll(w, true);
  }
  function getOffset(el) {
    var pos = getClientPosition(el);
    var doc = el.ownerDocument;
    var w = doc.defaultView || doc.parentWindow;
    pos.left += getScrollLeft(w);
    pos.top += getScrollTop(w);
    return pos;
  }
  function _getComputedStyle(elem, name, cs) {
    var computedStyle = cs;
    var val = '';
    var d = elem.ownerDocument;
    computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null);
    if (computedStyle) {
      val = computedStyle.getPropertyValue(name) || computedStyle[name];
    }
    return val;
  }
  var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');
  var RE_POS = /^(top|right|bottom|left)$/;
  var CURRENT_STYLE = 'currentStyle';
  var RUNTIME_STYLE = 'runtimeStyle';
  var LEFT = 'left';
  var PX = 'px';
  function _getComputedStyleIE(elem, name) {
    var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];
    if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
      var style = elem.style;
      var left = style[LEFT];
      var rsLeft = elem[RUNTIME_STYLE][LEFT];
      elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];
      style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
      ret = style.pixelLeft + PX;
      style[LEFT] = left;
      elem[RUNTIME_STYLE][LEFT] = rsLeft;
    }
    return ret === '' ? 'auto' : ret;
  }
  if (typeof window !== 'undefined') {
    getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
  }
  function getOffsetDirection(dir, option) {
    if (dir === 'left') {
      return option.useCssRight ? 'right' : dir;
    }
    return option.useCssBottom ? 'bottom' : dir;
  }
  function oppositeOffsetDirection(dir) {
    if (dir === 'left') {
      return 'right';
    } else if (dir === 'right') {
      return 'left';
    } else if (dir === 'top') {
      return 'bottom';
    } else if (dir === 'bottom') {
      return 'top';
    }
  }
  function setOffset(elem, offset, option) {
    if (css(elem, 'position') === 'static') {
      elem.style.position = 'relative';
    }
    var presetH = -999;
    var presetV = -999;
    var horizontalProperty = getOffsetDirection('left', option);
    var verticalProperty = getOffsetDirection('top', option);
    var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
    var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
    if (horizontalProperty !== 'left') {
      presetH = 999;
    }
    if (verticalProperty !== 'top') {
      presetV = 999;
    }
    if ('left' in offset) {
      elem.style[oppositeHorizontalProperty] = '';
      elem.style[horizontalProperty] = presetH + 'px';
    }
    if ('top' in offset) {
      elem.style[oppositeVerticalProperty] = '';
      elem.style[verticalProperty] = presetV + 'px';
    }
    var old = getOffset(elem);
    var ret = {};
    var key = undefined;
    for (key in offset) {
      if (offset.hasOwnProperty(key)) {
        var dir = getOffsetDirection(key, option);
        var preset = key === 'left' ? presetH : presetV;
        if (dir === key) {
          ret[dir] = preset + offset[key] - old[key];
        } else {
          ret[dir] = preset + old[key] - offset[key];
        }
      }
    }
    css(elem, ret);
  }
  function each(arr, fn) {
    for (var i = 0; i < arr.length; i++) {
      fn(arr[i]);
    }
  }
  function isBorderBoxFn(elem) {
    return getComputedStyleX(elem, 'boxSizing') === 'border-box';
  }
  var BOX_MODELS = ['margin', 'border', 'padding'];
  var CONTENT_INDEX = -1;
  var PADDING_INDEX = 2;
  var BORDER_INDEX = 1;
  var MARGIN_INDEX = 0;
  function swap(elem, options, callback) {
    var old = {};
    var style = elem.style;
    var name = undefined;
    for (name in options) {
      if (options.hasOwnProperty(name)) {
        old[name] = style[name];
        style[name] = options[name];
      }
    }
    callback.call(elem);
    for (name in options) {
      if (options.hasOwnProperty(name)) {
        style[name] = old[name];
      }
    }
  }
  function getPBMWidth(elem, props, which) {
    var value = 0;
    var prop = undefined;
    var j = undefined;
    var i = undefined;
    for (j = 0; j < props.length; j++) {
      prop = props[j];
      if (prop) {
        for (i = 0; i < which.length; i++) {
          var cssProp = undefined;
          if (prop === 'border') {
            cssProp = prop + which[i] + 'Width';
          } else {
            cssProp = prop + which[i];
          }
          value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
        }
      }
    }
    return value;
  }
  function isWindow(obj) {
    return obj !== null && obj !== undefined && obj == obj.window;
  }
  var domUtils = {};
  each(['Width', 'Height'], function(name) {
    domUtils['doc' + name] = function(refWin) {
      var d = refWin.document;
      return Math.max(d.documentElement['scroll' + name], d.body['scroll' + name], domUtils['viewport' + name](d));
    };
    domUtils['viewport' + name] = function(win) {
      var prop = 'client' + name;
      var doc = win.document;
      var body = doc.body;
      var documentElement = doc.documentElement;
      var documentElementProp = documentElement[prop];
      return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
    };
  });
  function getWH(elem, name, ex) {
    var extra = ex;
    if (isWindow(elem)) {
      return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
    } else if (elem.nodeType === 9) {
      return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
    }
    var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
    var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
    var computedStyle = getComputedStyleX(elem);
    var isBorderBox = isBorderBoxFn(elem, computedStyle);
    var cssBoxValue = 0;
    if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
      borderBoxValue = undefined;
      cssBoxValue = getComputedStyleX(elem, name);
      if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
        cssBoxValue = elem.style[name] || 0;
      }
      cssBoxValue = parseFloat(cssBoxValue) || 0;
    }
    if (extra === undefined) {
      extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
    }
    var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
    var val = borderBoxValue || cssBoxValue;
    if (extra === CONTENT_INDEX) {
      if (borderBoxValueOrIsBorderBox) {
        return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
      }
      return cssBoxValue;
    } else if (borderBoxValueOrIsBorderBox) {
      if (extra === BORDER_INDEX) {
        return val;
      }
      return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle));
    }
    return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
  }
  var cssShow = {
    position: 'absolute',
    visibility: 'hidden',
    display: 'block'
  };
  function getWHIgnoreDisplay() {
    for (var _len = arguments.length,
        args = Array(_len),
        _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var val = undefined;
    var elem = args[0];
    if (elem.offsetWidth !== 0) {
      val = getWH.apply(undefined, args);
    } else {
      swap(elem, cssShow, function() {
        val = getWH.apply(undefined, args);
      });
    }
    return val;
  }
  each(['width', 'height'], function(name) {
    var first = name.charAt(0).toUpperCase() + name.slice(1);
    domUtils['outer' + first] = function(el, includeMargin) {
      return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
    };
    var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
    domUtils[name] = function(elem, v) {
      var val = v;
      if (val !== undefined) {
        if (elem) {
          var computedStyle = getComputedStyleX(elem);
          var isBorderBox = isBorderBoxFn(elem);
          if (isBorderBox) {
            val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
          }
          return css(elem, name, val);
        }
        return undefined;
      }
      return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
    };
  });
  function mix(to, from) {
    for (var i in from) {
      if (from.hasOwnProperty(i)) {
        to[i] = from[i];
      }
    }
    return to;
  }
  var utils = {
    getWindow: function getWindow(node) {
      if (node && node.document && node.setTimeout) {
        return node;
      }
      var doc = node.ownerDocument || node;
      return doc.defaultView || doc.parentWindow;
    },
    offset: function offset(el, value, option) {
      if (typeof value !== 'undefined') {
        setOffset(el, value, option || {});
      } else {
        return getOffset(el);
      }
    },
    isWindow: isWindow,
    each: each,
    css: css,
    clone: function clone(obj) {
      var i = undefined;
      var ret = {};
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret[i] = obj[i];
        }
      }
      var overflow = obj.overflow;
      if (overflow) {
        for (i in obj) {
          if (obj.hasOwnProperty(i)) {
            ret.overflow[i] = obj.overflow[i];
          }
        }
      }
      return ret;
    },
    mix: mix,
    getWindowScrollLeft: function getWindowScrollLeft(w) {
      return getScrollLeft(w);
    },
    getWindowScrollTop: function getWindowScrollTop(w) {
      return getScrollTop(w);
    },
    merge: function merge() {
      var ret = {};
      for (var _len2 = arguments.length,
          args = Array(_len2),
          _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      for (var i = 0; i < args.length; i++) {
        utils.mix(ret, args[i]);
      }
      return ret;
    },
    viewportWidth: 0,
    viewportHeight: 0
  };
  mix(utils, domUtils);
  exports['default'] = utils;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:dom-align@1.4.0/lib/getRegion.js", ["./utils"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _utils = $__require('./utils');
  var _utils2 = _interopRequireDefault(_utils);
  function getRegion(node) {
    var offset = undefined;
    var w = undefined;
    var h = undefined;
    if (!_utils2['default'].isWindow(node) && node.nodeType !== 9) {
      offset = _utils2['default'].offset(node);
      w = _utils2['default'].outerWidth(node);
      h = _utils2['default'].outerHeight(node);
    } else {
      var win = _utils2['default'].getWindow(node);
      offset = {
        left: _utils2['default'].getWindowScrollLeft(win),
        top: _utils2['default'].getWindowScrollTop(win)
      };
      w = _utils2['default'].viewportWidth(win);
      h = _utils2['default'].viewportHeight(win);
    }
    offset.width = w;
    offset.height = h;
    return offset;
  }
  exports['default'] = getRegion;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:dom-align@1.4.0/lib/getAlignOffset.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function getAlignOffset(region, align) {
    var V = align.charAt(0);
    var H = align.charAt(1);
    var w = region.width;
    var h = region.height;
    var x = undefined;
    var y = undefined;
    x = region.left;
    y = region.top;
    if (V === 'c') {
      y += h / 2;
    } else if (V === 'b') {
      y += h;
    }
    if (H === 'c') {
      x += w / 2;
    } else if (H === 'r') {
      x += w;
    }
    return {
      left: x,
      top: y
    };
  }
  exports['default'] = getAlignOffset;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:dom-align@1.4.0/lib/getElFuturePos.js", ["./getAlignOffset"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _getAlignOffset = $__require('./getAlignOffset');
  var _getAlignOffset2 = _interopRequireDefault(_getAlignOffset);
  function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
    var xy = undefined;
    var diff = undefined;
    var p1 = undefined;
    var p2 = undefined;
    xy = {
      left: elRegion.left,
      top: elRegion.top
    };
    p1 = (0, _getAlignOffset2['default'])(refNodeRegion, points[1]);
    p2 = (0, _getAlignOffset2['default'])(elRegion, points[0]);
    diff = [p2.left - p1.left, p2.top - p1.top];
    return {
      left: xy.left - diff[0] + offset[0] - targetOffset[0],
      top: xy.top - diff[1] + offset[1] - targetOffset[1]
    };
  }
  exports['default'] = getElFuturePos;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:dom-align@1.4.0.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./lib": "./lib/index.js"
    }
  };
});

System.registerDynamic("npm:dom-align@1.4.0/lib/index.js", ["./utils", "./getOffsetParent", "./getVisibleRectForElement", "./adjustForViewport", "./getRegion", "./getElFuturePos"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _utils = $__require('./utils');
  var _utils2 = _interopRequireDefault(_utils);
  var _getOffsetParent = $__require('./getOffsetParent');
  var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);
  var _getVisibleRectForElement = $__require('./getVisibleRectForElement');
  var _getVisibleRectForElement2 = _interopRequireDefault(_getVisibleRectForElement);
  var _adjustForViewport = $__require('./adjustForViewport');
  var _adjustForViewport2 = _interopRequireDefault(_adjustForViewport);
  var _getRegion = $__require('./getRegion');
  var _getRegion2 = _interopRequireDefault(_getRegion);
  var _getElFuturePos = $__require('./getElFuturePos');
  var _getElFuturePos2 = _interopRequireDefault(_getElFuturePos);
  function isFailX(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
  }
  function isFailY(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
  }
  function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
  }
  function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
  }
  function flip(points, reg, map) {
    var ret = [];
    _utils2['default'].each(points, function(p) {
      ret.push(p.replace(reg, function(m) {
        return map[m];
      }));
    });
    return ret;
  }
  function flipOffset(offset, index) {
    offset[index] = -offset[index];
    return offset;
  }
  function convertOffset(str, offsetLen) {
    var n = undefined;
    if (/%$/.test(str)) {
      n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
    } else {
      n = parseInt(str, 10);
    }
    return n || 0;
  }
  function normalizeOffset(offset, el) {
    offset[0] = convertOffset(offset[0], el.width);
    offset[1] = convertOffset(offset[1], el.height);
  }
  function domAlign(el, refNode, align) {
    var points = align.points;
    var offset = align.offset || [0, 0];
    var targetOffset = align.targetOffset || [0, 0];
    var overflow = align.overflow;
    var target = align.target || refNode;
    var source = align.source || el;
    offset = [].concat(offset);
    targetOffset = [].concat(targetOffset);
    overflow = overflow || {};
    var newOverflowCfg = {};
    var fail = 0;
    var visibleRect = (0, _getVisibleRectForElement2['default'])(source);
    var elRegion = (0, _getRegion2['default'])(source);
    var refNodeRegion = (0, _getRegion2['default'])(target);
    normalizeOffset(offset, elRegion);
    normalizeOffset(targetOffset, refNodeRegion);
    var elFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, points, offset, targetOffset);
    var newElRegion = _utils2['default'].merge(elRegion, elFuturePos);
    if (visibleRect && (overflow.adjustX || overflow.adjustY)) {
      if (overflow.adjustX) {
        if (isFailX(elFuturePos, elRegion, visibleRect)) {
          var newPoints = flip(points, /[lr]/ig, {
            l: 'r',
            r: 'l'
          });
          var newOffset = flipOffset(offset, 0);
          var newTargetOffset = flipOffset(targetOffset, 0);
          var newElFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, newPoints, newOffset, newTargetOffset);
          if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
            fail = 1;
            points = newPoints;
            offset = newOffset;
            targetOffset = newTargetOffset;
          }
        }
      }
      if (overflow.adjustY) {
        if (isFailY(elFuturePos, elRegion, visibleRect)) {
          var newPoints = flip(points, /[tb]/ig, {
            t: 'b',
            b: 't'
          });
          var newOffset = flipOffset(offset, 1);
          var newTargetOffset = flipOffset(targetOffset, 1);
          var newElFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, newPoints, newOffset, newTargetOffset);
          if (!isCompleteFailY(newElFuturePos, elRegion, visibleRect)) {
            fail = 1;
            points = newPoints;
            offset = newOffset;
            targetOffset = newTargetOffset;
          }
        }
      }
      if (fail) {
        elFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, points, offset, targetOffset);
        _utils2['default'].mix(newElRegion, elFuturePos);
      }
      newOverflowCfg.adjustX = overflow.adjustX && isFailX(elFuturePos, elRegion, visibleRect);
      newOverflowCfg.adjustY = overflow.adjustY && isFailY(elFuturePos, elRegion, visibleRect);
      if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
        newElRegion = (0, _adjustForViewport2['default'])(elFuturePos, elRegion, visibleRect, newOverflowCfg);
      }
    }
    if (newElRegion.width !== elRegion.width) {
      _utils2['default'].css(source, 'width', source.width() + newElRegion.width - elRegion.width);
    }
    if (newElRegion.height !== elRegion.height) {
      _utils2['default'].css(source, 'height', source.height() + newElRegion.height - elRegion.height);
    }
    _utils2['default'].offset(source, {
      left: newElRegion.left,
      top: newElRegion.top
    }, {
      useCssRight: align.useCssRight,
      useCssBottom: align.useCssBottom
    });
    return {
      points: points,
      offset: offset,
      targetOffset: targetOffset,
      overflow: newOverflowCfg
    };
  }
  domAlign.__getOffsetParent = _getOffsetParent2['default'];
  domAlign.__getVisibleRectForElement = _getVisibleRectForElement2['default'];
  exports['default'] = domAlign;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:add-dom-event-listener@1.0.1/lib/EventBaseObject.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  function returnFalse() {
    return false;
  }
  function returnTrue() {
    return true;
  }
  function EventBaseObject() {
    this.timeStamp = Date.now();
    this.target = undefined;
    this.currentTarget = undefined;
  }
  EventBaseObject.prototype = {
    isEventObject: 1,
    constructor: EventBaseObject,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function preventDefault() {
      this.isDefaultPrevented = returnTrue;
    },
    stopPropagation: function stopPropagation() {
      this.isPropagationStopped = returnTrue;
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    },
    halt: function halt(immediate) {
      if (immediate) {
        this.stopImmediatePropagation();
      } else {
        this.stopPropagation();
      }
      this.preventDefault();
    }
  };
  exports["default"] = EventBaseObject;
  module.exports = exports["default"];
  return module.exports;
});

System.registerDynamic("npm:add-dom-event-listener@1.0.1/lib/EventObject.js", ["./EventBaseObject", "object-assign"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _EventBaseObject = $__require('./EventBaseObject');
  var _EventBaseObject2 = _interopRequireDefault(_EventBaseObject);
  var _objectAssign = $__require('object-assign');
  var _objectAssign2 = _interopRequireDefault(_objectAssign);
  var TRUE = true;
  var FALSE = false;
  var commonProps = ['altKey', 'bubbles', 'cancelable', 'ctrlKey', 'currentTarget', 'eventPhase', 'metaKey', 'shiftKey', 'target', 'timeStamp', 'view', 'type'];
  function isNullOrUndefined(w) {
    return w === null || w === undefined;
  }
  var eventNormalizers = [{
    reg: /^key/,
    props: ['char', 'charCode', 'key', 'keyCode', 'which'],
    fix: function fix(event, nativeEvent) {
      if (isNullOrUndefined(event.which)) {
        event.which = !isNullOrUndefined(nativeEvent.charCode) ? nativeEvent.charCode : nativeEvent.keyCode;
      }
      if (event.metaKey === undefined) {
        event.metaKey = event.ctrlKey;
      }
    }
  }, {
    reg: /^touch/,
    props: ['touches', 'changedTouches', 'targetTouches']
  }, {
    reg: /^hashchange$/,
    props: ['newURL', 'oldURL']
  }, {
    reg: /^gesturechange$/i,
    props: ['rotation', 'scale']
  }, {
    reg: /^(mousewheel|DOMMouseScroll)$/,
    props: [],
    fix: function fix(event, nativeEvent) {
      var deltaX = undefined;
      var deltaY = undefined;
      var delta = undefined;
      var wheelDelta = nativeEvent.wheelDelta;
      var axis = nativeEvent.axis;
      var wheelDeltaY = nativeEvent.wheelDeltaY;
      var wheelDeltaX = nativeEvent.wheelDeltaX;
      var detail = nativeEvent.detail;
      if (wheelDelta) {
        delta = wheelDelta / 120;
      }
      if (detail) {
        delta = 0 - (detail % 3 === 0 ? detail / 3 : detail);
      }
      if (axis !== undefined) {
        if (axis === event.HORIZONTAL_AXIS) {
          deltaY = 0;
          deltaX = 0 - delta;
        } else if (axis === event.VERTICAL_AXIS) {
          deltaX = 0;
          deltaY = delta;
        }
      }
      if (wheelDeltaY !== undefined) {
        deltaY = wheelDeltaY / 120;
      }
      if (wheelDeltaX !== undefined) {
        deltaX = -1 * wheelDeltaX / 120;
      }
      if (!deltaX && !deltaY) {
        deltaY = delta;
      }
      if (deltaX !== undefined) {
        event.deltaX = deltaX;
      }
      if (deltaY !== undefined) {
        event.deltaY = deltaY;
      }
      if (delta !== undefined) {
        event.delta = delta;
      }
    }
  }, {
    reg: /^mouse|contextmenu|click|mspointer|(^DOMMouseScroll$)/i,
    props: ['buttons', 'clientX', 'clientY', 'button', 'offsetX', 'relatedTarget', 'which', 'fromElement', 'toElement', 'offsetY', 'pageX', 'pageY', 'screenX', 'screenY'],
    fix: function fix(event, nativeEvent) {
      var eventDoc = undefined;
      var doc = undefined;
      var body = undefined;
      var target = event.target;
      var button = nativeEvent.button;
      if (target && isNullOrUndefined(event.pageX) && !isNullOrUndefined(nativeEvent.clientX)) {
        eventDoc = target.ownerDocument || document;
        doc = eventDoc.documentElement;
        body = eventDoc.body;
        event.pageX = nativeEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
        event.pageY = nativeEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
      }
      if (!event.which && button !== undefined) {
        if (button & 1) {
          event.which = 1;
        } else if (button & 2) {
          event.which = 3;
        } else if (button & 4) {
          event.which = 2;
        } else {
          event.which = 0;
        }
      }
      if (!event.relatedTarget && event.fromElement) {
        event.relatedTarget = event.fromElement === target ? event.toElement : event.fromElement;
      }
      return event;
    }
  }];
  function retTrue() {
    return TRUE;
  }
  function retFalse() {
    return FALSE;
  }
  function DomEventObject(nativeEvent) {
    var type = nativeEvent.type;
    var isNative = typeof nativeEvent.stopPropagation === 'function' || typeof nativeEvent.cancelBubble === 'boolean';
    _EventBaseObject2['default'].call(this);
    this.nativeEvent = nativeEvent;
    var isDefaultPrevented = retFalse;
    if ('defaultPrevented' in nativeEvent) {
      isDefaultPrevented = nativeEvent.defaultPrevented ? retTrue : retFalse;
    } else if ('getPreventDefault' in nativeEvent) {
      isDefaultPrevented = nativeEvent.getPreventDefault() ? retTrue : retFalse;
    } else if ('returnValue' in nativeEvent) {
      isDefaultPrevented = nativeEvent.returnValue === FALSE ? retTrue : retFalse;
    }
    this.isDefaultPrevented = isDefaultPrevented;
    var fixFns = [];
    var fixFn = undefined;
    var l = undefined;
    var prop = undefined;
    var props = commonProps.concat();
    eventNormalizers.forEach(function(normalizer) {
      if (type.match(normalizer.reg)) {
        props = props.concat(normalizer.props);
        if (normalizer.fix) {
          fixFns.push(normalizer.fix);
        }
      }
    });
    l = props.length;
    while (l) {
      prop = props[--l];
      this[prop] = nativeEvent[prop];
    }
    if (!this.target && isNative) {
      this.target = nativeEvent.srcElement || document;
    }
    if (this.target && this.target.nodeType === 3) {
      this.target = this.target.parentNode;
    }
    l = fixFns.length;
    while (l) {
      fixFn = fixFns[--l];
      fixFn(this, nativeEvent);
    }
    this.timeStamp = nativeEvent.timeStamp || Date.now();
  }
  var EventBaseObjectProto = _EventBaseObject2['default'].prototype;
  (0, _objectAssign2['default'])(DomEventObject.prototype, EventBaseObjectProto, {
    constructor: DomEventObject,
    preventDefault: function preventDefault() {
      var e = this.nativeEvent;
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = FALSE;
      }
      EventBaseObjectProto.preventDefault.call(this);
    },
    stopPropagation: function stopPropagation() {
      var e = this.nativeEvent;
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = TRUE;
      }
      EventBaseObjectProto.stopPropagation.call(this);
    }
  });
  exports['default'] = DomEventObject;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:add-dom-event-listener@1.0.1.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./lib": "./lib/index.js"
    }
  };
});

System.registerDynamic("npm:add-dom-event-listener@1.0.1/lib/index.js", ["./EventObject"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  exports['default'] = addEventListener;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _EventObject = $__require('./EventObject');
  var _EventObject2 = _interopRequireDefault(_EventObject);
  function addEventListener(target, eventType, callback) {
    function wrapCallback(e) {
      var ne = new _EventObject2['default'](e);
      callback.call(target, ne);
    }
    if (target.addEventListener) {
      target.addEventListener(eventType, wrapCallback, false);
      return {remove: function remove() {
          target.removeEventListener(eventType, wrapCallback, false);
        }};
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, wrapCallback);
      return {remove: function remove() {
          target.detachEvent('on' + eventType, wrapCallback);
        }};
    }
  }
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-util@3.2.1.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./lib": "./lib/index.js"
    }
  };
});

System.registerDynamic("npm:rc-util@3.2.1/lib/Dom/addEventListener.js", ["add-dom-event-listener", "react-dom", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  exports['default'] = addEventListenerWrap;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _addDomEventListener = $__require('add-dom-event-listener');
  var _addDomEventListener2 = _interopRequireDefault(_addDomEventListener);
  var _reactDom = $__require('react-dom');
  var _reactDom2 = _interopRequireDefault(_reactDom);
  function addEventListenerWrap(target, eventType, cb) {
    var callback = _reactDom2['default'].unstable_batchedUpdates ? function run(e) {
      _reactDom2['default'].unstable_batchedUpdates(cb, e);
    } : cb;
    return (0, _addDomEventListener2['default'])(target, eventType, callback);
  }
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-align@2.3.1/lib/isWindow.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports["default"] = isWindow;
  function isWindow(obj) {
    return obj != null && obj == obj.window;
  }
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-align@2.3.1/lib/Align.js", ["react", "react-dom", "dom-align", "rc-util/lib/Dom/addEventListener", "./isWindow"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _reactDom = $__require('react-dom');
  var _reactDom2 = _interopRequireDefault(_reactDom);
  var _domAlign = $__require('dom-align');
  var _domAlign2 = _interopRequireDefault(_domAlign);
  var _addEventListener = $__require('rc-util/lib/Dom/addEventListener');
  var _addEventListener2 = _interopRequireDefault(_addEventListener);
  var _isWindow = $__require('./isWindow');
  var _isWindow2 = _interopRequireDefault(_isWindow);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  function buffer(fn, ms) {
    var timer = void 0;
    return function bufferFn() {
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(fn, ms);
    };
  }
  var Align = _react2["default"].createClass({
    displayName: 'Align',
    propTypes: {
      childrenProps: _react.PropTypes.object,
      align: _react.PropTypes.object.isRequired,
      target: _react.PropTypes.func,
      onAlign: _react.PropTypes.func,
      monitorBufferTime: _react.PropTypes.number,
      monitorWindowResize: _react.PropTypes.bool,
      disabled: _react.PropTypes.bool,
      children: _react.PropTypes.any
    },
    getDefaultProps: function getDefaultProps() {
      return {
        target: function target() {
          return window;
        },
        onAlign: function onAlign() {},
        monitorBufferTime: 50,
        monitorWindowResize: false,
        disabled: false
      };
    },
    componentDidMount: function componentDidMount() {
      var props = this.props;
      this.forceAlign();
      if (!props.disabled && props.monitorWindowResize) {
        this.startMonitorWindowResize();
      }
    },
    componentDidUpdate: function componentDidUpdate(prevProps) {
      var reAlign = false;
      var props = this.props;
      if (!props.disabled) {
        if (prevProps.disabled || prevProps.align !== props.align) {
          reAlign = true;
        } else {
          var lastTarget = prevProps.target();
          var currentTarget = props.target();
          if ((0, _isWindow2["default"])(lastTarget) && (0, _isWindow2["default"])(currentTarget)) {
            reAlign = false;
          } else if (lastTarget !== currentTarget) {
            reAlign = true;
          }
        }
      }
      if (reAlign) {
        this.forceAlign();
      }
      if (props.monitorWindowResize && !props.disabled) {
        this.startMonitorWindowResize();
      } else {
        this.stopMonitorWindowResize();
      }
    },
    componentWillUnmount: function componentWillUnmount() {
      this.stopMonitorWindowResize();
    },
    startMonitorWindowResize: function startMonitorWindowResize() {
      if (!this.resizeHandler) {
        this.resizeHandler = (0, _addEventListener2["default"])(window, 'resize', buffer(this.forceAlign, this.props.monitorBufferTime));
      }
    },
    stopMonitorWindowResize: function stopMonitorWindowResize() {
      if (this.resizeHandler) {
        this.resizeHandler.remove();
        this.resizeHandler = null;
      }
    },
    forceAlign: function forceAlign() {
      var props = this.props;
      if (!props.disabled) {
        var source = _reactDom2["default"].findDOMNode(this);
        props.onAlign(source, (0, _domAlign2["default"])(source, props.target(), props.align));
      }
    },
    render: function render() {
      var _props = this.props;
      var childrenProps = _props.childrenProps;
      var children = _props.children;
      var child = _react2["default"].Children.only(children);
      if (childrenProps) {
        var newProps = {};
        for (var prop in childrenProps) {
          if (childrenProps.hasOwnProperty(prop)) {
            newProps[prop] = this.props[childrenProps[prop]];
          }
        }
        return _react2["default"].cloneElement(child, newProps);
      }
      return child;
    }
  });
  exports["default"] = Align;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-align@2.3.1.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./lib": "./lib/index.js"
    }
  };
});

System.registerDynamic("npm:rc-align@2.3.1/lib/index.js", ["./Align"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _Align = $__require('./Align');
  var _Align2 = _interopRequireDefault(_Align);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  exports["default"] = _Align2["default"];
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-animate@2.3.0/lib/ChildrenUtils.js", ["react"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.toArrayChildren = toArrayChildren;
  exports.findChildInChildrenByKey = findChildInChildrenByKey;
  exports.findShownChildInChildrenByKey = findShownChildInChildrenByKey;
  exports.findHiddenChildInChildrenByKey = findHiddenChildInChildrenByKey;
  exports.isSameChildren = isSameChildren;
  exports.mergeChildren = mergeChildren;
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  function toArrayChildren(children) {
    var ret = [];
    _react2["default"].Children.forEach(children, function(child) {
      ret.push(child);
    });
    return ret;
  }
  function findChildInChildrenByKey(children, key) {
    var ret = null;
    if (children) {
      children.forEach(function(child) {
        if (ret) {
          return;
        }
        if (child && child.key === key) {
          ret = child;
        }
      });
    }
    return ret;
  }
  function findShownChildInChildrenByKey(children, key, showProp) {
    var ret = null;
    if (children) {
      children.forEach(function(child) {
        if (child && child.key === key && child.props[showProp]) {
          if (ret) {
            throw new Error('two child with same key for <rc-animate> children');
          }
          ret = child;
        }
      });
    }
    return ret;
  }
  function findHiddenChildInChildrenByKey(children, key, showProp) {
    var found = 0;
    if (children) {
      children.forEach(function(child) {
        if (found) {
          return;
        }
        found = child && child.key === key && !child.props[showProp];
      });
    }
    return found;
  }
  function isSameChildren(c1, c2, showProp) {
    var same = c1.length === c2.length;
    if (same) {
      c1.forEach(function(child, index) {
        var child2 = c2[index];
        if (child && child2) {
          if (child && !child2 || !child && child2) {
            same = false;
          } else if (child.key !== child2.key) {
            same = false;
          } else if (showProp && child.props[showProp] !== child2.props[showProp]) {
            same = false;
          }
        }
      });
    }
    return same;
  }
  function mergeChildren(prev, next) {
    var ret = [];
    var nextChildrenPending = {};
    var pendingChildren = [];
    prev.forEach(function(child) {
      if (child && findChildInChildrenByKey(next, child.key)) {
        if (pendingChildren.length) {
          nextChildrenPending[child.key] = pendingChildren;
          pendingChildren = [];
        }
      } else {
        pendingChildren.push(child);
      }
    });
    next.forEach(function(child) {
      if (child && nextChildrenPending.hasOwnProperty(child.key)) {
        ret = ret.concat(nextChildrenPending[child.key]);
      }
      ret.push(child);
    });
    ret = ret.concat(pendingChildren);
    return ret;
  }
  return module.exports;
});

System.registerDynamic("npm:css-animation@1.2.5/lib/Event.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  var EVENT_NAME_MAP = {
    transitionend: {
      transition: 'transitionend',
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'mozTransitionEnd',
      OTransition: 'oTransitionEnd',
      msTransition: 'MSTransitionEnd'
    },
    animationend: {
      animation: 'animationend',
      WebkitAnimation: 'webkitAnimationEnd',
      MozAnimation: 'mozAnimationEnd',
      OAnimation: 'oAnimationEnd',
      msAnimation: 'MSAnimationEnd'
    }
  };
  var endEvents = [];
  function detectEvents() {
    var testEl = document.createElement('div');
    var style = testEl.style;
    if (!('AnimationEvent' in window)) {
      delete EVENT_NAME_MAP.animationend.animation;
    }
    if (!('TransitionEvent' in window)) {
      delete EVENT_NAME_MAP.transitionend.transition;
    }
    for (var baseEventName in EVENT_NAME_MAP) {
      if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
        var baseEvents = EVENT_NAME_MAP[baseEventName];
        for (var styleName in baseEvents) {
          if (styleName in style) {
            endEvents.push(baseEvents[styleName]);
            break;
          }
        }
      }
    }
  }
  if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    detectEvents();
  }
  function addEventListener(node, eventName, eventListener) {
    node.addEventListener(eventName, eventListener, false);
  }
  function removeEventListener(node, eventName, eventListener) {
    node.removeEventListener(eventName, eventListener, false);
  }
  var TransitionEvents = {
    addEndEventListener: function addEndEventListener(node, eventListener) {
      if (endEvents.length === 0) {
        window.setTimeout(eventListener, 0);
        return;
      }
      endEvents.forEach(function(endEvent) {
        addEventListener(node, endEvent, eventListener);
      });
    },
    endEvents: endEvents,
    removeEndEventListener: function removeEndEventListener(node, eventListener) {
      if (endEvents.length === 0) {
        return;
      }
      endEvents.forEach(function(endEvent) {
        removeEventListener(node, endEvent, eventListener);
      });
    }
  };
  exports["default"] = TransitionEvents;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:component-indexof@0.0.3.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:component-indexof@0.0.3/index.js", ["process"], true, function($__require, exports, module) {
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(arr, obj) {
    if (arr.indexOf)
      return arr.indexOf(obj);
    for (var i = 0; i < arr.length; ++i) {
      if (arr[i] === obj)
        return i;
    }
    return -1;
  };
  return module.exports;
});

System.registerDynamic("npm:component-classes@1.2.6.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "indexof": {
        "browser": "component-indexof"
      }
    }
  };
});

System.registerDynamic("npm:component-classes@1.2.6/index.js", ["indexof", "component-indexof"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  try {
    var index = $__require('indexof');
  } catch (err) {
    var index = $__require('component-indexof');
  }
  var re = /\s+/;
  var toString = Object.prototype.toString;
  module.exports = function(el) {
    return new ClassList(el);
  };
  function ClassList(el) {
    if (!el || !el.nodeType) {
      throw new Error('A DOM element reference is required');
    }
    this.el = el;
    this.list = el.classList;
  }
  ClassList.prototype.add = function(name) {
    if (this.list) {
      this.list.add(name);
      return this;
    }
    var arr = this.array();
    var i = index(arr, name);
    if (!~i)
      arr.push(name);
    this.el.className = arr.join(' ');
    return this;
  };
  ClassList.prototype.remove = function(name) {
    if ('[object RegExp]' == toString.call(name)) {
      return this.removeMatching(name);
    }
    if (this.list) {
      this.list.remove(name);
      return this;
    }
    var arr = this.array();
    var i = index(arr, name);
    if (~i)
      arr.splice(i, 1);
    this.el.className = arr.join(' ');
    return this;
  };
  ClassList.prototype.removeMatching = function(re) {
    var arr = this.array();
    for (var i = 0; i < arr.length; i++) {
      if (re.test(arr[i])) {
        this.remove(arr[i]);
      }
    }
    return this;
  };
  ClassList.prototype.toggle = function(name, force) {
    if (this.list) {
      if ("undefined" !== typeof force) {
        if (force !== this.list.toggle(name, force)) {
          this.list.toggle(name);
        }
      } else {
        this.list.toggle(name);
      }
      return this;
    }
    if ("undefined" !== typeof force) {
      if (!force) {
        this.remove(name);
      } else {
        this.add(name);
      }
    } else {
      if (this.has(name)) {
        this.remove(name);
      } else {
        this.add(name);
      }
    }
    return this;
  };
  ClassList.prototype.array = function() {
    var className = this.el.getAttribute('class') || '';
    var str = className.replace(/^\s+|\s+$/g, '');
    var arr = str.split(re);
    if ('' === arr[0])
      arr.shift();
    return arr;
  };
  ClassList.prototype.has = ClassList.prototype.contains = function(name) {
    return this.list ? this.list.contains(name) : !!~index(this.array(), name);
  };
  return module.exports;
});

System.registerDynamic("npm:css-animation@1.2.5.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./lib": "./lib/index.js"
    }
  };
});

System.registerDynamic("npm:css-animation@1.2.5/lib/index.js", ["./Event", "component-classes"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _Event = $__require('./Event');
  var _Event2 = _interopRequireDefault(_Event);
  var _componentClasses = $__require('component-classes');
  var _componentClasses2 = _interopRequireDefault(_componentClasses);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  var isCssAnimationSupported = _Event2["default"].endEvents.length !== 0;
  var capitalPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
  var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];
  function getDuration(node, name) {
    var style = window.getComputedStyle(node);
    var ret = '';
    for (var i = 0; i < prefixes.length; i++) {
      ret = style.getPropertyValue(prefixes[i] + name);
      if (ret) {
        break;
      }
    }
    return ret;
  }
  function fixBrowserByTimeout(node) {
    if (isCssAnimationSupported) {
      var transitionDuration = parseFloat(getDuration(node, 'transition-duration')) || 0;
      var animationDuration = parseFloat(getDuration(node, 'animation-duration')) || 0;
      var time = Math.max(transitionDuration, animationDuration);
      node.rcEndAnimTimeout = setTimeout(function() {
        node.rcEndAnimTimeout = null;
        if (node.rcEndListener) {
          node.rcEndListener();
        }
      }, time * 1000 + 200);
    }
  }
  function clearBrowserBugTimeout(node) {
    if (node.rcEndAnimTimeout) {
      clearTimeout(node.rcEndAnimTimeout);
      node.rcEndAnimTimeout = null;
    }
  }
  var cssAnimation = function cssAnimation(node, transitionName, endCallback) {
    var className = transitionName;
    var activeClassName = className + '-active';
    var end = endCallback;
    var start = void 0;
    var active = void 0;
    var nodeClasses = (0, _componentClasses2["default"])(node);
    if (endCallback && Object.prototype.toString.call(endCallback) === '[object Object]') {
      end = endCallback.end;
      start = endCallback.start;
      active = endCallback.active;
    }
    if (node.rcEndListener) {
      node.rcEndListener();
    }
    node.rcEndListener = function(e) {
      if (e && e.target !== node) {
        return;
      }
      if (node.rcAnimTimeout) {
        clearTimeout(node.rcAnimTimeout);
        node.rcAnimTimeout = null;
      }
      clearBrowserBugTimeout(node);
      nodeClasses.remove(className);
      nodeClasses.remove(activeClassName);
      _Event2["default"].removeEndEventListener(node, node.rcEndListener);
      node.rcEndListener = null;
      if (end) {
        end();
      }
    };
    _Event2["default"].addEndEventListener(node, node.rcEndListener);
    if (start) {
      start();
    }
    nodeClasses.add(className);
    node.rcAnimTimeout = setTimeout(function() {
      node.rcAnimTimeout = null;
      nodeClasses.add(activeClassName);
      if (active) {
        setTimeout(active, 0);
      }
      fixBrowserByTimeout(node);
    }, 30);
    return {stop: function stop() {
        if (node.rcEndListener) {
          node.rcEndListener();
        }
      }};
  };
  cssAnimation.style = function(node, style, callback) {
    if (node.rcEndListener) {
      node.rcEndListener();
    }
    node.rcEndListener = function(e) {
      if (e && e.target !== node) {
        return;
      }
      if (node.rcAnimTimeout) {
        clearTimeout(node.rcAnimTimeout);
        node.rcAnimTimeout = null;
      }
      clearBrowserBugTimeout(node);
      _Event2["default"].removeEndEventListener(node, node.rcEndListener);
      node.rcEndListener = null;
      if (callback) {
        callback();
      }
    };
    _Event2["default"].addEndEventListener(node, node.rcEndListener);
    node.rcAnimTimeout = setTimeout(function() {
      for (var s in style) {
        if (style.hasOwnProperty(s)) {
          node.style[s] = style[s];
        }
      }
      node.rcAnimTimeout = null;
      fixBrowserByTimeout(node);
    }, 0);
  };
  cssAnimation.setTransition = function(node, p, value) {
    var property = p;
    var v = value;
    if (value === undefined) {
      v = property;
      property = '';
    }
    property = property || '';
    capitalPrefixes.forEach(function(prefix) {
      node.style[prefix + 'Transition' + property] = v;
    });
  };
  cssAnimation.isCssAnimationSupported = isCssAnimationSupported;
  exports["default"] = cssAnimation;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-animate@2.3.0/lib/AnimateChild.js", ["react", "react-dom", "css-animation", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _reactDom = $__require('react-dom');
  var _reactDom2 = _interopRequireDefault(_reactDom);
  var _cssAnimation = $__require('css-animation');
  var _cssAnimation2 = _interopRequireDefault(_cssAnimation);
  var _util = $__require('./util');
  var _util2 = _interopRequireDefault(_util);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  var transitionMap = {
    enter: 'transitionEnter',
    appear: 'transitionAppear',
    leave: 'transitionLeave'
  };
  var AnimateChild = _react2["default"].createClass({
    displayName: 'AnimateChild',
    propTypes: {children: _react2["default"].PropTypes.any},
    componentWillUnmount: function componentWillUnmount() {
      this.stop();
    },
    componentWillEnter: function componentWillEnter(done) {
      if (_util2["default"].isEnterSupported(this.props)) {
        this.transition('enter', done);
      } else {
        done();
      }
    },
    componentWillAppear: function componentWillAppear(done) {
      if (_util2["default"].isAppearSupported(this.props)) {
        this.transition('appear', done);
      } else {
        done();
      }
    },
    componentWillLeave: function componentWillLeave(done) {
      if (_util2["default"].isLeaveSupported(this.props)) {
        this.transition('leave', done);
      } else {
        done();
      }
    },
    transition: function transition(animationType, finishCallback) {
      var _this = this;
      var node = _reactDom2["default"].findDOMNode(this);
      var props = this.props;
      var transitionName = props.transitionName;
      var nameIsObj = (typeof transitionName === 'undefined' ? 'undefined' : _typeof(transitionName)) === 'object';
      this.stop();
      var end = function end() {
        _this.stopper = null;
        finishCallback();
      };
      if ((_cssAnimation.isCssAnimationSupported || !props.animation[animationType]) && transitionName && props[transitionMap[animationType]]) {
        var name = nameIsObj ? transitionName[animationType] : transitionName + '-' + animationType;
        this.stopper = (0, _cssAnimation2["default"])(node, name, end);
      } else {
        this.stopper = props.animation[animationType](node, end);
      }
    },
    stop: function stop() {
      var stopper = this.stopper;
      if (stopper) {
        this.stopper = null;
        stopper.stop();
      }
    },
    render: function render() {
      return this.props.children;
    }
  });
  exports["default"] = AnimateChild;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-animate@2.3.0/lib/util.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  var util = {
    isAppearSupported: function isAppearSupported(props) {
      return props.transitionName && props.transitionAppear || props.animation.appear;
    },
    isEnterSupported: function isEnterSupported(props) {
      return props.transitionName && props.transitionEnter || props.animation.enter;
    },
    isLeaveSupported: function isLeaveSupported(props) {
      return props.transitionName && props.transitionLeave || props.animation.leave;
    },
    allowAppearCallback: function allowAppearCallback(props) {
      return props.transitionAppear || props.animation.appear;
    },
    allowEnterCallback: function allowEnterCallback(props) {
      return props.transitionEnter || props.animation.enter;
    },
    allowLeaveCallback: function allowLeaveCallback(props) {
      return props.transitionLeave || props.animation.leave;
    }
  };
  exports["default"] = util;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-animate@2.3.0/lib/Animate.js", ["react", "./ChildrenUtils", "./AnimateChild", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _ChildrenUtils = $__require('./ChildrenUtils');
  var _AnimateChild = $__require('./AnimateChild');
  var _AnimateChild2 = _interopRequireDefault(_AnimateChild);
  var _util = $__require('./util');
  var _util2 = _interopRequireDefault(_util);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var defaultKey = 'rc_animate_' + Date.now();
  function getChildrenFromProps(props) {
    var children = props.children;
    if (_react2["default"].isValidElement(children)) {
      if (!children.key) {
        return _react2["default"].cloneElement(children, {key: defaultKey});
      }
    }
    return children;
  }
  function noop() {}
  var Animate = _react2["default"].createClass({
    displayName: 'Animate',
    propTypes: {
      component: _react2["default"].PropTypes.any,
      animation: _react2["default"].PropTypes.object,
      transitionName: _react2["default"].PropTypes.oneOfType([_react2["default"].PropTypes.string, _react2["default"].PropTypes.object]),
      transitionEnter: _react2["default"].PropTypes.bool,
      transitionAppear: _react2["default"].PropTypes.bool,
      exclusive: _react2["default"].PropTypes.bool,
      transitionLeave: _react2["default"].PropTypes.bool,
      onEnd: _react2["default"].PropTypes.func,
      onEnter: _react2["default"].PropTypes.func,
      onLeave: _react2["default"].PropTypes.func,
      onAppear: _react2["default"].PropTypes.func,
      showProp: _react2["default"].PropTypes.string
    },
    getDefaultProps: function getDefaultProps() {
      return {
        animation: {},
        component: 'span',
        transitionEnter: true,
        transitionLeave: true,
        transitionAppear: false,
        onEnd: noop,
        onEnter: noop,
        onLeave: noop,
        onAppear: noop
      };
    },
    getInitialState: function getInitialState() {
      this.currentlyAnimatingKeys = {};
      this.keysToEnter = [];
      this.keysToLeave = [];
      return {children: (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(this.props))};
    },
    componentDidMount: function componentDidMount() {
      var _this = this;
      var showProp = this.props.showProp;
      var children = this.state.children;
      if (showProp) {
        children = children.filter(function(child) {
          return !!child.props[showProp];
        });
      }
      children.forEach(function(child) {
        if (child) {
          _this.performAppear(child.key);
        }
      });
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      var _this2 = this;
      this.nextProps = nextProps;
      var nextChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(nextProps));
      var props = this.props;
      if (props.exclusive) {
        Object.keys(this.currentlyAnimatingKeys).forEach(function(key) {
          _this2.stop(key);
        });
      }
      var showProp = props.showProp;
      var currentlyAnimatingKeys = this.currentlyAnimatingKeys;
      var currentChildren = props.exclusive ? (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props)) : this.state.children;
      var newChildren = [];
      if (showProp) {
        currentChildren.forEach(function(currentChild) {
          var nextChild = currentChild && (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, currentChild.key);
          var newChild = void 0;
          if ((!nextChild || !nextChild.props[showProp]) && currentChild.props[showProp]) {
            newChild = _react2["default"].cloneElement(nextChild || currentChild, _defineProperty({}, showProp, true));
          } else {
            newChild = nextChild;
          }
          if (newChild) {
            newChildren.push(newChild);
          }
        });
        nextChildren.forEach(function(nextChild) {
          if (!nextChild || !(0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, nextChild.key)) {
            newChildren.push(nextChild);
          }
        });
      } else {
        newChildren = (0, _ChildrenUtils.mergeChildren)(currentChildren, nextChildren);
      }
      this.setState({children: newChildren});
      nextChildren.forEach(function(child) {
        var key = child && child.key;
        if (child && currentlyAnimatingKeys[key]) {
          return;
        }
        var hasPrev = child && (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
        if (showProp) {
          var showInNext = child.props[showProp];
          if (hasPrev) {
            var showInNow = (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
            if (!showInNow && showInNext) {
              _this2.keysToEnter.push(key);
            }
          } else if (showInNext) {
            _this2.keysToEnter.push(key);
          }
        } else if (!hasPrev) {
          _this2.keysToEnter.push(key);
        }
      });
      currentChildren.forEach(function(child) {
        var key = child && child.key;
        if (child && currentlyAnimatingKeys[key]) {
          return;
        }
        var hasNext = child && (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, key);
        if (showProp) {
          var showInNow = child.props[showProp];
          if (hasNext) {
            var showInNext = (0, _ChildrenUtils.findShownChildInChildrenByKey)(nextChildren, key, showProp);
            if (!showInNext && showInNow) {
              _this2.keysToLeave.push(key);
            }
          } else if (showInNow) {
            _this2.keysToLeave.push(key);
          }
        } else if (!hasNext) {
          _this2.keysToLeave.push(key);
        }
      });
    },
    componentDidUpdate: function componentDidUpdate() {
      var keysToEnter = this.keysToEnter;
      this.keysToEnter = [];
      keysToEnter.forEach(this.performEnter);
      var keysToLeave = this.keysToLeave;
      this.keysToLeave = [];
      keysToLeave.forEach(this.performLeave);
    },
    performEnter: function performEnter(key) {
      if (this.refs[key]) {
        this.currentlyAnimatingKeys[key] = true;
        this.refs[key].componentWillEnter(this.handleDoneAdding.bind(this, key, 'enter'));
      }
    },
    performAppear: function performAppear(key) {
      if (this.refs[key]) {
        this.currentlyAnimatingKeys[key] = true;
        this.refs[key].componentWillAppear(this.handleDoneAdding.bind(this, key, 'appear'));
      }
    },
    handleDoneAdding: function handleDoneAdding(key, type) {
      var props = this.props;
      delete this.currentlyAnimatingKeys[key];
      if (props.exclusive && props !== this.nextProps) {
        return;
      }
      var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
      if (!this.isValidChildByKey(currentChildren, key)) {
        this.performLeave(key);
      } else {
        if (type === 'appear') {
          if (_util2["default"].allowAppearCallback(props)) {
            props.onAppear(key);
            props.onEnd(key, true);
          }
        } else {
          if (_util2["default"].allowEnterCallback(props)) {
            props.onEnter(key);
            props.onEnd(key, true);
          }
        }
      }
    },
    performLeave: function performLeave(key) {
      if (this.refs[key]) {
        this.currentlyAnimatingKeys[key] = true;
        this.refs[key].componentWillLeave(this.handleDoneLeaving.bind(this, key));
      }
    },
    handleDoneLeaving: function handleDoneLeaving(key) {
      var props = this.props;
      delete this.currentlyAnimatingKeys[key];
      if (props.exclusive && props !== this.nextProps) {
        return;
      }
      var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
      if (this.isValidChildByKey(currentChildren, key)) {
        this.performEnter(key);
      } else {
        var end = function end() {
          if (_util2["default"].allowLeaveCallback(props)) {
            props.onLeave(key);
            props.onEnd(key, false);
          }
        };
        if (this.isMounted() && !(0, _ChildrenUtils.isSameChildren)(this.state.children, currentChildren, props.showProp)) {
          this.setState({children: currentChildren}, end);
        } else {
          end();
        }
      }
    },
    isValidChildByKey: function isValidChildByKey(currentChildren, key) {
      var showProp = this.props.showProp;
      if (showProp) {
        return (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
      }
      return (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
    },
    stop: function stop(key) {
      delete this.currentlyAnimatingKeys[key];
      var component = this.refs[key];
      if (component) {
        component.stop();
      }
    },
    render: function render() {
      var props = this.props;
      this.nextProps = props;
      var stateChildren = this.state.children;
      var children = null;
      if (stateChildren) {
        children = stateChildren.map(function(child) {
          if (child === null || child === undefined) {
            return child;
          }
          if (!child.key) {
            throw new Error('must set key for <rc-animate> children');
          }
          return _react2["default"].createElement(_AnimateChild2["default"], {
            key: child.key,
            ref: child.key,
            animation: props.animation,
            transitionName: props.transitionName,
            transitionEnter: props.transitionEnter,
            transitionAppear: props.transitionAppear,
            transitionLeave: props.transitionLeave
          }, child);
        });
      }
      var Component = props.component;
      if (Component) {
        var passedProps = props;
        if (typeof Component === 'string') {
          passedProps = {
            className: props.className,
            style: props.style
          };
        }
        return _react2["default"].createElement(Component, passedProps, children);
      }
      return children[0] || null;
    }
  });
  exports["default"] = Animate;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-animate@2.3.0.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./lib": "./lib/index.js"
    }
  };
});

System.registerDynamic("npm:rc-animate@2.3.0/lib/index.js", ["./Animate"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./Animate');
  return module.exports;
});

System.registerDynamic("npm:rc-trigger@1.6.1/lib/PopupInner.js", ["react", "./LazyRenderBox"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _LazyRenderBox = $__require('./LazyRenderBox');
  var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  var PopupInner = _react2["default"].createClass({
    displayName: 'PopupInner',
    propTypes: {
      hiddenClassName: _react.PropTypes.string,
      className: _react.PropTypes.string,
      prefixCls: _react.PropTypes.string,
      onMouseEnter: _react.PropTypes.func,
      onMouseLeave: _react.PropTypes.func,
      children: _react.PropTypes.any
    },
    render: function render() {
      var props = this.props;
      var className = props.className;
      if (!props.visible) {
        className += ' ' + props.hiddenClassName;
      }
      return _react2["default"].createElement('div', {
        className: className,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        style: props.style
      }, _react2["default"].createElement(_LazyRenderBox2["default"], {
        className: props.prefixCls + '-content',
        visible: props.visible
      }, props.children));
    }
  });
  exports["default"] = PopupInner;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-trigger@1.6.1/lib/LazyRenderBox.js", ["react"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  function _objectWithoutProperties(obj, keys) {
    var target = {};
    for (var i in obj) {
      if (keys.indexOf(i) >= 0)
        continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i))
        continue;
      target[i] = obj[i];
    }
    return target;
  }
  var LazyRenderBox = _react2["default"].createClass({
    displayName: 'LazyRenderBox',
    propTypes: {
      children: _react.PropTypes.any,
      className: _react.PropTypes.string,
      visible: _react.PropTypes.bool,
      hiddenClassName: _react.PropTypes.string
    },
    shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
      return nextProps.hiddenClassName || nextProps.visible;
    },
    render: function render() {
      var _props = this.props;
      var hiddenClassName = _props.hiddenClassName;
      var visible = _props.visible;
      var props = _objectWithoutProperties(_props, ['hiddenClassName', 'visible']);
      if (hiddenClassName || _react2["default"].Children.count(props.children) > 1) {
        if (!visible && hiddenClassName) {
          props.className += ' ' + hiddenClassName;
        }
        return _react2["default"].createElement('div', props);
      }
      return _react2["default"].Children.only(props.children);
    }
  });
  exports["default"] = LazyRenderBox;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-trigger@1.6.1/lib/Popup.js", ["react", "react-dom", "rc-align", "rc-animate", "./PopupInner", "./LazyRenderBox"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _reactDom = $__require('react-dom');
  var _reactDom2 = _interopRequireDefault(_reactDom);
  var _rcAlign = $__require('rc-align');
  var _rcAlign2 = _interopRequireDefault(_rcAlign);
  var _rcAnimate = $__require('rc-animate');
  var _rcAnimate2 = _interopRequireDefault(_rcAnimate);
  var _PopupInner = $__require('./PopupInner');
  var _PopupInner2 = _interopRequireDefault(_PopupInner);
  var _LazyRenderBox = $__require('./LazyRenderBox');
  var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  var Popup = _react2["default"].createClass({
    displayName: 'Popup',
    propTypes: {
      visible: _react.PropTypes.bool,
      style: _react.PropTypes.object,
      getClassNameFromAlign: _react.PropTypes.func,
      onAlign: _react.PropTypes.func,
      getRootDomNode: _react.PropTypes.func,
      onMouseEnter: _react.PropTypes.func,
      align: _react.PropTypes.any,
      destroyPopupOnHide: _react.PropTypes.bool,
      className: _react.PropTypes.string,
      prefixCls: _react.PropTypes.string,
      onMouseLeave: _react.PropTypes.func
    },
    componentDidMount: function componentDidMount() {
      this.rootNode = this.getPopupDomNode();
    },
    onAlign: function onAlign(popupDomNode, align) {
      var props = this.props;
      var alignClassName = props.getClassNameFromAlign(props.align);
      var currentAlignClassName = props.getClassNameFromAlign(align);
      if (alignClassName !== currentAlignClassName) {
        this.currentAlignClassName = currentAlignClassName;
        popupDomNode.className = this.getClassName(currentAlignClassName);
      }
      props.onAlign(popupDomNode, align);
    },
    getPopupDomNode: function getPopupDomNode() {
      return _reactDom2["default"].findDOMNode(this.refs.popup);
    },
    getTarget: function getTarget() {
      return this.props.getRootDomNode();
    },
    getMaskTransitionName: function getMaskTransitionName() {
      var props = this.props;
      var transitionName = props.maskTransitionName;
      var animation = props.maskAnimation;
      if (!transitionName && animation) {
        transitionName = props.prefixCls + '-' + animation;
      }
      return transitionName;
    },
    getTransitionName: function getTransitionName() {
      var props = this.props;
      var transitionName = props.transitionName;
      if (!transitionName && props.animation) {
        transitionName = props.prefixCls + '-' + props.animation;
      }
      return transitionName;
    },
    getClassName: function getClassName(currentAlignClassName) {
      return this.props.prefixCls + ' ' + this.props.className + ' ' + currentAlignClassName;
    },
    getPopupElement: function getPopupElement() {
      var props = this.props;
      var align = props.align;
      var style = props.style;
      var visible = props.visible;
      var prefixCls = props.prefixCls;
      var destroyPopupOnHide = props.destroyPopupOnHide;
      var className = this.getClassName(this.currentAlignClassName || props.getClassNameFromAlign(align));
      var hiddenClassName = prefixCls + '-hidden';
      if (!visible) {
        this.currentAlignClassName = null;
      }
      var newStyle = _extends({}, style, this.getZIndexStyle());
      var popupInnerProps = {
        className: className,
        prefixCls: prefixCls,
        ref: 'popup',
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        style: newStyle
      };
      if (destroyPopupOnHide) {
        return _react2["default"].createElement(_rcAnimate2["default"], {
          component: '',
          exclusive: true,
          transitionAppear: true,
          transitionName: this.getTransitionName()
        }, visible ? _react2["default"].createElement(_rcAlign2["default"], {
          target: this.getTarget,
          key: 'popup',
          ref: this.saveAlign,
          monitorWindowResize: true,
          align: align,
          onAlign: this.onAlign
        }, _react2["default"].createElement(_PopupInner2["default"], _extends({visible: true}, popupInnerProps), props.children)) : null);
      }
      return _react2["default"].createElement(_rcAnimate2["default"], {
        component: '',
        exclusive: true,
        transitionAppear: true,
        transitionName: this.getTransitionName(),
        showProp: 'xVisible'
      }, _react2["default"].createElement(_rcAlign2["default"], {
        target: this.getTarget,
        key: 'popup',
        ref: this.saveAlign,
        monitorWindowResize: true,
        xVisible: visible,
        childrenProps: {visible: 'xVisible'},
        disabled: !visible,
        align: align,
        onAlign: this.onAlign
      }, _react2["default"].createElement(_PopupInner2["default"], _extends({hiddenClassName: hiddenClassName}, popupInnerProps), props.children)));
    },
    getZIndexStyle: function getZIndexStyle() {
      var style = {};
      var props = this.props;
      if (props.zIndex !== undefined) {
        style.zIndex = props.zIndex;
      }
      return style;
    },
    getMaskElement: function getMaskElement() {
      var props = this.props;
      var maskElement = void 0;
      if (props.mask) {
        var maskTransition = this.getMaskTransitionName();
        maskElement = _react2["default"].createElement(_LazyRenderBox2["default"], {
          style: this.getZIndexStyle(),
          key: 'mask',
          className: props.prefixCls + '-mask',
          hiddenClassName: props.prefixCls + '-mask-hidden',
          visible: props.visible
        });
        if (maskTransition) {
          maskElement = _react2["default"].createElement(_rcAnimate2["default"], {
            key: 'mask',
            showProp: 'visible',
            transitionAppear: true,
            component: '',
            transitionName: maskTransition
          }, maskElement);
        }
      }
      return maskElement;
    },
    saveAlign: function saveAlign(align) {
      this.alignInstance = align;
    },
    render: function render() {
      return _react2["default"].createElement('div', null, this.getMaskElement(), this.getPopupElement());
    }
  });
  exports["default"] = Popup;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-trigger@1.6.1/lib/utils.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  exports.getAlignFromPlacement = getAlignFromPlacement;
  exports.getPopupClassNameFromAlign = getPopupClassNameFromAlign;
  function isPointsEq(a1, a2) {
    return a1[0] === a2[0] && a1[1] === a2[1];
  }
  function getAlignFromPlacement(builtinPlacements, placementStr, align) {
    var baseAlign = builtinPlacements[placementStr] || {};
    return _extends({}, baseAlign, align);
  }
  function getPopupClassNameFromAlign(builtinPlacements, prefixCls, align) {
    var points = align.points;
    for (var placement in builtinPlacements) {
      if (builtinPlacements.hasOwnProperty(placement)) {
        if (isPointsEq(builtinPlacements[placement].points, points)) {
          return prefixCls + '-placement-' + placement;
        }
      }
    }
    return '';
  }
  return module.exports;
});

System.registerDynamic("npm:rc-trigger@1.6.1/lib/Trigger.js", ["react", "react-dom", "rc-util/lib/createChainedFunction", "rc-util/lib/Dom/contains", "rc-util/lib/Dom/addEventListener", "./Popup", "./utils"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _reactDom = $__require('react-dom');
  var _reactDom2 = _interopRequireDefault(_reactDom);
  var _createChainedFunction = $__require('rc-util/lib/createChainedFunction');
  var _createChainedFunction2 = _interopRequireDefault(_createChainedFunction);
  var _contains = $__require('rc-util/lib/Dom/contains');
  var _contains2 = _interopRequireDefault(_contains);
  var _addEventListener = $__require('rc-util/lib/Dom/addEventListener');
  var _addEventListener2 = _interopRequireDefault(_addEventListener);
  var _Popup = $__require('./Popup');
  var _Popup2 = _interopRequireDefault(_Popup);
  var _utils = $__require('./utils');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  function noop() {}
  function returnEmptyString() {
    return '';
  }
  var ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur'];
  var Trigger = _react2["default"].createClass({
    displayName: 'Trigger',
    propTypes: {
      action: _react.PropTypes.any,
      showAction: _react.PropTypes.any,
      hideAction: _react.PropTypes.any,
      getPopupClassNameFromAlign: _react.PropTypes.any,
      onPopupVisibleChange: _react.PropTypes.func,
      afterPopupVisibleChange: _react.PropTypes.func,
      popup: _react.PropTypes.oneOfType([_react.PropTypes.node, _react.PropTypes.func]).isRequired,
      popupStyle: _react.PropTypes.object,
      prefixCls: _react.PropTypes.string,
      popupClassName: _react.PropTypes.string,
      popupPlacement: _react.PropTypes.string,
      builtinPlacements: _react.PropTypes.object,
      popupTransitionName: _react.PropTypes.string,
      popupAnimation: _react.PropTypes.any,
      mouseEnterDelay: _react.PropTypes.number,
      mouseLeaveDelay: _react.PropTypes.number,
      zIndex: _react.PropTypes.number,
      focusDelay: _react.PropTypes.number,
      blurDelay: _react.PropTypes.number,
      getPopupContainer: _react.PropTypes.func,
      destroyPopupOnHide: _react.PropTypes.bool,
      mask: _react.PropTypes.bool,
      onPopupAlign: _react.PropTypes.func,
      popupAlign: _react.PropTypes.object,
      popupVisible: _react.PropTypes.bool,
      maskTransitionName: _react.PropTypes.string,
      maskAnimation: _react.PropTypes.string
    },
    getDefaultProps: function getDefaultProps() {
      return {
        prefixCls: 'rc-trigger-popup',
        getPopupClassNameFromAlign: returnEmptyString,
        onPopupVisibleChange: noop,
        afterPopupVisibleChange: noop,
        onPopupAlign: noop,
        popupClassName: '',
        mouseEnterDelay: 0,
        mouseLeaveDelay: 0.1,
        focusDelay: 0,
        blurDelay: 0.15,
        popupStyle: {},
        destroyPopupOnHide: false,
        popupAlign: {},
        defaultPopupVisible: false,
        mask: false,
        action: [],
        showAction: [],
        hideAction: []
      };
    },
    getInitialState: function getInitialState() {
      var props = this.props;
      var popupVisible = void 0;
      if ('popupVisible' in props) {
        popupVisible = !!props.popupVisible;
      } else {
        popupVisible = !!props.defaultPopupVisible;
      }
      return {popupVisible: popupVisible};
    },
    componentDidMount: function componentDidMount() {
      this.componentDidUpdate({}, {popupVisible: this.state.popupVisible});
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      if ('popupVisible' in nextProps) {
        this.setState({popupVisible: !!nextProps.popupVisible});
      }
    },
    componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
      var props = this.props;
      var state = this.state;
      if (this.popupRendered) {
        var self = this;
        self.popupInstance = _reactDom2["default"].unstable_renderSubtreeIntoContainer(this, this.getPopupElement(), this.getPopupContainer(), function() {
          if (prevState.popupVisible !== state.popupVisible) {
            props.afterPopupVisibleChange(state.popupVisible);
          }
        });
        if (this.isClickToHide()) {
          if (state.popupVisible) {
            if (!this.clickOutsideHandler) {
              this.clickOutsideHandler = (0, _addEventListener2["default"])(document, 'mousedown', this.onDocumentClick);
              this.touchOutsideHandler = (0, _addEventListener2["default"])(document, 'touchstart', this.onDocumentClick);
            }
            return;
          }
        }
        if (this.clickOutsideHandler) {
          this.clickOutsideHandler.remove();
          this.touchOutsideHandler.remove();
          this.clickOutsideHandler = null;
          this.touchOutsideHandler = null;
        }
      }
    },
    componentWillUnmount: function componentWillUnmount() {
      var popupContainer = this.popupContainer;
      if (popupContainer) {
        _reactDom2["default"].unmountComponentAtNode(popupContainer);
        popupContainer.parentNode.removeChild(popupContainer);
        this.popupContainer = null;
      }
      this.clearDelayTimer();
      if (this.clickOutsideHandler) {
        this.clickOutsideHandler.remove();
        this.touchOutsideHandler.remove();
        this.clickOutsideHandler = null;
        this.touchOutsideHandler = null;
      }
    },
    onMouseEnter: function onMouseEnter() {
      this.delaySetPopupVisible(true, this.props.mouseEnterDelay);
    },
    onMouseLeave: function onMouseLeave(e) {
      if (e.relatedTarget && !e.relatedTarget.setTimeout && (0, _contains2["default"])(this.popupContainer, e.relatedTarget)) {
        return;
      }
      this.delaySetPopupVisible(false, this.props.mouseLeaveDelay);
    },
    onFocus: function onFocus() {
      this.clearDelayTimer();
      if (this.isFocusToShow()) {
        this.focusTime = Date.now();
        this.delaySetPopupVisible(true, this.props.focusDelay);
      }
    },
    onMouseDown: function onMouseDown() {
      this.preClickTime = Date.now();
    },
    onTouchStart: function onTouchStart() {
      this.preTouchTime = Date.now();
    },
    onBlur: function onBlur() {
      this.clearDelayTimer();
      if (this.isBlurToHide()) {
        this.delaySetPopupVisible(false, this.props.blurDelay);
      }
    },
    onClick: function onClick(event) {
      if (this.focusTime) {
        var preTime = void 0;
        if (this.preClickTime && this.preTouchTime) {
          preTime = Math.min(this.preClickTime, this.preTouchTime);
        } else if (this.preClickTime) {
          preTime = this.preClickTime;
        } else if (this.preTouchTime) {
          preTime = this.preTouchTime;
        }
        if (Math.abs(preTime - this.focusTime) < 20) {
          return;
        }
        this.focusTime = 0;
      }
      this.preClickTime = 0;
      this.preTouchTime = 0;
      event.preventDefault();
      var nextVisible = !this.state.popupVisible;
      if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
        this.setPopupVisible(!this.state.popupVisible);
      }
    },
    onDocumentClick: function onDocumentClick(event) {
      var target = event.target;
      var root = (0, _reactDom.findDOMNode)(this);
      var popupNode = this.getPopupDomNode();
      if (!(0, _contains2["default"])(root, target) && !(0, _contains2["default"])(popupNode, target)) {
        this.setPopupVisible(false);
      }
    },
    getPopupDomNode: function getPopupDomNode() {
      return this.popupInstance.isMounted() ? this.popupInstance.getPopupDomNode() : null;
    },
    getRootDomNode: function getRootDomNode() {
      return _reactDom2["default"].findDOMNode(this);
    },
    getPopupContainer: function getPopupContainer() {
      if (!this.popupContainer) {
        this.popupContainer = document.createElement('div');
        var mountNode = this.props.getPopupContainer ? this.props.getPopupContainer((0, _reactDom.findDOMNode)(this)) : document.body;
        mountNode.appendChild(this.popupContainer);
      }
      return this.popupContainer;
    },
    getPopupClassNameFromAlign: function getPopupClassNameFromAlign(align) {
      var className = [];
      var props = this.props;
      var popupPlacement = props.popupPlacement;
      var builtinPlacements = props.builtinPlacements;
      var prefixCls = props.prefixCls;
      if (popupPlacement && builtinPlacements) {
        className.push((0, _utils.getPopupClassNameFromAlign)(builtinPlacements, prefixCls, align));
      }
      if (props.getPopupClassNameFromAlign) {
        className.push(props.getPopupClassNameFromAlign(align));
      }
      return className.join(' ');
    },
    getPopupAlign: function getPopupAlign() {
      var props = this.props;
      var popupPlacement = props.popupPlacement;
      var popupAlign = props.popupAlign;
      var builtinPlacements = props.builtinPlacements;
      if (popupPlacement && builtinPlacements) {
        return (0, _utils.getAlignFromPlacement)(builtinPlacements, popupPlacement, popupAlign);
      }
      return popupAlign;
    },
    getPopupElement: function getPopupElement() {
      var props = this.props;
      var state = this.state;
      var mouseProps = {};
      if (this.isMouseEnterToShow()) {
        mouseProps.onMouseEnter = this.onMouseEnter;
      }
      if (this.isMouseLeaveToHide()) {
        mouseProps.onMouseLeave = this.onMouseLeave;
      }
      return _react2["default"].createElement(_Popup2["default"], _extends({
        prefixCls: props.prefixCls,
        destroyPopupOnHide: props.destroyPopupOnHide,
        visible: state.popupVisible,
        className: props.popupClassName,
        action: props.action,
        align: this.getPopupAlign(),
        onAlign: props.onPopupAlign,
        animation: props.popupAnimation,
        getClassNameFromAlign: this.getPopupClassNameFromAlign
      }, mouseProps, {
        getRootDomNode: this.getRootDomNode,
        style: props.popupStyle,
        mask: props.mask,
        zIndex: props.zIndex,
        transitionName: props.popupTransitionName,
        maskAnimation: props.maskAnimation,
        maskTransitionName: props.maskTransitionName
      }), typeof props.popup === 'function' ? props.popup() : props.popup);
    },
    setPopupVisible: function setPopupVisible(popupVisible) {
      this.clearDelayTimer();
      if (this.state.popupVisible !== popupVisible) {
        if (!('popupVisible' in this.props)) {
          this.setState({popupVisible: popupVisible});
        }
        this.props.onPopupVisibleChange(popupVisible);
      }
    },
    delaySetPopupVisible: function delaySetPopupVisible(visible, delayS) {
      var _this = this;
      var delay = delayS * 1000;
      this.clearDelayTimer();
      if (delay) {
        this.delayTimer = setTimeout(function() {
          _this.setPopupVisible(visible);
          _this.clearDelayTimer();
        }, delay);
      } else {
        this.setPopupVisible(visible);
      }
    },
    clearDelayTimer: function clearDelayTimer() {
      if (this.delayTimer) {
        clearTimeout(this.delayTimer);
        this.delayTimer = null;
      }
    },
    isClickToShow: function isClickToShow() {
      var _props = this.props;
      var action = _props.action;
      var showAction = _props.showAction;
      return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
    },
    isClickToHide: function isClickToHide() {
      var _props2 = this.props;
      var action = _props2.action;
      var hideAction = _props2.hideAction;
      return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
    },
    isMouseEnterToShow: function isMouseEnterToShow() {
      var _props3 = this.props;
      var action = _props3.action;
      var showAction = _props3.showAction;
      return action.indexOf('hover') !== -1 || showAction.indexOf('mouseEnter') !== -1;
    },
    isMouseLeaveToHide: function isMouseLeaveToHide() {
      var _props4 = this.props;
      var action = _props4.action;
      var hideAction = _props4.hideAction;
      return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseLeave') !== -1;
    },
    isFocusToShow: function isFocusToShow() {
      var _props5 = this.props;
      var action = _props5.action;
      var showAction = _props5.showAction;
      return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
    },
    isBlurToHide: function isBlurToHide() {
      var _props6 = this.props;
      var action = _props6.action;
      var hideAction = _props6.hideAction;
      return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
    },
    forcePopupAlign: function forcePopupAlign() {
      if (this.state.popupVisible && this.popupInstance && this.popupInstance.alignInstance) {
        this.popupInstance.alignInstance.forceAlign();
      }
    },
    render: function render() {
      this.popupRendered = this.popupRendered || this.state.popupVisible;
      var props = this.props;
      var children = props.children;
      var child = _react2["default"].Children.only(children);
      var childProps = child.props || {};
      var newChildProps = {};
      if (this.isClickToHide() || this.isClickToShow()) {
        newChildProps.onClick = (0, _createChainedFunction2["default"])(this.onClick, childProps.onClick);
        newChildProps.onMouseDown = (0, _createChainedFunction2["default"])(this.onMouseDown, childProps.onMouseDown);
        newChildProps.onTouchStart = (0, _createChainedFunction2["default"])(this.onTouchStart, childProps.onTouchStart);
      }
      if (this.isMouseEnterToShow()) {
        newChildProps.onMouseEnter = (0, _createChainedFunction2["default"])(this.onMouseEnter, childProps.onMouseEnter);
      }
      if (this.isMouseLeaveToHide()) {
        newChildProps.onMouseLeave = (0, _createChainedFunction2["default"])(this.onMouseLeave, childProps.onMouseLeave);
      }
      if (this.isFocusToShow() || this.isBlurToHide()) {
        newChildProps.onFocus = (0, _createChainedFunction2["default"])(this.onFocus, childProps.onFocus);
        newChildProps.onBlur = (0, _createChainedFunction2["default"])(this.onBlur, childProps.onBlur);
      }
      ALL_HANDLERS.forEach(function(handler) {
        var newFn = void 0;
        if (props[handler] && newChildProps[handler]) {
          newFn = (0, _createChainedFunction2["default"])(props[handler], newChildProps[handler]);
        } else {
          newFn = props[handler] || newChildProps[handler];
        }
        if (newFn) {
          newChildProps[handler] = newFn;
        }
      });
      return _react2["default"].cloneElement(child, newChildProps);
    }
  });
  exports["default"] = Trigger;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-trigger@1.6.1.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./lib": "./lib/index.js"
    }
  };
});

System.registerDynamic("npm:rc-trigger@1.6.1/lib/index.js", ["./Trigger"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./Trigger');
  return module.exports;
});

System.registerDynamic("npm:rc-time-picker@1.1.5/lib/util/selection.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  exports['default'] = createSelection;
  function createSelection(field, start, end) {
    if (field.createTextRange) {
      var selRange = field.createTextRange();
      selRange.collapse(true);
      selRange.moveStart('character', start);
      selRange.moveEnd('character', end);
      selRange.select();
      field.focus();
    } else if (field.setSelectionRange) {
      field.focus();
      field.setSelectionRange(start, end);
    } else if (typeof field.selectionStart !== 'undefined') {
      field.selectionStart = start;
      field.selectionEnd = end;
      field.focus();
    }
  }
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-time-picker@1.1.5/lib/module/Header.js", ["react", "../util/selection"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _utilSelection = $__require('../util/selection');
  var _utilSelection2 = _interopRequireDefault(_utilSelection);
  var Header = _react2['default'].createClass({
    displayName: 'Header',
    propTypes: {
      formatter: _react.PropTypes.object,
      prefixCls: _react.PropTypes.string,
      gregorianCalendarLocale: _react.PropTypes.object,
      locale: _react.PropTypes.object,
      disabledDate: _react.PropTypes.func,
      placeholder: _react.PropTypes.string,
      value: _react.PropTypes.object,
      hourOptions: _react.PropTypes.array,
      minuteOptions: _react.PropTypes.array,
      secondOptions: _react.PropTypes.array,
      disabledHours: _react.PropTypes.func,
      disabledMinutes: _react.PropTypes.func,
      disabledSeconds: _react.PropTypes.func,
      onChange: _react.PropTypes.func,
      onClear: _react.PropTypes.func,
      onEsc: _react.PropTypes.func,
      allowEmpty: _react.PropTypes.bool,
      currentSelectPanel: _react.PropTypes.string
    },
    getInitialState: function getInitialState() {
      var value = this.props.value;
      return {
        str: value && this.props.formatter.format(value) || '',
        invalid: false
      };
    },
    componentDidMount: function componentDidMount() {
      this.timer = setTimeout(this.selectRange, 0);
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      var value = nextProps.value;
      this.setState({
        str: value && nextProps.formatter.format(value) || '',
        invalid: false
      });
    },
    componentDidUpdate: function componentDidUpdate() {
      this.timer = setTimeout(this.selectRange, 0);
    },
    componentWillUnmount: function componentWillUnmount() {
      clearTimeout(this.timer);
    },
    onInputChange: function onInputChange(event) {
      var str = event.target.value;
      this.setState({str: str});
      var value = null;
      var _props = this.props;
      var formatter = _props.formatter;
      var gregorianCalendarLocale = _props.gregorianCalendarLocale;
      var hourOptions = _props.hourOptions;
      var minuteOptions = _props.minuteOptions;
      var secondOptions = _props.secondOptions;
      var disabledHours = _props.disabledHours;
      var disabledMinutes = _props.disabledMinutes;
      var disabledSeconds = _props.disabledSeconds;
      var onChange = _props.onChange;
      var allowEmpty = _props.allowEmpty;
      if (str) {
        var originalValue = this.props.value;
        try {
          value = formatter.parse(str, {
            locale: gregorianCalendarLocale,
            obeyCount: true
          });
        } catch (ex) {
          this.setState({invalid: true});
          return;
        }
        if (value) {
          if (hourOptions.indexOf(value.getHourOfDay()) < 0 || minuteOptions.indexOf(value.getMinutes()) < 0 || secondOptions.indexOf(value.getSeconds()) < 0) {
            this.setState({invalid: true});
            return;
          }
          var disabledHourOptions = disabledHours();
          var disabledMinuteOptions = disabledMinutes(value.getHourOfDay());
          var disabledSecondOptions = disabledSeconds(value.getHourOfDay(), value.getMinutes());
          if (disabledHourOptions && disabledHourOptions.indexOf(value.getHourOfDay()) >= 0 || disabledMinuteOptions && disabledMinuteOptions.indexOf(value.getMinutes()) >= 0 || disabledSecondOptions && disabledSecondOptions.indexOf(value.getSeconds()) >= 0) {
            this.setState({invalid: true});
            return;
          }
          if (originalValue && value) {
            if (originalValue.getHourOfDay() !== value.getHourOfDay() || originalValue.getMinutes() !== value.getMinutes() || originalValue.getSeconds() !== value.getSeconds()) {
              var changedValue = originalValue.clone();
              changedValue.setHourOfDay(value.getHourOfDay());
              changedValue.setMinutes(value.getMinutes());
              changedValue.setSeconds(value.getSeconds());
              onChange(changedValue);
            }
          } else if (originalValue !== value) {
            onChange(value);
          }
        } else {
          this.setState({invalid: true});
          return;
        }
      } else if (allowEmpty) {
        onChange(null);
      } else {
        this.setState({invalid: true});
        return;
      }
      this.setState({invalid: false});
    },
    onKeyDown: function onKeyDown(e) {
      if (e.keyCode === 27) {
        this.props.onEsc();
      }
    },
    onClear: function onClear() {
      this.setState({str: ''});
      this.props.onClear();
    },
    getClearButton: function getClearButton() {
      var _props2 = this.props;
      var locale = _props2.locale;
      var prefixCls = _props2.prefixCls;
      var allowEmpty = _props2.allowEmpty;
      if (!allowEmpty) {
        return null;
      }
      return _react2['default'].createElement('a', {
        className: prefixCls + '-clear-btn',
        role: 'button',
        title: locale.clear,
        onMouseDown: this.onClear
      });
    },
    getInput: function getInput() {
      var _props3 = this.props;
      var prefixCls = _props3.prefixCls;
      var placeholder = _props3.placeholder;
      var _state = this.state;
      var invalid = _state.invalid;
      var str = _state.str;
      var invalidClass = invalid ? prefixCls + '-input-invalid' : '';
      return _react2['default'].createElement('input', {
        className: prefixCls + '-input  ' + invalidClass,
        ref: 'input',
        onKeyDown: this.onKeyDown,
        value: str,
        placeholder: placeholder,
        onChange: this.onInputChange
      });
    },
    selectRange: function selectRange() {
      this.refs.input.select();
      if (this.props.currentSelectPanel && this.refs.input.value) {
        var selectionRangeStart = 0;
        var selectionRangeEnd = 0;
        if (this.props.currentSelectPanel === 'hour') {
          selectionRangeStart = 0;
          selectionRangeEnd = this.refs.input.value.indexOf(':');
        } else if (this.props.currentSelectPanel === 'minute') {
          selectionRangeStart = this.refs.input.value.indexOf(':') + 1;
          selectionRangeEnd = this.refs.input.value.lastIndexOf(':');
        } else if (this.props.currentSelectPanel === 'second') {
          selectionRangeStart = this.refs.input.value.lastIndexOf(':') + 1;
          selectionRangeEnd = this.refs.input.value.length;
        }
        if (selectionRangeEnd - selectionRangeStart === 2) {
          (0, _utilSelection2['default'])(this.refs.input, selectionRangeStart, selectionRangeEnd);
        }
      }
    },
    render: function render() {
      var prefixCls = this.props.prefixCls;
      return _react2['default'].createElement('div', {className: prefixCls + '-input-wrap'}, this.getInput(), this.getClearButton());
    }
  });
  exports['default'] = Header;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-time-picker@1.1.5/lib/module/Select.js", ["react", "react-dom", "classnames"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _reactDom = $__require('react-dom');
  var _reactDom2 = _interopRequireDefault(_reactDom);
  var _classnames2 = $__require('classnames');
  var _classnames3 = _interopRequireDefault(_classnames2);
  var scrollTo = function scrollTo(element, to, duration) {
    var requestAnimationFrame = window.requestAnimationFrame || function requestAnimationFrameTimeout() {
      return setTimeout(arguments[0], 10);
    };
    if (duration <= 0) {
      element.scrollTop = to;
      return;
    }
    var difference = to - element.scrollTop;
    var perTick = difference / duration * 10;
    requestAnimationFrame(function() {
      element.scrollTop = element.scrollTop + perTick;
      if (element.scrollTop === to)
        return;
      scrollTo(element, to, duration - 10);
    });
  };
  var Select = _react2['default'].createClass({
    displayName: 'Select',
    propTypes: {
      prefixCls: _react.PropTypes.string,
      options: _react.PropTypes.array,
      gregorianCalendarLocale: _react.PropTypes.object,
      selectedIndex: _react.PropTypes.number,
      type: _react.PropTypes.string,
      onSelect: _react.PropTypes.func,
      onMouseEnter: _react.PropTypes.func
    },
    componentDidMount: function componentDidMount() {
      this.scrollToSelected(0);
    },
    componentDidUpdate: function componentDidUpdate(prevProps) {
      if (prevProps.selectedIndex !== this.props.selectedIndex) {
        this.scrollToSelected(120);
      }
    },
    onSelect: function onSelect(value) {
      var _props = this.props;
      var onSelect = _props.onSelect;
      var type = _props.type;
      onSelect(type, value);
    },
    getOptions: function getOptions() {
      var _this = this;
      var _props2 = this.props;
      var options = _props2.options;
      var selectedIndex = _props2.selectedIndex;
      var prefixCls = _props2.prefixCls;
      return options.map(function(item, index) {
        var _classnames;
        var cls = (0, _classnames3['default'])((_classnames = {}, _defineProperty(_classnames, prefixCls + '-select-option-selected', selectedIndex === index), _defineProperty(_classnames, prefixCls + '-select-option-disabled', item.disabled), _classnames));
        var onclick = null;
        if (!item.disabled) {
          onclick = _this.onSelect.bind(_this, +item.value);
        }
        return _react2['default'].createElement('li', {
          className: cls,
          key: index,
          onClick: onclick,
          disabled: item.disabled
        }, item.value);
      });
    },
    scrollToSelected: function scrollToSelected(duration) {
      var select = _reactDom2['default'].findDOMNode(this);
      var list = _reactDom2['default'].findDOMNode(this.refs.list);
      var index = this.props.selectedIndex;
      if (index < 0) {
        index = 0;
      }
      var topOption = list.children[index];
      var to = topOption.offsetTop;
      scrollTo(select, to, duration);
    },
    render: function render() {
      if (this.props.options.length === 0) {
        return null;
      }
      var prefixCls = this.props.prefixCls;
      return _react2['default'].createElement('div', {
        className: prefixCls + '-select',
        onMouseEnter: this.props.onMouseEnter
      }, _react2['default'].createElement('ul', {ref: 'list'}, this.getOptions()));
    }
  });
  exports['default'] = Select;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-time-picker@1.1.5/lib/module/Combobox.js", ["react", "./Select", "gregorian-calendar"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _Select = $__require('./Select');
  var _Select2 = _interopRequireDefault(_Select);
  var _gregorianCalendar = $__require('gregorian-calendar');
  var _gregorianCalendar2 = _interopRequireDefault(_gregorianCalendar);
  var formatOption = function formatOption(option, disabledOptions) {
    var value = '' + option;
    if (option < 10) {
      value = '0' + option;
    }
    var disabled = false;
    if (disabledOptions && disabledOptions.indexOf(option) >= 0) {
      disabled = true;
    }
    return {
      value: value,
      disabled: disabled
    };
  };
  var Combobox = _react2['default'].createClass({
    displayName: 'Combobox',
    propTypes: {
      formatter: _react.PropTypes.object,
      prefixCls: _react.PropTypes.string,
      value: _react.PropTypes.object,
      onChange: _react.PropTypes.func,
      showHour: _react.PropTypes.bool,
      gregorianCalendarLocale: _react.PropTypes.object,
      showSecond: _react.PropTypes.bool,
      hourOptions: _react.PropTypes.array,
      minuteOptions: _react.PropTypes.array,
      secondOptions: _react.PropTypes.array,
      disabledHours: _react.PropTypes.func,
      disabledMinutes: _react.PropTypes.func,
      disabledSeconds: _react.PropTypes.func,
      onCurrentSelectPanelChange: _react.PropTypes.func
    },
    onItemChange: function onItemChange(type, itemValue) {
      var onChange = this.props.onChange;
      var value = this.props.value;
      if (value) {
        value = value.clone();
      } else {
        value = this.getNow().clone();
      }
      if (type === 'hour') {
        value.setHourOfDay(itemValue);
      } else if (type === 'minute') {
        value.setMinutes(itemValue);
      } else {
        value.setSeconds(itemValue);
      }
      onChange(value);
    },
    onEnterSelectPanel: function onEnterSelectPanel(range) {
      this.props.onCurrentSelectPanelChange(range);
    },
    getHourSelect: function getHourSelect(hour) {
      var _props = this.props;
      var prefixCls = _props.prefixCls;
      var hourOptions = _props.hourOptions;
      var disabledHours = _props.disabledHours;
      var showHour = _props.showHour;
      if (!showHour) {
        return null;
      }
      var disabledOptions = disabledHours();
      return _react2['default'].createElement(_Select2['default'], {
        prefixCls: prefixCls,
        options: hourOptions.map(function(option) {
          return formatOption(option, disabledOptions);
        }),
        selectedIndex: hourOptions.indexOf(hour),
        type: 'hour',
        onSelect: this.onItemChange,
        onMouseEnter: this.onEnterSelectPanel.bind(this, 'hour')
      });
    },
    getMinuteSelect: function getMinuteSelect(minute) {
      var _props2 = this.props;
      var prefixCls = _props2.prefixCls;
      var minuteOptions = _props2.minuteOptions;
      var disabledMinutes = _props2.disabledMinutes;
      var value = this.props.value || this.getNow();
      var disabledOptions = disabledMinutes(value.getHourOfDay());
      return _react2['default'].createElement(_Select2['default'], {
        prefixCls: prefixCls,
        options: minuteOptions.map(function(option) {
          return formatOption(option, disabledOptions);
        }),
        selectedIndex: minuteOptions.indexOf(minute),
        type: 'minute',
        onSelect: this.onItemChange,
        onMouseEnter: this.onEnterSelectPanel.bind(this, 'minute')
      });
    },
    getSecondSelect: function getSecondSelect(second) {
      var _props3 = this.props;
      var prefixCls = _props3.prefixCls;
      var secondOptions = _props3.secondOptions;
      var disabledSeconds = _props3.disabledSeconds;
      var showSecond = _props3.showSecond;
      if (!showSecond) {
        return null;
      }
      var value = this.props.value || this.getNow();
      var disabledOptions = disabledSeconds(value.getHourOfDay(), value.getMinutes());
      return _react2['default'].createElement(_Select2['default'], {
        prefixCls: prefixCls,
        options: secondOptions.map(function(option) {
          return formatOption(option, disabledOptions);
        }),
        selectedIndex: secondOptions.indexOf(second),
        type: 'second',
        onSelect: this.onItemChange,
        onMouseEnter: this.onEnterSelectPanel.bind(this, 'second')
      });
    },
    getNow: function getNow() {
      if (this.showNow) {
        return this.showNow;
      }
      var value = new _gregorianCalendar2['default'](this.props.gregorianCalendarLocale);
      value.setTime(Date.now());
      this.showNow = value;
      return value;
    },
    render: function render() {
      var prefixCls = this.props.prefixCls;
      var value = this.props.value || this.getNow();
      return _react2['default'].createElement('div', {className: prefixCls + '-combobox'}, this.getHourSelect(value.getHourOfDay()), this.getMinuteSelect(value.getMinutes()), this.getSecondSelect(value.getSeconds()));
    }
  });
  exports['default'] = Combobox;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-time-picker@1.1.5/lib/module/Panel.js", ["react", "../mixin/CommonMixin", "./Header", "./Combobox"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _mixinCommonMixin = $__require('../mixin/CommonMixin');
  var _mixinCommonMixin2 = _interopRequireDefault(_mixinCommonMixin);
  var _Header = $__require('./Header');
  var _Header2 = _interopRequireDefault(_Header);
  var _Combobox = $__require('./Combobox');
  var _Combobox2 = _interopRequireDefault(_Combobox);
  function noop() {}
  function generateOptions(length, disabledOptions, hideDisabledOptions) {
    var arr = [];
    for (var value = 0; value < length; value++) {
      if (!disabledOptions || disabledOptions.indexOf(value) < 0 || !hideDisabledOptions) {
        arr.push(value);
      }
    }
    return arr;
  }
  var Panel = _react2['default'].createClass({
    displayName: 'Panel',
    propTypes: {
      prefixCls: _react.PropTypes.string,
      value: _react.PropTypes.object,
      locale: _react.PropTypes.object,
      placeholder: _react.PropTypes.string,
      gregorianCalendarLocale: _react.PropTypes.object,
      formatter: _react.PropTypes.object,
      disabledHours: _react.PropTypes.func,
      disabledMinutes: _react.PropTypes.func,
      disabledSeconds: _react.PropTypes.func,
      hideDisabledOptions: _react.PropTypes.bool,
      onChange: _react.PropTypes.func,
      onEsc: _react.PropTypes.func,
      allowEmpty: _react.PropTypes.bool,
      showHour: _react.PropTypes.bool,
      showSecond: _react.PropTypes.bool,
      onClear: _react.PropTypes.func
    },
    mixins: [_mixinCommonMixin2['default']],
    getDefaultProps: function getDefaultProps() {
      return {
        onChange: noop,
        onClear: noop
      };
    },
    getInitialState: function getInitialState() {
      return {
        value: this.props.value,
        selectionRange: []
      };
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      var value = nextProps.value;
      if (value) {
        this.setState({value: value});
      }
    },
    onChange: function onChange(newValue) {
      this.setState({value: newValue});
      this.props.onChange(newValue);
    },
    onClear: function onClear() {
      this.props.onClear();
    },
    onCurrentSelectPanelChange: function onCurrentSelectPanelChange(currentSelectPanel) {
      this.setState({currentSelectPanel: currentSelectPanel});
    },
    render: function render() {
      var _props = this.props;
      var locale = _props.locale;
      var prefixCls = _props.prefixCls;
      var placeholder = _props.placeholder;
      var disabledHours = _props.disabledHours;
      var disabledMinutes = _props.disabledMinutes;
      var disabledSeconds = _props.disabledSeconds;
      var hideDisabledOptions = _props.hideDisabledOptions;
      var allowEmpty = _props.allowEmpty;
      var showHour = _props.showHour;
      var showSecond = _props.showSecond;
      var formatter = _props.formatter;
      var gregorianCalendarLocale = _props.gregorianCalendarLocale;
      var value = this.state.value;
      var disabledHourOptions = disabledHours();
      var disabledMinuteOptions = disabledMinutes(value ? value.getHourOfDay() : null);
      var disabledSecondOptions = disabledSeconds(value ? value.getHourOfDay() : null, value ? value.getMinutes() : null);
      var hourOptions = generateOptions(24, disabledHourOptions, hideDisabledOptions);
      var minuteOptions = generateOptions(60, disabledMinuteOptions, hideDisabledOptions);
      var secondOptions = generateOptions(60, disabledSecondOptions, hideDisabledOptions);
      return _react2['default'].createElement('div', {className: prefixCls + '-inner'}, _react2['default'].createElement(_Header2['default'], {
        prefixCls: prefixCls,
        gregorianCalendarLocale: gregorianCalendarLocale,
        locale: locale,
        value: value,
        currentSelectPanel: this.state.currentSelectPanel,
        onEsc: this.props.onEsc,
        formatter: formatter,
        placeholder: placeholder,
        hourOptions: hourOptions,
        minuteOptions: minuteOptions,
        secondOptions: secondOptions,
        disabledHours: disabledHours,
        disabledMinutes: disabledMinutes,
        disabledSeconds: disabledSeconds,
        onChange: this.onChange,
        onClear: this.onClear,
        allowEmpty: allowEmpty
      }), _react2['default'].createElement(_Combobox2['default'], {
        prefixCls: prefixCls,
        value: value,
        gregorianCalendarLocale: gregorianCalendarLocale,
        formatter: formatter,
        onChange: this.onChange,
        showHour: showHour,
        showSecond: showSecond,
        hourOptions: hourOptions,
        minuteOptions: minuteOptions,
        secondOptions: secondOptions,
        disabledHours: disabledHours,
        disabledMinutes: disabledMinutes,
        disabledSeconds: disabledSeconds,
        onCurrentSelectPanelChange: this.onCurrentSelectPanelChange
      }));
    }
  });
  exports['default'] = Panel;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-time-picker@1.1.5/lib/util/placements.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  var autoAdjustOverflow = {
    adjustX: 1,
    adjustY: 1
  };
  var targetOffset = [0, 0];
  var placements = {
    bottomLeft: {
      points: ['tl', 'tl'],
      overflow: autoAdjustOverflow,
      offset: [0, -3],
      targetOffset: targetOffset
    },
    bottomRight: {
      points: ['tr', 'tr'],
      overflow: autoAdjustOverflow,
      offset: [0, -3],
      targetOffset: targetOffset
    },
    topRight: {
      points: ['br', 'br'],
      overflow: autoAdjustOverflow,
      offset: [0, 3],
      targetOffset: targetOffset
    },
    topLeft: {
      points: ['bl', 'bl'],
      overflow: autoAdjustOverflow,
      offset: [0, 3],
      targetOffset: targetOffset
    }
  };
  exports['default'] = placements;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-time-picker@1.1.5/lib/locale/en_US.js", ["gregorian-calendar-format/lib/locale/en_US", "gregorian-calendar/lib/locale/en_US"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _gregorianCalendarFormatLibLocaleEn_US = $__require('gregorian-calendar-format/lib/locale/en_US');
  var _gregorianCalendarFormatLibLocaleEn_US2 = _interopRequireDefault(_gregorianCalendarFormatLibLocaleEn_US);
  var _gregorianCalendarLibLocaleEn_US = $__require('gregorian-calendar/lib/locale/en_US');
  var _gregorianCalendarLibLocaleEn_US2 = _interopRequireDefault(_gregorianCalendarLibLocaleEn_US);
  exports['default'] = {
    clear: 'Clear',
    format: _gregorianCalendarFormatLibLocaleEn_US2['default'],
    calendar: _gregorianCalendarLibLocaleEn_US2['default']
  };
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-time-picker@1.1.5/lib/mixin/CommonMixin.js", ["react", "../locale/en_US"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _react = $__require('react');
  var _localeEn_US = $__require('../locale/en_US');
  var _localeEn_US2 = _interopRequireDefault(_localeEn_US);
  exports['default'] = {
    propTypes: {
      prefixCls: _react.PropTypes.string,
      locale: _react.PropTypes.object
    },
    getDefaultProps: function getDefaultProps() {
      return {
        prefixCls: 'rc-time-picker',
        locale: _localeEn_US2['default']
      };
    }
  };
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:gregorian-calendar@4.1.4/lib/utils.js", ["./const"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Const = $__require('./const');
  var floor = Math.floor;
  var ACCUMULATED_DAYS_IN_MONTH = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ACCUMULATED_DAYS_IN_MONTH_LEAP = [0, 31, 59 + 1, 90 + 1, 120 + 1, 151 + 1, 181 + 1, 212 + 1, 243 + 1, 273 + 1, 304 + 1, 334 + 1];
  var DAYS_OF_YEAR = 365;
  var DAYS_OF_4YEAR = 365 * 4 + 1;
  var DAYS_OF_100YEAR = DAYS_OF_4YEAR * 25 - 1;
  var DAYS_OF_400YEAR = DAYS_OF_100YEAR * 4 + 1;
  var _exports = {};
  function getDayOfYear(year, month, dayOfMonth) {
    return dayOfMonth + (_exports.isLeapYear(year) ? ACCUMULATED_DAYS_IN_MONTH_LEAP[month] : ACCUMULATED_DAYS_IN_MONTH[month]);
  }
  function getDayOfWeekFromFixedDate(fixedDate) {
    if (fixedDate >= 0) {
      return fixedDate % 7;
    }
    return _exports.mod(fixedDate, 7);
  }
  function getGregorianYearFromFixedDate(fixedDate) {
    var d0 = undefined;
    var d1 = undefined;
    var d2 = undefined;
    var d3 = undefined;
    var n400 = undefined;
    var n100 = undefined;
    var n4 = undefined;
    var n1 = undefined;
    var year = undefined;
    d0 = fixedDate - 1;
    n400 = floor(d0 / DAYS_OF_400YEAR);
    d1 = _exports.mod(d0, DAYS_OF_400YEAR);
    n100 = floor(d1 / DAYS_OF_100YEAR);
    d2 = _exports.mod(d1, DAYS_OF_100YEAR);
    n4 = floor(d2 / DAYS_OF_4YEAR);
    d3 = _exports.mod(d2, DAYS_OF_4YEAR);
    n1 = floor(d3 / DAYS_OF_YEAR);
    year = 400 * n400 + 100 * n100 + 4 * n4 + n1;
    if (!(n100 === 4 || n1 === 4)) {
      ++year;
    }
    return year;
  }
  _exports = module.exports = {
    each: function each(arr, fn) {
      for (var i = 0,
          len = arr.length; i < len; i++) {
        if (fn(arr[i], i, arr) === false) {
          break;
        }
      }
    },
    mix: function mix(t, s) {
      for (var p in s) {
        if (s.hasOwnProperty(p)) {
          t[p] = s[p];
        }
      }
    },
    isLeapYear: function isLeapYear(year) {
      if ((year & 3) !== 0) {
        return false;
      }
      return year % 100 !== 0 || year % 400 === 0;
    },
    mod: function mod(x, y) {
      return x - y * floor(x / y);
    },
    getFixedDate: function getFixedDate(year, month, dayOfMonth) {
      var prevYear = year - 1;
      return DAYS_OF_YEAR * prevYear + floor(prevYear / 4) - floor(prevYear / 100) + floor(prevYear / 400) + getDayOfYear(year, month, dayOfMonth);
    },
    getGregorianDateFromFixedDate: function getGregorianDateFromFixedDate(fixedDate) {
      var year = getGregorianYearFromFixedDate(fixedDate);
      var jan1 = _exports.getFixedDate(year, Const.JANUARY, 1);
      var isLeap = _exports.isLeapYear(year);
      var ACCUMULATED_DAYS = isLeap ? ACCUMULATED_DAYS_IN_MONTH_LEAP : ACCUMULATED_DAYS_IN_MONTH;
      var daysDiff = fixedDate - jan1;
      var month = undefined;
      for (var i = 0; i < ACCUMULATED_DAYS.length; i++) {
        if (ACCUMULATED_DAYS[i] <= daysDiff) {
          month = i;
        } else {
          break;
        }
      }
      var dayOfMonth = fixedDate - jan1 - ACCUMULATED_DAYS[month] + 1;
      var dayOfWeek = getDayOfWeekFromFixedDate(fixedDate);
      return {
        year: year,
        month: month,
        dayOfMonth: dayOfMonth,
        dayOfWeek: dayOfWeek,
        isLeap: isLeap
      };
    }
  };
  return module.exports;
});

System.registerDynamic("npm:gregorian-calendar@4.1.4/lib/locale/en_US.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {
    timezoneOffset: -8 * 60,
    firstDayOfWeek: 0,
    minimalDaysInFirstWeek: 1
  };
  return module.exports;
});

System.registerDynamic("npm:gregorian-calendar@4.1.4/lib/const.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {
    SUNDAY: 0,
    MONDAY: 1,
    TUESDAY: 2,
    WEDNESDAY: 3,
    THURSDAY: 4,
    FRIDAY: 5,
    SATURDAY: 6,
    JANUARY: 0,
    FEBRUARY: 1,
    MARCH: 2,
    APRIL: 3,
    MAY: 4,
    JUNE: 5,
    JULY: 6,
    AUGUST: 7,
    SEPTEMBER: 8,
    OCTOBER: 9,
    NOVEMBER: 10,
    DECEMBER: 11
  };
  return module.exports;
});

System.registerDynamic("npm:gregorian-calendar@4.1.4.json", [], false, function() {
  return {
    "main": "lib/gregorian-calendar.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:gregorian-calendar@4.1.4/lib/gregorian-calendar.js", ["./utils", "./locale/en_US", "./const"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var toInt = parseInt;
  var Utils = $__require('./utils');
  var defaultLocale = $__require('./locale/en_US');
  var Const = $__require('./const');
  function GregorianCalendar(loc) {
    var locale = loc || defaultLocale;
    this.locale = locale;
    this.fields = [];
    this.time = undefined;
    this.timezoneOffset = locale.timezoneOffset;
    this.firstDayOfWeek = locale.firstDayOfWeek;
    this.minimalDaysInFirstWeek = locale.minimalDaysInFirstWeek;
    this.fieldsComputed = false;
  }
  Utils.mix(GregorianCalendar, Const);
  Utils.mix(GregorianCalendar, {
    Utils: Utils,
    defaultLocale: defaultLocale,
    isLeapYear: Utils.isLeapYear,
    YEAR: 1,
    MONTH: 2,
    DAY_OF_MONTH: 3,
    HOUR_OF_DAY: 4,
    MINUTES: 5,
    SECONDS: 6,
    MILLISECONDS: 7,
    WEEK_OF_YEAR: 8,
    WEEK_OF_MONTH: 9,
    DAY_OF_YEAR: 10,
    DAY_OF_WEEK: 11,
    DAY_OF_WEEK_IN_MONTH: 12,
    AM: 0,
    PM: 1
  });
  var FIELDS = ['', 'Year', 'Month', 'DayOfMonth', 'HourOfDay', 'Minutes', 'Seconds', 'Milliseconds', 'WeekOfYear', 'WeekOfMonth', 'DayOfYear', 'DayOfWeek', 'DayOfWeekInMonth'];
  var YEAR = GregorianCalendar.YEAR;
  var MONTH = GregorianCalendar.MONTH;
  var DAY_OF_MONTH = GregorianCalendar.DAY_OF_MONTH;
  var HOUR_OF_DAY = GregorianCalendar.HOUR_OF_DAY;
  var MINUTE = GregorianCalendar.MINUTES;
  var SECONDS = GregorianCalendar.SECONDS;
  var MILLISECONDS = GregorianCalendar.MILLISECONDS;
  var DAY_OF_WEEK_IN_MONTH = GregorianCalendar.DAY_OF_WEEK_IN_MONTH;
  var DAY_OF_YEAR = GregorianCalendar.DAY_OF_YEAR;
  var DAY_OF_WEEK = GregorianCalendar.DAY_OF_WEEK;
  var WEEK_OF_MONTH = GregorianCalendar.WEEK_OF_MONTH;
  var WEEK_OF_YEAR = GregorianCalendar.WEEK_OF_YEAR;
  var MONTH_LENGTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var LEAP_MONTH_LENGTH = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var ONE_SECOND = 1000;
  var ONE_MINUTE = 60 * ONE_SECOND;
  var ONE_HOUR = 60 * ONE_MINUTE;
  var ONE_DAY = 24 * ONE_HOUR;
  var ONE_WEEK = ONE_DAY * 7;
  var EPOCH_OFFSET = 719163;
  var mod = Utils.mod;
  var _isLeapYear = Utils.isLeapYear;
  var floorDivide = Math.floor;
  var MIN_VALUES = [undefined, 1, GregorianCalendar.JANUARY, 1, 0, 0, 0, 0, 1, undefined, 1, GregorianCalendar.SUNDAY, 1];
  var MAX_VALUES = [undefined, 292278994, GregorianCalendar.DECEMBER, undefined, 23, 59, 59, 999, undefined, undefined, undefined, GregorianCalendar.SATURDAY, undefined];
  function getMonthLength(year, month) {
    return _isLeapYear(year) ? LEAP_MONTH_LENGTH[month] : MONTH_LENGTH[month];
  }
  function getYearLength(year) {
    return _isLeapYear(year) ? 366 : 365;
  }
  function adjustDayOfMonth(self) {
    var fields = self.fields;
    var year = fields[YEAR];
    var month = fields[MONTH];
    var monthLen = getMonthLength(year, month);
    var dayOfMonth = fields[DAY_OF_MONTH];
    if (dayOfMonth > monthLen) {
      self.set(DAY_OF_MONTH, monthLen);
    }
  }
  function getDayOfWeekDateOnOrBefore(fixedDate, dayOfWeek) {
    return fixedDate - mod(fixedDate - dayOfWeek, 7);
  }
  function getWeekNumber(self, fixedDay1, fixedDate) {
    var fixedDay1st = getDayOfWeekDateOnOrBefore(fixedDay1 + 6, self.firstDayOfWeek);
    var nDays = fixedDay1st - fixedDay1;
    if (nDays >= self.minimalDaysInFirstWeek) {
      fixedDay1st -= 7;
    }
    var normalizedDayOfPeriod = fixedDate - fixedDay1st;
    return floorDivide(normalizedDayOfPeriod / 7) + 1;
  }
  GregorianCalendar.prototype = {
    constructor: GregorianCalendar,
    isGregorianCalendar: 1,
    isLeapYear: function isLeapYear() {
      return _isLeapYear(this.getYear());
    },
    getLocale: function getLocale() {
      return this.locale;
    },
    getActualMinimum: function getActualMinimum(field) {
      if (MIN_VALUES[field] !== undefined) {
        return MIN_VALUES[field];
      }
      if (field === WEEK_OF_MONTH) {
        var cal = this.clone();
        cal.clear();
        cal.set(this.fields[YEAR], this.fields[MONTH], 1);
        return cal.get(WEEK_OF_MONTH);
      }
      throw new Error('minimum value not defined!');
    },
    getActualMaximum: function getActualMaximum(field) {
      if (MAX_VALUES[field] !== undefined) {
        return MAX_VALUES[field];
      }
      var value = undefined;
      var fields = this.fields;
      switch (field) {
        case DAY_OF_MONTH:
          value = getMonthLength(fields[YEAR], fields[MONTH]);
          break;
        case WEEK_OF_YEAR:
          var endOfYear = this.clone();
          endOfYear.clear();
          endOfYear.set(fields[YEAR], GregorianCalendar.DECEMBER, 31);
          value = endOfYear.get(WEEK_OF_YEAR);
          if (value === 1) {
            value = 52;
          }
          break;
        case WEEK_OF_MONTH:
          var endOfMonth = this.clone();
          endOfMonth.clear();
          endOfMonth.set(fields[YEAR], fields[MONTH], getMonthLength(fields[YEAR], fields[MONTH]));
          value = endOfMonth.get(WEEK_OF_MONTH);
          break;
        case DAY_OF_YEAR:
          value = getYearLength(fields[YEAR]);
          break;
        case DAY_OF_WEEK_IN_MONTH:
          value = toInt((getMonthLength(fields[YEAR], fields[MONTH]) - 1) / 7) + 1;
          break;
        default:
          break;
      }
      if (value === undefined) {
        throw new Error('maximum value not defined!');
      }
      return value;
    },
    isSet: function isSet(field) {
      return this.fields[field] !== undefined;
    },
    computeFields: function computeFields() {
      var time = this.time;
      var timezoneOffset = this.timezoneOffset * ONE_MINUTE;
      var fixedDate = toInt(timezoneOffset / ONE_DAY);
      var timeOfDay = timezoneOffset % ONE_DAY;
      fixedDate += toInt(time / ONE_DAY);
      timeOfDay += time % ONE_DAY;
      if (timeOfDay >= ONE_DAY) {
        timeOfDay -= ONE_DAY;
        fixedDate++;
      } else {
        while (timeOfDay < 0) {
          timeOfDay += ONE_DAY;
          fixedDate--;
        }
      }
      fixedDate += EPOCH_OFFSET;
      var date = Utils.getGregorianDateFromFixedDate(fixedDate);
      var year = date.year;
      var fields = this.fields;
      fields[YEAR] = year;
      fields[MONTH] = date.month;
      fields[DAY_OF_MONTH] = date.dayOfMonth;
      fields[DAY_OF_WEEK] = date.dayOfWeek;
      if (timeOfDay !== 0) {
        fields[HOUR_OF_DAY] = toInt(timeOfDay / ONE_HOUR);
        var r = timeOfDay % ONE_HOUR;
        fields[MINUTE] = toInt(r / ONE_MINUTE);
        r %= ONE_MINUTE;
        fields[SECONDS] = toInt(r / ONE_SECOND);
        fields[MILLISECONDS] = r % ONE_SECOND;
      } else {
        fields[HOUR_OF_DAY] = fields[MINUTE] = fields[SECONDS] = fields[MILLISECONDS] = 0;
      }
      var fixedDateJan1 = Utils.getFixedDate(year, GregorianCalendar.JANUARY, 1);
      var dayOfYear = fixedDate - fixedDateJan1 + 1;
      var fixDateMonth1 = fixedDate - date.dayOfMonth + 1;
      fields[DAY_OF_YEAR] = dayOfYear;
      fields[DAY_OF_WEEK_IN_MONTH] = toInt((date.dayOfMonth - 1) / 7) + 1;
      var weekOfYear = getWeekNumber(this, fixedDateJan1, fixedDate);
      if (weekOfYear === 0) {
        var fixedDec31 = fixedDateJan1 - 1;
        var prevJan1 = fixedDateJan1 - getYearLength(year - 1);
        weekOfYear = getWeekNumber(this, prevJan1, fixedDec31);
      } else if (weekOfYear >= 52) {
        var nextJan1 = fixedDateJan1 + getYearLength(year);
        var nextJan1st = getDayOfWeekDateOnOrBefore(nextJan1 + 6, this.firstDayOfWeek);
        var nDays = nextJan1st - nextJan1;
        if (nDays >= this.minimalDaysInFirstWeek && fixedDate >= nextJan1st - 7) {
          weekOfYear = 1;
        }
      }
      fields[WEEK_OF_YEAR] = weekOfYear;
      fields[WEEK_OF_MONTH] = getWeekNumber(this, fixDateMonth1, fixedDate);
      this.fieldsComputed = true;
    },
    computeTime: function computeTime() {
      var year = undefined;
      var fields = this.fields;
      if (this.isSet(YEAR)) {
        year = fields[YEAR];
      } else {
        year = new Date().getFullYear();
      }
      var timeOfDay = 0;
      if (this.isSet(HOUR_OF_DAY)) {
        timeOfDay += fields[HOUR_OF_DAY];
      }
      timeOfDay *= 60;
      timeOfDay += fields[MINUTE] || 0;
      timeOfDay *= 60;
      timeOfDay += fields[SECONDS] || 0;
      timeOfDay *= 1000;
      timeOfDay += fields[MILLISECONDS] || 0;
      var fixedDate = 0;
      fields[YEAR] = year;
      fixedDate = fixedDate + this.getFixedDate();
      var millis = (fixedDate - EPOCH_OFFSET) * ONE_DAY + timeOfDay;
      millis -= this.timezoneOffset * ONE_MINUTE;
      this.time = millis;
      this.computeFields();
    },
    complete: function complete() {
      if (this.time === undefined) {
        this.computeTime();
      }
      if (!this.fieldsComputed) {
        this.computeFields();
      }
    },
    getFixedDate: function getFixedDate() {
      var self = this;
      var fields = self.fields;
      var firstDayOfWeekCfg = self.firstDayOfWeek;
      var year = fields[YEAR];
      var month = GregorianCalendar.JANUARY;
      if (self.isSet(MONTH)) {
        month = fields[MONTH];
        if (month > GregorianCalendar.DECEMBER) {
          year += toInt(month / 12);
          month %= 12;
        } else if (month < GregorianCalendar.JANUARY) {
          year += floorDivide(month / 12);
          month = mod(month, 12);
        }
      }
      var fixedDate = Utils.getFixedDate(year, month, 1);
      var firstDayOfWeek = undefined;
      var dayOfWeek = self.firstDayOfWeek;
      if (self.isSet(DAY_OF_WEEK)) {
        dayOfWeek = fields[DAY_OF_WEEK];
      }
      if (self.isSet(MONTH)) {
        if (self.isSet(DAY_OF_MONTH)) {
          fixedDate += fields[DAY_OF_MONTH] - 1;
        } else {
          if (self.isSet(WEEK_OF_MONTH)) {
            firstDayOfWeek = getDayOfWeekDateOnOrBefore(fixedDate + 6, firstDayOfWeekCfg);
            if (firstDayOfWeek - fixedDate >= self.minimalDaysInFirstWeek) {
              firstDayOfWeek -= 7;
            }
            if (dayOfWeek !== firstDayOfWeekCfg) {
              firstDayOfWeek = getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6, dayOfWeek);
            }
            fixedDate = firstDayOfWeek + 7 * (fields[WEEK_OF_MONTH] - 1);
          } else {
            var dowim = undefined;
            if (self.isSet(DAY_OF_WEEK_IN_MONTH)) {
              dowim = fields[DAY_OF_WEEK_IN_MONTH];
            } else {
              dowim = 1;
            }
            var lastDate = 7 * dowim;
            if (dowim < 0) {
              lastDate = getMonthLength(year, month) + 7 * (dowim + 1);
            }
            fixedDate = getDayOfWeekDateOnOrBefore(fixedDate + lastDate - 1, dayOfWeek);
          }
        }
      } else {
        if (self.isSet(DAY_OF_YEAR)) {
          fixedDate += fields[DAY_OF_YEAR] - 1;
        } else if (self.isSet(WEEK_OF_YEAR)) {
          firstDayOfWeek = getDayOfWeekDateOnOrBefore(fixedDate + 6, firstDayOfWeekCfg);
          if (firstDayOfWeek - fixedDate >= self.minimalDaysInFirstWeek) {
            firstDayOfWeek -= 7;
          }
          if (dayOfWeek !== firstDayOfWeekCfg) {
            firstDayOfWeek = getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6, dayOfWeek);
          }
          fixedDate = firstDayOfWeek + 7 * (fields[WEEK_OF_YEAR] - 1);
        }
      }
      return fixedDate;
    },
    getTime: function getTime() {
      if (this.time === undefined) {
        this.computeTime();
      }
      return this.time;
    },
    setTime: function setTime(time) {
      this.time = time;
      this.fieldsComputed = false;
      this.complete();
    },
    get: function get(field) {
      this.complete();
      return this.fields[field];
    },
    set: function set(field, v) {
      var len = arguments.length;
      if (len === 2) {
        this.fields[field] = v;
      } else if (len < MILLISECONDS + 1) {
        for (var i = 0; i < len; i++) {
          this.fields[YEAR + i] = arguments[i];
        }
      } else {
        throw new Error('illegal arguments for GregorianCalendar set');
      }
      this.time = undefined;
    },
    add: function add(field, a) {
      if (!a) {
        return;
      }
      var amount = a;
      var self = this;
      var fields = self.fields;
      var value = self.get(field);
      if (field === YEAR) {
        value += amount;
        self.set(YEAR, value);
        adjustDayOfMonth(self);
      } else if (field === MONTH) {
        value += amount;
        var yearAmount = floorDivide(value / 12);
        value = mod(value, 12);
        if (yearAmount) {
          self.set(YEAR, fields[YEAR] + yearAmount);
        }
        self.set(MONTH, value);
        adjustDayOfMonth(self);
      } else {
        switch (field) {
          case HOUR_OF_DAY:
            amount *= ONE_HOUR;
            break;
          case MINUTE:
            amount *= ONE_MINUTE;
            break;
          case SECONDS:
            amount *= ONE_SECOND;
            break;
          case MILLISECONDS:
            break;
          case WEEK_OF_MONTH:
          case WEEK_OF_YEAR:
          case DAY_OF_WEEK_IN_MONTH:
            amount *= ONE_WEEK;
            break;
          case DAY_OF_WEEK:
          case DAY_OF_YEAR:
          case DAY_OF_MONTH:
            amount *= ONE_DAY;
            break;
          default:
            throw new Error('illegal field for add');
        }
        self.setTime(self.time + amount);
      }
    },
    getRolledValue: function getRolledValue(value, a, min, max) {
      var amount = a;
      var diff = value - min;
      var range = max - min + 1;
      amount %= range;
      return min + (diff + amount + range) % range;
    },
    roll: function roll(field, amount) {
      if (!amount) {
        return;
      }
      var self = this;
      var value = self.get(field);
      var min = self.getActualMinimum(field);
      var max = self.getActualMaximum(field);
      value = self.getRolledValue(value, amount, min, max);
      self.set(field, value);
      switch (field) {
        case MONTH:
          adjustDayOfMonth(self);
          break;
        default:
          self.updateFieldsBySet(field);
          break;
      }
    },
    rollSet: function rollSet(field, v) {
      this.set(field, v);
      switch (field) {
        case MONTH:
          adjustDayOfMonth(this);
          break;
        default:
          this.updateFieldsBySet(field);
          break;
      }
    },
    updateFieldsBySet: function updateFieldsBySet(field) {
      var fields = this.fields;
      switch (field) {
        case WEEK_OF_MONTH:
          fields[DAY_OF_MONTH] = undefined;
          break;
        case DAY_OF_YEAR:
          fields[MONTH] = undefined;
          break;
        case DAY_OF_WEEK:
          fields[DAY_OF_MONTH] = undefined;
          break;
        case WEEK_OF_YEAR:
          fields[DAY_OF_YEAR] = undefined;
          fields[MONTH] = undefined;
          break;
        default:
          break;
      }
    },
    getTimezoneOffset: function getTimezoneOffset() {
      return this.timezoneOffset;
    },
    setTimezoneOffset: function setTimezoneOffset(timezoneOffset) {
      if (this.timezoneOffset !== timezoneOffset) {
        this.fieldsComputed = undefined;
        this.timezoneOffset = timezoneOffset;
      }
    },
    setFirstDayOfWeek: function setFirstDayOfWeek(firstDayOfWeek) {
      if (this.firstDayOfWeek !== firstDayOfWeek) {
        this.firstDayOfWeek = firstDayOfWeek;
        this.fieldsComputed = false;
      }
    },
    getFirstDayOfWeek: function getFirstDayOfWeek() {
      return this.firstDayOfWeek;
    },
    setMinimalDaysInFirstWeek: function setMinimalDaysInFirstWeek(minimalDaysInFirstWeek) {
      if (this.minimalDaysInFirstWeek !== minimalDaysInFirstWeek) {
        this.minimalDaysInFirstWeek = minimalDaysInFirstWeek;
        this.fieldsComputed = false;
      }
    },
    getMinimalDaysInFirstWeek: function getMinimalDaysInFirstWeek() {
      return this.minimalDaysInFirstWeek;
    },
    getWeeksInWeekYear: function getWeeksInWeekYear() {
      var weekYear = this.getWeekYear();
      if (weekYear === this.get(YEAR)) {
        return this.getActualMaximum(WEEK_OF_YEAR);
      }
      var gc = this.clone();
      gc.clear();
      gc.setWeekDate(weekYear, 2, this.get(DAY_OF_WEEK));
      return gc.getActualMaximum(WEEK_OF_YEAR);
    },
    getWeekYear: function getWeekYear() {
      var year = this.get(YEAR);
      var weekOfYear = this.get(WEEK_OF_YEAR);
      var month = this.get(MONTH);
      if (month === GregorianCalendar.JANUARY) {
        if (weekOfYear >= 52) {
          --year;
        }
      } else if (month === GregorianCalendar.DECEMBER) {
        if (weekOfYear === 1) {
          ++year;
        }
      }
      return year;
    },
    setWeekDate: function setWeekDate(weekYear, weekOfYear, dayOfWeek) {
      if (dayOfWeek < GregorianCalendar.SUNDAY || dayOfWeek > GregorianCalendar.SATURDAY) {
        throw new Error('invalid dayOfWeek: ' + dayOfWeek);
      }
      var fields = this.fields;
      var gc = this.clone();
      gc.clear();
      gc.setTimezoneOffset(0);
      gc.set(YEAR, weekYear);
      gc.set(WEEK_OF_YEAR, 1);
      gc.set(DAY_OF_WEEK, this.getFirstDayOfWeek());
      var days = dayOfWeek - this.getFirstDayOfWeek();
      if (days < 0) {
        days += 7;
      }
      days += 7 * (weekOfYear - 1);
      if (days !== 0) {
        gc.add(DAY_OF_YEAR, days);
      } else {
        gc.complete();
      }
      fields[YEAR] = gc.get(YEAR);
      fields[MONTH] = gc.get(MONTH);
      fields[DAY_OF_MONTH] = gc.get(DAY_OF_MONTH);
      this.complete();
    },
    clone: function clone() {
      if (this.time === undefined) {
        this.computeTime();
      }
      var cal = new GregorianCalendar(this.locale);
      cal.setTimezoneOffset(cal.getTimezoneOffset());
      cal.setFirstDayOfWeek(cal.getFirstDayOfWeek());
      cal.setMinimalDaysInFirstWeek(cal.getMinimalDaysInFirstWeek());
      cal.setTime(this.time);
      return cal;
    },
    equals: function equals(obj) {
      return this.getTime() === obj.getTime() && this.firstDayOfWeek === obj.firstDayOfWeek && this.timezoneOffset === obj.timezoneOffset && this.minimalDaysInFirstWeek === obj.minimalDaysInFirstWeek;
    },
    compareToDay: function compareToDay(d2) {
      var d1Year = this.getYear();
      var d2Year = d2.getYear();
      var d1Month = this.getMonth();
      var d2Month = d2.getMonth();
      var d1Day = this.getDayOfMonth();
      var d2Day = d2.getDayOfMonth();
      if (d1Year !== d2Year) {
        return d1Year - d2Year;
      }
      if (d1Month !== d2Month) {
        return d1Month - d2Month;
      }
      return d1Day - d2Day;
    },
    clear: function clear(field) {
      if (field === undefined) {
        this.field = [];
      } else {
        this.fields[field] = undefined;
      }
      this.time = undefined;
      this.fieldsComputed = false;
    },
    toString: function toString() {
      var v = this;
      return '[GregorianCalendar]: ' + v.getYear() + '/' + v.getMonth() + '/' + v.getDayOfMonth() + ' ' + v.getHourOfDay() + ':' + v.getMinutes() + ':' + v.getSeconds();
    }
  };
  var GregorianCalendarProto = GregorianCalendar.prototype;
  Utils.each(FIELDS, function(f, index) {
    if (f) {
      GregorianCalendarProto['get' + f] = function get() {
        return this.get(index);
      };
      GregorianCalendarProto['isSet' + f] = function isSet() {
        return this.isSet(index);
      };
      GregorianCalendarProto['set' + f] = function set(v) {
        return this.set(index, v);
      };
      GregorianCalendarProto['add' + f] = function add(v) {
        return this.add(index, v);
      };
      GregorianCalendarProto['roll' + f] = function roll(v) {
        return this.roll(index, v);
      };
      GregorianCalendarProto['rollSet' + f] = function rollSet(v) {
        return this.rollSet(index, v);
      };
    }
  });
  module.exports = GregorianCalendar;
  return module.exports;
});

System.registerDynamic("npm:gregorian-calendar-format@4.1.3/lib/locale/en_US.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {
    eras: ['BC', 'AD'],
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    shortWeekdays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    veryShortWeekdays: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    ampms: ['AM', 'PM'],
    datePatterns: ['EEEE, MMMM d, yyyy', 'MMMM d, yyyy', 'MMM d, yyyy', 'M/d/yy'],
    timePatterns: ['h:mm:ss a \'GMT\'Z', 'h:mm:ss a', 'h:mm:ss a', 'h:mm a'],
    dateTimePattern: '{date} {time}'
  };
  return module.exports;
});

System.registerDynamic("npm:warning@2.1.0.json", [], false, function() {
  return {
    "main": "warning.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./warning.js": {
        "browser": "./browser.js"
      }
    }
  };
});

System.registerDynamic("npm:warning@2.1.0/browser.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var warning = function() {};
  if ("production" !== 'production') {
    warning = function(condition, format, args) {
      var len = arguments.length;
      args = new Array(len > 2 ? len - 2 : 0);
      for (var key = 2; key < len; key++) {
        args[key - 2] = arguments[key];
      }
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }
      if (format.length < 10 || (/^[s\W]*$/).test(format)) {
        throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
      }
      if (!condition) {
        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {}
      }
    };
  }
  module.exports = warning;
  return module.exports;
});

System.registerDynamic("npm:gregorian-calendar-format@4.1.3.json", [], false, function() {
  return {
    "main": "lib/gregorian-calendar-format.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:gregorian-calendar-format@4.1.3/lib/gregorian-calendar-format.js", ["gregorian-calendar", "./locale/en_US", "warning"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var GregorianCalendar = $__require('gregorian-calendar');
  var enUsLocale = $__require('./locale/en_US');
  var MAX_VALUE = Number.MAX_VALUE;
  var warning = $__require('warning');
  var DateTimeStyle = {
    FULL: 0,
    LONG: 1,
    MEDIUM: 2,
    SHORT: 3
  };
  var patternChars = new Array(GregorianCalendar.DAY_OF_WEEK_IN_MONTH + 2).join('1');
  var ERA = 0;
  var calendarIndexMap = {};
  patternChars = patternChars.split('');
  patternChars[ERA] = 'G';
  patternChars[GregorianCalendar.YEAR] = 'y';
  patternChars[GregorianCalendar.MONTH] = 'M';
  patternChars[GregorianCalendar.DAY_OF_MONTH] = 'd';
  patternChars[GregorianCalendar.HOUR_OF_DAY] = 'H';
  patternChars[GregorianCalendar.MINUTES] = 'm';
  patternChars[GregorianCalendar.SECONDS] = 's';
  patternChars[GregorianCalendar.MILLISECONDS] = 'S';
  patternChars[GregorianCalendar.WEEK_OF_YEAR] = 'w';
  patternChars[GregorianCalendar.WEEK_OF_MONTH] = 'W';
  patternChars[GregorianCalendar.DAY_OF_YEAR] = 'D';
  patternChars[GregorianCalendar.DAY_OF_WEEK_IN_MONTH] = 'F';
  patternChars.push('Y');
  patternChars.forEach(function(v, key) {
    var k = key;
    if (v === 'Y') {
      k = GregorianCalendar.YEAR;
    }
    if (v) {
      calendarIndexMap[v] = k;
    }
  });
  function mix(t, s) {
    for (var p in s) {
      if (s.hasOwnProperty(p)) {
        t[p] = s[p];
      }
    }
  }
  var SUBSTITUTE_REG = /\\?\{([^{}]+)\}/g;
  var EMPTY = '';
  function substitute(str, o, regexp) {
    if (typeof str !== 'string' || !o) {
      return str;
    }
    return str.replace(regexp || SUBSTITUTE_REG, function(match, name) {
      if (match.charAt(0) === '\\') {
        return match.slice(1);
      }
      return o[name] === undefined ? EMPTY : o[name];
    });
  }
  patternChars = patternChars.join('') + 'ahkKZE';
  function encode(lastField, count, compiledPattern) {
    compiledPattern.push({
      field: lastField,
      count: count
    });
  }
  function compile(pattern) {
    var length = pattern.length;
    var inQuote = false;
    var compiledPattern = [];
    var tmpBuffer = null;
    var count = 0;
    var lastField = -1;
    for (var i = 0; i < length; i++) {
      var c = pattern.charAt(i);
      if (c === '\'') {
        if (i + 1 < length) {
          c = pattern.charAt(i + 1);
          if (c === '\'') {
            i++;
            if (count !== 0) {
              encode(lastField, count, compiledPattern);
              lastField = -1;
              count = 0;
            }
            if (inQuote) {
              tmpBuffer += c;
            }
            continue;
          }
        }
        if (!inQuote) {
          if (count !== 0) {
            encode(lastField, count, compiledPattern);
            lastField = -1;
            count = 0;
          }
          tmpBuffer = '';
          inQuote = true;
        } else {
          compiledPattern.push({text: tmpBuffer});
          inQuote = false;
        }
        continue;
      }
      if (inQuote) {
        tmpBuffer += c;
        continue;
      }
      if (!(c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')) {
        if (count !== 0) {
          encode(lastField, count, compiledPattern);
          lastField = -1;
          count = 0;
        }
        compiledPattern.push({text: c});
        continue;
      }
      if (patternChars.indexOf(c) === -1) {
        throw new Error('Illegal pattern character "' + c + '"');
      }
      if (lastField === -1 || lastField === c) {
        lastField = c;
        count++;
        continue;
      }
      encode(lastField, count, compiledPattern);
      lastField = c;
      count = 1;
    }
    if (inQuote) {
      throw new Error('Unterminated quote');
    }
    if (count !== 0) {
      encode(lastField, count, compiledPattern);
    }
    return compiledPattern;
  }
  var zeroDigit = '0';
  function zeroPaddingNumber(_x, _x2, _x3, _x4) {
    var _again = true;
    _function: while (_again) {
      var value = _x,
          minDigits = _x2,
          maxDigits_ = _x3,
          b = _x4;
      _again = false;
      var buffer = b || [];
      var maxDigits = maxDigits_ || MAX_VALUE;
      if (value >= 0) {
        if (value < 100 && minDigits >= 1 && minDigits <= 2) {
          if (value < 10 && minDigits === 2) {
            buffer.push(zeroDigit);
          }
          buffer.push(value);
          return buffer.join('');
        } else if (value >= 1000 && value < 10000) {
          if (minDigits === 4) {
            buffer.push(value);
            return buffer.join('');
          }
          if (minDigits === 2 && maxDigits === 2) {
            _x = value % 100;
            _x2 = 2;
            _x3 = 2;
            _x4 = buffer;
            _again = true;
            buffer = maxDigits = undefined;
            continue _function;
          }
        }
      }
      buffer.push(value + '');
      return buffer.join('');
    }
  }
  function DateTimeFormat(pattern, locale) {
    this.locale = locale || enUsLocale;
    this.originalPattern = pattern;
    this.pattern = compile(pattern);
  }
  function formatField(field, count, locale, calendar) {
    var current = undefined;
    var value = undefined;
    switch (field) {
      case 'G':
        value = calendar.getYear() > 0 ? 1 : 0;
        current = locale.eras[value];
        break;
      case 'Y':
        value = calendar.getWeekYear();
        if (value <= 0) {
          value = 1 - value;
        }
        current = zeroPaddingNumber(value, 2, count !== 2 ? MAX_VALUE : 2);
        break;
      case 'y':
        value = calendar.getYear();
        if (value <= 0) {
          value = 1 - value;
        }
        current = zeroPaddingNumber(value, 2, count !== 2 ? MAX_VALUE : 2);
        break;
      case 'M':
        value = calendar.getMonth();
        if (count >= 4) {
          current = locale.months[value];
        } else if (count === 3) {
          current = locale.shortMonths[value];
        } else {
          current = zeroPaddingNumber(value + 1, count);
        }
        break;
      case 'k':
        current = zeroPaddingNumber(calendar.getHourOfDay() || 24, count);
        break;
      case 'E':
        value = calendar.getDayOfWeek();
        current = count >= 4 ? locale.weekdays[value] : locale.shortWeekdays[value];
        break;
      case 'a':
        current = locale.ampms[calendar.getHourOfDay() >= 12 ? 1 : 0];
        break;
      case 'h':
        current = zeroPaddingNumber(calendar.getHourOfDay() % 12 || 12, count);
        break;
      case 'K':
        current = zeroPaddingNumber(calendar.getHourOfDay() % 12, count);
        break;
      case 'Z':
        var offset = calendar.getTimezoneOffset();
        var parts = [offset < 0 ? '-' : '+'];
        offset = Math.abs(offset);
        parts.push(zeroPaddingNumber(Math.floor(offset / 60) % 100, 2), zeroPaddingNumber(offset % 60, 2));
        current = parts.join('');
        break;
      default:
        var index = calendarIndexMap[field];
        value = calendar.get(index);
        current = zeroPaddingNumber(value, count);
    }
    return current;
  }
  function matchPartString(dateStr, startIndex, match, mLen) {
    for (var i = 0; i < mLen; i++) {
      if (dateStr.charAt(startIndex + i) !== match.charAt(i)) {
        return false;
      }
    }
    return true;
  }
  function matchField(dateStr, startIndex, matches) {
    var matchedLen = -1;
    var index = -1;
    var i = undefined;
    var len = matches.length;
    for (i = 0; i < len; i++) {
      var m = matches[i];
      var mLen = m.length;
      if (mLen > matchedLen && matchPartString(dateStr, startIndex, m, mLen)) {
        matchedLen = mLen;
        index = i;
      }
    }
    return index >= 0 ? {
      value: index,
      startIndex: startIndex + matchedLen
    } : null;
  }
  function getLeadingNumberLen(str) {
    var i = undefined;
    var c = undefined;
    var len = str.length;
    for (i = 0; i < len; i++) {
      c = str.charAt(i);
      if (c < '0' || c > '9') {
        break;
      }
    }
    return i;
  }
  function matchNumber(dateStr, startIndex, count, obeyCount) {
    var str = dateStr;
    var n = undefined;
    if (obeyCount) {
      if (dateStr.length < startIndex + count) {
        return null;
      }
      str = dateStr.slice(startIndex, startIndex + count);
      if (!str.match(/^\d+$/)) {
        throw new Error('GregorianCalendarFormat parse error, dateStr: ' + dateStr + ', patter: ' + this.originalPattern);
      }
    } else {
      str = str.slice(startIndex);
    }
    n = parseInt(str, 10);
    if (isNaN(n)) {
      throw new Error('GregorianCalendarFormat parse error, dateStr: ' + dateStr + ', patter: ' + this.originalPattern);
    }
    return {
      value: n,
      startIndex: startIndex + getLeadingNumberLen(str)
    };
  }
  function parseField(calendar, dateStr, startIndex_, field, count, obeyCount, tmp) {
    var match = undefined;
    var year = undefined;
    var hour = undefined;
    var startIndex = startIndex_;
    if (dateStr.length <= startIndex) {
      return startIndex;
    }
    var locale = this.locale;
    switch (field) {
      case 'G':
        match = matchField(dateStr, startIndex, locale.eras);
        if (match) {
          if (calendar.isSetYear()) {
            if (match.value === 0) {
              year = calendar.getYear();
              calendar.setYear(1 - year);
            }
          } else {
            tmp.era = match.value;
          }
        }
        break;
      case 'y':
        match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
        if (match) {
          year = match.value;
          if ('era' in tmp) {
            if (tmp.era === 0) {
              year = 1 - year;
            }
          }
          calendar.setYear(year);
        }
        break;
      case 'M':
        var month = undefined;
        if (count >= 3) {
          match = matchField(dateStr, startIndex, locale[count === 3 ? 'shortMonths' : 'months']);
          if (match) {
            month = match.value;
          }
        } else {
          match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
          if (match) {
            month = match.value - 1;
          }
        }
        if (match) {
          calendar.setMonth(month);
        }
        break;
      case 'k':
        match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
        if (match) {
          calendar.setHourOfDay(match.value % 24);
        }
        break;
      case 'E':
        match = matchField(dateStr, startIndex, locale[count > 3 ? 'weekdays' : 'shortWeekdays']);
        if (match) {
          calendar.setDayOfWeek(match.value);
        }
        break;
      case 'a':
        match = matchField(dateStr, startIndex, locale.ampms);
        if (match) {
          if (calendar.isSetHourOfDay()) {
            if (match.value) {
              hour = calendar.getHourOfDay();
              if (hour < 12) {
                calendar.setHourOfDay((hour + 12) % 24);
              }
            }
          } else {
            tmp.ampm = match.value;
          }
        }
        break;
      case 'h':
        match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
        if (match) {
          hour = match.value %= 12;
          if (tmp.ampm) {
            hour += 12;
          }
          calendar.setHourOfDay(hour);
        }
        break;
      case 'K':
        match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
        if (match) {
          hour = match.value;
          if (tmp.ampm) {
            hour += 12;
          }
          calendar.setHourOfDay(hour);
        }
        break;
      case 'Z':
        var zoneChar = dateStr.charAt(startIndex);
        if (zoneChar === '-') {
          startIndex++;
        } else if (zoneChar === '+') {
          startIndex++;
        } else {
          break;
        }
        match = matchNumber.call(this, dateStr, startIndex, 2, true);
        if (match) {
          var zoneOffset = match.value * 60;
          startIndex = match.startIndex;
          match = matchNumber.call(this, dateStr, startIndex, 2, true);
          if (match) {
            zoneOffset += match.value;
          }
          calendar.setTimezoneOffset(zoneOffset);
        }
        break;
      default:
        match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
        if (match) {
          var index = calendarIndexMap[field];
          calendar.set(index, match.value);
        }
    }
    if (match) {
      startIndex = match.startIndex;
    }
    return startIndex;
  }
  mix(DateTimeFormat.prototype, {
    format: function format(calendar) {
      if (!calendar.isGregorianCalendar) {
        throw new Error('calendar must be type of GregorianCalendar');
      }
      var i = undefined;
      var ret = [];
      var pattern = this.pattern;
      var len = pattern.length;
      for (i = 0; i < len; i++) {
        var comp = pattern[i];
        if (comp.text) {
          ret.push(comp.text);
        } else if ('field' in comp) {
          ret.push(formatField(comp.field, comp.count, this.locale, calendar));
        }
      }
      return ret.join('');
    },
    parse: function parse(dateStr, option_) {
      var option = option_ || {};
      var calendarLocale = option.locale;
      var calendar = new GregorianCalendar(calendarLocale);
      var i = undefined;
      var j = undefined;
      var tmp = {};
      var obeyCount = option.obeyCount || false;
      var dateStrLen = dateStr.length;
      var errorIndex = -1;
      var startIndex = 0;
      var oldStartIndex = 0;
      var pattern = this.pattern;
      var len = pattern.length;
      loopPattern: {
        for (i = 0; errorIndex < 0 && i < len; i++) {
          var comp = pattern[i];
          var text = undefined;
          var textLen = undefined;
          oldStartIndex = startIndex;
          text = comp.text;
          if (text) {
            textLen = text.length;
            if (textLen + startIndex > dateStrLen) {
              errorIndex = startIndex;
            } else {
              for (j = 0; j < textLen; j++) {
                if (text.charAt(j) !== dateStr.charAt(j + startIndex)) {
                  errorIndex = startIndex;
                  break loopPattern;
                }
              }
              startIndex += textLen;
            }
          } else if ('field' in comp) {
            if (!option.obeyCount) {
              var nextComp = pattern[i + 1];
              obeyCount = false;
              if (nextComp) {
                if ('field' in nextComp) {
                  obeyCount = true;
                } else {
                  var c = nextComp.text.charAt(0);
                  if (c >= '0' && c <= '9') {
                    obeyCount = true;
                  }
                }
              }
            }
            startIndex = parseField.call(this, calendar, dateStr, startIndex, comp.field, comp.count, obeyCount, tmp);
            if (startIndex === oldStartIndex) {
              errorIndex = startIndex;
            }
          }
        }
      }
      if (errorIndex >= 0) {
        warning(false, 'error when parsing date: ' + dateStr + ', position: ' + dateStr.slice(0, errorIndex) + '^');
        return undefined;
      }
      return calendar;
    }
  });
  mix(DateTimeFormat, {
    Style: DateTimeStyle,
    getInstance: function getInstance(locale) {
      return this.getDateTimeInstance(DateTimeStyle.SHORT, DateTimeStyle.SHORT, locale);
    },
    getDateInstance: function getDateInstance(dateStyle, locale) {
      return this.getDateTimeInstance(dateStyle, undefined, locale);
    },
    getDateTimeInstance: function getDateTimeInstance(dateStyle, timeStyle, locale_) {
      var locale = locale_ || enUsLocale;
      var datePattern = '';
      if (dateStyle !== undefined) {
        datePattern = locale.datePatterns[dateStyle];
      }
      var timePattern = '';
      if (timeStyle !== undefined) {
        timePattern = locale.timePatterns[timeStyle];
      }
      var pattern = datePattern;
      if (timePattern) {
        if (datePattern) {
          pattern = substitute(locale.dateTimePattern, {
            date: datePattern,
            time: timePattern
          });
        } else {
          pattern = timePattern;
        }
      }
      return new DateTimeFormat(pattern, locale);
    },
    getTimeInstance: function getTimeInstance(timeStyle, locale) {
      return this.getDateTimeInstance(undefined, timeStyle, locale);
    }
  });
  module.exports = DateTimeFormat;
  DateTimeFormat.version = '@VERSION@';
  return module.exports;
});

System.registerDynamic("npm:rc-time-picker@1.1.5/lib/util/index.js", ["gregorian-calendar-format"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  exports.getFormatter = getFormatter;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _gregorianCalendarFormat = $__require('gregorian-calendar-format');
  var _gregorianCalendarFormat2 = _interopRequireDefault(_gregorianCalendarFormat);
  function getFormatter(format, locale) {
    if (typeof format === 'string') {
      return new _gregorianCalendarFormat2['default'](format, locale.format);
    }
    return format;
  }
  return module.exports;
});

System.registerDynamic("npm:rc-time-picker@1.1.5/lib/TimePicker.js", ["react", "rc-trigger", "./module/Panel", "./util/placements", "./mixin/CommonMixin", "./util/index"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _rcTrigger = $__require('rc-trigger');
  var _rcTrigger2 = _interopRequireDefault(_rcTrigger);
  var _modulePanel = $__require('./module/Panel');
  var _modulePanel2 = _interopRequireDefault(_modulePanel);
  var _utilPlacements = $__require('./util/placements');
  var _utilPlacements2 = _interopRequireDefault(_utilPlacements);
  var _mixinCommonMixin = $__require('./mixin/CommonMixin');
  var _mixinCommonMixin2 = _interopRequireDefault(_mixinCommonMixin);
  var _utilIndex = $__require('./util/index');
  function noop() {}
  function refFn(field, component) {
    this[field] = component;
  }
  var Picker = _react2['default'].createClass({
    displayName: 'Picker',
    propTypes: {
      prefixCls: _react.PropTypes.string,
      locale: _react.PropTypes.object,
      value: _react.PropTypes.object,
      disabled: _react.PropTypes.bool,
      allowEmpty: _react.PropTypes.bool,
      defaultValue: _react.PropTypes.object,
      open: _react.PropTypes.bool,
      defaultOpen: _react.PropTypes.bool,
      align: _react.PropTypes.object,
      placement: _react.PropTypes.any,
      transitionName: _react.PropTypes.string,
      getPopupContainer: _react.PropTypes.func,
      placeholder: _react.PropTypes.string,
      formatter: _react.PropTypes.any,
      showHour: _react.PropTypes.bool,
      style: _react.PropTypes.object,
      className: _react.PropTypes.string,
      showSecond: _react.PropTypes.bool,
      disabledHours: _react.PropTypes.func,
      disabledMinutes: _react.PropTypes.func,
      disabledSeconds: _react.PropTypes.func,
      hideDisabledOptions: _react.PropTypes.bool,
      onChange: _react.PropTypes.func,
      onOpen: _react.PropTypes.func,
      onClose: _react.PropTypes.func
    },
    mixins: [_mixinCommonMixin2['default']],
    getDefaultProps: function getDefaultProps() {
      return {
        defaultOpen: false,
        style: {},
        className: '',
        align: {},
        allowEmpty: true,
        showHour: true,
        showSecond: true,
        disabledHours: noop,
        disabledMinutes: noop,
        disabledSeconds: noop,
        hideDisabledOptions: false,
        placement: 'bottomLeft',
        onChange: noop,
        onOpen: noop,
        onClose: noop
      };
    },
    getInitialState: function getInitialState() {
      this.savePanelRef = refFn.bind(this, 'panelInstance');
      var _props = this.props;
      var defaultOpen = _props.defaultOpen;
      var defaultValue = _props.defaultValue;
      var _props$open = _props.open;
      var open = _props$open === undefined ? defaultOpen : _props$open;
      var _props$value = _props.value;
      var value = _props$value === undefined ? defaultValue : _props$value;
      return {
        open: open,
        value: value
      };
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      var value = nextProps.value;
      var open = nextProps.open;
      if ('value' in nextProps) {
        this.setState({value: value});
      }
      if (open !== undefined) {
        this.setState({open: open});
      }
    },
    onPanelChange: function onPanelChange(value) {
      this.setValue(value);
    },
    onPanelClear: function onPanelClear() {
      this.setValue(null);
      this.setOpen(false);
    },
    onVisibleChange: function onVisibleChange(open) {
      this.setOpen(open);
    },
    onEsc: function onEsc() {
      this.setOpen(false);
      this.refs.picker.focus();
    },
    onKeyDown: function onKeyDown(e) {
      if (e.keyCode === 40) {
        this.setOpen(true);
      }
    },
    setValue: function setValue(value) {
      if (!('value' in this.props)) {
        this.setState({value: value});
      }
      this.props.onChange(value);
    },
    getFormatter: function getFormatter() {
      var formatter = this.props.formatter;
      var locale = this.props.locale;
      if (formatter) {
        if (formatter === this.lastFormatter) {
          return this.normalFormatter;
        }
        this.normalFormatter = (0, _utilIndex.getFormatter)(formatter, locale);
        this.lastFormatter = formatter;
        return this.normalFormatter;
      }
      if (!this.props.showSecond) {
        if (!this.notShowSecondFormatter) {
          this.notShowSecondFormatter = (0, _utilIndex.getFormatter)('HH:mm', locale);
        }
        return this.notShowSecondFormatter;
      }
      if (!this.props.showHour) {
        if (!this.notShowHourFormatter) {
          this.notShowHourFormatter = (0, _utilIndex.getFormatter)('mm:ss', locale);
        }
        return this.notShowHourFormatter;
      }
      if (!this.normalFormatter) {
        this.normalFormatter = (0, _utilIndex.getFormatter)('HH:mm:ss', locale);
      }
      return this.normalFormatter;
    },
    getPanelElement: function getPanelElement() {
      var _props2 = this.props;
      var prefixCls = _props2.prefixCls;
      var defaultValue = _props2.defaultValue;
      var locale = _props2.locale;
      var placeholder = _props2.placeholder;
      var disabledHours = _props2.disabledHours;
      var disabledMinutes = _props2.disabledMinutes;
      var disabledSeconds = _props2.disabledSeconds;
      var hideDisabledOptions = _props2.hideDisabledOptions;
      var allowEmpty = _props2.allowEmpty;
      var showHour = _props2.showHour;
      var showSecond = _props2.showSecond;
      return _react2['default'].createElement(_modulePanel2['default'], {
        prefixCls: prefixCls + '-panel',
        ref: this.savePanelRef,
        value: this.state.value,
        onChange: this.onPanelChange,
        gregorianCalendarLocale: locale.calendar,
        onClear: this.onPanelClear,
        defaultValue: defaultValue,
        showHour: showHour,
        onEsc: this.onEsc,
        showSecond: showSecond,
        locale: locale,
        allowEmpty: allowEmpty,
        formatter: this.getFormatter(),
        placeholder: placeholder,
        disabledHours: disabledHours,
        disabledMinutes: disabledMinutes,
        disabledSeconds: disabledSeconds,
        hideDisabledOptions: hideDisabledOptions
      });
    },
    setOpen: function setOpen(open, callback) {
      var _props3 = this.props;
      var onOpen = _props3.onOpen;
      var onClose = _props3.onClose;
      if (this.state.open !== open) {
        this.setState({open: open}, callback);
        var _event = {open: open};
        if (open) {
          onOpen(_event);
        } else {
          onClose(_event);
        }
      }
    },
    render: function render() {
      var _props4 = this.props;
      var prefixCls = _props4.prefixCls;
      var placeholder = _props4.placeholder;
      var placement = _props4.placement;
      var align = _props4.align;
      var disabled = _props4.disabled;
      var transitionName = _props4.transitionName;
      var style = _props4.style;
      var className = _props4.className;
      var showHour = _props4.showHour;
      var showSecond = _props4.showSecond;
      var getPopupContainer = _props4.getPopupContainer;
      var _state = this.state;
      var open = _state.open;
      var value = _state.value;
      var popupClassName = undefined;
      if (!showHour || !showSecond) {
        popupClassName = prefixCls + '-panel-narrow';
      }
      return _react2['default'].createElement(_rcTrigger2['default'], {
        prefixCls: prefixCls + '-panel',
        popupClassName: popupClassName,
        popup: this.getPanelElement(),
        popupAlign: align,
        builtinPlacements: _utilPlacements2['default'],
        popupPlacement: placement,
        action: disabled ? [] : ['click'],
        destroyPopupOnHide: true,
        getPopupContainer: getPopupContainer,
        popupTransitionName: transitionName,
        popupVisible: open,
        onPopupVisibleChange: this.onVisibleChange
      }, _react2['default'].createElement('span', {
        className: prefixCls + ' ' + className,
        style: style
      }, _react2['default'].createElement('input', {
        className: prefixCls + '-input',
        ref: 'picker',
        type: 'text',
        placeholder: placeholder,
        readOnly: true,
        onKeyDown: this.onKeyDown,
        disabled: disabled,
        value: value && this.getFormatter().format(value) || ''
      }), _react2['default'].createElement('span', {className: prefixCls + '-icon'})));
    }
  });
  exports['default'] = Picker;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:rc-time-picker@1.1.5.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./lib": "./lib/index.js",
      "./lib/util": "./lib/util/index.js"
    }
  };
});

System.registerDynamic("npm:rc-time-picker@1.1.5/lib/index.js", ["./TimePicker"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _TimePicker = $__require('./TimePicker');
  var _TimePicker2 = _interopRequireDefault(_TimePicker);
  exports['default'] = _TimePicker2['default'];
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:moment@2.14.1.json", [], false, function() {
  return {
    "main": "./moment.js",
    "map": {
      "moment": "./moment"
    }
  };
});

(function() {
var define = System.amdDefine;
;
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define("npm:moment@2.14.1/moment.js", [], factory) : global.moment = factory();
}(this, function() {
  'use strict';
  var hookCallback;
  function utils_hooks__hooks() {
    return hookCallback.apply(null, arguments);
  }
  function setHookCallback(callback) {
    hookCallback = callback;
  }
  function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
  }
  function isObject(input) {
    return Object.prototype.toString.call(input) === '[object Object]';
  }
  function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
      return false;
    }
    return true;
  }
  function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
  }
  function map(arr, fn) {
    var res = [],
        i;
    for (i = 0; i < arr.length; ++i) {
      res.push(fn(arr[i], i));
    }
    return res;
  }
  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }
  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }
    if (hasOwnProp(b, 'toString')) {
      a.toString = b.toString;
    }
    if (hasOwnProp(b, 'valueOf')) {
      a.valueOf = b.valueOf;
    }
    return a;
  }
  function create_utc__createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
  }
  function defaultParsingFlags() {
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false,
      parsedDateParts: [],
      meridiem: null
    };
  }
  function getParsingFlags(m) {
    if (m._pf == null) {
      m._pf = defaultParsingFlags();
    }
    return m._pf;
  }
  var some;
  if (Array.prototype.some) {
    some = Array.prototype.some;
  } else {
    some = function(fun) {
      var t = Object(this);
      var len = t.length >>> 0;
      for (var i = 0; i < len; i++) {
        if (i in t && fun.call(this, t[i], i, t)) {
          return true;
        }
      }
      return false;
    };
  }
  function valid__isValid(m) {
    if (m._isValid == null) {
      var flags = getParsingFlags(m);
      var parsedParts = some.call(flags.parsedDateParts, function(i) {
        return i != null;
      });
      m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || (flags.meridiem && parsedParts));
      if (m._strict) {
        m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
      }
    }
    return m._isValid;
  }
  function valid__createInvalid(flags) {
    var m = create_utc__createUTC(NaN);
    if (flags != null) {
      extend(getParsingFlags(m), flags);
    } else {
      getParsingFlags(m).userInvalidated = true;
    }
    return m;
  }
  function isUndefined(input) {
    return input === void 0;
  }
  var momentProperties = utils_hooks__hooks.momentProperties = [];
  function copyConfig(to, from) {
    var i,
        prop,
        val;
    if (!isUndefined(from._isAMomentObject)) {
      to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
      to._i = from._i;
    }
    if (!isUndefined(from._f)) {
      to._f = from._f;
    }
    if (!isUndefined(from._l)) {
      to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
      to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
      to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
      to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
      to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
      to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
      to._locale = from._locale;
    }
    if (momentProperties.length > 0) {
      for (i in momentProperties) {
        prop = momentProperties[i];
        val = from[prop];
        if (!isUndefined(val)) {
          to[prop] = val;
        }
      }
    }
    return to;
  }
  var updateInProgress = false;
  function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (updateInProgress === false) {
      updateInProgress = true;
      utils_hooks__hooks.updateOffset(this);
      updateInProgress = false;
    }
  }
  function isMoment(obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
  }
  function absFloor(number) {
    if (number < 0) {
      return Math.ceil(number) || 0;
    } else {
      return Math.floor(number);
    }
  }
  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;
    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      value = absFloor(coercedNumber);
    }
    return value;
  }
  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
      if ((dontConvert && array1[i] !== array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
        diffs++;
      }
    }
    return diffs + lengthDiff;
  }
  function warn(msg) {
    if (utils_hooks__hooks.suppressDeprecationWarnings === false && (typeof console !== 'undefined') && console.warn) {
      console.warn('Deprecation warning: ' + msg);
    }
  }
  function deprecate(msg, fn) {
    var firstTime = true;
    return extend(function() {
      if (utils_hooks__hooks.deprecationHandler != null) {
        utils_hooks__hooks.deprecationHandler(null, msg);
      }
      if (firstTime) {
        warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
        firstTime = false;
      }
      return fn.apply(this, arguments);
    }, fn);
  }
  var deprecations = {};
  function deprecateSimple(name, msg) {
    if (utils_hooks__hooks.deprecationHandler != null) {
      utils_hooks__hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
      warn(msg);
      deprecations[name] = true;
    }
  }
  utils_hooks__hooks.suppressDeprecationWarnings = false;
  utils_hooks__hooks.deprecationHandler = null;
  function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }
  function locale_set__set(config) {
    var prop,
        i;
    for (i in config) {
      prop = config[i];
      if (isFunction(prop)) {
        this[i] = prop;
      } else {
        this['_' + i] = prop;
      }
    }
    this._config = config;
    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
  }
  function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig),
        prop;
    for (prop in childConfig) {
      if (hasOwnProp(childConfig, prop)) {
        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
          res[prop] = {};
          extend(res[prop], parentConfig[prop]);
          extend(res[prop], childConfig[prop]);
        } else if (childConfig[prop] != null) {
          res[prop] = childConfig[prop];
        } else {
          delete res[prop];
        }
      }
    }
    for (prop in parentConfig) {
      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
        res[prop] = extend({}, res[prop]);
      }
    }
    return res;
  }
  function Locale(config) {
    if (config != null) {
      this.set(config);
    }
  }
  var keys;
  if (Object.keys) {
    keys = Object.keys;
  } else {
    keys = function(obj) {
      var i,
          res = [];
      for (i in obj) {
        if (hasOwnProp(obj, i)) {
          res.push(i);
        }
      }
      return res;
    };
  }
  var defaultCalendar = {
    sameDay: '[Today at] LT',
    nextDay: '[Tomorrow at] LT',
    nextWeek: 'dddd [at] LT',
    lastDay: '[Yesterday at] LT',
    lastWeek: '[Last] dddd [at] LT',
    sameElse: 'L'
  };
  function locale_calendar__calendar(key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
  }
  var defaultLongDateFormat = {
    LTS: 'h:mm:ss A',
    LT: 'h:mm A',
    L: 'MM/DD/YYYY',
    LL: 'MMMM D, YYYY',
    LLL: 'MMMM D, YYYY h:mm A',
    LLLL: 'dddd, MMMM D, YYYY h:mm A'
  };
  function longDateFormat(key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];
    if (format || !formatUpper) {
      return format;
    }
    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
      return val.slice(1);
    });
    return this._longDateFormat[key];
  }
  var defaultInvalidDate = 'Invalid date';
  function invalidDate() {
    return this._invalidDate;
  }
  var defaultOrdinal = '%d';
  var defaultOrdinalParse = /\d{1,2}/;
  function ordinal(number) {
    return this._ordinal.replace('%d', number);
  }
  var defaultRelativeTime = {
    future: 'in %s',
    past: '%s ago',
    s: 'a few seconds',
    m: 'a minute',
    mm: '%d minutes',
    h: 'an hour',
    hh: '%d hours',
    d: 'a day',
    dd: '%d days',
    M: 'a month',
    MM: '%d months',
    y: 'a year',
    yy: '%d years'
  };
  function relative__relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
  }
  function pastFuture(diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
  }
  var aliases = {};
  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
  }
  function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
  }
  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;
    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);
        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }
    return normalizedInput;
  }
  var priorities = {};
  function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
  }
  function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
      units.push({
        unit: u,
        priority: priorities[u]
      });
    }
    units.sort(function(a, b) {
      return a.priority - b.priority;
    });
    return units;
  }
  function makeGetSet(unit, keepTime) {
    return function(value) {
      if (value != null) {
        get_set__set(this, unit, value);
        utils_hooks__hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get_set__get(this, unit);
      }
    };
  }
  function get_set__get(mom, unit) {
    return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
  }
  function get_set__set(mom, unit, value) {
    if (mom.isValid()) {
      mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
  }
  function stringGet(units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units]();
    }
    return this;
  }
  function stringSet(units, value) {
    if (typeof units === 'object') {
      units = normalizeObjectUnits(units);
      var prioritized = getPrioritizedUnits(units);
      for (var i = 0; i < prioritized.length; i++) {
        this[prioritized[i].unit](units[prioritized[i].unit]);
      }
    } else {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units](value);
      }
    }
    return this;
  }
  function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
  }
  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
  var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
  var formatFunctions = {};
  var formatTokenFunctions = {};
  function addFormatToken(token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
      func = function() {
        return this[callback]();
      };
    }
    if (token) {
      formatTokenFunctions[token] = func;
    }
    if (padded) {
      formatTokenFunctions[padded[0]] = function() {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }
    if (ordinal) {
      formatTokenFunctions[ordinal] = function() {
        return this.localeData().ordinal(func.apply(this, arguments), token);
      };
    }
  }
  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
  }
  function makeFormatFunction(format) {
    var array = format.match(formattingTokens),
        i,
        length;
    for (i = 0, length = array.length; i < length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }
    return function(mom) {
      var output = '',
          i;
      for (i = 0; i < length; i++) {
        output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
      }
      return output;
    };
  }
  function formatMoment(m, format) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }
    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
    return formatFunctions[format](m);
  }
  function expandFormat(format, locale) {
    var i = 5;
    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }
    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }
    return format;
  }
  var match1 = /\d/;
  var match2 = /\d\d/;
  var match3 = /\d{3}/;
  var match4 = /\d{4}/;
  var match6 = /[+-]?\d{6}/;
  var match1to2 = /\d\d?/;
  var match3to4 = /\d\d\d\d?/;
  var match5to6 = /\d\d\d\d\d\d?/;
  var match1to3 = /\d{1,3}/;
  var match1to4 = /\d{1,4}/;
  var match1to6 = /[+-]?\d{1,6}/;
  var matchUnsigned = /\d+/;
  var matchSigned = /[+-]?\d+/;
  var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
  var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
  var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
  var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var regexes = {};
  function addRegexToken(token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
      return (isStrict && strictRegex) ? strictRegex : regex;
    };
  }
  function getParseRegexForToken(token, config) {
    if (!hasOwnProp(regexes, token)) {
      return new RegExp(unescapeFormat(token));
    }
    return regexes[token](config._strict, config._locale);
  }
  function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
      return p1 || p2 || p3 || p4;
    }));
  }
  function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }
  var tokens = {};
  function addParseToken(token, callback) {
    var i,
        func = callback;
    if (typeof token === 'string') {
      token = [token];
    }
    if (typeof callback === 'number') {
      func = function(input, array) {
        array[callback] = toInt(input);
      };
    }
    for (i = 0; i < token.length; i++) {
      tokens[token[i]] = func;
    }
  }
  function addWeekParseToken(token, callback) {
    addParseToken(token, function(input, array, config, token) {
      config._w = config._w || {};
      callback(input, config._w, config, token);
    });
  }
  function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
      tokens[token](input, config._a, config, token);
    }
  }
  var YEAR = 0;
  var MONTH = 1;
  var DATE = 2;
  var HOUR = 3;
  var MINUTE = 4;
  var SECOND = 5;
  var MILLISECOND = 6;
  var WEEK = 7;
  var WEEKDAY = 8;
  var indexOf;
  if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
  } else {
    indexOf = function(o) {
      var i;
      for (i = 0; i < this.length; ++i) {
        if (this[i] === o) {
          return i;
        }
      }
      return -1;
    };
  }
  function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
  }
  addFormatToken('M', ['MM', 2], 'Mo', function() {
    return this.month() + 1;
  });
  addFormatToken('MMM', 0, 0, function(format) {
    return this.localeData().monthsShort(this, format);
  });
  addFormatToken('MMMM', 0, 0, function(format) {
    return this.localeData().months(this, format);
  });
  addUnitAlias('month', 'M');
  addUnitPriority('month', 8);
  addRegexToken('M', match1to2);
  addRegexToken('MM', match1to2, match2);
  addRegexToken('MMM', function(isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
  });
  addRegexToken('MMMM', function(isStrict, locale) {
    return locale.monthsRegex(isStrict);
  });
  addParseToken(['M', 'MM'], function(input, array) {
    array[MONTH] = toInt(input) - 1;
  });
  addParseToken(['MMM', 'MMMM'], function(input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  });
  var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
  function localeMonths(m, format) {
    return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
  }
  var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
  function localeMonthsShort(m, format) {
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
  }
  function units_month__handleStrictParse(monthName, format, strict) {
    var i,
        ii,
        mom,
        llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
      for (i = 0; i < 12; ++i) {
        mom = create_utc__createUTC([2000, i]);
        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeMonthsParse(monthName, format, strict) {
    var i,
        mom,
        regex;
    if (this._monthsParseExact) {
      return units_month__handleStrictParse.call(this, monthName, format, strict);
    }
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    }
    for (i = 0; i < 12; i++) {
      mom = create_utc__createUTC([2000, i]);
      if (strict && !this._longMonthsParse[i]) {
        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
      }
      if (!strict && !this._monthsParse[i]) {
        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
      }
      if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
        return i;
      } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
        return i;
      } else if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  }
  function setMonth(mom, value) {
    var dayOfMonth;
    if (!mom.isValid()) {
      return mom;
    }
    if (typeof value === 'string') {
      if (/^\d+$/.test(value)) {
        value = toInt(value);
      } else {
        value = mom.localeData().monthsParse(value);
        if (typeof value !== 'number') {
          return mom;
        }
      }
    }
    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
  }
  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      utils_hooks__hooks.updateOffset(this, true);
      return this;
    } else {
      return get_set__get(this, 'Month');
    }
  }
  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }
  var defaultMonthsShortRegex = matchWord;
  function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsShortStrictRegex;
      } else {
        return this._monthsShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsShortRegex')) {
        this._monthsShortRegex = defaultMonthsShortRegex;
      }
      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
    }
  }
  var defaultMonthsRegex = matchWord;
  function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsStrictRegex;
      } else {
        return this._monthsRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsRegex')) {
        this._monthsRegex = defaultMonthsRegex;
      }
      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
    }
  }
  function computeMonthsParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom;
    for (i = 0; i < 12; i++) {
      mom = create_utc__createUTC([2000, i]);
      shortPieces.push(this.monthsShort(mom, ''));
      longPieces.push(this.months(mom, ''));
      mixedPieces.push(this.months(mom, ''));
      mixedPieces.push(this.monthsShort(mom, ''));
    }
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }
    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
  }
  addFormatToken('Y', 0, 0, function() {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
  });
  addFormatToken(0, ['YY', 2], 0, function() {
    return this.year() % 100;
  });
  addFormatToken(0, ['YYYY', 4], 0, 'year');
  addFormatToken(0, ['YYYYY', 5], 0, 'year');
  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
  addUnitAlias('year', 'y');
  addUnitPriority('year', 1);
  addRegexToken('Y', matchSigned);
  addRegexToken('YY', match1to2, match2);
  addRegexToken('YYYY', match1to4, match4);
  addRegexToken('YYYYY', match1to6, match6);
  addRegexToken('YYYYYY', match1to6, match6);
  addParseToken(['YYYYY', 'YYYYYY'], YEAR);
  addParseToken('YYYY', function(input, array) {
    array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken('YY', function(input, array) {
    array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
  });
  addParseToken('Y', function(input, array) {
    array[YEAR] = parseInt(input, 10);
  });
  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }
  function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
  }
  utils_hooks__hooks.parseTwoDigitYear = function(input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  };
  var getSetYear = makeGetSet('FullYear', true);
  function getIsLeapYear() {
    return isLeapYear(this.year());
  }
  function createDate(y, m, d, h, M, s, ms) {
    var date = new Date(y, m, d, h, M, s, ms);
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
    return date;
  }
  function createUTCDate(y) {
    var date = new Date(Date.UTC.apply(null, arguments));
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
    return date;
  }
  function firstWeekOffset(year, dow, doy) {
    var fwd = 7 + dow - doy,
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
  }
  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear,
        resDayOfYear;
    if (dayOfYear <= 0) {
      resYear = year - 1;
      resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
      resYear = year + 1;
      resDayOfYear = dayOfYear - daysInYear(year);
    } else {
      resYear = year;
      resDayOfYear = dayOfYear;
    }
    return {
      year: resYear,
      dayOfYear: resDayOfYear
    };
  }
  function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek,
        resYear;
    if (week < 1) {
      resYear = mom.year() - 1;
      resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
      resWeek = week - weeksInYear(mom.year(), dow, doy);
      resYear = mom.year() + 1;
    } else {
      resYear = mom.year();
      resWeek = week;
    }
    return {
      week: resWeek,
      year: resYear
    };
  }
  function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  }
  addFormatToken('w', ['ww', 2], 'wo', 'week');
  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
  addUnitAlias('week', 'w');
  addUnitAlias('isoWeek', 'W');
  addUnitPriority('week', 5);
  addUnitPriority('isoWeek', 5);
  addRegexToken('w', match1to2);
  addRegexToken('ww', match1to2, match2);
  addRegexToken('W', match1to2);
  addRegexToken('WW', match1to2, match2);
  addWeekParseToken(['w', 'ww', 'W', 'WW'], function(input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
  });
  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }
  var defaultLocaleWeek = {
    dow: 0,
    doy: 6
  };
  function localeFirstDayOfWeek() {
    return this._week.dow;
  }
  function localeFirstDayOfYear() {
    return this._week.doy;
  }
  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
  }
  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
  }
  addFormatToken('d', 0, 'do', 'day');
  addFormatToken('dd', 0, 0, function(format) {
    return this.localeData().weekdaysMin(this, format);
  });
  addFormatToken('ddd', 0, 0, function(format) {
    return this.localeData().weekdaysShort(this, format);
  });
  addFormatToken('dddd', 0, 0, function(format) {
    return this.localeData().weekdays(this, format);
  });
  addFormatToken('e', 0, 0, 'weekday');
  addFormatToken('E', 0, 0, 'isoWeekday');
  addUnitAlias('day', 'd');
  addUnitAlias('weekday', 'e');
  addUnitAlias('isoWeekday', 'E');
  addUnitPriority('day', 11);
  addUnitPriority('weekday', 11);
  addUnitPriority('isoWeekday', 11);
  addRegexToken('d', match1to2);
  addRegexToken('e', match1to2);
  addRegexToken('E', match1to2);
  addRegexToken('dd', function(isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken('ddd', function(isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken('dddd', function(isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
  });
  addWeekParseToken(['dd', 'ddd', 'dddd'], function(input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken(['d', 'e', 'E'], function(input, week, config, token) {
    week[token] = toInt(input);
  });
  function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
      return input;
    }
    if (!isNaN(input)) {
      return parseInt(input, 10);
    }
    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
      return input;
    }
    return null;
  }
  function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
      return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
  }
  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
  function localeWeekdays(m, format) {
    return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
  }
  var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
  function localeWeekdaysShort(m) {
    return this._weekdaysShort[m.day()];
  }
  var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
  function localeWeekdaysMin(m) {
    return this._weekdaysMin[m.day()];
  }
  function day_of_week__handleStrictParse(weekdayName, format, strict) {
    var i,
        ii,
        mom,
        llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._minWeekdaysParse = [];
      for (i = 0; i < 7; ++i) {
        mom = create_utc__createUTC([2000, 1]).day(i);
        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeWeekdaysParse(weekdayName, format, strict) {
    var i,
        mom,
        regex;
    if (this._weekdaysParseExact) {
      return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
    }
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._minWeekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._fullWeekdaysParse = [];
    }
    for (i = 0; i < 7; i++) {
      mom = create_utc__createUTC([2000, 1]).day(i);
      if (strict && !this._fullWeekdaysParse[i]) {
        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
      }
      if (!this._weekdaysParse[i]) {
        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
      }
      if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
        return i;
      }
    }
  }
  function getSetDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, 'd');
    } else {
      return day;
    }
  }
  function getSetLocaleDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
  }
  function getSetISODayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      var weekday = parseIsoWeekday(input, this.localeData());
      return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
      return this.day() || 7;
    }
  }
  var defaultWeekdaysRegex = matchWord;
  function weekdaysRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysStrictRegex;
      } else {
        return this._weekdaysRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        this._weekdaysRegex = defaultWeekdaysRegex;
      }
      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
    }
  }
  var defaultWeekdaysShortRegex = matchWord;
  function weekdaysShortRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysShortStrictRegex;
      } else {
        return this._weekdaysShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysShortRegex')) {
        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
      }
      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
  }
  var defaultWeekdaysMinRegex = matchWord;
  function weekdaysMinRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysMinStrictRegex;
      } else {
        return this._weekdaysMinRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysMinRegex')) {
        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
      }
      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
  }
  function computeWeekdaysParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var minPieces = [],
        shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom,
        minp,
        shortp,
        longp;
    for (i = 0; i < 7; i++) {
      mom = create_utc__createUTC([2000, 1]).day(i);
      minp = this.weekdaysMin(mom, '');
      shortp = this.weekdaysShort(mom, '');
      longp = this.weekdays(mom, '');
      minPieces.push(minp);
      shortPieces.push(shortp);
      longPieces.push(longp);
      mixedPieces.push(minp);
      mixedPieces.push(shortp);
      mixedPieces.push(longp);
    }
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }
    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;
    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
  }
  function hFormat() {
    return this.hours() % 12 || 12;
  }
  function kFormat() {
    return this.hours() || 24;
  }
  addFormatToken('H', ['HH', 2], 0, 'hour');
  addFormatToken('h', ['hh', 2], 0, hFormat);
  addFormatToken('k', ['kk', 2], 0, kFormat);
  addFormatToken('hmm', 0, 0, function() {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });
  addFormatToken('hmmss', 0, 0, function() {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  addFormatToken('Hmm', 0, 0, function() {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
  });
  addFormatToken('Hmmss', 0, 0, function() {
    return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function() {
      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
  }
  meridiem('a', true);
  meridiem('A', false);
  addUnitAlias('hour', 'h');
  addUnitPriority('hour', 13);
  function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
  }
  addRegexToken('a', matchMeridiem);
  addRegexToken('A', matchMeridiem);
  addRegexToken('H', match1to2);
  addRegexToken('h', match1to2);
  addRegexToken('HH', match1to2, match2);
  addRegexToken('hh', match1to2, match2);
  addRegexToken('hmm', match3to4);
  addRegexToken('hmmss', match5to6);
  addRegexToken('Hmm', match3to4);
  addRegexToken('Hmmss', match5to6);
  addParseToken(['H', 'HH'], HOUR);
  addParseToken(['a', 'A'], function(input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken(['h', 'hh'], function(input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmm', function(input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmmss', function(input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('Hmm', function(input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken('Hmmss', function(input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
  });
  function localeIsPM(input) {
    return ((input + '').toLowerCase().charAt(0) === 'p');
  }
  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
  function localeMeridiem(hours, minutes, isLower) {
    if (hours > 11) {
      return isLower ? 'pm' : 'PM';
    } else {
      return isLower ? 'am' : 'AM';
    }
  }
  var getSetHour = makeGetSet('Hours', true);
  var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    ordinalParse: defaultOrdinalParse,
    relativeTime: defaultRelativeTime,
    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,
    week: defaultLocaleWeek,
    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,
    meridiemParse: defaultLocaleMeridiemParse
  };
  var locales = {};
  var globalLocale;
  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
  }
  function chooseLocale(names) {
    var i = 0,
        j,
        next,
        locale,
        split;
    while (i < names.length) {
      split = normalizeLocale(names[i]).split('-');
      j = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split('-') : null;
      while (j > 0) {
        locale = loadLocale(split.slice(0, j).join('-'));
        if (locale) {
          return locale;
        }
        if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
          break;
        }
        j--;
      }
      i++;
    }
    return null;
  }
  function loadLocale(name) {
    var oldLocale = null;
    if (!locales[name] && (typeof module !== 'undefined') && module && module.exports) {
      try {
        oldLocale = globalLocale._abbr;
        require('./locale/' + name);
        locale_locales__getSetGlobalLocale(oldLocale);
      } catch (e) {}
    }
    return locales[name];
  }
  function locale_locales__getSetGlobalLocale(key, values) {
    var data;
    if (key) {
      if (isUndefined(values)) {
        data = locale_locales__getLocale(key);
      } else {
        data = defineLocale(key, values);
      }
      if (data) {
        globalLocale = data;
      }
    }
    return globalLocale._abbr;
  }
  function defineLocale(name, config) {
    if (config !== null) {
      var parentConfig = baseConfig;
      config.abbr = name;
      if (locales[name] != null) {
        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
        parentConfig = locales[name]._config;
      } else if (config.parentLocale != null) {
        if (locales[config.parentLocale] != null) {
          parentConfig = locales[config.parentLocale]._config;
        } else {
          deprecateSimple('parentLocaleUndefined', 'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
        }
      }
      locales[name] = new Locale(mergeConfigs(parentConfig, config));
      locale_locales__getSetGlobalLocale(name);
      return locales[name];
    } else {
      delete locales[name];
      return null;
    }
  }
  function updateLocale(name, config) {
    if (config != null) {
      var locale,
          parentConfig = baseConfig;
      if (locales[name] != null) {
        parentConfig = locales[name]._config;
      }
      config = mergeConfigs(parentConfig, config);
      locale = new Locale(config);
      locale.parentLocale = locales[name];
      locales[name] = locale;
      locale_locales__getSetGlobalLocale(name);
    } else {
      if (locales[name] != null) {
        if (locales[name].parentLocale != null) {
          locales[name] = locales[name].parentLocale;
        } else if (locales[name] != null) {
          delete locales[name];
        }
      }
    }
    return locales[name];
  }
  function locale_locales__getLocale(key) {
    var locale;
    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }
    if (!key) {
      return globalLocale;
    }
    if (!isArray(key)) {
      locale = loadLocale(key);
      if (locale) {
        return locale;
      }
      key = [key];
    }
    return chooseLocale(key);
  }
  function locale_locales__listLocales() {
    return keys(locales);
  }
  function checkOverflow(m) {
    var overflow;
    var a = m._a;
    if (a && getParsingFlags(m).overflow === -2) {
      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
        overflow = DATE;
      }
      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
        overflow = WEEK;
      }
      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
        overflow = WEEKDAY;
      }
      getParsingFlags(m).overflow = overflow;
    }
    return m;
  }
  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
  var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
  var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
  var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]];
  var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
  var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
  function configFromISO(config) {
    var i,
        l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime,
        dateFormat,
        timeFormat,
        tzFormat;
    if (match) {
      getParsingFlags(config).iso = true;
      for (i = 0, l = isoDates.length; i < l; i++) {
        if (isoDates[i][1].exec(match[1])) {
          dateFormat = isoDates[i][0];
          allowTime = isoDates[i][2] !== false;
          break;
        }
      }
      if (dateFormat == null) {
        config._isValid = false;
        return;
      }
      if (match[3]) {
        for (i = 0, l = isoTimes.length; i < l; i++) {
          if (isoTimes[i][1].exec(match[3])) {
            timeFormat = (match[2] || ' ') + isoTimes[i][0];
            break;
          }
        }
        if (timeFormat == null) {
          config._isValid = false;
          return;
        }
      }
      if (!allowTime && timeFormat != null) {
        config._isValid = false;
        return;
      }
      if (match[4]) {
        if (tzRegex.exec(match[4])) {
          tzFormat = 'Z';
        } else {
          config._isValid = false;
          return;
        }
      }
      config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
      configFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  }
  function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);
    if (matched !== null) {
      config._d = new Date(+matched[1]);
      return;
    }
    configFromISO(config);
    if (config._isValid === false) {
      delete config._isValid;
      utils_hooks__hooks.createFromInputFallback(config);
    }
  }
  utils_hooks__hooks.createFromInputFallback = deprecate('moment construction falls back to js Date. This is ' + 'discouraged and will be removed in upcoming major ' + 'release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function(config) {
    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
  });
  function defaults(a, b, c) {
    if (a != null) {
      return a;
    }
    if (b != null) {
      return b;
    }
    return c;
  }
  function currentDateArray(config) {
    var nowValue = new Date(utils_hooks__hooks.now());
    if (config._useUTC) {
      return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  }
  function configFromArray(config) {
    var i,
        date,
        input = [],
        currentDate,
        yearToUse;
    if (config._d) {
      return;
    }
    currentDate = currentDateArray(config);
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    }
    if (config._dayOfYear) {
      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
      if (config._dayOfYear > daysInYear(yearToUse)) {
        getParsingFlags(config)._overflowDayOfYear = true;
      }
      date = createUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    }
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    }
    for (; i < 7; i++) {
      config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }
    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
      config._nextDay = true;
      config._a[HOUR] = 0;
    }
    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }
    if (config._nextDay) {
      config._a[HOUR] = 24;
    }
  }
  function dayOfYearFromWeekInfo(config) {
    var w,
        weekYear,
        week,
        weekday,
        dow,
        doy,
        temp,
        weekdayOverflow;
    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4;
      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
      week = defaults(w.W, 1);
      weekday = defaults(w.E, 1);
      if (weekday < 1 || weekday > 7) {
        weekdayOverflow = true;
      }
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
      week = defaults(w.w, 1);
      if (w.d != null) {
        weekday = w.d;
        if (weekday < 0 || weekday > 6) {
          weekdayOverflow = true;
        }
      } else if (w.e != null) {
        weekday = w.e + dow;
        if (w.e < 0 || w.e > 6) {
          weekdayOverflow = true;
        }
      } else {
        weekday = dow;
      }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
      getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
      getParsingFlags(config)._overflowWeekday = true;
    } else {
      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
      config._a[YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
  }
  utils_hooks__hooks.ISO_8601 = function() {};
  function configFromStringAndFormat(config) {
    if (config._f === utils_hooks__hooks.ISO_8601) {
      configFromISO(config);
      return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;
    var string = '' + config._i,
        i,
        parsedInput,
        tokens,
        token,
        skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;
    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));
        if (skipped.length > 0) {
          getParsingFlags(config).unusedInput.push(skipped);
        }
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      }
      if (formatTokenFunctions[token]) {
        if (parsedInput) {
          getParsingFlags(config).empty = false;
        } else {
          getParsingFlags(config).unusedTokens.push(token);
        }
        addTimeToArrayFromToken(token, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        getParsingFlags(config).unusedTokens.push(token);
      }
    }
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
      getParsingFlags(config).unusedInput.push(string);
    }
    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
      getParsingFlags(config).bigHour = undefined;
    }
    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
    configFromArray(config);
    checkOverflow(config);
  }
  function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;
    if (meridiem == null) {
      return hour;
    }
    if (locale.meridiemHour != null) {
      return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
      isPm = locale.isPM(meridiem);
      if (isPm && hour < 12) {
        hour += 12;
      }
      if (!isPm && hour === 12) {
        hour = 0;
      }
      return hour;
    } else {
      return hour;
    }
  }
  function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,
        scoreToBeat,
        i,
        currentScore;
    if (config._f.length === 0) {
      getParsingFlags(config).invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }
    for (i = 0; i < config._f.length; i++) {
      currentScore = 0;
      tempConfig = copyConfig({}, config);
      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }
      tempConfig._f = config._f[i];
      configFromStringAndFormat(tempConfig);
      if (!valid__isValid(tempConfig)) {
        continue;
      }
      currentScore += getParsingFlags(tempConfig).charsLeftOver;
      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
      getParsingFlags(tempConfig).score = currentScore;
      if (scoreToBeat == null || currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
    extend(config, bestMoment || tempConfig);
  }
  function configFromObject(config) {
    if (config._d) {
      return;
    }
    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function(obj) {
      return obj && parseInt(obj, 10);
    });
    configFromArray(config);
  }
  function createFromConfig(config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
      res.add(1, 'd');
      res._nextDay = undefined;
    }
    return res;
  }
  function prepareConfig(config) {
    var input = config._i,
        format = config._f;
    config._locale = config._locale || locale_locales__getLocale(config._l);
    if (input === null || (format === undefined && input === '')) {
      return valid__createInvalid({nullInput: true});
    }
    if (typeof input === 'string') {
      config._i = input = config._locale.preparse(input);
    }
    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isArray(format)) {
      configFromStringAndArray(config);
    } else if (isDate(input)) {
      config._d = input;
    } else if (format) {
      configFromStringAndFormat(config);
    } else {
      configFromInput(config);
    }
    if (!valid__isValid(config)) {
      config._d = null;
    }
    return config;
  }
  function configFromInput(config) {
    var input = config._i;
    if (input === undefined) {
      config._d = new Date(utils_hooks__hooks.now());
    } else if (isDate(input)) {
      config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
      configFromString(config);
    } else if (isArray(input)) {
      config._a = map(input.slice(0), function(obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config);
    } else if (typeof(input) === 'object') {
      configFromObject(config);
    } else if (typeof(input) === 'number') {
      config._d = new Date(input);
    } else {
      utils_hooks__hooks.createFromInputFallback(config);
    }
  }
  function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var c = {};
    if (typeof(locale) === 'boolean') {
      strict = locale;
      locale = undefined;
    }
    if ((isObject(input) && isObjectEmpty(input)) || (isArray(input) && input.length === 0)) {
      input = undefined;
    }
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;
    return createFromConfig(c);
  }
  function local__createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
  }
  var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function() {
    var other = local__createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return valid__createInvalid();
    }
  });
  var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function() {
    var other = local__createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return valid__createInvalid();
    }
  });
  function pickBy(fn, moments) {
    var res,
        i;
    if (moments.length === 1 && isArray(moments[0])) {
      moments = moments[0];
    }
    if (!moments.length) {
      return local__createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
      if (!moments[i].isValid() || moments[i][fn](res)) {
        res = moments[i];
      }
    }
    return res;
  }
  function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isBefore', args);
  }
  function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isAfter', args);
  }
  var now = function() {
    return Date.now ? Date.now() : +(new Date());
  };
  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;
    this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 1000 * 60 * 60;
    this._days = +days + weeks * 7;
    this._months = +months + quarters * 3 + years * 12;
    this._data = {};
    this._locale = locale_locales__getLocale();
    this._bubble();
  }
  function isDuration(obj) {
    return obj instanceof Duration;
  }
  function offset(token, separator) {
    addFormatToken(token, 0, 0, function() {
      var offset = this.utcOffset();
      var sign = '+';
      if (offset < 0) {
        offset = -offset;
        sign = '-';
      }
      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
  }
  offset('Z', ':');
  offset('ZZ', '');
  addRegexToken('Z', matchShortOffset);
  addRegexToken('ZZ', matchShortOffset);
  addParseToken(['Z', 'ZZ'], function(input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
  });
  var chunkOffset = /([\+\-]|\d\d)/gi;
  function offsetFromString(matcher, string) {
    var matches = ((string || '').match(matcher) || []);
    var chunk = matches[matches.length - 1] || [];
    var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);
    return parts[0] === '+' ? minutes : -minutes;
  }
  function cloneWithOffset(input, model) {
    var res,
        diff;
    if (model._isUTC) {
      res = model.clone();
      diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
      res._d.setTime(res._d.valueOf() + diff);
      utils_hooks__hooks.updateOffset(res, false);
      return res;
    } else {
      return local__createLocal(input).local();
    }
  }
  function getDateOffset(m) {
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
  }
  utils_hooks__hooks.updateOffset = function() {};
  function getSetOffset(input, keepLocalTime) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      if (typeof input === 'string') {
        input = offsetFromString(matchShortOffset, input);
      } else if (Math.abs(input) < 16) {
        input = input * 60;
      }
      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }
      this._offset = input;
      this._isUTC = true;
      if (localAdjust != null) {
        this.add(localAdjust, 'm');
      }
      if (offset !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          utils_hooks__hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }
      return this;
    } else {
      return this._isUTC ? offset : getDateOffset(this);
    }
  }
  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== 'string') {
        input = -input;
      }
      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }
  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }
  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;
      if (keepLocalTime) {
        this.subtract(getDateOffset(this), 'm');
      }
    }
    return this;
  }
  function setOffsetToParsedOffset() {
    if (this._tzm) {
      this.utcOffset(this._tzm);
    } else if (typeof this._i === 'string') {
      this.utcOffset(offsetFromString(matchOffset, this._i));
    }
    return this;
  }
  function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
      return false;
    }
    input = input ? local__createLocal(input).utcOffset() : 0;
    return (this.utcOffset() - input) % 60 === 0;
  }
  function isDaylightSavingTime() {
    return (this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset());
  }
  function isDaylightSavingTimeShifted() {
    if (!isUndefined(this._isDSTShifted)) {
      return this._isDSTShifted;
    }
    var c = {};
    copyConfig(c, this);
    c = prepareConfig(c);
    if (c._a) {
      var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }
    return this._isDSTShifted;
  }
  function isLocal() {
    return this.isValid() ? !this._isUTC : false;
  }
  function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
  }
  function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
  }
  var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;
  var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
  function create__createDuration(input, key) {
    var duration = input,
        match = null,
        sign,
        ret,
        diffRes;
    if (isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months
      };
    } else if (typeof input === 'number') {
      duration = {};
      if (key) {
        duration[key] = input;
      } else {
        duration.milliseconds = input;
      }
    } else if (!!(match = aspNetRegex.exec(input))) {
      sign = (match[1] === '-') ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign,
        h: toInt(match[HOUR]) * sign,
        m: toInt(match[MINUTE]) * sign,
        s: toInt(match[SECOND]) * sign,
        ms: toInt(match[MILLISECOND]) * sign
      };
    } else if (!!(match = isoRegex.exec(input))) {
      sign = (match[1] === '-') ? -1 : 1;
      duration = {
        y: parseIso(match[2], sign),
        M: parseIso(match[3], sign),
        w: parseIso(match[4], sign),
        d: parseIso(match[5], sign),
        h: parseIso(match[6], sign),
        m: parseIso(match[7], sign),
        s: parseIso(match[8], sign)
      };
    } else if (duration == null) {
      duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
      diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }
    ret = new Duration(duration);
    if (isDuration(input) && hasOwnProp(input, '_locale')) {
      ret._locale = input._locale;
    }
    return ret;
  }
  create__createDuration.fn = Duration.prototype;
  function parseIso(inp, sign) {
    var res = inp && parseFloat(inp.replace(',', '.'));
    return (isNaN(res) ? 0 : res) * sign;
  }
  function positiveMomentsDifference(base, other) {
    var res = {
      milliseconds: 0,
      months: 0
    };
    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
      --res.months;
    }
    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
    return res;
  }
  function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
      return {
        milliseconds: 0,
        months: 0
      };
    }
    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }
    return res;
  }
  function absRound(number) {
    if (number < 0) {
      return Math.round(-1 * number) * -1;
    } else {
      return Math.round(number);
    }
  }
  function createAdder(direction, name) {
    return function(val, period) {
      var dur,
          tmp;
      if (period !== null && !isNaN(+period)) {
        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
        tmp = val;
        val = period;
        period = tmp;
      }
      val = typeof val === 'string' ? +val : val;
      dur = create__createDuration(val, period);
      add_subtract__addSubtract(this, dur, direction);
      return this;
    };
  }
  function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);
    if (!mom.isValid()) {
      return;
    }
    updateOffset = updateOffset == null ? true : updateOffset;
    if (milliseconds) {
      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
      get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
    }
    if (months) {
      setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
      utils_hooks__hooks.updateOffset(mom, days || months);
    }
  }
  var add_subtract__add = createAdder(1, 'add');
  var add_subtract__subtract = createAdder(-1, 'subtract');
  function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
  }
  function moment_calendar__calendar(time, formats) {
    var now = time || local__createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';
    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
    return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
  }
  function clone() {
    return new Moment(this);
  }
  function isAfter(input, units) {
    var localInput = isMoment(input) ? input : local__createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
      return this.valueOf() > localInput.valueOf();
    } else {
      return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
  }
  function isBefore(input, units) {
    var localInput = isMoment(input) ? input : local__createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
      return this.valueOf() < localInput.valueOf();
    } else {
      return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
  }
  function isBetween(from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) && (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
  }
  function isSame(input, units) {
    var localInput = isMoment(input) ? input : local__createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
      return this.valueOf() === localInput.valueOf();
    } else {
      inputMs = localInput.valueOf();
      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
  }
  function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
  }
  function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
  }
  function diff(input, units, asFloat) {
    var that,
        zoneDelta,
        delta,
        output;
    if (!this.isValid()) {
      return NaN;
    }
    that = cloneWithOffset(input, this);
    if (!that.isValid()) {
      return NaN;
    }
    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
    units = normalizeUnits(units);
    if (units === 'year' || units === 'month' || units === 'quarter') {
      output = monthDiff(this, that);
      if (units === 'quarter') {
        output = output / 3;
      } else if (units === 'year') {
        output = output / 12;
      }
    } else {
      delta = this - that;
      output = units === 'second' ? delta / 1e3 : units === 'minute' ? delta / 6e4 : units === 'hour' ? delta / 36e5 : units === 'day' ? (delta - zoneDelta) / 864e5 : units === 'week' ? (delta - zoneDelta) / 6048e5 : delta;
    }
    return asFloat ? output : absFloor(output);
  }
  function monthDiff(a, b) {
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2,
        adjust;
    if (b - anchor < 0) {
      anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
      adjust = (b - anchor) / (anchor2 - anchor);
    }
    return -(wholeMonthDiff + adjust) || 0;
  }
  utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
  utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
  function toString() {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
  }
  function moment_format__toISOString() {
    var m = this.clone().utc();
    if (0 < m.year() && m.year() <= 9999) {
      if (isFunction(Date.prototype.toISOString)) {
        return this.toDate().toISOString();
      } else {
        return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
      }
    } else {
      return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
  }
  function format(inputString) {
    if (!inputString) {
      inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
  }
  function from(time, withoutSuffix) {
    if (this.isValid() && ((isMoment(time) && time.isValid()) || local__createLocal(time).isValid())) {
      return create__createDuration({
        to: this,
        from: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function fromNow(withoutSuffix) {
    return this.from(local__createLocal(), withoutSuffix);
  }
  function to(time, withoutSuffix) {
    if (this.isValid() && ((isMoment(time) && time.isValid()) || local__createLocal(time).isValid())) {
      return create__createDuration({
        from: this,
        to: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function toNow(withoutSuffix) {
    return this.to(local__createLocal(), withoutSuffix);
  }
  function locale(key) {
    var newLocaleData;
    if (key === undefined) {
      return this._locale._abbr;
    } else {
      newLocaleData = locale_locales__getLocale(key);
      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }
      return this;
    }
  }
  var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function(key) {
    if (key === undefined) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  });
  function localeData() {
    return this._locale;
  }
  function startOf(units) {
    units = normalizeUnits(units);
    switch (units) {
      case 'year':
        this.month(0);
      case 'quarter':
      case 'month':
        this.date(1);
      case 'week':
      case 'isoWeek':
      case 'day':
      case 'date':
        this.hours(0);
      case 'hour':
        this.minutes(0);
      case 'minute':
        this.seconds(0);
      case 'second':
        this.milliseconds(0);
    }
    if (units === 'week') {
      this.weekday(0);
    }
    if (units === 'isoWeek') {
      this.isoWeekday(1);
    }
    if (units === 'quarter') {
      this.month(Math.floor(this.month() / 3) * 3);
    }
    return this;
  }
  function endOf(units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
      return this;
    }
    if (units === 'date') {
      units = 'day';
    }
    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
  }
  function to_type__valueOf() {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
  }
  function unix() {
    return Math.floor(this.valueOf() / 1000);
  }
  function toDate() {
    return new Date(this.valueOf());
  }
  function toArray() {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
  }
  function toObject() {
    var m = this;
    return {
      years: m.year(),
      months: m.month(),
      date: m.date(),
      hours: m.hours(),
      minutes: m.minutes(),
      seconds: m.seconds(),
      milliseconds: m.milliseconds()
    };
  }
  function toJSON() {
    return this.isValid() ? this.toISOString() : null;
  }
  function moment_valid__isValid() {
    return valid__isValid(this);
  }
  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }
  function invalidAt() {
    return getParsingFlags(this).overflow;
  }
  function creationData() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    };
  }
  addFormatToken(0, ['gg', 2], 0, function() {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ['GG', 2], 0, function() {
    return this.isoWeekYear() % 100;
  });
  function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
  }
  addWeekYearFormatToken('gggg', 'weekYear');
  addWeekYearFormatToken('ggggg', 'weekYear');
  addWeekYearFormatToken('GGGG', 'isoWeekYear');
  addWeekYearFormatToken('GGGGG', 'isoWeekYear');
  addUnitAlias('weekYear', 'gg');
  addUnitAlias('isoWeekYear', 'GG');
  addUnitPriority('weekYear', 1);
  addUnitPriority('isoWeekYear', 1);
  addRegexToken('G', matchSigned);
  addRegexToken('g', matchSigned);
  addRegexToken('GG', match1to2, match2);
  addRegexToken('gg', match1to2, match2);
  addRegexToken('GGGG', match1to4, match4);
  addRegexToken('gggg', match1to4, match4);
  addRegexToken('GGGGG', match1to6, match6);
  addRegexToken('ggggg', match1to6, match6);
  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function(input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
  });
  addWeekParseToken(['gg', 'GG'], function(input, week, config, token) {
    week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
  });
  function getSetWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
  }
  function getSetISOWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
  }
  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }
  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }
  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
      return weekOfYear(this, dow, doy).year;
    } else {
      weeksTarget = weeksInYear(input, dow, doy);
      if (week > weeksTarget) {
        week = weeksTarget;
      }
      return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
  }
  function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
  }
  addFormatToken('Q', 0, 'Qo', 'quarter');
  addUnitAlias('quarter', 'Q');
  addUnitPriority('quarter', 7);
  addRegexToken('Q', match1);
  addParseToken('Q', function(input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  });
  function getSetQuarter(input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
  }
  addFormatToken('D', ['DD', 2], 'Do', 'date');
  addUnitAlias('date', 'D');
  addUnitPriority('date', 9);
  addRegexToken('D', match1to2);
  addRegexToken('DD', match1to2, match2);
  addRegexToken('Do', function(isStrict, locale) {
    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
  });
  addParseToken(['D', 'DD'], DATE);
  addParseToken('Do', function(input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
  });
  var getSetDayOfMonth = makeGetSet('Date', true);
  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
  addUnitAlias('dayOfYear', 'DDD');
  addUnitPriority('dayOfYear', 4);
  addRegexToken('DDD', match1to3);
  addRegexToken('DDDD', match3);
  addParseToken(['DDD', 'DDDD'], function(input, array, config) {
    config._dayOfYear = toInt(input);
  });
  function getSetDayOfYear(input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
  }
  addFormatToken('m', ['mm', 2], 0, 'minute');
  addUnitAlias('minute', 'm');
  addUnitPriority('minute', 14);
  addRegexToken('m', match1to2);
  addRegexToken('mm', match1to2, match2);
  addParseToken(['m', 'mm'], MINUTE);
  var getSetMinute = makeGetSet('Minutes', false);
  addFormatToken('s', ['ss', 2], 0, 'second');
  addUnitAlias('second', 's');
  addUnitPriority('second', 15);
  addRegexToken('s', match1to2);
  addRegexToken('ss', match1to2, match2);
  addParseToken(['s', 'ss'], SECOND);
  var getSetSecond = makeGetSet('Seconds', false);
  addFormatToken('S', 0, 0, function() {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ['SS', 2], 0, function() {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ['SSS', 3], 0, 'millisecond');
  addFormatToken(0, ['SSSS', 4], 0, function() {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ['SSSSS', 5], 0, function() {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ['SSSSSS', 6], 0, function() {
    return this.millisecond() * 1000;
  });
  addFormatToken(0, ['SSSSSSS', 7], 0, function() {
    return this.millisecond() * 10000;
  });
  addFormatToken(0, ['SSSSSSSS', 8], 0, function() {
    return this.millisecond() * 100000;
  });
  addFormatToken(0, ['SSSSSSSSS', 9], 0, function() {
    return this.millisecond() * 1000000;
  });
  addUnitAlias('millisecond', 'ms');
  addUnitPriority('millisecond', 16);
  addRegexToken('S', match1to3, match1);
  addRegexToken('SS', match1to3, match2);
  addRegexToken('SSS', match1to3, match3);
  var token;
  for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
  }
  function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
  }
  for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
  }
  var getSetMillisecond = makeGetSet('Milliseconds', false);
  addFormatToken('z', 0, 0, 'zoneAbbr');
  addFormatToken('zz', 0, 0, 'zoneName');
  function getZoneAbbr() {
    return this._isUTC ? 'UTC' : '';
  }
  function getZoneName() {
    return this._isUTC ? 'Coordinated Universal Time' : '';
  }
  var momentPrototype__proto = Moment.prototype;
  momentPrototype__proto.add = add_subtract__add;
  momentPrototype__proto.calendar = moment_calendar__calendar;
  momentPrototype__proto.clone = clone;
  momentPrototype__proto.diff = diff;
  momentPrototype__proto.endOf = endOf;
  momentPrototype__proto.format = format;
  momentPrototype__proto.from = from;
  momentPrototype__proto.fromNow = fromNow;
  momentPrototype__proto.to = to;
  momentPrototype__proto.toNow = toNow;
  momentPrototype__proto.get = stringGet;
  momentPrototype__proto.invalidAt = invalidAt;
  momentPrototype__proto.isAfter = isAfter;
  momentPrototype__proto.isBefore = isBefore;
  momentPrototype__proto.isBetween = isBetween;
  momentPrototype__proto.isSame = isSame;
  momentPrototype__proto.isSameOrAfter = isSameOrAfter;
  momentPrototype__proto.isSameOrBefore = isSameOrBefore;
  momentPrototype__proto.isValid = moment_valid__isValid;
  momentPrototype__proto.lang = lang;
  momentPrototype__proto.locale = locale;
  momentPrototype__proto.localeData = localeData;
  momentPrototype__proto.max = prototypeMax;
  momentPrototype__proto.min = prototypeMin;
  momentPrototype__proto.parsingFlags = parsingFlags;
  momentPrototype__proto.set = stringSet;
  momentPrototype__proto.startOf = startOf;
  momentPrototype__proto.subtract = add_subtract__subtract;
  momentPrototype__proto.toArray = toArray;
  momentPrototype__proto.toObject = toObject;
  momentPrototype__proto.toDate = toDate;
  momentPrototype__proto.toISOString = moment_format__toISOString;
  momentPrototype__proto.toJSON = toJSON;
  momentPrototype__proto.toString = toString;
  momentPrototype__proto.unix = unix;
  momentPrototype__proto.valueOf = to_type__valueOf;
  momentPrototype__proto.creationData = creationData;
  momentPrototype__proto.year = getSetYear;
  momentPrototype__proto.isLeapYear = getIsLeapYear;
  momentPrototype__proto.weekYear = getSetWeekYear;
  momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
  momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
  momentPrototype__proto.month = getSetMonth;
  momentPrototype__proto.daysInMonth = getDaysInMonth;
  momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
  momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
  momentPrototype__proto.weeksInYear = getWeeksInYear;
  momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
  momentPrototype__proto.date = getSetDayOfMonth;
  momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
  momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
  momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
  momentPrototype__proto.dayOfYear = getSetDayOfYear;
  momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
  momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
  momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
  momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
  momentPrototype__proto.utcOffset = getSetOffset;
  momentPrototype__proto.utc = setOffsetToUTC;
  momentPrototype__proto.local = setOffsetToLocal;
  momentPrototype__proto.parseZone = setOffsetToParsedOffset;
  momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
  momentPrototype__proto.isDST = isDaylightSavingTime;
  momentPrototype__proto.isLocal = isLocal;
  momentPrototype__proto.isUtcOffset = isUtcOffset;
  momentPrototype__proto.isUtc = isUtc;
  momentPrototype__proto.isUTC = isUtc;
  momentPrototype__proto.zoneAbbr = getZoneAbbr;
  momentPrototype__proto.zoneName = getZoneName;
  momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
  momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
  momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
  momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
  momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
  var momentPrototype = momentPrototype__proto;
  function moment__createUnix(input) {
    return local__createLocal(input * 1000);
  }
  function moment__createInZone() {
    return local__createLocal.apply(null, arguments).parseZone();
  }
  function preParsePostFormat(string) {
    return string;
  }
  var prototype__proto = Locale.prototype;
  prototype__proto.calendar = locale_calendar__calendar;
  prototype__proto.longDateFormat = longDateFormat;
  prototype__proto.invalidDate = invalidDate;
  prototype__proto.ordinal = ordinal;
  prototype__proto.preparse = preParsePostFormat;
  prototype__proto.postformat = preParsePostFormat;
  prototype__proto.relativeTime = relative__relativeTime;
  prototype__proto.pastFuture = pastFuture;
  prototype__proto.set = locale_set__set;
  prototype__proto.months = localeMonths;
  prototype__proto.monthsShort = localeMonthsShort;
  prototype__proto.monthsParse = localeMonthsParse;
  prototype__proto.monthsRegex = monthsRegex;
  prototype__proto.monthsShortRegex = monthsShortRegex;
  prototype__proto.week = localeWeek;
  prototype__proto.firstDayOfYear = localeFirstDayOfYear;
  prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
  prototype__proto.weekdays = localeWeekdays;
  prototype__proto.weekdaysMin = localeWeekdaysMin;
  prototype__proto.weekdaysShort = localeWeekdaysShort;
  prototype__proto.weekdaysParse = localeWeekdaysParse;
  prototype__proto.weekdaysRegex = weekdaysRegex;
  prototype__proto.weekdaysShortRegex = weekdaysShortRegex;
  prototype__proto.weekdaysMinRegex = weekdaysMinRegex;
  prototype__proto.isPM = localeIsPM;
  prototype__proto.meridiem = localeMeridiem;
  function lists__get(format, index, field, setter) {
    var locale = locale_locales__getLocale();
    var utc = create_utc__createUTC().set(setter, index);
    return locale[field](utc, format);
  }
  function listMonthsImpl(format, index, field) {
    if (typeof format === 'number') {
      index = format;
      format = undefined;
    }
    format = format || '';
    if (index != null) {
      return lists__get(format, index, field, 'month');
    }
    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
      out[i] = lists__get(format, i, field, 'month');
    }
    return out;
  }
  function listWeekdaysImpl(localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
      if (typeof format === 'number') {
        index = format;
        format = undefined;
      }
      format = format || '';
    } else {
      format = localeSorted;
      index = format;
      localeSorted = false;
      if (typeof format === 'number') {
        index = format;
        format = undefined;
      }
      format = format || '';
    }
    var locale = locale_locales__getLocale(),
        shift = localeSorted ? locale._week.dow : 0;
    if (index != null) {
      return lists__get(format, (index + shift) % 7, field, 'day');
    }
    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
      out[i] = lists__get(format, (i + shift) % 7, field, 'day');
    }
    return out;
  }
  function lists__listMonths(format, index) {
    return listMonthsImpl(format, index, 'months');
  }
  function lists__listMonthsShort(format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
  }
  function lists__listWeekdays(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
  }
  function lists__listWeekdaysShort(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
  }
  function lists__listWeekdaysMin(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
  }
  locale_locales__getSetGlobalLocale('en', {
    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function(number) {
      var b = number % 10,
          output = (toInt(number % 100 / 10) === 1) ? 'th' : (b === 1) ? 'st' : (b === 2) ? 'nd' : (b === 3) ? 'rd' : 'th';
      return number + output;
    }
  });
  utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
  utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
  var mathAbs = Math.abs;
  function duration_abs__abs() {
    var data = this._data;
    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);
    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);
    return this;
  }
  function duration_add_subtract__addSubtract(duration, input, value, direction) {
    var other = create__createDuration(input, value);
    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;
    return duration._bubble();
  }
  function duration_add_subtract__add(input, value) {
    return duration_add_subtract__addSubtract(this, input, value, 1);
  }
  function duration_add_subtract__subtract(input, value) {
    return duration_add_subtract__addSubtract(this, input, value, -1);
  }
  function absCeil(number) {
    if (number < 0) {
      return Math.floor(number);
    } else {
      return Math.ceil(number);
    }
  }
  function bubble() {
    var milliseconds = this._milliseconds;
    var days = this._days;
    var months = this._months;
    var data = this._data;
    var seconds,
        minutes,
        hours,
        years,
        monthsFromDays;
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) || (milliseconds <= 0 && days <= 0 && months <= 0))) {
      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
      days = 0;
      months = 0;
    }
    data.milliseconds = milliseconds % 1000;
    seconds = absFloor(milliseconds / 1000);
    data.seconds = seconds % 60;
    minutes = absFloor(seconds / 60);
    data.minutes = minutes % 60;
    hours = absFloor(minutes / 60);
    data.hours = hours % 24;
    days += absFloor(hours / 24);
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));
    years = absFloor(months / 12);
    months %= 12;
    data.days = days;
    data.months = months;
    data.years = years;
    return this;
  }
  function daysToMonths(days) {
    return days * 4800 / 146097;
  }
  function monthsToDays(months) {
    return months * 146097 / 4800;
  }
  function as(units) {
    var days;
    var months;
    var milliseconds = this._milliseconds;
    units = normalizeUnits(units);
    if (units === 'month' || units === 'year') {
      days = this._days + milliseconds / 864e5;
      months = this._months + daysToMonths(days);
      return units === 'month' ? months : months / 12;
    } else {
      days = this._days + Math.round(monthsToDays(this._months));
      switch (units) {
        case 'week':
          return days / 7 + milliseconds / 6048e5;
        case 'day':
          return days + milliseconds / 864e5;
        case 'hour':
          return days * 24 + milliseconds / 36e5;
        case 'minute':
          return days * 1440 + milliseconds / 6e4;
        case 'second':
          return days * 86400 + milliseconds / 1000;
        case 'millisecond':
          return Math.floor(days * 864e5) + milliseconds;
        default:
          throw new Error('Unknown unit ' + units);
      }
    }
  }
  function duration_as__valueOf() {
    return (this._milliseconds + this._days * 864e5 + (this._months % 12) * 2592e6 + toInt(this._months / 12) * 31536e6);
  }
  function makeAs(alias) {
    return function() {
      return this.as(alias);
    };
  }
  var asMilliseconds = makeAs('ms');
  var asSeconds = makeAs('s');
  var asMinutes = makeAs('m');
  var asHours = makeAs('h');
  var asDays = makeAs('d');
  var asWeeks = makeAs('w');
  var asMonths = makeAs('M');
  var asYears = makeAs('y');
  function duration_get__get(units) {
    units = normalizeUnits(units);
    return this[units + 's']();
  }
  function makeGetter(name) {
    return function() {
      return this._data[name];
    };
  }
  var milliseconds = makeGetter('milliseconds');
  var seconds = makeGetter('seconds');
  var minutes = makeGetter('minutes');
  var hours = makeGetter('hours');
  var days = makeGetter('days');
  var months = makeGetter('months');
  var years = makeGetter('years');
  function weeks() {
    return absFloor(this.days() / 7);
  }
  var round = Math.round;
  var thresholds = {
    s: 45,
    m: 45,
    h: 22,
    d: 26,
    M: 11
  };
  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }
  function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
    var duration = create__createDuration(posNegDuration).abs();
    var seconds = round(duration.as('s'));
    var minutes = round(duration.as('m'));
    var hours = round(duration.as('h'));
    var days = round(duration.as('d'));
    var months = round(duration.as('M'));
    var years = round(duration.as('y'));
    var a = seconds < thresholds.s && ['s', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
  }
  function duration_humanize__getSetRelativeTimeRounding(roundingFunction) {
    if (roundingFunction === undefined) {
      return round;
    }
    if (typeof(roundingFunction) === 'function') {
      round = roundingFunction;
      return true;
    }
    return false;
  }
  function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === undefined) {
      return false;
    }
    if (limit === undefined) {
      return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    return true;
  }
  function humanize(withSuffix) {
    var locale = this.localeData();
    var output = duration_humanize__relativeTime(this, !withSuffix, locale);
    if (withSuffix) {
      output = locale.pastFuture(+this, output);
    }
    return locale.postformat(output);
  }
  var iso_string__abs = Math.abs;
  function iso_string__toISOString() {
    var seconds = iso_string__abs(this._milliseconds) / 1000;
    var days = iso_string__abs(this._days);
    var months = iso_string__abs(this._months);
    var minutes,
        hours,
        years;
    minutes = absFloor(seconds / 60);
    hours = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;
    years = absFloor(months / 12);
    months %= 12;
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();
    if (!total) {
      return 'P0D';
    }
    return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + ((h || m || s) ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
  }
  var duration_prototype__proto = Duration.prototype;
  duration_prototype__proto.abs = duration_abs__abs;
  duration_prototype__proto.add = duration_add_subtract__add;
  duration_prototype__proto.subtract = duration_add_subtract__subtract;
  duration_prototype__proto.as = as;
  duration_prototype__proto.asMilliseconds = asMilliseconds;
  duration_prototype__proto.asSeconds = asSeconds;
  duration_prototype__proto.asMinutes = asMinutes;
  duration_prototype__proto.asHours = asHours;
  duration_prototype__proto.asDays = asDays;
  duration_prototype__proto.asWeeks = asWeeks;
  duration_prototype__proto.asMonths = asMonths;
  duration_prototype__proto.asYears = asYears;
  duration_prototype__proto.valueOf = duration_as__valueOf;
  duration_prototype__proto._bubble = bubble;
  duration_prototype__proto.get = duration_get__get;
  duration_prototype__proto.milliseconds = milliseconds;
  duration_prototype__proto.seconds = seconds;
  duration_prototype__proto.minutes = minutes;
  duration_prototype__proto.hours = hours;
  duration_prototype__proto.days = days;
  duration_prototype__proto.weeks = weeks;
  duration_prototype__proto.months = months;
  duration_prototype__proto.years = years;
  duration_prototype__proto.humanize = humanize;
  duration_prototype__proto.toISOString = iso_string__toISOString;
  duration_prototype__proto.toString = iso_string__toISOString;
  duration_prototype__proto.toJSON = iso_string__toISOString;
  duration_prototype__proto.locale = locale;
  duration_prototype__proto.localeData = localeData;
  duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
  duration_prototype__proto.lang = lang;
  addFormatToken('X', 0, 0, 'unix');
  addFormatToken('x', 0, 0, 'valueOf');
  addRegexToken('x', matchSigned);
  addRegexToken('X', matchTimestamp);
  addParseToken('X', function(input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
  });
  addParseToken('x', function(input, array, config) {
    config._d = new Date(toInt(input));
  });
  utils_hooks__hooks.version = '2.14.1';
  setHookCallback(local__createLocal);
  utils_hooks__hooks.fn = momentPrototype;
  utils_hooks__hooks.min = min;
  utils_hooks__hooks.max = max;
  utils_hooks__hooks.now = now;
  utils_hooks__hooks.utc = create_utc__createUTC;
  utils_hooks__hooks.unix = moment__createUnix;
  utils_hooks__hooks.months = lists__listMonths;
  utils_hooks__hooks.isDate = isDate;
  utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
  utils_hooks__hooks.invalid = valid__createInvalid;
  utils_hooks__hooks.duration = create__createDuration;
  utils_hooks__hooks.isMoment = isMoment;
  utils_hooks__hooks.weekdays = lists__listWeekdays;
  utils_hooks__hooks.parseZone = moment__createInZone;
  utils_hooks__hooks.localeData = locale_locales__getLocale;
  utils_hooks__hooks.isDuration = isDuration;
  utils_hooks__hooks.monthsShort = lists__listMonthsShort;
  utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
  utils_hooks__hooks.defineLocale = defineLocale;
  utils_hooks__hooks.updateLocale = updateLocale;
  utils_hooks__hooks.locales = locale_locales__listLocales;
  utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
  utils_hooks__hooks.normalizeUnits = normalizeUnits;
  utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
  utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
  utils_hooks__hooks.calendarFormat = getCalendarFormat;
  utils_hooks__hooks.prototype = momentPrototype;
  var _moment = utils_hooks__hooks;
  return _moment;
}));

})();
System.registerDynamic("npm:react-onclickoutside@4.9.0.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "react-onclickoutside": "."
    }
  };
});

System.registerDynamic("npm:react-onclickoutside@4.9.0/index.js", ["react-dom"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define(['react-dom'], function(reactDom) {
        return factory(root, reactDom);
      });
    } else if (typeof exports === 'object') {
      module.exports = factory(root, $__require('react-dom'));
    } else {
      root.OnClickOutside = factory(root, ReactDOM);
    }
  }(this, function(root, ReactDOM) {
    "use strict";
    var registeredComponents = [];
    var handlers = [];
    var IGNORE_CLASS = 'ignore-react-onclickoutside';
    var isSourceFound = function(source, localNode, ignoreClass) {
      if (source === localNode) {
        return true;
      }
      if (source.correspondingElement) {
        return source.correspondingElement.classList.contains(ignoreClass);
      }
      return source.classList.contains(ignoreClass);
    };
    return {
      componentDidMount: function() {
        if (typeof this.handleClickOutside !== "function")
          throw new Error("Component lacks a handleClickOutside(event) function for processing outside click events.");
        var fn = this.__outsideClickHandler = (function(localNode, eventHandler, ignoreClass) {
          return function(evt) {
            evt.stopPropagation();
            var source = evt.target;
            var found = false;
            while (source.parentNode) {
              found = isSourceFound(source, localNode, ignoreClass);
              if (found)
                return;
              source = source.parentNode;
            }
            if (source !== document)
              return;
            eventHandler(evt);
          };
        }(ReactDOM.findDOMNode(this), this.handleClickOutside, this.props.outsideClickIgnoreClass || IGNORE_CLASS));
        var pos = registeredComponents.length;
        registeredComponents.push(this);
        handlers[pos] = fn;
        if (!this.props.disableOnClickOutside) {
          this.enableOnClickOutside();
        }
      },
      componentWillUnmount: function() {
        this.disableOnClickOutside();
        this.__outsideClickHandler = false;
        var pos = registeredComponents.indexOf(this);
        if (pos > -1) {
          if (handlers[pos]) {
            handlers.splice(pos, 1);
            registeredComponents.splice(pos, 1);
          }
        }
      },
      enableOnClickOutside: function() {
        var fn = this.__outsideClickHandler;
        if (typeof document !== "undefined") {
          document.addEventListener("mousedown", fn);
          document.addEventListener("touchstart", fn);
        }
      },
      disableOnClickOutside: function() {
        var fn = this.__outsideClickHandler;
        if (typeof document !== "undefined") {
          document.removeEventListener("mousedown", fn);
          document.removeEventListener("touchstart", fn);
        }
      }
    };
  }));
  return module.exports;
});

System.registerDynamic("npm:react-datepicker@0.28.1.json", [], false, function() {
  return {
    "main": "dist/react-datepicker.min.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:react-datepicker@0.28.1/dist/react-datepicker.min.js", ["moment", "react", "react-onclickoutside", "react-dom"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  !function(t, e) {
    "object" == typeof exports && "object" == typeof module ? module.exports = e($__require('moment'), $__require('react'), $__require('react-onclickoutside'), $__require('react-dom')) : "function" == typeof define && define.amd ? define(["moment", "react", "react-onclickoutside", "react-dom"], e) : "object" == typeof exports ? exports.DatePicker = e($__require('moment'), $__require('react'), $__require('react-onclickoutside'), $__require('react-dom')) : t.DatePicker = e(t.moment, t.React, t.OnClickOutside, t.ReactDOM);
  }(this, function(t, e, n, o) {
    return function(t) {
      function e(o) {
        if (n[o])
          return n[o].exports;
        var r = n[o] = {
          exports: {},
          id: o,
          loaded: !1
        };
        return t[o].call(r.exports, r, r.exports, e), r.loaded = !0, r.exports;
      }
      var n = {};
      return e.m = t, e.c = n, e.p = "", e(0);
    }([function(t, e, n) {
      "use strict";
      function o(t) {
        return t && t.__esModule ? t : {"default": t};
      }
      function r(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : t[e] = n, t;
      }
      var a = n(1),
          i = o(a),
          s = n(5),
          l = o(s),
          p = n(3),
          d = o(p),
          f = n(13),
          u = o(f),
          c = n(12),
          h = o(c),
          m = n(4),
          y = "react-datepicker-ignore-onclickoutside",
          g = d["default"].createClass({
            displayName: "DatePicker",
            propTypes: {
              autoComplete: d["default"].PropTypes.string,
              className: d["default"].PropTypes.string,
              dateFormat: d["default"].PropTypes.string,
              dateFormatCalendar: d["default"].PropTypes.string,
              disabled: d["default"].PropTypes.bool,
              endDate: d["default"].PropTypes.object,
              excludeDates: d["default"].PropTypes.array,
              filterDate: d["default"].PropTypes.func,
              fixedHeight: d["default"].PropTypes.bool,
              id: d["default"].PropTypes.string,
              includeDates: d["default"].PropTypes.array,
              inline: d["default"].PropTypes.bool,
              isClearable: d["default"].PropTypes.bool,
              locale: d["default"].PropTypes.string,
              maxDate: d["default"].PropTypes.object,
              minDate: d["default"].PropTypes.object,
              name: d["default"].PropTypes.string,
              onBlur: d["default"].PropTypes.func,
              onChange: d["default"].PropTypes.func.isRequired,
              onFocus: d["default"].PropTypes.func,
              openToDate: d["default"].PropTypes.object,
              placeholderText: d["default"].PropTypes.string,
              popoverAttachment: d["default"].PropTypes.string,
              popoverTargetAttachment: d["default"].PropTypes.string,
              popoverTargetOffset: d["default"].PropTypes.string,
              readOnly: d["default"].PropTypes.bool,
              renderCalendarTo: d["default"].PropTypes.any,
              required: d["default"].PropTypes.bool,
              selected: d["default"].PropTypes.object,
              showYearDropdown: d["default"].PropTypes.bool,
              startDate: d["default"].PropTypes.object,
              tabIndex: d["default"].PropTypes.number,
              tetherConstraints: d["default"].PropTypes.array,
              title: d["default"].PropTypes.string,
              todayButton: d["default"].PropTypes.string
            },
            getDefaultProps: function() {
              return {
                dateFormatCalendar: "MMMM YYYY",
                onChange: function() {},
                disabled: !1,
                onFocus: function() {},
                onBlur: function() {},
                popoverAttachment: "top left",
                popoverTargetAttachment: "bottom left",
                popoverTargetOffset: "10px 0",
                tetherConstraints: [{
                  to: "window",
                  attachment: "together"
                }]
              };
            },
            getInitialState: function() {
              return {open: !1};
            },
            setOpen: function(t) {
              this.setState({open: t});
            },
            handleFocus: function(t) {
              this.props.onFocus(t), this.setOpen(!0);
            },
            handleBlur: function(t) {
              this.state.open ? this.refs.input.focus() : this.props.onBlur(t);
            },
            handleCalendarClickOutside: function(t) {
              this.setOpen(!1);
            },
            handleSelect: function(t) {
              this.setSelected(t), this.setOpen(!1);
            },
            setSelected: function(t) {
              (0, m.isSameDay)(this.props.selected, t) || this.props.onChange(t);
            },
            onInputClick: function() {
              this.props.disabled || this.setOpen(!0);
            },
            onInputKeyDown: function(t) {
              "Enter" === t.key || "Escape" === t.key ? (t.preventDefault(), this.setOpen(!1)) : "Tab" === t.key && this.setOpen(!1);
            },
            onClearClick: function(t) {
              t.preventDefault(), this.props.onChange(null);
            },
            renderCalendar: function() {
              return this.props.inline || this.state.open && !this.props.disabled ? d["default"].createElement(l["default"], {
                ref: "calendar",
                locale: this.props.locale,
                dateFormat: this.props.dateFormatCalendar,
                selected: this.props.selected,
                onSelect: this.handleSelect,
                openToDate: this.props.openToDate,
                minDate: this.props.minDate,
                maxDate: this.props.maxDate,
                startDate: this.props.startDate,
                endDate: this.props.endDate,
                excludeDates: this.props.excludeDates,
                filterDate: this.props.filterDate,
                onClickOutside: this.handleCalendarClickOutside,
                includeDates: this.props.includeDates,
                showYearDropdown: this.props.showYearDropdown,
                todayButton: this.props.todayButton,
                outsideClickIgnoreClass: y,
                fixedHeight: this.props.fixedHeight
              }) : null;
            },
            renderDateInput: function() {
              var t = (0, h["default"])(this.props.className, r({}, y, this.state.open));
              return d["default"].createElement(i["default"], {
                ref: "input",
                id: this.props.id,
                name: this.props.name,
                date: this.props.selected,
                locale: this.props.locale,
                minDate: this.props.minDate,
                maxDate: this.props.maxDate,
                excludeDates: this.props.excludeDates,
                includeDates: this.props.includeDates,
                filterDate: this.props.filterDate,
                dateFormat: this.props.dateFormat,
                onFocus: this.handleFocus,
                onBlur: this.handleBlur,
                onClick: this.onInputClick,
                onKeyDown: this.onInputKeyDown,
                onChangeDate: this.setSelected,
                placeholder: this.props.placeholderText,
                disabled: this.props.disabled,
                autoComplete: this.props.autoComplete,
                className: t,
                title: this.props.title,
                readOnly: this.props.readOnly,
                required: this.props.required,
                tabIndex: this.props.tabIndex
              });
            },
            renderClearButton: function() {
              return this.props.isClearable && null != this.props.selected ? d["default"].createElement("a", {
                className: "react-datepicker__close-icon",
                href: "#",
                onClick: this.onClearClick
              }) : null;
            },
            render: function() {
              var t = this.renderCalendar();
              return this.props.inline ? t : d["default"].createElement(u["default"], {
                classPrefix: "react-datepicker__tether",
                attachment: this.props.popoverAttachment,
                targetAttachment: this.props.popoverTargetAttachment,
                targetOffset: this.props.popoverTargetOffset,
                renderElementTo: this.props.renderCalendarTo,
                constraints: this.props.tetherConstraints
              }, d["default"].createElement("div", {className: "react-datepicker__input-container"}, this.renderDateInput(), this.renderClearButton()), t);
            }
          });
      t.exports = g;
    }, function(t, e, n) {
      "use strict";
      function o(t) {
        return t && t.__esModule ? t : {"default": t};
      }
      function r(t, e) {
        var n = {};
        for (var o in t)
          e.indexOf(o) >= 0 || Object.prototype.hasOwnProperty.call(t, o) && (n[o] = t[o]);
        return n;
      }
      var a = Object.assign || function(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = arguments[e];
          for (var o in n)
            Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
        }
        return t;
      },
          i = n(2),
          s = o(i),
          l = n(3),
          p = o(l),
          d = n(4),
          f = p["default"].createClass({
            displayName: "DateInput",
            propTypes: {
              date: p["default"].PropTypes.object,
              dateFormat: p["default"].PropTypes.string,
              disabled: p["default"].PropTypes.bool,
              excludeDates: p["default"].PropTypes.array,
              filterDate: p["default"].PropTypes.func,
              includeDates: p["default"].PropTypes.array,
              locale: p["default"].PropTypes.string,
              maxDate: p["default"].PropTypes.object,
              minDate: p["default"].PropTypes.object,
              onBlur: p["default"].PropTypes.func,
              onChange: p["default"].PropTypes.func,
              onChangeDate: p["default"].PropTypes.func
            },
            getDefaultProps: function() {
              return {dateFormat: "L"};
            },
            getInitialState: function() {
              return {value: this.safeDateFormat(this.props)};
            },
            componentWillReceiveProps: function(t) {
              (0, d.isSameDay)(t.date, this.props.date) && t.locale === this.props.locale && t.dateFormat === this.props.dateFormat || this.setState({value: this.safeDateFormat(t)});
            },
            handleChange: function(t) {
              this.props.onChange && this.props.onChange(t), t.isDefaultPrevented() || this.handleChangeDate(t.target.value);
            },
            handleChangeDate: function(t) {
              if (this.props.onChangeDate) {
                var e = (0, s["default"])(t, this.props.dateFormat, this.props.locale || s["default"].locale(), !0);
                e.isValid() && !(0, d.isDayDisabled)(e, this.props) ? this.props.onChangeDate(e) : "" === t && this.props.onChangeDate(null);
              }
              this.setState({value: t});
            },
            safeDateFormat: function(t) {
              return t.date && t.date.clone().locale(t.locale || s["default"].locale()).format(t.dateFormat) || "";
            },
            handleBlur: function(t) {
              this.setState({value: this.safeDateFormat(this.props)}), this.props.onBlur && this.props.onBlur(t);
            },
            focus: function() {
              this.refs.input.focus();
            },
            render: function() {
              var t = this.props,
                  e = (t.date, t.locale, t.minDate, t.maxDate, t.excludeDates, t.includeDates, t.filterDate, t.dateFormat, t.onChangeDate, r(t, ["date", "locale", "minDate", "maxDate", "excludeDates", "includeDates", "filterDate", "dateFormat", "onChangeDate"]));
              return p["default"].createElement("input", a({
                ref: "input",
                type: "text"
              }, e, {
                value: this.state.value,
                onBlur: this.handleBlur,
                onChange: this.handleChange
              }));
            }
          });
      t.exports = f;
    }, function(e, n) {
      e.exports = t;
    }, function(t, n) {
      t.exports = e;
    }, function(t, e, n) {
      "use strict";
      function o(t) {
        return t && t.__esModule ? t : {"default": t};
      }
      function r(t, e) {
        return t && e ? t.isSame(e, "day") : !t && !e;
      }
      function a(t) {
        var e = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
            n = e.minDate,
            o = e.maxDate,
            a = e.excludeDates,
            i = e.includeDates,
            s = e.filterDate;
        return n && t.isBefore(n, "day") || o && t.isAfter(o, "day") || a && a.some(function(e) {
          return r(t, e);
        }) || i && !i.some(function(e) {
          return r(t, e);
        }) || s && !s(t.clone()) || !1;
      }
      function i(t, e) {
        var n = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2],
            o = n.minDate,
            r = n.includeDates,
            a = t.clone().subtract(1, e);
        return o && a.isBefore(o, e) || r && r.every(function(t) {
          return a.isBefore(t, e);
        }) || !1;
      }
      function s(t, e) {
        var n = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2],
            o = n.maxDate,
            r = n.includeDates,
            a = t.clone().add(1, e);
        return o && a.isAfter(o, e) || r && r.every(function(t) {
          return a.isAfter(t, e);
        }) || !1;
      }
      function l(t) {
        var e = t.minDate,
            n = t.includeDates;
        return n && e ? f["default"].min(n.filter(function(t) {
          return e.isSameOrBefore(t, "day");
        })) : n ? f["default"].min(n) : e;
      }
      function p(t) {
        var e = t.maxDate,
            n = t.includeDates;
        return n && e ? f["default"].max(n.filter(function(t) {
          return e.isSameOrAfter(t, "day");
        })) : n ? f["default"].max(n) : e;
      }
      Object.defineProperty(e, "__esModule", {value: !0}), e.isSameDay = r, e.isDayDisabled = a, e.allDaysDisabledBefore = i, e.allDaysDisabledAfter = s, e.getEffectiveMinDate = l, e.getEffectiveMaxDate = p;
      var d = n(2),
          f = o(d);
    }, function(t, e, n) {
      "use strict";
      function o(t) {
        return t && t.__esModule ? t : {"default": t};
      }
      var r = n(2),
          a = o(r),
          i = n(6),
          s = o(i),
          l = n(9),
          p = o(l),
          d = n(3),
          f = o(d),
          u = n(4),
          c = f["default"].createClass({
            displayName: "Calendar",
            propTypes: {
              dateFormat: f["default"].PropTypes.string.isRequired,
              endDate: f["default"].PropTypes.object,
              excludeDates: f["default"].PropTypes.array,
              filterDate: f["default"].PropTypes.func,
              fixedHeight: f["default"].PropTypes.bool,
              includeDates: f["default"].PropTypes.array,
              locale: f["default"].PropTypes.string,
              maxDate: f["default"].PropTypes.object,
              minDate: f["default"].PropTypes.object,
              onClickOutside: f["default"].PropTypes.func.isRequired,
              onSelect: f["default"].PropTypes.func.isRequired,
              openToDate: f["default"].PropTypes.object,
              selected: f["default"].PropTypes.object,
              showYearDropdown: f["default"].PropTypes.bool,
              startDate: f["default"].PropTypes.object,
              todayButton: f["default"].PropTypes.string
            },
            mixins: [n(8)],
            getInitialState: function() {
              return {date: this.localizeMoment(this.getDateInView())};
            },
            componentWillReceiveProps: function(t) {
              t.selected && !(0, u.isSameDay)(t.selected, this.props.selected) && this.setState({date: this.localizeMoment(t.selected)});
            },
            handleClickOutside: function(t) {
              this.props.onClickOutside(t);
            },
            getDateInView: function() {
              var t = this.props,
                  e = t.selected,
                  n = t.openToDate,
                  o = (0, u.getEffectiveMinDate)(this.props),
                  r = (0, u.getEffectiveMaxDate)(this.props),
                  i = (0, a["default"])();
              return e ? e : o && o.isAfter(i) ? o : r && r.isBefore(i) ? r : n ? n : i;
            },
            localizeMoment: function(t) {
              return t.clone().locale(this.props.locale || a["default"].locale());
            },
            increaseMonth: function() {
              this.setState({date: this.state.date.clone().add(1, "month")});
            },
            decreaseMonth: function() {
              this.setState({date: this.state.date.clone().subtract(1, "month")});
            },
            handleDayClick: function(t) {
              this.props.onSelect(t);
            },
            changeYear: function(t) {
              this.setState({date: this.state.date.clone().set("year", t)});
            },
            header: function() {
              var t = this.state.date.clone().startOf("week");
              return [0, 1, 2, 3, 4, 5, 6].map(function(e) {
                var n = t.clone().add(e, "days");
                return f["default"].createElement("div", {
                  key: e,
                  className: "react-datepicker__day-name"
                }, n.localeData().weekdaysMin(n));
              });
            },
            renderPreviousMonthButton: function() {
              if (!(0, u.allDaysDisabledBefore)(this.state.date, "month", this.props))
                return f["default"].createElement("a", {
                  className: "react-datepicker__navigation react-datepicker__navigation--previous",
                  onClick: this.decreaseMonth
                });
            },
            renderNextMonthButton: function() {
              if (!(0, u.allDaysDisabledAfter)(this.state.date, "month", this.props))
                return f["default"].createElement("a", {
                  className: "react-datepicker__navigation react-datepicker__navigation--next",
                  onClick: this.increaseMonth
                });
            },
            renderCurrentMonth: function() {
              var t = ["react-datepicker__current-month"];
              return this.props.showYearDropdown && t.push("react-datepicker__current-month--hasYearDropdown"), f["default"].createElement("div", {className: t.join(" ")}, this.state.date.format(this.props.dateFormat));
            },
            renderYearDropdown: function() {
              if (this.props.showYearDropdown)
                return f["default"].createElement(s["default"], {
                  onChange: this.changeYear,
                  year: this.state.date.year()
                });
            },
            renderTodayButton: function() {
              var t = this;
              if (this.props.todayButton)
                return f["default"].createElement("div", {
                  className: "react-datepicker__today-button",
                  onClick: function() {
                    return t.props.onSelect((0, a["default"])());
                  }
                }, this.props.todayButton);
            },
            render: function() {
              return f["default"].createElement("div", {className: "react-datepicker"}, f["default"].createElement("div", {className: "react-datepicker__triangle"}), f["default"].createElement("div", {className: "react-datepicker__header"}, this.renderPreviousMonthButton(), this.renderCurrentMonth(), this.renderYearDropdown(), this.renderNextMonthButton(), f["default"].createElement("div", null, this.header())), f["default"].createElement(p["default"], {
                day: this.state.date,
                onDayClick: this.handleDayClick,
                minDate: this.props.minDate,
                maxDate: this.props.maxDate,
                excludeDates: this.props.excludeDates,
                includeDates: this.props.includeDates,
                fixedHeight: this.props.fixedHeight,
                filterDate: this.props.filterDate,
                selected: this.props.selected,
                startDate: this.props.startDate,
                endDate: this.props.endDate
              }), this.renderTodayButton());
            }
          });
      t.exports = c;
    }, function(t, e, n) {
      "use strict";
      function o(t) {
        return t && t.__esModule ? t : {"default": t};
      }
      var r = n(3),
          a = o(r),
          i = n(7),
          s = o(i),
          l = a["default"].createClass({
            displayName: "YearDropdown",
            propTypes: {
              onChange: a["default"].PropTypes.func.isRequired,
              year: a["default"].PropTypes.number.isRequired
            },
            getInitialState: function() {
              return {dropdownVisible: !1};
            },
            renderReadView: function() {
              return a["default"].createElement("div", {
                className: "react-datepicker__year-read-view",
                onClick: this.toggleDropdown
              }, a["default"].createElement("span", {className: "react-datepicker__year-read-view--selected-year"}, this.props.year), a["default"].createElement("span", {className: "react-datepicker__year-read-view--down-arrow"}));
            },
            renderDropdown: function() {
              return a["default"].createElement(s["default"], {
                ref: "options",
                year: this.props.year,
                onChange: this.onChange,
                onCancel: this.toggleDropdown
              });
            },
            onChange: function(t) {
              this.toggleDropdown(), t !== this.props.year && this.props.onChange(t);
            },
            toggleDropdown: function() {
              this.setState({dropdownVisible: !this.state.dropdownVisible});
            },
            render: function() {
              return a["default"].createElement("div", null, this.state.dropdownVisible ? this.renderDropdown() : this.renderReadView());
            }
          });
      t.exports = l;
    }, function(t, e, n) {
      "use strict";
      function o(t) {
        return t && t.__esModule ? t : {"default": t};
      }
      function r(t) {
        for (var e = [],
            n = 0; n < 5; n++)
          e.push(t - n);
        return e;
      }
      var a = n(3),
          i = o(a),
          s = i["default"].createClass({
            displayName: "YearDropdownOptions",
            propTypes: {
              onCancel: i["default"].PropTypes.func.isRequired,
              onChange: i["default"].PropTypes.func.isRequired,
              year: i["default"].PropTypes.number.isRequired
            },
            mixins: [n(8)],
            getInitialState: function() {
              return {yearsList: r(this.props.year)};
            },
            renderOptions: function() {
              var t = this,
                  e = this.props.year,
                  n = this.state.yearsList.map(function(n) {
                    return i["default"].createElement("div", {
                      className: "react-datepicker__year-option",
                      key: n,
                      onClick: t.onChange.bind(t, n)
                    }, e === n ? i["default"].createElement("span", {className: "react-datepicker__year-option--selected"}, "") : "", n);
                  });
              return n.unshift(i["default"].createElement("div", {
                className: "react-datepicker__year-option",
                ref: "upcoming",
                key: "upcoming",
                onClick: this.incrementYears
              }, i["default"].createElement("a", {className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming"}))), n.push(i["default"].createElement("div", {
                className: "react-datepicker__year-option",
                ref: "previous",
                key: "previous",
                onClick: this.decrementYears
              }, i["default"].createElement("a", {className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous"}))), n;
            },
            onChange: function(t) {
              this.props.onChange(t);
            },
            handleClickOutside: function() {
              this.props.onCancel();
            },
            shiftYears: function(t) {
              var e = this.state.yearsList.map(function(e) {
                return e + t;
              });
              this.setState({yearsList: e});
            },
            incrementYears: function() {
              return this.shiftYears(1);
            },
            decrementYears: function() {
              return this.shiftYears(-1);
            },
            render: function() {
              return i["default"].createElement("div", {className: "react-datepicker__year-dropdown"}, this.renderOptions());
            }
          });
      t.exports = s;
    }, function(t, e) {
      t.exports = n;
    }, function(t, e, n) {
      "use strict";
      function o(t) {
        return t && t.__esModule ? t : {"default": t};
      }
      var r = n(3),
          a = o(r),
          i = n(10),
          s = o(i),
          l = a["default"].createClass({
            displayName: "Month",
            propTypes: {
              day: a["default"].PropTypes.object.isRequired,
              endDate: a["default"].PropTypes.object,
              excludeDates: a["default"].PropTypes.array,
              filterDate: a["default"].PropTypes.func,
              fixedHeight: a["default"].PropTypes.bool,
              includeDates: a["default"].PropTypes.array,
              maxDate: a["default"].PropTypes.object,
              minDate: a["default"].PropTypes.object,
              onDayClick: a["default"].PropTypes.func,
              selected: a["default"].PropTypes.object,
              startDate: a["default"].PropTypes.object
            },
            handleDayClick: function(t) {
              this.props.onDayClick && this.props.onDayClick(t);
            },
            isWeekInMonth: function(t) {
              var e = this.props.day,
                  n = t.clone().add(6, "days");
              return t.isSame(e, "month") || n.isSame(e, "month");
            },
            renderWeeks: function() {
              var t = this,
                  e = this.props.day.clone().startOf("month").startOf("week");
              return [0, 1, 2, 3, 4, 5].map(function(t) {
                return e.clone().add(t, "weeks");
              }).filter(function(e) {
                return t.props.fixedHeight || t.isWeekInMonth(e);
              }).map(function(e, n) {
                return a["default"].createElement(s["default"], {
                  key: n,
                  day: e,
                  month: t.props.day.month(),
                  onDayClick: t.handleDayClick,
                  minDate: t.props.minDate,
                  maxDate: t.props.maxDate,
                  excludeDates: t.props.excludeDates,
                  includeDates: t.props.includeDates,
                  filterDate: t.props.filterDate,
                  selected: t.props.selected,
                  startDate: t.props.startDate,
                  endDate: t.props.endDate
                });
              });
            },
            render: function() {
              return a["default"].createElement("div", {className: "react-datepicker__month"}, this.renderWeeks());
            }
          });
      t.exports = l;
    }, function(t, e, n) {
      "use strict";
      function o(t) {
        return t && t.__esModule ? t : {"default": t};
      }
      var r = n(3),
          a = o(r),
          i = n(11),
          s = o(i),
          l = a["default"].createClass({
            displayName: "Week",
            propTypes: {
              day: a["default"].PropTypes.object.isRequired,
              endDate: a["default"].PropTypes.object,
              excludeDates: a["default"].PropTypes.array,
              filterDate: a["default"].PropTypes.func,
              includeDates: a["default"].PropTypes.array,
              maxDate: a["default"].PropTypes.object,
              minDate: a["default"].PropTypes.object,
              month: a["default"].PropTypes.number,
              onDayClick: a["default"].PropTypes.func,
              selected: a["default"].PropTypes.object,
              startDate: a["default"].PropTypes.object
            },
            handleDayClick: function(t) {
              this.props.onDayClick && this.props.onDayClick(t);
            },
            renderDays: function() {
              var t = this,
                  e = this.props.day.clone().startOf("week");
              return [0, 1, 2, 3, 4, 5, 6].map(function(n) {
                var o = e.clone().add(n, "days");
                return a["default"].createElement(s["default"], {
                  key: n,
                  day: o,
                  month: t.props.month,
                  onClick: t.handleDayClick.bind(t, o),
                  minDate: t.props.minDate,
                  maxDate: t.props.maxDate,
                  excludeDates: t.props.excludeDates,
                  includeDates: t.props.includeDates,
                  filterDate: t.props.filterDate,
                  selected: t.props.selected,
                  startDate: t.props.startDate,
                  endDate: t.props.endDate
                });
              });
            },
            render: function() {
              return a["default"].createElement("div", {className: "react-datepicker__week"}, this.renderDays());
            }
          });
      t.exports = l;
    }, function(t, e, n) {
      "use strict";
      function o(t) {
        return t && t.__esModule ? t : {"default": t};
      }
      var r = n(2),
          a = o(r),
          i = n(3),
          s = o(i),
          l = n(12),
          p = o(l),
          d = n(4),
          f = s["default"].createClass({
            displayName: "Day",
            propTypes: {
              day: s["default"].PropTypes.object.isRequired,
              endDate: s["default"].PropTypes.object,
              excludeDates: s["default"].PropTypes.array,
              filterDate: s["default"].PropTypes.func,
              includeDates: s["default"].PropTypes.array,
              maxDate: s["default"].PropTypes.object,
              minDate: s["default"].PropTypes.object,
              month: s["default"].PropTypes.number,
              onClick: s["default"].PropTypes.func,
              selected: s["default"].PropTypes.object,
              startDate: s["default"].PropTypes.object
            },
            handleClick: function(t) {
              !this.isDisabled() && this.props.onClick && this.props.onClick(t);
            },
            isSameDay: function(t) {
              return (0, d.isSameDay)(this.props.day, t);
            },
            isDisabled: function() {
              return (0, d.isDayDisabled)(this.props.day, this.props);
            },
            isInRange: function() {
              var t = this.props,
                  e = t.day,
                  n = t.startDate,
                  o = t.endDate;
              if (!n || !o)
                return !1;
              var r = n.clone().startOf("day").subtract(1, "seconds"),
                  a = o.clone().startOf("day").add(1, "seconds");
              return e.clone().startOf("day").isBetween(r, a);
            },
            isWeekend: function() {
              var t = this.props.day.day();
              return 0 === t || 6 === t;
            },
            isOutsideMonth: function() {
              return void 0 !== this.props.month && this.props.month !== this.props.day.month();
            },
            getClassNames: function() {
              return (0, p["default"])("react-datepicker__day", {
                "react-datepicker__day--disabled": this.isDisabled(),
                "react-datepicker__day--selected": this.isSameDay(this.props.selected),
                "react-datepicker__day--in-range": this.isInRange(),
                "react-datepicker__day--today": this.isSameDay((0, a["default"])()),
                "react-datepicker__day--weekend": this.isWeekend(),
                "react-datepicker__day--outside-month": this.isOutsideMonth()
              });
            },
            render: function() {
              return s["default"].createElement("div", {
                className: this.getClassNames(),
                onClick: this.handleClick
              }, this.props.day.date());
            }
          });
      t.exports = f;
    }, function(t, e, n) {
      var o,
          r;
      !function() {
        "use strict";
        function n() {
          for (var t = [],
              e = 0; e < arguments.length; e++) {
            var o = arguments[e];
            if (o) {
              var r = typeof o;
              if ("string" === r || "number" === r)
                t.push(o);
              else if (Array.isArray(o))
                t.push(n.apply(null, o));
              else if ("object" === r)
                for (var i in o)
                  a.call(o, i) && o[i] && t.push(i);
            }
          }
          return t.join(" ");
        }
        var a = {}.hasOwnProperty;
        "undefined" != typeof t && t.exports ? t.exports = n : (o = [], r = function() {
          return n;
        }.apply(e, o), !(void 0 !== r && (t.exports = r)));
      }();
    }, function(t, e, n) {
      "use strict";
      function o(t) {
        return t && t.__esModule ? t : {"default": t};
      }
      function r(t, e) {
        var n = {};
        for (var o in t)
          e.indexOf(o) >= 0 || Object.prototype.hasOwnProperty.call(t, o) && (n[o] = t[o]);
        return n;
      }
      function a(t, e, n) {
        var o = t.children,
            r = s.Children.count(o);
        return r <= 0 ? new Error(n + " expects at least one child to use as the target element.") : r > 2 ? new Error("Only a max of two children allowed in " + n + ".") : void 0;
      }
      var i = Object.assign || function(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = arguments[e];
          for (var o in n)
            Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
        }
        return t;
      },
          s = n(3),
          l = o(s),
          p = n(14),
          d = o(p),
          f = n(15),
          u = o(f),
          c = ["top left", "top center", "top right", "middle left", "middle center", "middle right", "bottom left", "bottom center", "bottom right"],
          h = l["default"].createClass({
            displayName: "TetherComponent",
            propTypes: {
              attachment: s.PropTypes.oneOf(c).isRequired,
              children: a,
              className: s.PropTypes.string,
              classPrefix: s.PropTypes.string,
              classes: s.PropTypes.object,
              constraints: s.PropTypes.array,
              enabled: s.PropTypes.bool,
              id: s.PropTypes.string,
              offset: s.PropTypes.string,
              optimizations: s.PropTypes.object,
              renderElementTag: s.PropTypes.string,
              renderElementTo: s.PropTypes.any,
              style: s.PropTypes.object,
              targetAttachment: s.PropTypes.oneOf(c),
              targetModifier: s.PropTypes.string,
              targetOffset: s.PropTypes.string
            },
            getDefaultProps: function() {
              return {
                renderElementTag: "div",
                renderElementTo: null
              };
            },
            componentDidMount: function() {
              this._targetNode = d["default"].findDOMNode(this), this._update();
            },
            componentDidUpdate: function() {
              this._update();
            },
            componentWillUnmount: function() {
              this._destroy();
            },
            disable: function() {
              this._tether.disable();
            },
            enable: function() {
              this._tether.enable();
            },
            position: function() {
              this._tether.position();
            },
            _destroy: function() {
              this._elementParentNode && (d["default"].unmountComponentAtNode(this._elementParentNode), this._elementParentNode.parentNode.removeChild(this._elementParentNode)), this._tether && this._tether.destroy(), this._elementParentNode = null, this._tether = null;
            },
            _update: function() {
              var t = this,
                  e = this.props,
                  n = e.children,
                  o = e.renderElementTag,
                  r = e.renderElementTo,
                  a = n[1];
              if (!a)
                return void(this._tether && this._destroy());
              if (!this._elementParentNode) {
                this._elementParentNode = document.createElement(o);
                var i = r || document.body;
                i.appendChild(this._elementParentNode);
              }
              d["default"].unstable_renderSubtreeIntoContainer(this, a, this._elementParentNode, function() {
                t._updateTether();
              });
            },
            _updateTether: function() {
              var t = this.props,
                  e = (t.renderElementTag, t.renderElementTo, r(t, ["renderElementTag", "renderElementTo"])),
                  n = i({
                    target: this._targetNode,
                    element: this._elementParentNode
                  }, e);
              this._tether ? this._tether.setOptions(n) : this._tether = new u["default"](n), this._tether.position();
            },
            render: function() {
              var t = this.props.children,
                  e = null;
              return s.Children.forEach(t, function(t, n) {
                if (0 === n)
                  return void(e = t);
              }), e;
            }
          });
      t.exports = h;
    }, function(t, e) {
      t.exports = o;
    }, function(t, e, n) {
      var o,
          r;
      !function(a, i) {
        o = i, r = "function" == typeof o ? o.call(e, n, e, t) : o, !(void 0 !== r && (t.exports = r));
      }(this, function(t, e, n) {
        "use strict";
        function o(t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        }
        function r(t) {
          var e = getComputedStyle(t) || {},
              n = e.position,
              o = [];
          if ("fixed" === n)
            return [t];
          for (var r = t; (r = r.parentNode) && r && 1 === r.nodeType; ) {
            var a = void 0;
            try {
              a = getComputedStyle(r);
            } catch (i) {}
            if ("undefined" == typeof a || null === a)
              return o.push(r), o;
            var s = a,
                l = s.overflow,
                p = s.overflowX,
                d = s.overflowY;
            /(auto|scroll)/.test(l + d + p) && ("absolute" !== n || ["relative", "absolute", "fixed"].indexOf(a.position) >= 0) && o.push(r);
          }
          return o.push(document.body), o;
        }
        function a() {
          w && document.body.removeChild(w), w = null;
        }
        function i(t) {
          var e = void 0;
          t === document ? (e = document, t = document.documentElement) : e = t.ownerDocument;
          var n = e.documentElement,
              o = {},
              r = t.getBoundingClientRect();
          for (var a in r)
            o[a] = r[a];
          var i = k();
          return o.top -= i.top, o.left -= i.left, "undefined" == typeof o.width && (o.width = document.body.scrollWidth - o.left - o.right), "undefined" == typeof o.height && (o.height = document.body.scrollHeight - o.top - o.bottom), o.top = o.top - n.clientTop, o.left = o.left - n.clientLeft, o.right = e.body.clientWidth - o.width - o.left, o.bottom = e.body.clientHeight - o.height - o.top, o;
        }
        function s(t) {
          return t.offsetParent || document.documentElement;
        }
        function l() {
          var t = document.createElement("div");
          t.style.width = "100%", t.style.height = "200px";
          var e = document.createElement("div");
          p(e.style, {
            position: "absolute",
            top: 0,
            left: 0,
            pointerEvents: "none",
            visibility: "hidden",
            width: "200px",
            height: "150px",
            overflow: "hidden"
          }), e.appendChild(t), document.body.appendChild(e);
          var n = t.offsetWidth;
          e.style.overflow = "scroll";
          var o = t.offsetWidth;
          n === o && (o = e.clientWidth), document.body.removeChild(e);
          var r = n - o;
          return {
            width: r,
            height: r
          };
        }
        function p() {
          var t = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],
              e = [];
          return Array.prototype.push.apply(e, arguments), e.slice(1).forEach(function(e) {
            if (e)
              for (var n in e)
                ({}).hasOwnProperty.call(e, n) && (t[n] = e[n]);
          }), t;
        }
        function d(t, e) {
          if ("undefined" != typeof t.classList)
            e.split(" ").forEach(function(e) {
              e.trim() && t.classList.remove(e);
            });
          else {
            var n = new RegExp("(^| )" + e.split(" ").join("|") + "( |$)", "gi"),
                o = c(t).replace(n, " ");
            h(t, o);
          }
        }
        function f(t, e) {
          if ("undefined" != typeof t.classList)
            e.split(" ").forEach(function(e) {
              e.trim() && t.classList.add(e);
            });
          else {
            d(t, e);
            var n = c(t) + (" " + e);
            h(t, n);
          }
        }
        function u(t, e) {
          if ("undefined" != typeof t.classList)
            return t.classList.contains(e);
          var n = c(t);
          return new RegExp("(^| )" + e + "( |$)", "gi").test(n);
        }
        function c(t) {
          return t.className instanceof SVGAnimatedString ? t.className.baseVal : t.className;
        }
        function h(t, e) {
          t.setAttribute("class", e);
        }
        function m(t, e, n) {
          n.forEach(function(n) {
            e.indexOf(n) === -1 && u(t, n) && d(t, n);
          }), e.forEach(function(e) {
            u(t, e) || f(t, e);
          });
        }
        function o(t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        }
        function y(t, e) {
          if ("function" != typeof e && null !== e)
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, {constructor: {
              value: t,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }}), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        function g(t, e) {
          var n = arguments.length <= 2 || void 0 === arguments[2] ? 1 : arguments[2];
          return t + n >= e && e >= t - n;
        }
        function v() {
          return "undefined" != typeof performance && "undefined" != typeof performance.now ? performance.now() : +new Date;
        }
        function b() {
          for (var t = {
            top: 0,
            left: 0
          },
              e = arguments.length,
              n = Array(e),
              o = 0; o < e; o++)
            n[o] = arguments[o];
          return n.forEach(function(e) {
            var n = e.top,
                o = e.left;
            "string" == typeof n && (n = parseFloat(n, 10)), "string" == typeof o && (o = parseFloat(o, 10)), t.top += n, t.left += o;
          }), t;
        }
        function D(t, e) {
          return "string" == typeof t.left && t.left.indexOf("%") !== -1 && (t.left = parseFloat(t.left, 10) / 100 * e.width), "string" == typeof t.top && t.top.indexOf("%") !== -1 && (t.top = parseFloat(t.top, 10) / 100 * e.height), t;
        }
        function C(t, e) {
          return "scrollParent" === e ? e = t.scrollParents[0] : "window" === e && (e = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset]), e === document && (e = e.documentElement), "undefined" != typeof e.nodeType && !function() {
            var t = i(e),
                n = t,
                o = getComputedStyle(e);
            e = [n.left, n.top, t.width + n.left, t.height + n.top], U.forEach(function(t, n) {
              t = t[0].toUpperCase() + t.substr(1), "Top" === t || "Left" === t ? e[n] += parseFloat(o["border" + t + "Width"]) : e[n] -= parseFloat(o["border" + t + "Width"]);
            });
          }(), e;
        }
        var T = function() {
          function t(t, e) {
            for (var n = 0; n < e.length; n++) {
              var o = e[n];
              o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
            }
          }
          return function(e, n, o) {
            return n && t(e.prototype, n), o && t(e, o), e;
          };
        }(),
            P = void 0;
        "undefined" == typeof P && (P = {modules: []});
        var w = null,
            _ = function() {
              var t = 0;
              return function() {
                return ++t;
              };
            }(),
            x = {},
            k = function() {
              var t = w;
              t || (t = document.createElement("div"), t.setAttribute("data-tether-id", _()), p(t.style, {
                top: 0,
                left: 0,
                position: "absolute"
              }), document.body.appendChild(t), w = t);
              var e = t.getAttribute("data-tether-id");
              if ("undefined" == typeof x[e]) {
                x[e] = {};
                var n = t.getBoundingClientRect();
                for (var o in n)
                  x[e][o] = n[o];
                E(function() {
                  delete x[e];
                });
              }
              return x[e];
            },
            O = [],
            E = function(t) {
              O.push(t);
            },
            j = function() {
              for (var t = void 0; t = O.pop(); )
                t();
            },
            S = function() {
              function t() {
                o(this, t);
              }
              return T(t, [{
                key: "on",
                value: function(t, e, n) {
                  var o = !(arguments.length <= 3 || void 0 === arguments[3]) && arguments[3];
                  "undefined" == typeof this.bindings && (this.bindings = {}), "undefined" == typeof this.bindings[t] && (this.bindings[t] = []), this.bindings[t].push({
                    handler: e,
                    ctx: n,
                    once: o
                  });
                }
              }, {
                key: "once",
                value: function(t, e, n) {
                  this.on(t, e, n, !0);
                }
              }, {
                key: "off",
                value: function(t, e) {
                  if ("undefined" == typeof this.bindings || "undefined" == typeof this.bindings[t])
                    if ("undefined" == typeof e)
                      delete this.bindings[t];
                    else
                      for (var n = 0; n < this.bindings[t].length; )
                        this.bindings[t][n].handler === e ? this.bindings[t].splice(n, 1) : ++n;
                }
              }, {
                key: "trigger",
                value: function(t) {
                  if ("undefined" != typeof this.bindings && this.bindings[t]) {
                    for (var e = 0,
                        n = arguments.length,
                        o = Array(n > 1 ? n - 1 : 0),
                        r = 1; r < n; r++)
                      o[r - 1] = arguments[r];
                    for (; e < this.bindings[t].length; ) {
                      var a = this.bindings[t][e],
                          i = a.handler,
                          s = a.ctx,
                          l = a.once,
                          p = s;
                      "undefined" == typeof p && (p = this), i.apply(p, o), l ? this.bindings[t].splice(e, 1) : ++e;
                    }
                  }
                }
              }]), t;
            }();
        P.Utils = {
          getScrollParents: r,
          getBounds: i,
          getOffsetParent: s,
          extend: p,
          addClass: f,
          removeClass: d,
          hasClass: u,
          updateClasses: m,
          defer: E,
          flush: j,
          uniqueId: _,
          Evented: S,
          getScrollBarSize: l,
          removeUtilElements: a
        };
        var N = function() {
          function t(t, e) {
            var n = [],
                o = !0,
                r = !1,
                a = void 0;
            try {
              for (var i,
                  s = t[Symbol.iterator](); !(o = (i = s.next()).done) && (n.push(i.value), !e || n.length !== e); o = !0)
                ;
            } catch (l) {
              r = !0, a = l;
            } finally {
              try {
                !o && s["return"] && s["return"]();
              } finally {
                if (r)
                  throw a;
              }
            }
            return n;
          }
          return function(e, n) {
            if (Array.isArray(e))
              return e;
            if (Symbol.iterator in Object(e))
              return t(e, n);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }(),
            T = function() {
              function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                  var o = e[n];
                  o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
                }
              }
              return function(e, n, o) {
                return n && t(e.prototype, n), o && t(e, o), e;
              };
            }(),
            M = function(t, e, n) {
              for (var o = !0; o; ) {
                var r = t,
                    a = e,
                    i = n;
                o = !1, null === r && (r = Function.prototype);
                var s = Object.getOwnPropertyDescriptor(r, a);
                if (void 0 !== s) {
                  if ("value" in s)
                    return s.value;
                  var l = s.get;
                  if (void 0 === l)
                    return;
                  return l.call(i);
                }
                var p = Object.getPrototypeOf(r);
                if (null === p)
                  return;
                t = p, e = a, n = i, o = !0, s = p = void 0;
              }
            };
        if ("undefined" == typeof P)
          throw new Error("You must include the utils.js file before tether.js");
        var A = P.Utils,
            r = A.getScrollParents,
            i = A.getBounds,
            s = A.getOffsetParent,
            p = A.extend,
            f = A.addClass,
            d = A.removeClass,
            m = A.updateClasses,
            E = A.defer,
            j = A.flush,
            l = A.getScrollBarSize,
            a = A.removeUtilElements,
            B = function() {
              if ("undefined" == typeof document)
                return "";
              for (var t = document.createElement("div"),
                  e = ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"],
                  n = 0; n < e.length; ++n) {
                var o = e[n];
                if (void 0 !== t.style[o])
                  return o;
              }
            }(),
            F = [],
            Y = function() {
              F.forEach(function(t) {
                t.position(!1);
              }), j();
            };
        !function() {
          var t = null,
              e = null,
              n = null,
              o = function r() {
                return "undefined" != typeof e && e > 16 ? (e = Math.min(e - 16, 250), void(n = setTimeout(r, 250))) : void("undefined" != typeof t && v() - t < 10 || (null != n && (clearTimeout(n), n = null), t = v(), Y(), e = v() - t));
              };
          "undefined" != typeof window && "undefined" != typeof window.addEventListener && ["resize", "scroll", "touchmove"].forEach(function(t) {
            window.addEventListener(t, o);
          });
        }();
        var W = {
          center: "center",
          left: "right",
          right: "left"
        },
            q = {
              middle: "middle",
              top: "bottom",
              bottom: "top"
            },
            I = {
              top: 0,
              left: 0,
              middle: "50%",
              center: "50%",
              bottom: "100%",
              right: "100%"
            },
            R = function(t, e) {
              var n = t.left,
                  o = t.top;
              return "auto" === n && (n = W[e.left]), "auto" === o && (o = q[e.top]), {
                left: n,
                top: o
              };
            },
            z = function(t) {
              var e = t.left,
                  n = t.top;
              return "undefined" != typeof I[t.left] && (e = I[t.left]), "undefined" != typeof I[t.top] && (n = I[t.top]), {
                left: e,
                top: n
              };
            },
            H = function(t) {
              var e = t.split(" "),
                  n = N(e, 2),
                  o = n[0],
                  r = n[1];
              return {
                top: o,
                left: r
              };
            },
            L = H,
            X = function(t) {
              function e(t) {
                var n = this;
                o(this, e), M(Object.getPrototypeOf(e.prototype), "constructor", this).call(this), this.position = this.position.bind(this), F.push(this), this.history = [], this.setOptions(t, !1), P.modules.forEach(function(t) {
                  "undefined" != typeof t.initialize && t.initialize.call(n);
                }), this.position();
              }
              return y(e, t), T(e, [{
                key: "getClass",
                value: function() {
                  var t = arguments.length <= 0 || void 0 === arguments[0] ? "" : arguments[0],
                      e = this.options.classes;
                  return "undefined" != typeof e && e[t] ? this.options.classes[t] : this.options.classPrefix ? this.options.classPrefix + "-" + t : t;
                }
              }, {
                key: "setOptions",
                value: function(t) {
                  var e = this,
                      n = arguments.length <= 1 || void 0 === arguments[1] || arguments[1],
                      o = {
                        offset: "0 0",
                        targetOffset: "0 0",
                        targetAttachment: "auto auto",
                        classPrefix: "tether"
                      };
                  this.options = p(o, t);
                  var a = this.options,
                      i = a.element,
                      s = a.target,
                      l = a.targetModifier;
                  if (this.element = i, this.target = s, this.targetModifier = l, "viewport" === this.target ? (this.target = document.body, this.targetModifier = "visible") : "scroll-handle" === this.target && (this.target = document.body, this.targetModifier = "scroll-handle"), ["element", "target"].forEach(function(t) {
                    if ("undefined" == typeof e[t])
                      throw new Error("Tether Error: Both element and target must be defined");
                    "undefined" != typeof e[t].jquery ? e[t] = e[t][0] : "string" == typeof e[t] && (e[t] = document.querySelector(e[t]));
                  }), f(this.element, this.getClass("element")), this.options.addTargetClasses !== !1 && f(this.target, this.getClass("target")), !this.options.attachment)
                    throw new Error("Tether Error: You must provide an attachment");
                  this.targetAttachment = L(this.options.targetAttachment), this.attachment = L(this.options.attachment), this.offset = H(this.options.offset), this.targetOffset = H(this.options.targetOffset), "undefined" != typeof this.scrollParents && this.disable(), "scroll-handle" === this.targetModifier ? this.scrollParents = [this.target] : this.scrollParents = r(this.target), this.options.enabled !== !1 && this.enable(n);
                }
              }, {
                key: "getTargetBounds",
                value: function() {
                  if ("undefined" == typeof this.targetModifier)
                    return i(this.target);
                  if ("visible" === this.targetModifier) {
                    if (this.target === document.body)
                      return {
                        top: pageYOffset,
                        left: pageXOffset,
                        height: innerHeight,
                        width: innerWidth
                      };
                    var t = i(this.target),
                        e = {
                          height: t.height,
                          width: t.width,
                          top: t.top,
                          left: t.left
                        };
                    return e.height = Math.min(e.height, t.height - (pageYOffset - t.top)), e.height = Math.min(e.height, t.height - (t.top + t.height - (pageYOffset + innerHeight))), e.height = Math.min(innerHeight, e.height), e.height -= 2, e.width = Math.min(e.width, t.width - (pageXOffset - t.left)), e.width = Math.min(e.width, t.width - (t.left + t.width - (pageXOffset + innerWidth))), e.width = Math.min(innerWidth, e.width), e.width -= 2, e.top < pageYOffset && (e.top = pageYOffset), e.left < pageXOffset && (e.left = pageXOffset), e;
                  }
                  if ("scroll-handle" === this.targetModifier) {
                    var t = void 0,
                        n = this.target;
                    n === document.body ? (n = document.documentElement, t = {
                      left: pageXOffset,
                      top: pageYOffset,
                      height: innerHeight,
                      width: innerWidth
                    }) : t = i(n);
                    var o = getComputedStyle(n),
                        r = n.scrollWidth > n.clientWidth || [o.overflow, o.overflowX].indexOf("scroll") >= 0 || this.target !== document.body,
                        a = 0;
                    r && (a = 15);
                    var s = t.height - parseFloat(o.borderTopWidth) - parseFloat(o.borderBottomWidth) - a,
                        e = {
                          width: 15,
                          height: .975 * s * (s / n.scrollHeight),
                          left: t.left + t.width - parseFloat(o.borderLeftWidth) - 15
                        },
                        l = 0;
                    s < 408 && this.target === document.body && (l = -11e-5 * Math.pow(s, 2) - .00727 * s + 22.58), this.target !== document.body && (e.height = Math.max(e.height, 24));
                    var p = this.target.scrollTop / (n.scrollHeight - s);
                    return e.top = p * (s - e.height - l) + t.top + parseFloat(o.borderTopWidth), this.target === document.body && (e.height = Math.max(e.height, 24)), e;
                  }
                }
              }, {
                key: "clearCache",
                value: function() {
                  this._cache = {};
                }
              }, {
                key: "cache",
                value: function(t, e) {
                  return "undefined" == typeof this._cache && (this._cache = {}), "undefined" == typeof this._cache[t] && (this._cache[t] = e.call(this)), this._cache[t];
                }
              }, {
                key: "enable",
                value: function() {
                  var t = this,
                      e = arguments.length <= 0 || void 0 === arguments[0] || arguments[0];
                  this.options.addTargetClasses !== !1 && f(this.target, this.getClass("enabled")), f(this.element, this.getClass("enabled")), this.enabled = !0, this.scrollParents.forEach(function(e) {
                    e !== document && e.addEventListener("scroll", t.position);
                  }), e && this.position();
                }
              }, {
                key: "disable",
                value: function() {
                  var t = this;
                  d(this.target, this.getClass("enabled")), d(this.element, this.getClass("enabled")), this.enabled = !1, "undefined" != typeof this.scrollParents && this.scrollParents.forEach(function(e) {
                    e.removeEventListener("scroll", t.position);
                  });
                }
              }, {
                key: "destroy",
                value: function() {
                  var t = this;
                  this.disable(), F.forEach(function(e, n) {
                    e === t && F.splice(n, 1);
                  }), 0 === F.length && a();
                }
              }, {
                key: "updateAttachClasses",
                value: function(t, e) {
                  var n = this;
                  t = t || this.attachment, e = e || this.targetAttachment;
                  var o = ["left", "top", "bottom", "right", "middle", "center"];
                  "undefined" != typeof this._addAttachClasses && this._addAttachClasses.length && this._addAttachClasses.splice(0, this._addAttachClasses.length), "undefined" == typeof this._addAttachClasses && (this._addAttachClasses = []);
                  var r = this._addAttachClasses;
                  t.top && r.push(this.getClass("element-attached") + "-" + t.top), t.left && r.push(this.getClass("element-attached") + "-" + t.left), e.top && r.push(this.getClass("target-attached") + "-" + e.top), e.left && r.push(this.getClass("target-attached") + "-" + e.left);
                  var a = [];
                  o.forEach(function(t) {
                    a.push(n.getClass("element-attached") + "-" + t), a.push(n.getClass("target-attached") + "-" + t);
                  }), E(function() {
                    "undefined" != typeof n._addAttachClasses && (m(n.element, n._addAttachClasses, a), n.options.addTargetClasses !== !1 && m(n.target, n._addAttachClasses, a), delete n._addAttachClasses);
                  });
                }
              }, {
                key: "position",
                value: function() {
                  var t = this,
                      e = arguments.length <= 0 || void 0 === arguments[0] || arguments[0];
                  if (this.enabled) {
                    this.clearCache();
                    var n = R(this.targetAttachment, this.attachment);
                    this.updateAttachClasses(this.attachment, n);
                    var o = this.cache("element-bounds", function() {
                      return i(t.element);
                    }),
                        r = o.width,
                        a = o.height;
                    if (0 === r && 0 === a && "undefined" != typeof this.lastSize) {
                      var p = this.lastSize;
                      r = p.width, a = p.height;
                    } else
                      this.lastSize = {
                        width: r,
                        height: a
                      };
                    var d = this.cache("target-bounds", function() {
                      return t.getTargetBounds();
                    }),
                        f = d,
                        u = D(z(this.attachment), {
                          width: r,
                          height: a
                        }),
                        c = D(z(n), f),
                        h = D(this.offset, {
                          width: r,
                          height: a
                        }),
                        m = D(this.targetOffset, f);
                    u = b(u, h), c = b(c, m);
                    for (var y = d.left + c.left - u.left,
                        g = d.top + c.top - u.top,
                        v = 0; v < P.modules.length; ++v) {
                      var C = P.modules[v],
                          T = C.position.call(this, {
                            left: y,
                            top: g,
                            targetAttachment: n,
                            targetPos: d,
                            elementPos: o,
                            offset: u,
                            targetOffset: c,
                            manualOffset: h,
                            manualTargetOffset: m,
                            scrollbarSize: _,
                            attachment: this.attachment
                          });
                      if (T === !1)
                        return !1;
                      "undefined" != typeof T && "object" == typeof T && (g = T.top, y = T.left);
                    }
                    var w = {
                      page: {
                        top: g,
                        left: y
                      },
                      viewport: {
                        top: g - pageYOffset,
                        bottom: pageYOffset - g - a + innerHeight,
                        left: y - pageXOffset,
                        right: pageXOffset - y - r + innerWidth
                      }
                    },
                        _ = void 0;
                    return document.body.scrollWidth > window.innerWidth && (_ = this.cache("scrollbar-size", l), w.viewport.bottom -= _.height), document.body.scrollHeight > window.innerHeight && (_ = this.cache("scrollbar-size", l), w.viewport.right -= _.width), ["", "static"].indexOf(document.body.style.position) !== -1 && ["", "static"].indexOf(document.body.parentElement.style.position) !== -1 || (w.page.bottom = document.body.scrollHeight - g - a, w.page.right = document.body.scrollWidth - y - r), "undefined" != typeof this.options.optimizations && this.options.optimizations.moveElement !== !1 && "undefined" == typeof this.targetModifier && !function() {
                      var e = t.cache("target-offsetparent", function() {
                        return s(t.target);
                      }),
                          n = t.cache("target-offsetparent-bounds", function() {
                            return i(e);
                          }),
                          o = getComputedStyle(e),
                          r = n,
                          a = {};
                      if (["Top", "Left", "Bottom", "Right"].forEach(function(t) {
                        a[t.toLowerCase()] = parseFloat(o["border" + t + "Width"]);
                      }), n.right = document.body.scrollWidth - n.left - r.width + a.right, n.bottom = document.body.scrollHeight - n.top - r.height + a.bottom, w.page.top >= n.top + a.top && w.page.bottom >= n.bottom && w.page.left >= n.left + a.left && w.page.right >= n.right) {
                        var l = e.scrollTop,
                            p = e.scrollLeft;
                        w.offset = {
                          top: w.page.top - n.top + l - a.top,
                          left: w.page.left - n.left + p - a.left
                        };
                      }
                    }(), this.move(w), this.history.unshift(w), this.history.length > 3 && this.history.pop(), e && j(), !0;
                  }
                }
              }, {
                key: "move",
                value: function(t) {
                  var e = this;
                  if ("undefined" != typeof this.element.parentNode) {
                    var n = {};
                    for (var o in t) {
                      n[o] = {};
                      for (var r in t[o]) {
                        for (var a = !1,
                            i = 0; i < this.history.length; ++i) {
                          var l = this.history[i];
                          if ("undefined" != typeof l[o] && !g(l[o][r], t[o][r])) {
                            a = !0;
                            break;
                          }
                        }
                        a || (n[o][r] = !0);
                      }
                    }
                    var d = {
                      top: "",
                      left: "",
                      right: "",
                      bottom: ""
                    },
                        f = function(t, n) {
                          var o = "undefined" != typeof e.options.optimizations,
                              r = o ? e.options.optimizations.gpu : null;
                          if (r !== !1) {
                            var a = void 0,
                                i = void 0;
                            t.top ? (d.top = 0, a = n.top) : (d.bottom = 0, a = -n.bottom), t.left ? (d.left = 0, i = n.left) : (d.right = 0, i = -n.right), d[B] = "translateX(" + Math.round(i) + "px) translateY(" + Math.round(a) + "px)", "msTransform" !== B && (d[B] += " translateZ(0)");
                          } else
                            t.top ? d.top = n.top + "px" : d.bottom = n.bottom + "px", t.left ? d.left = n.left + "px" : d.right = n.right + "px";
                        },
                        u = !1;
                    if ((n.page.top || n.page.bottom) && (n.page.left || n.page.right) ? (d.position = "absolute", f(n.page, t.page)) : (n.viewport.top || n.viewport.bottom) && (n.viewport.left || n.viewport.right) ? (d.position = "fixed", f(n.viewport, t.viewport)) : "undefined" != typeof n.offset && n.offset.top && n.offset.left ? !function() {
                      d.position = "absolute";
                      var o = e.cache("target-offsetparent", function() {
                        return s(e.target);
                      });
                      s(e.element) !== o && E(function() {
                        e.element.parentNode.removeChild(e.element), o.appendChild(e.element);
                      }), f(n.offset, t.offset), u = !0;
                    }() : (d.position = "absolute", f({
                      top: !0,
                      left: !0
                    }, t.page)), !u) {
                      for (var c = !0,
                          h = this.element.parentNode; h && 1 === h.nodeType && "BODY" !== h.tagName; ) {
                        if ("static" !== getComputedStyle(h).position) {
                          c = !1;
                          break;
                        }
                        h = h.parentNode;
                      }
                      c || (this.element.parentNode.removeChild(this.element), document.body.appendChild(this.element));
                    }
                    var m = {},
                        y = !1;
                    for (var r in d) {
                      var v = d[r],
                          b = this.element.style[r];
                      b !== v && (y = !0, m[r] = v);
                    }
                    y && E(function() {
                      p(e.element.style, m);
                    });
                  }
                }
              }]), e;
            }(S);
        X.modules = [], P.position = Y;
        var V = p(X, P),
            N = function() {
              function t(t, e) {
                var n = [],
                    o = !0,
                    r = !1,
                    a = void 0;
                try {
                  for (var i,
                      s = t[Symbol.iterator](); !(o = (i = s.next()).done) && (n.push(i.value), !e || n.length !== e); o = !0)
                    ;
                } catch (l) {
                  r = !0, a = l;
                } finally {
                  try {
                    !o && s["return"] && s["return"]();
                  } finally {
                    if (r)
                      throw a;
                  }
                }
                return n;
              }
              return function(e, n) {
                if (Array.isArray(e))
                  return e;
                if (Symbol.iterator in Object(e))
                  return t(e, n);
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              };
            }(),
            A = P.Utils,
            i = A.getBounds,
            p = A.extend,
            m = A.updateClasses,
            E = A.defer,
            U = ["left", "top", "right", "bottom"];
        P.modules.push({position: function(t) {
            var e = this,
                n = t.top,
                o = t.left,
                r = t.targetAttachment;
            if (!this.options.constraints)
              return !0;
            var a = this.cache("element-bounds", function() {
              return i(e.element);
            }),
                s = a.height,
                l = a.width;
            if (0 === l && 0 === s && "undefined" != typeof this.lastSize) {
              var d = this.lastSize;
              l = d.width, s = d.height;
            }
            var f = this.cache("target-bounds", function() {
              return e.getTargetBounds();
            }),
                u = f.height,
                c = f.width,
                h = [this.getClass("pinned"), this.getClass("out-of-bounds")];
            this.options.constraints.forEach(function(t) {
              var e = t.outOfBoundsClass,
                  n = t.pinnedClass;
              e && h.push(e), n && h.push(n);
            }), h.forEach(function(t) {
              ["left", "top", "right", "bottom"].forEach(function(e) {
                h.push(t + "-" + e);
              });
            });
            var y = [],
                g = p({}, r),
                v = p({}, this.attachment);
            return this.options.constraints.forEach(function(t) {
              var a = t.to,
                  i = t.attachment,
                  p = t.pin;
              "undefined" == typeof i && (i = "");
              var d = void 0,
                  f = void 0;
              if (i.indexOf(" ") >= 0) {
                var h = i.split(" "),
                    m = N(h, 2);
                f = m[0], d = m[1];
              } else
                d = f = i;
              var b = C(e, a);
              "target" !== f && "both" !== f || (n < b[1] && "top" === g.top && (n += u, g.top = "bottom"), n + s > b[3] && "bottom" === g.top && (n -= u, g.top = "top")), "together" === f && ("top" === g.top && ("bottom" === v.top && n < b[1] ? (n += u, g.top = "bottom", n += s, v.top = "top") : "top" === v.top && n + s > b[3] && n - (s - u) >= b[1] && (n -= s - u, g.top = "bottom", v.top = "bottom")), "bottom" === g.top && ("top" === v.top && n + s > b[3] ? (n -= u, g.top = "top", n -= s, v.top = "bottom") : "bottom" === v.top && n < b[1] && n + (2 * s - u) <= b[3] && (n += s - u, g.top = "top", v.top = "top")), "middle" === g.top && (n + s > b[3] && "top" === v.top ? (n -= s, v.top = "bottom") : n < b[1] && "bottom" === v.top && (n += s, v.top = "top"))), "target" !== d && "both" !== d || (o < b[0] && "left" === g.left && (o += c, g.left = "right"), o + l > b[2] && "right" === g.left && (o -= c, g.left = "left")), "together" === d && (o < b[0] && "left" === g.left ? "right" === v.left ? (o += c, g.left = "right", o += l, v.left = "left") : "left" === v.left && (o += c, g.left = "right", o -= l, v.left = "right") : o + l > b[2] && "right" === g.left ? "left" === v.left ? (o -= c, g.left = "left", o -= l, v.left = "right") : "right" === v.left && (o -= c, g.left = "left", o += l, v.left = "left") : "center" === g.left && (o + l > b[2] && "left" === v.left ? (o -= l, v.left = "right") : o < b[0] && "right" === v.left && (o += l, v.left = "left"))), "element" !== f && "both" !== f || (n < b[1] && "bottom" === v.top && (n += s, v.top = "top"), n + s > b[3] && "top" === v.top && (n -= s, v.top = "bottom")), "element" !== d && "both" !== d || (o < b[0] && ("right" === v.left ? (o += l, v.left = "left") : "center" === v.left && (o += l / 2, v.left = "left")), o + l > b[2] && ("left" === v.left ? (o -= l, v.left = "right") : "center" === v.left && (o -= l / 2, v.left = "right"))), "string" == typeof p ? p = p.split(",").map(function(t) {
                return t.trim();
              }) : p === !0 && (p = ["top", "left", "right", "bottom"]), p = p || [];
              var D = [],
                  T = [];
              n < b[1] && (p.indexOf("top") >= 0 ? (n = b[1], D.push("top")) : T.push("top")), n + s > b[3] && (p.indexOf("bottom") >= 0 ? (n = b[3] - s, D.push("bottom")) : T.push("bottom")), o < b[0] && (p.indexOf("left") >= 0 ? (o = b[0], D.push("left")) : T.push("left")), o + l > b[2] && (p.indexOf("right") >= 0 ? (o = b[2] - l, D.push("right")) : T.push("right")), D.length && !function() {
                var t = void 0;
                t = "undefined" != typeof e.options.pinnedClass ? e.options.pinnedClass : e.getClass("pinned"), y.push(t), D.forEach(function(e) {
                  y.push(t + "-" + e);
                });
              }(), T.length && !function() {
                var t = void 0;
                t = "undefined" != typeof e.options.outOfBoundsClass ? e.options.outOfBoundsClass : e.getClass("out-of-bounds"), y.push(t), T.forEach(function(e) {
                  y.push(t + "-" + e);
                });
              }(), (D.indexOf("left") >= 0 || D.indexOf("right") >= 0) && (v.left = g.left = !1), (D.indexOf("top") >= 0 || D.indexOf("bottom") >= 0) && (v.top = g.top = !1), g.top === r.top && g.left === r.left && v.top === e.attachment.top && v.left === e.attachment.left || (e.updateAttachClasses(v, g), e.trigger("update", {
                attachment: v,
                targetAttachment: g
              }));
            }), E(function() {
              e.options.addTargetClasses !== !1 && m(e.target, y, h), m(e.element, y, h);
            }), {
              top: n,
              left: o
            };
          }});
        var A = P.Utils,
            i = A.getBounds,
            m = A.updateClasses,
            E = A.defer;
        P.modules.push({position: function(t) {
            var e = this,
                n = t.top,
                o = t.left,
                r = this.cache("element-bounds", function() {
                  return i(e.element);
                }),
                a = r.height,
                s = r.width,
                l = this.getTargetBounds(),
                p = n + a,
                d = o + s,
                f = [];
            n <= l.bottom && p >= l.top && ["left", "right"].forEach(function(t) {
              var e = l[t];
              e !== o && e !== d || f.push(t);
            }), o <= l.right && d >= l.left && ["top", "bottom"].forEach(function(t) {
              var e = l[t];
              e !== n && e !== p || f.push(t);
            });
            var u = [],
                c = [],
                h = ["left", "top", "right", "bottom"];
            return u.push(this.getClass("abutted")), h.forEach(function(t) {
              u.push(e.getClass("abutted") + "-" + t);
            }), f.length && c.push(this.getClass("abutted")), f.forEach(function(t) {
              c.push(e.getClass("abutted") + "-" + t);
            }), E(function() {
              e.options.addTargetClasses !== !1 && m(e.target, c, u), m(e.element, c, u);
            }), !0;
          }});
        var N = function() {
          function t(t, e) {
            var n = [],
                o = !0,
                r = !1,
                a = void 0;
            try {
              for (var i,
                  s = t[Symbol.iterator](); !(o = (i = s.next()).done) && (n.push(i.value), !e || n.length !== e); o = !0)
                ;
            } catch (l) {
              r = !0, a = l;
            } finally {
              try {
                !o && s["return"] && s["return"]();
              } finally {
                if (r)
                  throw a;
              }
            }
            return n;
          }
          return function(e, n) {
            if (Array.isArray(e))
              return e;
            if (Symbol.iterator in Object(e))
              return t(e, n);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }();
        return P.modules.push({position: function(t) {
            var e = t.top,
                n = t.left;
            if (this.options.shift) {
              var o = this.options.shift;
              "function" == typeof this.options.shift && (o = this.options.shift.call(this, {
                top: e,
                left: n
              }));
              var r = void 0,
                  a = void 0;
              if ("string" == typeof o) {
                o = o.split(" "), o[1] = o[1] || o[0];
                var i = o,
                    s = N(i, 2);
                r = s[0], a = s[1], r = parseFloat(r, 10), a = parseFloat(a, 10);
              } else
                r = o.top, a = o.left;
              return e += r, n += a, {
                top: e,
                left: n
              };
            }
          }}), V;
      });
    }]);
  });
  return module.exports;
});

System.registerDynamic("npm:isarray@0.0.1.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:isarray@0.0.1/index.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = Array.isArray || function(arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };
  return module.exports;
});

System.registerDynamic("npm:path-to-regexp@1.5.3.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:path-to-regexp@1.5.3/index.js", ["isarray"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var isarray = $__require('isarray');
  module.exports = pathToRegexp;
  module.exports.parse = parse;
  module.exports.compile = compile;
  module.exports.tokensToFunction = tokensToFunction;
  module.exports.tokensToRegExp = tokensToRegExp;
  var PATH_REGEXP = new RegExp(['(\\\\.)', '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');
  function parse(str) {
    var tokens = [];
    var key = 0;
    var index = 0;
    var path = '';
    var res;
    while ((res = PATH_REGEXP.exec(str)) != null) {
      var m = res[0];
      var escaped = res[1];
      var offset = res.index;
      path += str.slice(index, offset);
      index = offset + m.length;
      if (escaped) {
        path += escaped[1];
        continue;
      }
      var next = str[index];
      var prefix = res[2];
      var name = res[3];
      var capture = res[4];
      var group = res[5];
      var modifier = res[6];
      var asterisk = res[7];
      if (path) {
        tokens.push(path);
        path = '';
      }
      var partial = prefix != null && next != null && next !== prefix;
      var repeat = modifier === '+' || modifier === '*';
      var optional = modifier === '?' || modifier === '*';
      var delimiter = res[2] || '/';
      var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');
      tokens.push({
        name: name || key++,
        prefix: prefix || '',
        delimiter: delimiter,
        optional: optional,
        repeat: repeat,
        partial: partial,
        asterisk: !!asterisk,
        pattern: escapeGroup(pattern)
      });
    }
    if (index < str.length) {
      path += str.substr(index);
    }
    if (path) {
      tokens.push(path);
    }
    return tokens;
  }
  function compile(str) {
    return tokensToFunction(parse(str));
  }
  function encodeURIComponentPretty(str) {
    return encodeURI(str).replace(/[\/?#]/g, function(c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeAsterisk(str) {
    return encodeURI(str).replace(/[?#]/g, function(c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function tokensToFunction(tokens) {
    var matches = new Array(tokens.length);
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] === 'object') {
        matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
      }
    }
    return function(obj, opts) {
      var path = '';
      var data = obj || {};
      var options = opts || {};
      var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (typeof token === 'string') {
          path += token;
          continue;
        }
        var value = data[token.name];
        var segment;
        if (value == null) {
          if (token.optional) {
            if (token.partial) {
              path += token.prefix;
            }
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to be defined');
          }
        }
        if (isarray(value)) {
          if (!token.repeat) {
            throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
          }
          if (value.length === 0) {
            if (token.optional) {
              continue;
            } else {
              throw new TypeError('Expected "' + token.name + '" to not be empty');
            }
          }
          for (var j = 0; j < value.length; j++) {
            segment = encode(value[j]);
            if (!matches[i].test(segment)) {
              throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
            }
            path += (j === 0 ? token.prefix : token.delimiter) + segment;
          }
          continue;
        }
        segment = token.asterisk ? encodeAsterisk(value) : encode(value);
        if (!matches[i].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
        }
        path += token.prefix + segment;
      }
      return path;
    };
  }
  function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
  }
  function escapeGroup(group) {
    return group.replace(/([=!:$\/()])/g, '\\$1');
  }
  function attachKeys(re, keys) {
    re.keys = keys;
    return re;
  }
  function flags(options) {
    return options.sensitive ? '' : 'i';
  }
  function regexpToRegexp(path, keys) {
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          partial: false,
          asterisk: false,
          pattern: null
        });
      }
    }
    return attachKeys(path, keys);
  }
  function arrayToRegexp(path, keys, options) {
    var parts = [];
    for (var i = 0; i < path.length; i++) {
      parts.push(pathToRegexp(path[i], keys, options).source);
    }
    var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
    return attachKeys(regexp, keys);
  }
  function stringToRegexp(path, keys, options) {
    var tokens = parse(path);
    var re = tokensToRegExp(tokens, options);
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] !== 'string') {
        keys.push(tokens[i]);
      }
    }
    return attachKeys(re, keys);
  }
  function tokensToRegExp(tokens, options) {
    options = options || {};
    var strict = options.strict;
    var end = options.end !== false;
    var route = '';
    var lastToken = tokens[tokens.length - 1];
    var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken);
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (typeof token === 'string') {
        route += escapeString(token);
      } else {
        var prefix = escapeString(token.prefix);
        var capture = '(?:' + token.pattern + ')';
        if (token.repeat) {
          capture += '(?:' + prefix + capture + ')*';
        }
        if (token.optional) {
          if (!token.partial) {
            capture = '(?:' + prefix + '(' + capture + '))?';
          } else {
            capture = prefix + '(' + capture + ')?';
          }
        } else {
          capture = prefix + '(' + capture + ')';
        }
        route += capture;
      }
    }
    if (!strict) {
      route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
    }
    if (end) {
      route += '$';
    } else {
      route += strict && endsWithSlash ? '' : '(?=\\/|$)';
    }
    return new RegExp('^' + route, flags(options));
  }
  function pathToRegexp(path, keys, options) {
    keys = keys || [];
    if (!isarray(keys)) {
      options = (keys);
      keys = [];
    } else if (!options) {
      options = {};
    }
    if (path instanceof RegExp) {
      return regexpToRegexp(path, (keys));
    }
    if (isarray(path)) {
      return arrayToRegexp((path), (keys), options);
    }
    return stringToRegexp((path), (keys), options);
  }
  return module.exports;
});

System.registerDynamic("npm:enroute@1.0.1.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:enroute@1.0.1/index.js", ["path-to-regexp", "object-assign"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Regexp = $__require('path-to-regexp');
  var assign = $__require('object-assign');
  module.exports = Enroute;
  function Enroute(routes) {
    return function enroute(location, props) {
      if (!location)
        throw new Error('enroute requires a location');
      props = props || {};
      var params = {};
      for (var route in routes) {
        var m = match(route, params, location);
        var fn = routes[route];
        if (m) {
          if (typeof fn !== 'function')
            return fn;
          else
            return fn(params, props);
        }
      }
      return null;
    };
  }
  function match(path, params, pathname) {
    var keys = [];
    var regexp = Regexp(path, keys);
    var m = regexp.exec(pathname);
    if (!m)
      return false;
    else if (!params)
      return true;
    for (var i = 1,
        len = m.length; i < len; ++i) {
      var key = keys[i - 1];
      var val = 'string' == typeof m[i] ? decodeURIComponent(m[i]) : m[i];
      if (key)
        params[key.name] = val;
    }
    return true;
  }
  return module.exports;
});

System.registerDynamic("npm:react-enroute@0.0.1.json", [], false, function() {
  return {
    "main": "build/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./build": "./build/index.js"
    }
  };
});

System.registerDynamic("npm:react-enroute@0.0.1/build/index.js", ["react", "enroute"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Router = undefined;
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var _createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  exports.Route = Route;
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _enroute = $__require('enroute');
  var _enroute2 = _interopRequireDefault(_enroute);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _objectWithoutProperties(obj, keys) {
    var target = {};
    for (var i in obj) {
      if (keys.indexOf(i) >= 0)
        continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i))
        continue;
      target[i] = obj[i];
    }
    return target;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  function assert(e, msg) {
    if (!e)
      throw new Error('react-enroute: ' + msg);
  }
  var Router = exports.Router = function(_Component) {
    _inherits(Router, _Component);
    function Router(props) {
      _classCallCheck(this, Router);
      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Router).call(this, props));
      _this.routes = {};
      _this.addRoutes(props.children);
      _this.router = (0, _enroute2.default)(_this.routes);
      return _this;
    }
    _createClass(Router, [{
      key: 'addRoutes',
      value: function addRoutes(routes, parent) {
        var _this2 = this;
        _react2.default.Children.forEach(routes, function(r) {
          return _this2.addRoute(r, parent);
        });
      }
    }, {
      key: 'addRoute',
      value: function addRoute(el, parent) {
        var _props = this.props;
        var location = _props.location;
        var props = _objectWithoutProperties(_props, ['location']);
        var _el$props = el.props;
        var path = _el$props.path;
        var component = _el$props.component;
        var children = _el$props.children;
        assert(typeof path == 'string', 'Route ' + context(el.props) + 'is missing the "path" property');
        assert(component, 'Route ' + context(el.props) + 'is missing the "component" property');
        function render(params, renderProps) {
          var finalProps = _extends({}, props, renderProps, {
            location: location,
            params: params
          });
          var children = _react2.default.createElement(component, finalProps);
          return parent ? parent.render(params, {children: children}) : children;
        }
        var route = normalizeRoute(path, parent);
        var child = {
          route: route,
          render: render
        };
        if (children)
          this.addRoutes(children, child);
        this.routes[cleanPath(route)] = render;
      }
    }, {
      key: 'render',
      value: function render() {
        var location = this.props.location;
        if (localStorage.debugRoutes)
          console.log('routes:', Object.keys(this.routes));
        assert(location, 'Router "location" property is missing');
        return this.router(location, {children: null});
      }
    }]);
    return Router;
  }(_react.Component);
  function Route() {
    assert(false, 'Route should not be rendered');
  }
  function context(_ref) {
    var path = _ref.path;
    var component = _ref.component;
    if (path)
      return 'with path "' + path + '" ';
    if (component)
      return 'with component ' + component.name + ' ';
    return '';
  }
  function normalizeRoute(path, parent) {
    if (path[0] == '/')
      return path;
    if (parent == null)
      return path;
    return parent.route + '/' + path;
  }
  function cleanPath(path) {
    return path.replace(/\/\//g, '/');
  }
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.4.5/lib/components/Provider.js", ["react", "../utils/storeShape", "../utils/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports["default"] = undefined;
  var _react = $__require('react');
  var _storeShape = $__require('../utils/storeShape');
  var _storeShape2 = _interopRequireDefault(_storeShape);
  var _warning = $__require('../utils/warning');
  var _warning2 = _interopRequireDefault(_warning);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var didWarnAboutReceivingStore = false;
  function warnAboutReceivingStore() {
    if (didWarnAboutReceivingStore) {
      return;
    }
    didWarnAboutReceivingStore = true;
    (0, _warning2["default"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
  }
  var Provider = function(_Component) {
    _inherits(Provider, _Component);
    Provider.prototype.getChildContext = function getChildContext() {
      return {store: this.store};
    };
    function Provider(props, context) {
      _classCallCheck(this, Provider);
      var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
      _this.store = props.store;
      return _this;
    }
    Provider.prototype.render = function render() {
      var children = this.props.children;
      return _react.Children.only(children);
    };
    return Provider;
  }(_react.Component);
  exports["default"] = Provider;
  if ("production" !== 'production') {
    Provider.prototype.componentWillReceiveProps = function(nextProps) {
      var store = this.store;
      var nextStore = nextProps.store;
      if (store !== nextStore) {
        warnAboutReceivingStore();
      }
    };
  }
  Provider.propTypes = {
    store: _storeShape2["default"].isRequired,
    children: _react.PropTypes.element.isRequired
  };
  Provider.childContextTypes = {store: _storeShape2["default"].isRequired};
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.4.5/lib/utils/storeShape.js", ["react", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  var _react = $__require('react');
  exports["default"] = _react.PropTypes.shape({
    subscribe: _react.PropTypes.func.isRequired,
    dispatch: _react.PropTypes.func.isRequired,
    getState: _react.PropTypes.func.isRequired
  });
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.4.5/lib/utils/shallowEqual.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports["default"] = shallowEqual;
  function shallowEqual(objA, objB) {
    if (objA === objB) {
      return true;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty;
    for (var i = 0; i < keysA.length; i++) {
      if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
        return false;
      }
    }
    return true;
  }
  return module.exports;
});

System.registerDynamic("npm:symbol-observable@0.2.4/ponyfill.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function symbolObservablePonyfill(root) {
    var result;
    var Symbol = root.Symbol;
    if (typeof Symbol === 'function') {
      if (Symbol.observable) {
        result = Symbol.observable;
      } else {
        result = Symbol('observable');
        Symbol.observable = result;
      }
    } else {
      result = '@@observable';
    }
    return result;
  };
  return module.exports;
});

System.registerDynamic("npm:symbol-observable@0.2.4.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:symbol-observable@0.2.4/index.js", ["./ponyfill"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./ponyfill')(global || window || this);
  return module.exports;
});

System.registerDynamic("npm:redux@3.5.2/lib/createStore.js", ["lodash/isPlainObject", "symbol-observable", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.ActionTypes = undefined;
  exports["default"] = createStore;
  var _isPlainObject = $__require('lodash/isPlainObject');
  var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
  var _symbolObservable = $__require('symbol-observable');
  var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  var ActionTypes = exports.ActionTypes = {INIT: '@@redux/INIT'};
  function createStore(reducer, initialState, enhancer) {
    var _ref2;
    if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
      enhancer = initialState;
      initialState = undefined;
    }
    if (typeof enhancer !== 'undefined') {
      if (typeof enhancer !== 'function') {
        throw new Error('Expected the enhancer to be a function.');
      }
      return enhancer(createStore)(reducer, initialState);
    }
    if (typeof reducer !== 'function') {
      throw new Error('Expected the reducer to be a function.');
    }
    var currentReducer = reducer;
    var currentState = initialState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;
    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }
    function getState() {
      return currentState;
    }
    function subscribe(listener) {
      if (typeof listener !== 'function') {
        throw new Error('Expected listener to be a function.');
      }
      var isSubscribed = true;
      ensureCanMutateNextListeners();
      nextListeners.push(listener);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }
        isSubscribed = false;
        ensureCanMutateNextListeners();
        var index = nextListeners.indexOf(listener);
        nextListeners.splice(index, 1);
      };
    }
    function dispatch(action) {
      if (!(0, _isPlainObject2["default"])(action)) {
        throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
      }
      if (typeof action.type === 'undefined') {
        throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
      }
      if (isDispatching) {
        throw new Error('Reducers may not dispatch actions.');
      }
      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }
      var listeners = currentListeners = nextListeners;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
      return action;
    }
    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== 'function') {
        throw new Error('Expected the nextReducer to be a function.');
      }
      currentReducer = nextReducer;
      dispatch({type: ActionTypes.INIT});
    }
    function observable() {
      var _ref;
      var outerSubscribe = subscribe;
      return _ref = {subscribe: function subscribe(observer) {
          if (typeof observer !== 'object') {
            throw new TypeError('Expected the observer to be an object.');
          }
          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }
          observeState();
          var unsubscribe = outerSubscribe(observeState);
          return {unsubscribe: unsubscribe};
        }}, _ref[_symbolObservable2["default"]] = function() {
        return this;
      }, _ref;
    }
    dispatch({type: ActionTypes.INIT});
    return _ref2 = {
      dispatch: dispatch,
      subscribe: subscribe,
      getState: getState,
      replaceReducer: replaceReducer
    }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
  }
  return module.exports;
});

System.registerDynamic("npm:redux@3.5.2/lib/combineReducers.js", ["./createStore", "lodash/isPlainObject", "./utils/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports["default"] = combineReducers;
  var _createStore = $__require('./createStore');
  var _isPlainObject = $__require('lodash/isPlainObject');
  var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
  var _warning = $__require('./utils/warning');
  var _warning2 = _interopRequireDefault(_warning);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  function getUndefinedStateErrorMessage(key, action) {
    var actionType = action && action.type;
    var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
    return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
  }
  function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
    var reducerKeys = Object.keys(reducers);
    var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
    if (reducerKeys.length === 0) {
      return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
    }
    if (!(0, _isPlainObject2["default"])(inputState)) {
      return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
    }
    var unexpectedKeys = Object.keys(inputState).filter(function(key) {
      return !reducers.hasOwnProperty(key);
    });
    if (unexpectedKeys.length > 0) {
      return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
    }
  }
  function assertReducerSanity(reducers) {
    Object.keys(reducers).forEach(function(key) {
      var reducer = reducers[key];
      var initialState = reducer(undefined, {type: _createStore.ActionTypes.INIT});
      if (typeof initialState === 'undefined') {
        throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
      }
      var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
      if (typeof reducer(undefined, {type: type}) === 'undefined') {
        throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
      }
    });
  }
  function combineReducers(reducers) {
    var reducerKeys = Object.keys(reducers);
    var finalReducers = {};
    for (var i = 0; i < reducerKeys.length; i++) {
      var key = reducerKeys[i];
      if (typeof reducers[key] === 'function') {
        finalReducers[key] = reducers[key];
      }
    }
    var finalReducerKeys = Object.keys(finalReducers);
    var sanityError;
    try {
      assertReducerSanity(finalReducers);
    } catch (e) {
      sanityError = e;
    }
    return function combination() {
      var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var action = arguments[1];
      if (sanityError) {
        throw sanityError;
      }
      if ("production" !== 'production') {
        var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
        if (warningMessage) {
          (0, _warning2["default"])(warningMessage);
        }
      }
      var hasChanged = false;
      var nextState = {};
      for (var i = 0; i < finalReducerKeys.length; i++) {
        var key = finalReducerKeys[i];
        var reducer = finalReducers[key];
        var previousStateForKey = state[key];
        var nextStateForKey = reducer(previousStateForKey, action);
        if (typeof nextStateForKey === 'undefined') {
          var errorMessage = getUndefinedStateErrorMessage(key, action);
          throw new Error(errorMessage);
        }
        nextState[key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }
      return hasChanged ? nextState : state;
    };
  }
  return module.exports;
});

System.registerDynamic("npm:redux@3.5.2/lib/bindActionCreators.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports["default"] = bindActionCreators;
  function bindActionCreator(actionCreator, dispatch) {
    return function() {
      return dispatch(actionCreator.apply(undefined, arguments));
    };
  }
  function bindActionCreators(actionCreators, dispatch) {
    if (typeof actionCreators === 'function') {
      return bindActionCreator(actionCreators, dispatch);
    }
    if (typeof actionCreators !== 'object' || actionCreators === null) {
      throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
    }
    var keys = Object.keys(actionCreators);
    var boundActionCreators = {};
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var actionCreator = actionCreators[key];
      if (typeof actionCreator === 'function') {
        boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
      }
    }
    return boundActionCreators;
  }
  return module.exports;
});

System.registerDynamic("npm:redux@3.5.2/lib/applyMiddleware.js", ["./compose", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  exports["default"] = applyMiddleware;
  var _compose = $__require('./compose');
  var _compose2 = _interopRequireDefault(_compose);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  function applyMiddleware() {
    for (var _len = arguments.length,
        middlewares = Array(_len),
        _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }
    return function(createStore) {
      return function(reducer, initialState, enhancer) {
        var store = createStore(reducer, initialState, enhancer);
        var _dispatch = store.dispatch;
        var chain = [];
        var middlewareAPI = {
          getState: store.getState,
          dispatch: function dispatch(action) {
            return _dispatch(action);
          }
        };
        chain = middlewares.map(function(middleware) {
          return middleware(middlewareAPI);
        });
        _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
        return _extends({}, store, {dispatch: _dispatch});
      };
    };
  }
  return module.exports;
});

System.registerDynamic("npm:redux@3.5.2/lib/compose.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports["default"] = compose;
  function compose() {
    for (var _len = arguments.length,
        funcs = Array(_len),
        _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }
    if (funcs.length === 0) {
      return function(arg) {
        return arg;
      };
    } else {
      var _ret = function() {
        var last = funcs[funcs.length - 1];
        var rest = funcs.slice(0, -1);
        return {v: function v() {
            return rest.reduceRight(function(composed, f) {
              return f(composed);
            }, last.apply(undefined, arguments));
          }};
      }();
      if (typeof _ret === "object")
        return _ret.v;
    }
  }
  return module.exports;
});

System.registerDynamic("npm:redux@3.5.2/lib/utils/warning.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports["default"] = warning;
  function warning(message) {
    if (typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error(message);
    }
    try {
      throw new Error(message);
    } catch (e) {}
  }
  return module.exports;
});

System.registerDynamic("npm:redux@3.5.2.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      },
      "es/*": {
        "format": "esm"
      },
      "src/bindActionCreators.js": {
        "format": "esm"
      },
      "src/combineReducers.js": {
        "format": "esm"
      },
      "src/compose.js": {
        "format": "esm"
      },
      "src/createStore.js": {
        "format": "esm"
      },
      "src/index.js": {
        "format": "esm"
      },
      "src/utils/*": {
        "format": "esm"
      }
    },
    "map": {
      "./lib": "./lib/index.js"
    }
  };
});

System.registerDynamic("npm:redux@3.5.2/lib/index.js", ["./createStore", "./combineReducers", "./bindActionCreators", "./applyMiddleware", "./compose", "./utils/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
  var _createStore = $__require('./createStore');
  var _createStore2 = _interopRequireDefault(_createStore);
  var _combineReducers = $__require('./combineReducers');
  var _combineReducers2 = _interopRequireDefault(_combineReducers);
  var _bindActionCreators = $__require('./bindActionCreators');
  var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
  var _applyMiddleware = $__require('./applyMiddleware');
  var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
  var _compose = $__require('./compose');
  var _compose2 = _interopRequireDefault(_compose);
  var _warning = $__require('./utils/warning');
  var _warning2 = _interopRequireDefault(_warning);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  function isCrushed() {}
  if ("production" !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
    (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
  }
  exports.createStore = _createStore2["default"];
  exports.combineReducers = _combineReducers2["default"];
  exports.bindActionCreators = _bindActionCreators2["default"];
  exports.applyMiddleware = _applyMiddleware2["default"];
  exports.compose = _compose2["default"];
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.4.5/lib/utils/wrapActionCreators.js", ["redux", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports["default"] = wrapActionCreators;
  var _redux = $__require('redux');
  function wrapActionCreators(actionCreators) {
    return function(dispatch) {
      return (0, _redux.bindActionCreators)(actionCreators, dispatch);
    };
  }
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.4.5/lib/utils/warning.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports["default"] = warning;
  function warning(message) {
    if (typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error(message);
    }
    try {
      throw new Error(message);
    } catch (e) {}
  }
  return module.exports;
});

System.registerDynamic("npm:lodash@4.14.1/_overArg.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  module.exports = overArg;
  return module.exports;
});

System.registerDynamic("npm:lodash@4.14.1/_getPrototype.js", ["./_overArg"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var overArg = $__require('./_overArg');
  var nativeGetPrototype = Object.getPrototypeOf;
  var getPrototype = overArg(nativeGetPrototype, Object);
  module.exports = getPrototype;
  return module.exports;
});

System.registerDynamic("npm:lodash@4.14.1/_isHostObject.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }
    return result;
  }
  module.exports = isHostObject;
  return module.exports;
});

System.registerDynamic("npm:lodash@4.14.1/isObjectLike.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  module.exports = isObjectLike;
  return module.exports;
});

System.registerDynamic("npm:lodash@4.14.1.json", [], false, function() {
  return {
    "main": "lodash.js",
    "map": {
      "buffer": "@empty",
      "process": "@empty"
    },
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:lodash@4.14.1/isPlainObject.js", ["./_getPrototype", "./_isHostObject", "./isObjectLike"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var getPrototype = $__require('./_getPrototype'),
      isHostObject = $__require('./_isHostObject'),
      isObjectLike = $__require('./isObjectLike');
  var objectTag = '[object Object]';
  var objectProto = Object.prototype;
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return (typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
  }
  module.exports = isPlainObject;
  return module.exports;
});

System.registerDynamic("npm:hoist-non-react-statics@1.0.6.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:hoist-non-react-statics@1.0.6/index.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    arguments: true,
    arity: true
  };
  module.exports = function hoistNonReactStatics(targetComponent, sourceComponent) {
    if (typeof sourceComponent !== 'string') {
      var keys = Object.getOwnPropertyNames(sourceComponent);
      for (var i = 0; i < keys.length; ++i) {
        if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]]) {
          try {
            targetComponent[keys[i]] = sourceComponent[keys[i]];
          } catch (error) {}
        }
      }
    }
    return targetComponent;
  };
  return module.exports;
});

System.registerDynamic("npm:invariant@2.2.1.json", [], false, function() {
  return {
    "main": "invariant.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./invariant.js": {
        "browser": "./browser.js"
      }
    }
  };
});

System.registerDynamic("npm:invariant@2.2.1/browser.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var invariant = function(condition, format, a, b, c, d, e, f) {
    if ("production" !== 'production') {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function() {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }
      error.framesToPop = 1;
      throw error;
    }
  };
  module.exports = invariant;
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.4.5/lib/components/connect.js", ["react", "../utils/storeShape", "../utils/shallowEqual", "../utils/wrapActionCreators", "../utils/warning", "lodash/isPlainObject", "hoist-non-react-statics", "invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  exports.__esModule = true;
  exports["default"] = connect;
  var _react = $__require('react');
  var _storeShape = $__require('../utils/storeShape');
  var _storeShape2 = _interopRequireDefault(_storeShape);
  var _shallowEqual = $__require('../utils/shallowEqual');
  var _shallowEqual2 = _interopRequireDefault(_shallowEqual);
  var _wrapActionCreators = $__require('../utils/wrapActionCreators');
  var _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);
  var _warning = $__require('../utils/warning');
  var _warning2 = _interopRequireDefault(_warning);
  var _isPlainObject = $__require('lodash/isPlainObject');
  var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
  var _hoistNonReactStatics = $__require('hoist-non-react-statics');
  var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
  var _invariant = $__require('invariant');
  var _invariant2 = _interopRequireDefault(_invariant);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var defaultMapStateToProps = function defaultMapStateToProps(state) {
    return {};
  };
  var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
    return {dispatch: dispatch};
  };
  var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
    return _extends({}, parentProps, stateProps, dispatchProps);
  };
  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || 'Component';
  }
  var errorObject = {value: null};
  function tryCatch(fn, ctx) {
    try {
      return fn.apply(ctx);
    } catch (e) {
      errorObject.value = e;
      return errorObject;
    }
  }
  var nextVersion = 0;
  function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
    var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
    var shouldSubscribe = Boolean(mapStateToProps);
    var mapState = mapStateToProps || defaultMapStateToProps;
    var mapDispatch = undefined;
    if (typeof mapDispatchToProps === 'function') {
      mapDispatch = mapDispatchToProps;
    } else if (!mapDispatchToProps) {
      mapDispatch = defaultMapDispatchToProps;
    } else {
      mapDispatch = (0, _wrapActionCreators2["default"])(mapDispatchToProps);
    }
    var finalMergeProps = mergeProps || defaultMergeProps;
    var _options$pure = options.pure;
    var pure = _options$pure === undefined ? true : _options$pure;
    var _options$withRef = options.withRef;
    var withRef = _options$withRef === undefined ? false : _options$withRef;
    var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;
    var version = nextVersion++;
    return function wrapWithConnect(WrappedComponent) {
      var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
      function checkStateShape(props, methodName) {
        if (!(0, _isPlainObject2["default"])(props)) {
          (0, _warning2["default"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));
        }
      }
      function computeMergedProps(stateProps, dispatchProps, parentProps) {
        var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
        if ("production" !== 'production') {
          checkStateShape(mergedProps, 'mergeProps');
        }
        return mergedProps;
      }
      var Connect = function(_Component) {
        _inherits(Connect, _Component);
        Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
          return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
        };
        function Connect(props, context) {
          _classCallCheck(this, Connect);
          var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
          _this.version = version;
          _this.store = props.store || context.store;
          (0, _invariant2["default"])(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + connectDisplayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + connectDisplayName + '".'));
          var storeState = _this.store.getState();
          _this.state = {storeState: storeState};
          _this.clearCache();
          return _this;
        }
        Connect.prototype.computeStateProps = function computeStateProps(store, props) {
          if (!this.finalMapStateToProps) {
            return this.configureFinalMapState(store, props);
          }
          var state = store.getState();
          var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);
          if ("production" !== 'production') {
            checkStateShape(stateProps, 'mapStateToProps');
          }
          return stateProps;
        };
        Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {
          var mappedState = mapState(store.getState(), props);
          var isFactory = typeof mappedState === 'function';
          this.finalMapStateToProps = isFactory ? mappedState : mapState;
          this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;
          if (isFactory) {
            return this.computeStateProps(store, props);
          }
          if ("production" !== 'production') {
            checkStateShape(mappedState, 'mapStateToProps');
          }
          return mappedState;
        };
        Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {
          if (!this.finalMapDispatchToProps) {
            return this.configureFinalMapDispatch(store, props);
          }
          var dispatch = store.dispatch;
          var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);
          if ("production" !== 'production') {
            checkStateShape(dispatchProps, 'mapDispatchToProps');
          }
          return dispatchProps;
        };
        Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {
          var mappedDispatch = mapDispatch(store.dispatch, props);
          var isFactory = typeof mappedDispatch === 'function';
          this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;
          this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;
          if (isFactory) {
            return this.computeDispatchProps(store, props);
          }
          if ("production" !== 'production') {
            checkStateShape(mappedDispatch, 'mapDispatchToProps');
          }
          return mappedDispatch;
        };
        Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
          var nextStateProps = this.computeStateProps(this.store, this.props);
          if (this.stateProps && (0, _shallowEqual2["default"])(nextStateProps, this.stateProps)) {
            return false;
          }
          this.stateProps = nextStateProps;
          return true;
        };
        Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
          var nextDispatchProps = this.computeDispatchProps(this.store, this.props);
          if (this.dispatchProps && (0, _shallowEqual2["default"])(nextDispatchProps, this.dispatchProps)) {
            return false;
          }
          this.dispatchProps = nextDispatchProps;
          return true;
        };
        Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {
          var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
          if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2["default"])(nextMergedProps, this.mergedProps)) {
            return false;
          }
          this.mergedProps = nextMergedProps;
          return true;
        };
        Connect.prototype.isSubscribed = function isSubscribed() {
          return typeof this.unsubscribe === 'function';
        };
        Connect.prototype.trySubscribe = function trySubscribe() {
          if (shouldSubscribe && !this.unsubscribe) {
            this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
            this.handleChange();
          }
        };
        Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
          if (this.unsubscribe) {
            this.unsubscribe();
            this.unsubscribe = null;
          }
        };
        Connect.prototype.componentDidMount = function componentDidMount() {
          this.trySubscribe();
        };
        Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
          if (!pure || !(0, _shallowEqual2["default"])(nextProps, this.props)) {
            this.haveOwnPropsChanged = true;
          }
        };
        Connect.prototype.componentWillUnmount = function componentWillUnmount() {
          this.tryUnsubscribe();
          this.clearCache();
        };
        Connect.prototype.clearCache = function clearCache() {
          this.dispatchProps = null;
          this.stateProps = null;
          this.mergedProps = null;
          this.haveOwnPropsChanged = true;
          this.hasStoreStateChanged = true;
          this.haveStatePropsBeenPrecalculated = false;
          this.statePropsPrecalculationError = null;
          this.renderedElement = null;
          this.finalMapDispatchToProps = null;
          this.finalMapStateToProps = null;
        };
        Connect.prototype.handleChange = function handleChange() {
          if (!this.unsubscribe) {
            return;
          }
          var storeState = this.store.getState();
          var prevStoreState = this.state.storeState;
          if (pure && prevStoreState === storeState) {
            return;
          }
          if (pure && !this.doStatePropsDependOnOwnProps) {
            var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);
            if (!haveStatePropsChanged) {
              return;
            }
            if (haveStatePropsChanged === errorObject) {
              this.statePropsPrecalculationError = errorObject.value;
            }
            this.haveStatePropsBeenPrecalculated = true;
          }
          this.hasStoreStateChanged = true;
          this.setState({storeState: storeState});
        };
        Connect.prototype.getWrappedInstance = function getWrappedInstance() {
          (0, _invariant2["default"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');
          return this.refs.wrappedInstance;
        };
        Connect.prototype.render = function render() {
          var haveOwnPropsChanged = this.haveOwnPropsChanged;
          var hasStoreStateChanged = this.hasStoreStateChanged;
          var haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated;
          var statePropsPrecalculationError = this.statePropsPrecalculationError;
          var renderedElement = this.renderedElement;
          this.haveOwnPropsChanged = false;
          this.hasStoreStateChanged = false;
          this.haveStatePropsBeenPrecalculated = false;
          this.statePropsPrecalculationError = null;
          if (statePropsPrecalculationError) {
            throw statePropsPrecalculationError;
          }
          var shouldUpdateStateProps = true;
          var shouldUpdateDispatchProps = true;
          if (pure && renderedElement) {
            shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;
            shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;
          }
          var haveStatePropsChanged = false;
          var haveDispatchPropsChanged = false;
          if (haveStatePropsBeenPrecalculated) {
            haveStatePropsChanged = true;
          } else if (shouldUpdateStateProps) {
            haveStatePropsChanged = this.updateStatePropsIfNeeded();
          }
          if (shouldUpdateDispatchProps) {
            haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
          }
          var haveMergedPropsChanged = true;
          if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
            haveMergedPropsChanged = this.updateMergedPropsIfNeeded();
          } else {
            haveMergedPropsChanged = false;
          }
          if (!haveMergedPropsChanged && renderedElement) {
            return renderedElement;
          }
          if (withRef) {
            this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {ref: 'wrappedInstance'}));
          } else {
            this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);
          }
          return this.renderedElement;
        };
        return Connect;
      }(_react.Component);
      Connect.displayName = connectDisplayName;
      Connect.WrappedComponent = WrappedComponent;
      Connect.contextTypes = {store: _storeShape2["default"]};
      Connect.propTypes = {store: _storeShape2["default"]};
      if ("production" !== 'production') {
        Connect.prototype.componentWillUpdate = function componentWillUpdate() {
          if (this.version === version) {
            return;
          }
          this.version = version;
          this.trySubscribe();
          this.clearCache();
        };
      }
      return (0, _hoistNonReactStatics2["default"])(Connect, WrappedComponent);
    };
  }
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.4.5.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      },
      "src/components/Provider.js": {
        "format": "esm"
      },
      "src/index.js": {
        "format": "esm"
      },
      "src/utils/*": {
        "format": "esm"
      }
    },
    "map": {
      "./lib": "./lib/index.js"
    }
  };
});

System.registerDynamic("npm:react-redux@4.4.5/lib/index.js", ["./components/Provider", "./components/connect", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.connect = exports.Provider = undefined;
  var _Provider = $__require('./components/Provider');
  var _Provider2 = _interopRequireDefault(_Provider);
  var _connect = $__require('./components/connect');
  var _connect2 = _interopRequireDefault(_connect);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  exports.Provider = _Provider2["default"];
  exports.connect = _connect2["default"];
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/FallbackCompositionState.js", ["object-assign", "./PooledClass", "./getTextContentAccessor", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');
  var PooledClass = $__require('./PooledClass');
  var getTextContentAccessor = $__require('./getTextContentAccessor');
  function FallbackCompositionState(root) {
    this._root = root;
    this._startText = this.getText();
    this._fallbackText = null;
  }
  _assign(FallbackCompositionState.prototype, {
    destructor: function() {
      this._root = null;
      this._startText = null;
      this._fallbackText = null;
    },
    getText: function() {
      if ('value' in this._root) {
        return this._root.value;
      }
      return this._root[getTextContentAccessor()];
    },
    getData: function() {
      if (this._fallbackText) {
        return this._fallbackText;
      }
      var start;
      var startValue = this._startText;
      var startLength = startValue.length;
      var end;
      var endValue = this.getText();
      var endLength = endValue.length;
      for (start = 0; start < startLength; start++) {
        if (startValue[start] !== endValue[start]) {
          break;
        }
      }
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd; end++) {
        if (startValue[startLength - end] !== endValue[endLength - end]) {
          break;
        }
      }
      var sliceTail = end > 1 ? 1 - end : undefined;
      this._fallbackText = endValue.slice(start, sliceTail);
      return this._fallbackText;
    }
  });
  PooledClass.addPoolingTo(FallbackCompositionState);
  module.exports = FallbackCompositionState;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SyntheticCompositionEvent.js", ["./SyntheticEvent", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('./SyntheticEvent');
  var CompositionEventInterface = {data: null};
  function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
  module.exports = SyntheticCompositionEvent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SyntheticInputEvent.js", ["./SyntheticEvent", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('./SyntheticEvent');
  var InputEventInterface = {data: null};
  function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
  module.exports = SyntheticInputEvent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/BeforeInputEventPlugin.js", ["./EventConstants", "./EventPropagators", "fbjs/lib/ExecutionEnvironment", "./FallbackCompositionState", "./SyntheticCompositionEvent", "./SyntheticInputEvent", "fbjs/lib/keyOf", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var EventConstants = $__require('./EventConstants');
  var EventPropagators = $__require('./EventPropagators');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var FallbackCompositionState = $__require('./FallbackCompositionState');
  var SyntheticCompositionEvent = $__require('./SyntheticCompositionEvent');
  var SyntheticInputEvent = $__require('./SyntheticInputEvent');
  var keyOf = $__require('fbjs/lib/keyOf');
  var END_KEYCODES = [9, 13, 27, 32];
  var START_KEYCODE = 229;
  var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
  var documentMode = null;
  if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
    documentMode = document.documentMode;
  }
  var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
  var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
  function isPresto() {
    var opera = window.opera;
    return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
  }
  var SPACEBAR_CODE = 32;
  var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {
    beforeInput: {
      phasedRegistrationNames: {
        bubbled: keyOf({onBeforeInput: null}),
        captured: keyOf({onBeforeInputCapture: null})
      },
      dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
    },
    compositionEnd: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionEnd: null}),
        captured: keyOf({onCompositionEndCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionStart: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionStart: null}),
        captured: keyOf({onCompositionStartCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionUpdate: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionUpdate: null}),
        captured: keyOf({onCompositionUpdateCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    }
  };
  var hasSpaceKeypress = false;
  function isKeypressCommand(nativeEvent) {
    return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
  }
  function getCompositionEventType(topLevelType) {
    switch (topLevelType) {
      case topLevelTypes.topCompositionStart:
        return eventTypes.compositionStart;
      case topLevelTypes.topCompositionEnd:
        return eventTypes.compositionEnd;
      case topLevelTypes.topCompositionUpdate:
        return eventTypes.compositionUpdate;
    }
  }
  function isFallbackCompositionStart(topLevelType, nativeEvent) {
    return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
  }
  function isFallbackCompositionEnd(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case topLevelTypes.topKeyUp:
        return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
      case topLevelTypes.topKeyDown:
        return nativeEvent.keyCode !== START_KEYCODE;
      case topLevelTypes.topKeyPress:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topBlur:
        return true;
      default:
        return false;
    }
  }
  function getDataFromCustomEvent(nativeEvent) {
    var detail = nativeEvent.detail;
    if (typeof detail === 'object' && 'data' in detail) {
      return detail.data;
    }
    return null;
  }
  var currentComposition = null;
  function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var eventType;
    var fallbackData;
    if (canUseCompositionEvent) {
      eventType = getCompositionEventType(topLevelType);
    } else if (!currentComposition) {
      if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionStart;
      }
    } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionEnd;
    }
    if (!eventType) {
      return null;
    }
    if (useFallbackCompositionData) {
      if (!currentComposition && eventType === eventTypes.compositionStart) {
        currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
      } else if (eventType === eventTypes.compositionEnd) {
        if (currentComposition) {
          fallbackData = currentComposition.getData();
        }
      }
    }
    var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
    if (fallbackData) {
      event.data = fallbackData;
    } else {
      var customData = getDataFromCustomEvent(nativeEvent);
      if (customData !== null) {
        event.data = customData;
      }
    }
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
  function getNativeBeforeInputChars(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case topLevelTypes.topCompositionEnd:
        return getDataFromCustomEvent(nativeEvent);
      case topLevelTypes.topKeyPress:
        var which = nativeEvent.which;
        if (which !== SPACEBAR_CODE) {
          return null;
        }
        hasSpaceKeypress = true;
        return SPACEBAR_CHAR;
      case topLevelTypes.topTextInput:
        var chars = nativeEvent.data;
        if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
          return null;
        }
        return chars;
      default:
        return null;
    }
  }
  function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
    if (currentComposition) {
      if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
        var chars = currentComposition.getData();
        FallbackCompositionState.release(currentComposition);
        currentComposition = null;
        return chars;
      }
      return null;
    }
    switch (topLevelType) {
      case topLevelTypes.topPaste:
        return null;
      case topLevelTypes.topKeyPress:
        if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
          return String.fromCharCode(nativeEvent.which);
        }
        return null;
      case topLevelTypes.topCompositionEnd:
        return useFallbackCompositionData ? null : nativeEvent.data;
      default:
        return null;
    }
  }
  function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var chars;
    if (canUseTextInputEvent) {
      chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
    } else {
      chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
    }
    if (!chars) {
      return null;
    }
    var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
    event.data = chars;
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
  var BeforeInputEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
    }
  };
  module.exports = BeforeInputEventPlugin;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ChangeEventPlugin.js", ["./EventConstants", "./EventPluginHub", "./EventPropagators", "fbjs/lib/ExecutionEnvironment", "./ReactDOMComponentTree", "./ReactUpdates", "./SyntheticEvent", "./getEventTarget", "./isEventSupported", "./isTextInputElement", "fbjs/lib/keyOf", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var EventConstants = $__require('./EventConstants');
  var EventPluginHub = $__require('./EventPluginHub');
  var EventPropagators = $__require('./EventPropagators');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactUpdates = $__require('./ReactUpdates');
  var SyntheticEvent = $__require('./SyntheticEvent');
  var getEventTarget = $__require('./getEventTarget');
  var isEventSupported = $__require('./isEventSupported');
  var isTextInputElement = $__require('./isTextInputElement');
  var keyOf = $__require('fbjs/lib/keyOf');
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {change: {
      phasedRegistrationNames: {
        bubbled: keyOf({onChange: null}),
        captured: keyOf({onChangeCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
    }};
  var activeElement = null;
  var activeElementInst = null;
  var activeElementValue = null;
  var activeElementValueProp = null;
  function shouldUseChangeEvent(elem) {
    var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
  }
  var doesChangeEventBubble = false;
  if (ExecutionEnvironment.canUseDOM) {
    doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
  }
  function manualDispatchChangeEvent(nativeEvent) {
    var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
    EventPropagators.accumulateTwoPhaseDispatches(event);
    ReactUpdates.batchedUpdates(runEventInBatch, event);
  }
  function runEventInBatch(event) {
    EventPluginHub.enqueueEvents(event);
    EventPluginHub.processEventQueue(false);
  }
  function startWatchingForChangeEventIE8(target, targetInst) {
    activeElement = target;
    activeElementInst = targetInst;
    activeElement.attachEvent('onchange', manualDispatchChangeEvent);
  }
  function stopWatchingForChangeEventIE8() {
    if (!activeElement) {
      return;
    }
    activeElement.detachEvent('onchange', manualDispatchChangeEvent);
    activeElement = null;
    activeElementInst = null;
  }
  function getTargetInstForChangeEvent(topLevelType, targetInst) {
    if (topLevelType === topLevelTypes.topChange) {
      return targetInst;
    }
  }
  function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
    if (topLevelType === topLevelTypes.topFocus) {
      stopWatchingForChangeEventIE8();
      startWatchingForChangeEventIE8(target, targetInst);
    } else if (topLevelType === topLevelTypes.topBlur) {
      stopWatchingForChangeEventIE8();
    }
  }
  var isInputEventSupported = false;
  if (ExecutionEnvironment.canUseDOM) {
    isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 11);
  }
  var newValueProp = {
    get: function() {
      return activeElementValueProp.get.call(this);
    },
    set: function(val) {
      activeElementValue = '' + val;
      activeElementValueProp.set.call(this, val);
    }
  };
  function startWatchingForValueChange(target, targetInst) {
    activeElement = target;
    activeElementInst = targetInst;
    activeElementValue = target.value;
    activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
    Object.defineProperty(activeElement, 'value', newValueProp);
    if (activeElement.attachEvent) {
      activeElement.attachEvent('onpropertychange', handlePropertyChange);
    } else {
      activeElement.addEventListener('propertychange', handlePropertyChange, false);
    }
  }
  function stopWatchingForValueChange() {
    if (!activeElement) {
      return;
    }
    delete activeElement.value;
    if (activeElement.detachEvent) {
      activeElement.detachEvent('onpropertychange', handlePropertyChange);
    } else {
      activeElement.removeEventListener('propertychange', handlePropertyChange, false);
    }
    activeElement = null;
    activeElementInst = null;
    activeElementValue = null;
    activeElementValueProp = null;
  }
  function handlePropertyChange(nativeEvent) {
    if (nativeEvent.propertyName !== 'value') {
      return;
    }
    var value = nativeEvent.srcElement.value;
    if (value === activeElementValue) {
      return;
    }
    activeElementValue = value;
    manualDispatchChangeEvent(nativeEvent);
  }
  function getTargetInstForInputEvent(topLevelType, targetInst) {
    if (topLevelType === topLevelTypes.topInput) {
      return targetInst;
    }
  }
  function handleEventsForInputEventIE(topLevelType, target, targetInst) {
    if (topLevelType === topLevelTypes.topFocus) {
      stopWatchingForValueChange();
      startWatchingForValueChange(target, targetInst);
    } else if (topLevelType === topLevelTypes.topBlur) {
      stopWatchingForValueChange();
    }
  }
  function getTargetInstForInputEventIE(topLevelType, targetInst) {
    if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
      if (activeElement && activeElement.value !== activeElementValue) {
        activeElementValue = activeElement.value;
        return activeElementInst;
      }
    }
  }
  function shouldUseClickEvent(elem) {
    return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
  }
  function getTargetInstForClickEvent(topLevelType, targetInst) {
    if (topLevelType === topLevelTypes.topClick) {
      return targetInst;
    }
  }
  var ChangeEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
      var getTargetInstFunc,
          handleEventFunc;
      if (shouldUseChangeEvent(targetNode)) {
        if (doesChangeEventBubble) {
          getTargetInstFunc = getTargetInstForChangeEvent;
        } else {
          handleEventFunc = handleEventsForChangeEventIE8;
        }
      } else if (isTextInputElement(targetNode)) {
        if (isInputEventSupported) {
          getTargetInstFunc = getTargetInstForInputEvent;
        } else {
          getTargetInstFunc = getTargetInstForInputEventIE;
          handleEventFunc = handleEventsForInputEventIE;
        }
      } else if (shouldUseClickEvent(targetNode)) {
        getTargetInstFunc = getTargetInstForClickEvent;
      }
      if (getTargetInstFunc) {
        var inst = getTargetInstFunc(topLevelType, targetInst);
        if (inst) {
          var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
          event.type = 'change';
          EventPropagators.accumulateTwoPhaseDispatches(event);
          return event;
        }
      }
      if (handleEventFunc) {
        handleEventFunc(topLevelType, targetNode, targetInst);
      }
    }
  };
  module.exports = ChangeEventPlugin;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/DefaultEventPluginOrder.js", ["fbjs/lib/keyOf", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var keyOf = $__require('fbjs/lib/keyOf');
  var DefaultEventPluginOrder = [keyOf({ResponderEventPlugin: null}), keyOf({SimpleEventPlugin: null}), keyOf({TapEventPlugin: null}), keyOf({EnterLeaveEventPlugin: null}), keyOf({ChangeEventPlugin: null}), keyOf({SelectEventPlugin: null}), keyOf({BeforeInputEventPlugin: null})];
  module.exports = DefaultEventPluginOrder;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/EnterLeaveEventPlugin.js", ["./EventConstants", "./EventPropagators", "./ReactDOMComponentTree", "./SyntheticMouseEvent", "fbjs/lib/keyOf", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var EventConstants = $__require('./EventConstants');
  var EventPropagators = $__require('./EventPropagators');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var SyntheticMouseEvent = $__require('./SyntheticMouseEvent');
  var keyOf = $__require('fbjs/lib/keyOf');
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {
    mouseEnter: {
      registrationName: keyOf({onMouseEnter: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    },
    mouseLeave: {
      registrationName: keyOf({onMouseLeave: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    }
  };
  var EnterLeaveEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
        return null;
      }
      if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
        return null;
      }
      var win;
      if (nativeEventTarget.window === nativeEventTarget) {
        win = nativeEventTarget;
      } else {
        var doc = nativeEventTarget.ownerDocument;
        if (doc) {
          win = doc.defaultView || doc.parentWindow;
        } else {
          win = window;
        }
      }
      var from;
      var to;
      if (topLevelType === topLevelTypes.topMouseOut) {
        from = targetInst;
        var related = nativeEvent.relatedTarget || nativeEvent.toElement;
        to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
      } else {
        from = null;
        to = targetInst;
      }
      if (from === to) {
        return null;
      }
      var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
      var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
      var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
      leave.type = 'mouseleave';
      leave.target = fromNode;
      leave.relatedTarget = toNode;
      var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
      enter.type = 'mouseenter';
      enter.target = toNode;
      enter.relatedTarget = fromNode;
      EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
      return [leave, enter];
    }
  };
  module.exports = EnterLeaveEventPlugin;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/HTMLDOMPropertyConfig.js", ["./DOMProperty", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMProperty = $__require('./DOMProperty');
  var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
  var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
  var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
  var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
  var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
  var HTMLDOMPropertyConfig = {
    isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
    Properties: {
      accept: 0,
      acceptCharset: 0,
      accessKey: 0,
      action: 0,
      allowFullScreen: HAS_BOOLEAN_VALUE,
      allowTransparency: 0,
      alt: 0,
      async: HAS_BOOLEAN_VALUE,
      autoComplete: 0,
      autoPlay: HAS_BOOLEAN_VALUE,
      capture: HAS_BOOLEAN_VALUE,
      cellPadding: 0,
      cellSpacing: 0,
      charSet: 0,
      challenge: 0,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      cite: 0,
      classID: 0,
      className: 0,
      cols: HAS_POSITIVE_NUMERIC_VALUE,
      colSpan: 0,
      content: 0,
      contentEditable: 0,
      contextMenu: 0,
      controls: HAS_BOOLEAN_VALUE,
      coords: 0,
      crossOrigin: 0,
      data: 0,
      dateTime: 0,
      'default': HAS_BOOLEAN_VALUE,
      defer: HAS_BOOLEAN_VALUE,
      dir: 0,
      disabled: HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: 0,
      encType: 0,
      form: 0,
      formAction: 0,
      formEncType: 0,
      formMethod: 0,
      formNoValidate: HAS_BOOLEAN_VALUE,
      formTarget: 0,
      frameBorder: 0,
      headers: 0,
      height: 0,
      hidden: HAS_BOOLEAN_VALUE,
      high: 0,
      href: 0,
      hrefLang: 0,
      htmlFor: 0,
      httpEquiv: 0,
      icon: 0,
      id: 0,
      inputMode: 0,
      integrity: 0,
      is: 0,
      keyParams: 0,
      keyType: 0,
      kind: 0,
      label: 0,
      lang: 0,
      list: 0,
      loop: HAS_BOOLEAN_VALUE,
      low: 0,
      manifest: 0,
      marginHeight: 0,
      marginWidth: 0,
      max: 0,
      maxLength: 0,
      media: 0,
      mediaGroup: 0,
      method: 0,
      min: 0,
      minLength: 0,
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      name: 0,
      nonce: 0,
      noValidate: HAS_BOOLEAN_VALUE,
      open: HAS_BOOLEAN_VALUE,
      optimum: 0,
      pattern: 0,
      placeholder: 0,
      poster: 0,
      preload: 0,
      profile: 0,
      radioGroup: 0,
      readOnly: HAS_BOOLEAN_VALUE,
      rel: 0,
      required: HAS_BOOLEAN_VALUE,
      reversed: HAS_BOOLEAN_VALUE,
      role: 0,
      rows: HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: HAS_NUMERIC_VALUE,
      sandbox: 0,
      scope: 0,
      scoped: HAS_BOOLEAN_VALUE,
      scrolling: 0,
      seamless: HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      shape: 0,
      size: HAS_POSITIVE_NUMERIC_VALUE,
      sizes: 0,
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: 0,
      src: 0,
      srcDoc: 0,
      srcLang: 0,
      srcSet: 0,
      start: HAS_NUMERIC_VALUE,
      step: 0,
      style: 0,
      summary: 0,
      tabIndex: 0,
      target: 0,
      title: 0,
      type: 0,
      useMap: 0,
      value: 0,
      width: 0,
      wmode: 0,
      wrap: 0,
      about: 0,
      datatype: 0,
      inlist: 0,
      prefix: 0,
      property: 0,
      resource: 0,
      'typeof': 0,
      vocab: 0,
      autoCapitalize: 0,
      autoCorrect: 0,
      autoSave: 0,
      color: 0,
      itemProp: 0,
      itemScope: HAS_BOOLEAN_VALUE,
      itemType: 0,
      itemID: 0,
      itemRef: 0,
      results: 0,
      security: 0,
      unselectable: 0
    },
    DOMAttributeNames: {
      acceptCharset: 'accept-charset',
      className: 'class',
      htmlFor: 'for',
      httpEquiv: 'http-equiv'
    },
    DOMPropertyNames: {}
  };
  module.exports = HTMLDOMPropertyConfig;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/AutoFocusUtils.js", ["./ReactDOMComponentTree", "fbjs/lib/focusNode", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var focusNode = $__require('fbjs/lib/focusNode');
  var AutoFocusUtils = {focusDOMComponent: function() {
      focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
    }};
  module.exports = AutoFocusUtils;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/camelize.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _hyphenPattern = /-(.)/g;
  function camelize(string) {
    return string.replace(_hyphenPattern, function(_, character) {
      return character.toUpperCase();
    });
  }
  module.exports = camelize;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/camelizeStyleName.js", ["./camelize", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var camelize = $__require('./camelize');
  var msPattern = /^-ms-/;
  function camelizeStyleName(string) {
    return camelize(string.replace(msPattern, 'ms-'));
  }
  module.exports = camelizeStyleName;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/CSSProperty.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridColumn: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  function prefixKey(prefix, key) {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  }
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
  Object.keys(isUnitlessNumber).forEach(function(prop) {
    prefixes.forEach(function(prefix) {
      isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
    });
  });
  var shorthandPropertyExpansions = {
    background: {
      backgroundAttachment: true,
      backgroundColor: true,
      backgroundImage: true,
      backgroundPositionX: true,
      backgroundPositionY: true,
      backgroundRepeat: true
    },
    backgroundPosition: {
      backgroundPositionX: true,
      backgroundPositionY: true
    },
    border: {
      borderWidth: true,
      borderStyle: true,
      borderColor: true
    },
    borderBottom: {
      borderBottomWidth: true,
      borderBottomStyle: true,
      borderBottomColor: true
    },
    borderLeft: {
      borderLeftWidth: true,
      borderLeftStyle: true,
      borderLeftColor: true
    },
    borderRight: {
      borderRightWidth: true,
      borderRightStyle: true,
      borderRightColor: true
    },
    borderTop: {
      borderTopWidth: true,
      borderTopStyle: true,
      borderTopColor: true
    },
    font: {
      fontStyle: true,
      fontVariant: true,
      fontWeight: true,
      fontSize: true,
      lineHeight: true,
      fontFamily: true
    },
    outline: {
      outlineWidth: true,
      outlineStyle: true,
      outlineColor: true
    }
  };
  var CSSProperty = {
    isUnitlessNumber: isUnitlessNumber,
    shorthandPropertyExpansions: shorthandPropertyExpansions
  };
  module.exports = CSSProperty;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/dangerousStyleValue.js", ["./CSSProperty", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var CSSProperty = $__require('./CSSProperty');
  var warning = $__require('fbjs/lib/warning');
  var isUnitlessNumber = CSSProperty.isUnitlessNumber;
  var styleWarnings = {};
  function dangerousStyleValue(name, value, component) {
    var isEmpty = value == null || typeof value === 'boolean' || value === '';
    if (isEmpty) {
      return '';
    }
    var isNonNumeric = isNaN(value);
    if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
      return '' + value;
    }
    if (typeof value === 'string') {
      if ("production" !== 'production') {
        if (component && value !== '0') {
          var owner = component._currentElement._owner;
          var ownerName = owner ? owner.getName() : null;
          if (ownerName && !styleWarnings[ownerName]) {
            styleWarnings[ownerName] = {};
          }
          var warned = false;
          if (ownerName) {
            var warnings = styleWarnings[ownerName];
            warned = warnings[name];
            if (!warned) {
              warnings[name] = true;
            }
          }
          if (!warned) {
            "production" !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
          }
        }
      }
      value = value.trim();
    }
    return value + 'px';
  }
  module.exports = dangerousStyleValue;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/hyphenate.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _uppercasePattern = /([A-Z])/g;
  function hyphenate(string) {
    return string.replace(_uppercasePattern, '-$1').toLowerCase();
  }
  module.exports = hyphenate;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/hyphenateStyleName.js", ["./hyphenate", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var hyphenate = $__require('./hyphenate');
  var msPattern = /^ms-/;
  function hyphenateStyleName(string) {
    return hyphenate(string).replace(msPattern, '-ms-');
  }
  module.exports = hyphenateStyleName;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/memoizeStringOnly.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function memoizeStringOnly(callback) {
    var cache = {};
    return function(string) {
      if (!cache.hasOwnProperty(string)) {
        cache[string] = callback.call(this, string);
      }
      return cache[string];
    };
  }
  module.exports = memoizeStringOnly;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/CSSPropertyOperations.js", ["./CSSProperty", "fbjs/lib/ExecutionEnvironment", "./ReactInstrumentation", "fbjs/lib/camelizeStyleName", "./dangerousStyleValue", "fbjs/lib/hyphenateStyleName", "fbjs/lib/memoizeStringOnly", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var CSSProperty = $__require('./CSSProperty');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var camelizeStyleName = $__require('fbjs/lib/camelizeStyleName');
  var dangerousStyleValue = $__require('./dangerousStyleValue');
  var hyphenateStyleName = $__require('fbjs/lib/hyphenateStyleName');
  var memoizeStringOnly = $__require('fbjs/lib/memoizeStringOnly');
  var warning = $__require('fbjs/lib/warning');
  var processStyleName = memoizeStringOnly(function(styleName) {
    return hyphenateStyleName(styleName);
  });
  var hasShorthandPropertyBug = false;
  var styleFloatAccessor = 'cssFloat';
  if (ExecutionEnvironment.canUseDOM) {
    var tempStyle = document.createElement('div').style;
    try {
      tempStyle.font = '';
    } catch (e) {
      hasShorthandPropertyBug = true;
    }
    if (document.documentElement.style.cssFloat === undefined) {
      styleFloatAccessor = 'styleFloat';
    }
  }
  if ("production" !== 'production') {
    var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
    var badStyleValueWithSemicolonPattern = /;\s*$/;
    var warnedStyleNames = {};
    var warnedStyleValues = {};
    var warnedForNaNValue = false;
    var warnHyphenatedStyleName = function(name, owner) {
      if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
        return;
      }
      warnedStyleNames[name] = true;
      "production" !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
    };
    var warnBadVendoredStyleName = function(name, owner) {
      if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
        return;
      }
      warnedStyleNames[name] = true;
      "production" !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
    };
    var warnStyleValueWithSemicolon = function(name, value, owner) {
      if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
        return;
      }
      warnedStyleValues[value] = true;
      "production" !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
    };
    var warnStyleValueIsNaN = function(name, value, owner) {
      if (warnedForNaNValue) {
        return;
      }
      warnedForNaNValue = true;
      "production" !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
    };
    var checkRenderMessage = function(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    };
    var warnValidStyle = function(name, value, component) {
      var owner;
      if (component) {
        owner = component._currentElement._owner;
      }
      if (name.indexOf('-') > -1) {
        warnHyphenatedStyleName(name, owner);
      } else if (badVendoredStyleNamePattern.test(name)) {
        warnBadVendoredStyleName(name, owner);
      } else if (badStyleValueWithSemicolonPattern.test(value)) {
        warnStyleValueWithSemicolon(name, value, owner);
      }
      if (typeof value === 'number' && isNaN(value)) {
        warnStyleValueIsNaN(name, value, owner);
      }
    };
  }
  var CSSPropertyOperations = {
    createMarkupForStyles: function(styles, component) {
      var serialized = '';
      for (var styleName in styles) {
        if (!styles.hasOwnProperty(styleName)) {
          continue;
        }
        var styleValue = styles[styleName];
        if ("production" !== 'production') {
          warnValidStyle(styleName, styleValue, component);
        }
        if (styleValue != null) {
          serialized += processStyleName(styleName) + ':';
          serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
        }
      }
      return serialized || null;
    },
    setValueForStyles: function(node, styles, component) {
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onHostOperation(component._debugID, 'update styles', styles);
      }
      var style = node.style;
      for (var styleName in styles) {
        if (!styles.hasOwnProperty(styleName)) {
          continue;
        }
        if ("production" !== 'production') {
          warnValidStyle(styleName, styles[styleName], component);
        }
        var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
        if (styleName === 'float' || styleName === 'cssFloat') {
          styleName = styleFloatAccessor;
        }
        if (styleValue) {
          style[styleName] = styleValue;
        } else {
          var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
          if (expansion) {
            for (var individualStyleName in expansion) {
              style[individualStyleName] = '';
            }
          } else {
            style[styleName] = '';
          }
        }
      }
    }
  };
  module.exports = CSSPropertyOperations;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMIDOperations.js", ["./DOMChildrenOperations", "./ReactDOMComponentTree", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMChildrenOperations = $__require('./DOMChildrenOperations');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactDOMIDOperations = {dangerouslyProcessChildrenUpdates: function(parentInst, updates) {
      var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
      DOMChildrenOperations.processUpdates(node, updates);
    }};
  module.exports = ReactDOMIDOperations;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactComponentBrowserEnvironment.js", ["./DOMChildrenOperations", "./ReactDOMIDOperations", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMChildrenOperations = $__require('./DOMChildrenOperations');
  var ReactDOMIDOperations = $__require('./ReactDOMIDOperations');
  var ReactComponentBrowserEnvironment = {
    processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
    replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup,
    unmountIDFromEnvironment: function(rootNodeID) {}
  };
  module.exports = ReactComponentBrowserEnvironment;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMButton.js", ["./DisabledInputUtils", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var DisabledInputUtils = $__require('./DisabledInputUtils');
  var ReactDOMButton = {getHostProps: DisabledInputUtils.getHostProps};
  module.exports = ReactDOMButton;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMNullInputValuePropDevtool.js", ["./ReactComponentTreeDevtool", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactComponentTreeDevtool = $__require('./ReactComponentTreeDevtool');
  var warning = $__require('fbjs/lib/warning');
  var didWarnValueNull = false;
  function handleElement(debugID, element) {
    if (element == null) {
      return;
    }
    if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
      return;
    }
    if (element.props != null && element.props.value === null && !didWarnValueNull) {
      "production" !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeDevtool.getStackAddendumByID(debugID)) : void 0;
      didWarnValueNull = true;
    }
  }
  var ReactDOMUnknownPropertyDevtool = {
    onBeforeMountComponent: function(debugID, element) {
      handleElement(debugID, element);
    },
    onBeforeUpdateComponent: function(debugID, element) {
      handleElement(debugID, element);
    }
  };
  module.exports = ReactDOMUnknownPropertyDevtool;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMUnknownPropertyDevtool.js", ["./DOMProperty", "./EventPluginRegistry", "./ReactComponentTreeDevtool", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMProperty = $__require('./DOMProperty');
  var EventPluginRegistry = $__require('./EventPluginRegistry');
  var ReactComponentTreeDevtool = $__require('./ReactComponentTreeDevtool');
  var warning = $__require('fbjs/lib/warning');
  if ("production" !== 'production') {
    var reactProps = {
      children: true,
      dangerouslySetInnerHTML: true,
      key: true,
      ref: true,
      autoFocus: true,
      defaultValue: true,
      valueLink: true,
      defaultChecked: true,
      checkedLink: true,
      innerHTML: true,
      suppressContentEditableWarning: true,
      onFocusIn: true,
      onFocusOut: true
    };
    var warnedProperties = {};
    var validateProperty = function(tagName, name, debugID) {
      if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
        return true;
      }
      if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
        return true;
      }
      if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
        return true;
      }
      warnedProperties[name] = true;
      var lowerCasedName = name.toLowerCase();
      var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
      var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
      if (standardName != null) {
        "production" !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeDevtool.getStackAddendumByID(debugID)) : void 0;
        return true;
      } else if (registrationName != null) {
        "production" !== 'production' ? warning(registrationName == null, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeDevtool.getStackAddendumByID(debugID)) : void 0;
        return true;
      } else {
        return false;
      }
    };
  }
  var warnUnknownProperties = function(debugID, element) {
    var unknownProps = [];
    for (var key in element.props) {
      var isValid = validateProperty(element.type, key, debugID);
      if (!isValid) {
        unknownProps.push(key);
      }
    }
    var unknownPropString = unknownProps.map(function(prop) {
      return '`' + prop + '`';
    }).join(', ');
    if (unknownProps.length === 1) {
      "production" !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeDevtool.getStackAddendumByID(debugID)) : void 0;
    } else if (unknownProps.length > 1) {
      "production" !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeDevtool.getStackAddendumByID(debugID)) : void 0;
    }
  };
  function handleElement(debugID, element) {
    if (element == null || typeof element.type !== 'string') {
      return;
    }
    if (element.type.indexOf('-') >= 0 || element.props.is) {
      return;
    }
    warnUnknownProperties(debugID, element);
  }
  var ReactDOMUnknownPropertyDevtool = {
    onBeforeMountComponent: function(debugID, element) {
      handleElement(debugID, element);
    },
    onBeforeUpdateComponent: function(debugID, element) {
      handleElement(debugID, element);
    }
  };
  module.exports = ReactDOMUnknownPropertyDevtool;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMDebugTool.js", ["./ReactDOMNullInputValuePropDevtool", "./ReactDOMUnknownPropertyDevtool", "./ReactDebugTool", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMNullInputValuePropDevtool = $__require('./ReactDOMNullInputValuePropDevtool');
  var ReactDOMUnknownPropertyDevtool = $__require('./ReactDOMUnknownPropertyDevtool');
  var ReactDebugTool = $__require('./ReactDebugTool');
  var warning = $__require('fbjs/lib/warning');
  var eventHandlers = [];
  var handlerDoesThrowForEvent = {};
  function emitEvent(handlerFunctionName, arg1, arg2, arg3, arg4, arg5) {
    eventHandlers.forEach(function(handler) {
      try {
        if (handler[handlerFunctionName]) {
          handler[handlerFunctionName](arg1, arg2, arg3, arg4, arg5);
        }
      } catch (e) {
        "production" !== 'production' ? warning(handlerDoesThrowForEvent[handlerFunctionName], 'exception thrown by devtool while handling %s: %s', handlerFunctionName, e + '\n' + e.stack) : void 0;
        handlerDoesThrowForEvent[handlerFunctionName] = true;
      }
    });
  }
  var ReactDOMDebugTool = {
    addDevtool: function(devtool) {
      ReactDebugTool.addDevtool(devtool);
      eventHandlers.push(devtool);
    },
    removeDevtool: function(devtool) {
      ReactDebugTool.removeDevtool(devtool);
      for (var i = 0; i < eventHandlers.length; i++) {
        if (eventHandlers[i] === devtool) {
          eventHandlers.splice(i, 1);
          i--;
        }
      }
    },
    onCreateMarkupForProperty: function(name, value) {
      emitEvent('onCreateMarkupForProperty', name, value);
    },
    onSetValueForProperty: function(node, name, value) {
      emitEvent('onSetValueForProperty', node, name, value);
    },
    onDeleteValueForProperty: function(node, name) {
      emitEvent('onDeleteValueForProperty', node, name);
    },
    onTestEvent: function() {
      emitEvent('onTestEvent');
    }
  };
  ReactDOMDebugTool.addDevtool(ReactDOMUnknownPropertyDevtool);
  ReactDOMDebugTool.addDevtool(ReactDOMNullInputValuePropDevtool);
  module.exports = ReactDOMDebugTool;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMInstrumentation.js", ["./ReactDOMDebugTool", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var debugTool = null;
  if ("production" !== 'production') {
    var ReactDOMDebugTool = $__require('./ReactDOMDebugTool');
    debugTool = ReactDOMDebugTool;
  }
  module.exports = {debugTool: debugTool};
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/quoteAttributeValueForBrowser.js", ["./escapeTextContentForBrowser", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var escapeTextContentForBrowser = $__require('./escapeTextContentForBrowser');
  function quoteAttributeValueForBrowser(value) {
    return '"' + escapeTextContentForBrowser(value) + '"';
  }
  module.exports = quoteAttributeValueForBrowser;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/DOMPropertyOperations.js", ["./DOMProperty", "./ReactDOMComponentTree", "./ReactDOMInstrumentation", "./ReactInstrumentation", "./quoteAttributeValueForBrowser", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMProperty = $__require('./DOMProperty');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactDOMInstrumentation = $__require('./ReactDOMInstrumentation');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var quoteAttributeValueForBrowser = $__require('./quoteAttributeValueForBrowser');
  var warning = $__require('fbjs/lib/warning');
  var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
  var illegalAttributeNameCache = {};
  var validatedAttributeNameCache = {};
  function isAttributeNameSafe(attributeName) {
    if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
      return true;
    }
    if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
      return false;
    }
    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
      validatedAttributeNameCache[attributeName] = true;
      return true;
    }
    illegalAttributeNameCache[attributeName] = true;
    "production" !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
    return false;
  }
  function shouldIgnoreValue(propertyInfo, value) {
    return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
  }
  var DOMPropertyOperations = {
    createMarkupForID: function(id) {
      return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
    },
    setAttributeForID: function(node, id) {
      node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
    },
    createMarkupForRoot: function() {
      return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
    },
    setAttributeForRoot: function(node) {
      node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
    },
    createMarkupForProperty: function(name, value) {
      if ("production" !== 'production') {
        ReactDOMInstrumentation.debugTool.onCreateMarkupForProperty(name, value);
      }
      var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
      if (propertyInfo) {
        if (shouldIgnoreValue(propertyInfo, value)) {
          return '';
        }
        var attributeName = propertyInfo.attributeName;
        if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          return attributeName + '=""';
        }
        return attributeName + '=' + quoteAttributeValueForBrowser(value);
      } else if (DOMProperty.isCustomAttribute(name)) {
        if (value == null) {
          return '';
        }
        return name + '=' + quoteAttributeValueForBrowser(value);
      }
      return null;
    },
    createMarkupForCustomAttribute: function(name, value) {
      if (!isAttributeNameSafe(name) || value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    },
    setValueForProperty: function(node, name, value) {
      var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
      if (propertyInfo) {
        var mutationMethod = propertyInfo.mutationMethod;
        if (mutationMethod) {
          mutationMethod(node, value);
        } else if (shouldIgnoreValue(propertyInfo, value)) {
          this.deleteValueForProperty(node, name);
          return;
        } else if (propertyInfo.mustUseProperty) {
          node[propertyInfo.propertyName] = value;
        } else {
          var attributeName = propertyInfo.attributeName;
          var namespace = propertyInfo.attributeNamespace;
          if (namespace) {
            node.setAttributeNS(namespace, attributeName, '' + value);
          } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
            node.setAttribute(attributeName, '');
          } else {
            node.setAttribute(attributeName, '' + value);
          }
        }
      } else if (DOMProperty.isCustomAttribute(name)) {
        DOMPropertyOperations.setValueForAttribute(node, name, value);
        return;
      }
      if ("production" !== 'production') {
        ReactDOMInstrumentation.debugTool.onSetValueForProperty(node, name, value);
        var payload = {};
        payload[name] = value;
        ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
      }
    },
    setValueForAttribute: function(node, name, value) {
      if (!isAttributeNameSafe(name)) {
        return;
      }
      if (value == null) {
        node.removeAttribute(name);
      } else {
        node.setAttribute(name, '' + value);
      }
      if ("production" !== 'production') {
        var payload = {};
        payload[name] = value;
        ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
      }
    },
    deleteValueForAttribute: function(node, name) {
      node.removeAttribute(name);
      if ("production" !== 'production') {
        ReactDOMInstrumentation.debugTool.onDeleteValueForProperty(node, name);
        ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
      }
    },
    deleteValueForProperty: function(node, name) {
      var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
      if (propertyInfo) {
        var mutationMethod = propertyInfo.mutationMethod;
        if (mutationMethod) {
          mutationMethod(node, undefined);
        } else if (propertyInfo.mustUseProperty) {
          var propName = propertyInfo.propertyName;
          if (propertyInfo.hasBooleanValue) {
            node[propName] = false;
          } else {
            node[propName] = '';
          }
        } else {
          node.removeAttribute(propertyInfo.attributeName);
        }
      } else if (DOMProperty.isCustomAttribute(name)) {
        node.removeAttribute(name);
      }
      if ("production" !== 'production') {
        ReactDOMInstrumentation.debugTool.onDeleteValueForProperty(node, name);
        ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
      }
    }
  };
  module.exports = DOMPropertyOperations;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMInput.js", ["./reactProdInvariant", "object-assign", "./DisabledInputUtils", "./DOMPropertyOperations", "./LinkedValueUtils", "./ReactDOMComponentTree", "./ReactUpdates", "fbjs/lib/invariant", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');
  var DisabledInputUtils = $__require('./DisabledInputUtils');
  var DOMPropertyOperations = $__require('./DOMPropertyOperations');
  var LinkedValueUtils = $__require('./LinkedValueUtils');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactUpdates = $__require('./ReactUpdates');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');
  var didWarnValueLink = false;
  var didWarnCheckedLink = false;
  var didWarnValueDefaultValue = false;
  var didWarnCheckedDefaultChecked = false;
  var didWarnControlledToUncontrolled = false;
  var didWarnUncontrolledToControlled = false;
  function forceUpdateIfMounted() {
    if (this._rootNodeID) {
      ReactDOMInput.updateWrapper(this);
    }
  }
  function isControlled(props) {
    var usesChecked = props.type === 'checkbox' || props.type === 'radio';
    return usesChecked ? props.checked !== undefined : props.value !== undefined;
  }
  var ReactDOMInput = {
    getHostProps: function(inst, props) {
      var value = LinkedValueUtils.getValue(props);
      var checked = LinkedValueUtils.getChecked(props);
      var hostProps = _assign({type: undefined}, DisabledInputUtils.getHostProps(inst, props), {
        defaultChecked: undefined,
        defaultValue: undefined,
        value: value != null ? value : inst._wrapperState.initialValue,
        checked: checked != null ? checked : inst._wrapperState.initialChecked,
        onChange: inst._wrapperState.onChange
      });
      return hostProps;
    },
    mountWrapper: function(inst, props) {
      if ("production" !== 'production') {
        LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
        var owner = inst._currentElement._owner;
        if (props.valueLink !== undefined && !didWarnValueLink) {
          "production" !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
          didWarnValueLink = true;
        }
        if (props.checkedLink !== undefined && !didWarnCheckedLink) {
          "production" !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
          didWarnCheckedLink = true;
        }
        if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
          "production" !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
          didWarnCheckedDefaultChecked = true;
        }
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
          "production" !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
          didWarnValueDefaultValue = true;
        }
      }
      var defaultValue = props.defaultValue;
      inst._wrapperState = {
        initialChecked: props.checked != null ? props.checked : props.defaultChecked,
        initialValue: props.value != null ? props.value : defaultValue,
        listeners: null,
        onChange: _handleChange.bind(inst)
      };
      if ("production" !== 'production') {
        inst._wrapperState.controlled = isControlled(props);
      }
    },
    updateWrapper: function(inst) {
      var props = inst._currentElement.props;
      if ("production" !== 'production') {
        var controlled = isControlled(props);
        var owner = inst._currentElement._owner;
        if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
          "production" !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
          didWarnUncontrolledToControlled = true;
        }
        if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
          "production" !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
          didWarnControlledToUncontrolled = true;
        }
      }
      var checked = props.checked;
      if (checked != null) {
        DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
      }
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      var value = LinkedValueUtils.getValue(props);
      if (value != null) {
        var newValue = '' + value;
        if (newValue !== node.value) {
          node.value = newValue;
        }
      } else {
        if (props.value == null && props.defaultValue != null) {
          node.defaultValue = '' + props.defaultValue;
        }
        if (props.checked == null && props.defaultChecked != null) {
          node.defaultChecked = !!props.defaultChecked;
        }
      }
    },
    postMountWrapper: function(inst) {
      var props = inst._currentElement.props;
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      if (props.type !== 'submit' && props.type !== 'reset') {
        node.value = node.value;
      }
      var name = node.name;
      if (name !== '') {
        node.name = '';
      }
      node.defaultChecked = !node.defaultChecked;
      node.defaultChecked = !node.defaultChecked;
      if (name !== '') {
        node.name = name;
      }
    }
  };
  function _handleChange(event) {
    var props = this._currentElement.props;
    var returnValue = LinkedValueUtils.executeOnChange(props, event);
    ReactUpdates.asap(forceUpdateIfMounted, this);
    var name = props.name;
    if (props.type === 'radio' && name != null) {
      var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
      var queryRoot = rootNode;
      while (queryRoot.parentNode) {
        queryRoot = queryRoot.parentNode;
      }
      var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
      for (var i = 0; i < group.length; i++) {
        var otherNode = group[i];
        if (otherNode === rootNode || otherNode.form !== rootNode.form) {
          continue;
        }
        var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
        !otherInstance ? "production" !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
        ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
      }
    }
    return returnValue;
  }
  module.exports = ReactDOMInput;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMOption.js", ["object-assign", "./ReactChildren", "./ReactDOMComponentTree", "./ReactDOMSelect", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');
  var ReactChildren = $__require('./ReactChildren');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactDOMSelect = $__require('./ReactDOMSelect');
  var warning = $__require('fbjs/lib/warning');
  var didWarnInvalidOptionChildren = false;
  function flattenChildren(children) {
    var content = '';
    ReactChildren.forEach(children, function(child) {
      if (child == null) {
        return;
      }
      if (typeof child === 'string' || typeof child === 'number') {
        content += child;
      } else if (!didWarnInvalidOptionChildren) {
        didWarnInvalidOptionChildren = true;
        "production" !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
      }
    });
    return content;
  }
  var ReactDOMOption = {
    mountWrapper: function(inst, props, hostParent) {
      if ("production" !== 'production') {
        "production" !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
      }
      var selectValue = null;
      if (hostParent != null) {
        var selectParent = hostParent;
        if (selectParent._tag === 'optgroup') {
          selectParent = selectParent._hostParent;
        }
        if (selectParent != null && selectParent._tag === 'select') {
          selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
        }
      }
      var selected = null;
      if (selectValue != null) {
        var value;
        if (props.value != null) {
          value = props.value + '';
        } else {
          value = flattenChildren(props.children);
        }
        selected = false;
        if (Array.isArray(selectValue)) {
          for (var i = 0; i < selectValue.length; i++) {
            if ('' + selectValue[i] === value) {
              selected = true;
              break;
            }
          }
        } else {
          selected = '' + selectValue === value;
        }
      }
      inst._wrapperState = {selected: selected};
    },
    postMountWrapper: function(inst) {
      var props = inst._currentElement.props;
      if (props.value != null) {
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        node.setAttribute('value', props.value);
      }
    },
    getHostProps: function(inst, props) {
      var hostProps = _assign({
        selected: undefined,
        children: undefined
      }, props);
      if (inst._wrapperState.selected != null) {
        hostProps.selected = inst._wrapperState.selected;
      }
      var content = flattenChildren(props.children);
      if (content) {
        hostProps.children = content;
      }
      return hostProps;
    }
  };
  module.exports = ReactDOMOption;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMSelect.js", ["object-assign", "./DisabledInputUtils", "./LinkedValueUtils", "./ReactDOMComponentTree", "./ReactUpdates", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');
  var DisabledInputUtils = $__require('./DisabledInputUtils');
  var LinkedValueUtils = $__require('./LinkedValueUtils');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactUpdates = $__require('./ReactUpdates');
  var warning = $__require('fbjs/lib/warning');
  var didWarnValueLink = false;
  var didWarnValueDefaultValue = false;
  function updateOptionsIfPendingUpdateAndMounted() {
    if (this._rootNodeID && this._wrapperState.pendingUpdate) {
      this._wrapperState.pendingUpdate = false;
      var props = this._currentElement.props;
      var value = LinkedValueUtils.getValue(props);
      if (value != null) {
        updateOptions(this, Boolean(props.multiple), value);
      }
    }
  }
  function getDeclarationErrorAddendum(owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  }
  var valuePropNames = ['value', 'defaultValue'];
  function checkSelectPropTypes(inst, props) {
    var owner = inst._currentElement._owner;
    LinkedValueUtils.checkPropTypes('select', props, owner);
    if (props.valueLink !== undefined && !didWarnValueLink) {
      "production" !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
      didWarnValueLink = true;
    }
    for (var i = 0; i < valuePropNames.length; i++) {
      var propName = valuePropNames[i];
      if (props[propName] == null) {
        continue;
      }
      if (props.multiple) {
        "production" !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
      } else {
        "production" !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
      }
    }
  }
  function updateOptions(inst, multiple, propValue) {
    var selectedValue,
        i;
    var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
    if (multiple) {
      selectedValue = {};
      for (i = 0; i < propValue.length; i++) {
        selectedValue['' + propValue[i]] = true;
      }
      for (i = 0; i < options.length; i++) {
        var selected = selectedValue.hasOwnProperty(options[i].value);
        if (options[i].selected !== selected) {
          options[i].selected = selected;
        }
      }
    } else {
      selectedValue = '' + propValue;
      for (i = 0; i < options.length; i++) {
        if (options[i].value === selectedValue) {
          options[i].selected = true;
          return;
        }
      }
      if (options.length) {
        options[0].selected = true;
      }
    }
  }
  var ReactDOMSelect = {
    getHostProps: function(inst, props) {
      return _assign({}, DisabledInputUtils.getHostProps(inst, props), {
        onChange: inst._wrapperState.onChange,
        value: undefined
      });
    },
    mountWrapper: function(inst, props) {
      if ("production" !== 'production') {
        checkSelectPropTypes(inst, props);
      }
      var value = LinkedValueUtils.getValue(props);
      inst._wrapperState = {
        pendingUpdate: false,
        initialValue: value != null ? value : props.defaultValue,
        listeners: null,
        onChange: _handleChange.bind(inst),
        wasMultiple: Boolean(props.multiple)
      };
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
        "production" !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
        didWarnValueDefaultValue = true;
      }
    },
    getSelectValueContext: function(inst) {
      return inst._wrapperState.initialValue;
    },
    postUpdateWrapper: function(inst) {
      var props = inst._currentElement.props;
      inst._wrapperState.initialValue = undefined;
      var wasMultiple = inst._wrapperState.wasMultiple;
      inst._wrapperState.wasMultiple = Boolean(props.multiple);
      var value = LinkedValueUtils.getValue(props);
      if (value != null) {
        inst._wrapperState.pendingUpdate = false;
        updateOptions(inst, Boolean(props.multiple), value);
      } else if (wasMultiple !== Boolean(props.multiple)) {
        if (props.defaultValue != null) {
          updateOptions(inst, Boolean(props.multiple), props.defaultValue);
        } else {
          updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
        }
      }
    }
  };
  function _handleChange(event) {
    var props = this._currentElement.props;
    var returnValue = LinkedValueUtils.executeOnChange(props, event);
    if (this._rootNodeID) {
      this._wrapperState.pendingUpdate = true;
    }
    ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
    return returnValue;
  }
  module.exports = ReactDOMSelect;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/DisabledInputUtils.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var disableableMouseListenerNames = {
    onClick: true,
    onDoubleClick: true,
    onMouseDown: true,
    onMouseMove: true,
    onMouseUp: true,
    onClickCapture: true,
    onDoubleClickCapture: true,
    onMouseDownCapture: true,
    onMouseMoveCapture: true,
    onMouseUpCapture: true
  };
  var DisabledInputUtils = {getHostProps: function(inst, props) {
      if (!props.disabled) {
        return props;
      }
      var hostProps = {};
      for (var key in props) {
        if (!disableableMouseListenerNames[key] && props.hasOwnProperty(key)) {
          hostProps[key] = props[key];
        }
      }
      return hostProps;
    }};
  module.exports = DisabledInputUtils;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/LinkedValueUtils.js", ["./reactProdInvariant", "./ReactPropTypes", "./ReactPropTypeLocations", "fbjs/lib/invariant", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var ReactPropTypes = $__require('./ReactPropTypes');
  var ReactPropTypeLocations = $__require('./ReactPropTypeLocations');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');
  var hasReadOnlyValue = {
    'button': true,
    'checkbox': true,
    'image': true,
    'hidden': true,
    'radio': true,
    'reset': true,
    'submit': true
  };
  function _assertSingleLink(inputProps) {
    !(inputProps.checkedLink == null || inputProps.valueLink == null) ? "production" !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
  }
  function _assertValueLink(inputProps) {
    _assertSingleLink(inputProps);
    !(inputProps.value == null && inputProps.onChange == null) ? "production" !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
  }
  function _assertCheckedLink(inputProps) {
    _assertSingleLink(inputProps);
    !(inputProps.checked == null && inputProps.onChange == null) ? "production" !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
  }
  var propTypes = {
    value: function(props, propName, componentName) {
      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    checked: function(props, propName, componentName) {
      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    onChange: ReactPropTypes.func
  };
  var loggedTypeFailures = {};
  function getDeclarationErrorAddendum(owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  }
  var LinkedValueUtils = {
    checkPropTypes: function(tagName, props, owner) {
      for (var propName in propTypes) {
        if (propTypes.hasOwnProperty(propName)) {
          var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          loggedTypeFailures[error.message] = true;
          var addendum = getDeclarationErrorAddendum(owner);
          "production" !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
        }
      }
    },
    getValue: function(inputProps) {
      if (inputProps.valueLink) {
        _assertValueLink(inputProps);
        return inputProps.valueLink.value;
      }
      return inputProps.value;
    },
    getChecked: function(inputProps) {
      if (inputProps.checkedLink) {
        _assertCheckedLink(inputProps);
        return inputProps.checkedLink.value;
      }
      return inputProps.checked;
    },
    executeOnChange: function(inputProps, event) {
      if (inputProps.valueLink) {
        _assertValueLink(inputProps);
        return inputProps.valueLink.requestChange(event.target.value);
      } else if (inputProps.checkedLink) {
        _assertCheckedLink(inputProps);
        return inputProps.checkedLink.requestChange(event.target.checked);
      } else if (inputProps.onChange) {
        return inputProps.onChange.call(undefined, event);
      }
    }
  };
  module.exports = LinkedValueUtils;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMTextarea.js", ["./reactProdInvariant", "object-assign", "./DisabledInputUtils", "./LinkedValueUtils", "./ReactDOMComponentTree", "./ReactUpdates", "fbjs/lib/invariant", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');
  var DisabledInputUtils = $__require('./DisabledInputUtils');
  var LinkedValueUtils = $__require('./LinkedValueUtils');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactUpdates = $__require('./ReactUpdates');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');
  var didWarnValueLink = false;
  var didWarnValDefaultVal = false;
  function forceUpdateIfMounted() {
    if (this._rootNodeID) {
      ReactDOMTextarea.updateWrapper(this);
    }
  }
  var ReactDOMTextarea = {
    getHostProps: function(inst, props) {
      !(props.dangerouslySetInnerHTML == null) ? "production" !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
      var hostProps = _assign({}, DisabledInputUtils.getHostProps(inst, props), {
        value: undefined,
        defaultValue: undefined,
        children: '' + inst._wrapperState.initialValue,
        onChange: inst._wrapperState.onChange
      });
      return hostProps;
    },
    mountWrapper: function(inst, props) {
      if ("production" !== 'production') {
        LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
        if (props.valueLink !== undefined && !didWarnValueLink) {
          "production" !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
          didWarnValueLink = true;
        }
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
          "production" !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
          didWarnValDefaultVal = true;
        }
      }
      var value = LinkedValueUtils.getValue(props);
      var initialValue = value;
      if (value == null) {
        var defaultValue = props.defaultValue;
        var children = props.children;
        if (children != null) {
          if ("production" !== 'production') {
            "production" !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
          }
          !(defaultValue == null) ? "production" !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
          if (Array.isArray(children)) {
            !(children.length <= 1) ? "production" !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
            children = children[0];
          }
          defaultValue = '' + children;
        }
        if (defaultValue == null) {
          defaultValue = '';
        }
        initialValue = defaultValue;
      }
      inst._wrapperState = {
        initialValue: '' + initialValue,
        listeners: null,
        onChange: _handleChange.bind(inst)
      };
    },
    updateWrapper: function(inst) {
      var props = inst._currentElement.props;
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      var value = LinkedValueUtils.getValue(props);
      if (value != null) {
        var newValue = '' + value;
        if (newValue !== node.value) {
          node.value = newValue;
        }
        if (props.defaultValue == null) {
          node.defaultValue = newValue;
        }
      }
      if (props.defaultValue != null) {
        node.defaultValue = props.defaultValue;
      }
    },
    postMountWrapper: function(inst) {
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      node.value = node.textContent;
    }
  };
  function _handleChange(event) {
    var props = this._currentElement.props;
    var returnValue = LinkedValueUtils.executeOnChange(props, event);
    ReactUpdates.asap(forceUpdateIfMounted, this);
    return returnValue;
  }
  module.exports = ReactDOMTextarea;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactChildReconciler.js", ["./ReactReconciler", "./instantiateReactComponent", "./KeyEscapeUtils", "./shouldUpdateReactComponent", "./traverseAllChildren", "fbjs/lib/warning", "./ReactComponentTreeDevtool", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactReconciler = $__require('./ReactReconciler');
  var instantiateReactComponent = $__require('./instantiateReactComponent');
  var KeyEscapeUtils = $__require('./KeyEscapeUtils');
  var shouldUpdateReactComponent = $__require('./shouldUpdateReactComponent');
  var traverseAllChildren = $__require('./traverseAllChildren');
  var warning = $__require('fbjs/lib/warning');
  function instantiateChild(childInstances, child, name, selfDebugID) {
    var keyUnique = childInstances[name] === undefined;
    if ("production" !== 'production') {
      var ReactComponentTreeDevtool = $__require('./ReactComponentTreeDevtool');
      "production" !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeDevtool.getStackAddendumByID(selfDebugID)) : void 0;
    }
    if (child != null && keyUnique) {
      childInstances[name] = instantiateReactComponent(child, true);
    }
  }
  var ReactChildReconciler = {
    instantiateChildren: function(nestedChildNodes, transaction, context, selfDebugID) {
      if (nestedChildNodes == null) {
        return null;
      }
      var childInstances = {};
      if ("production" !== 'production') {
        traverseAllChildren(nestedChildNodes, function(childInsts, child, name) {
          return instantiateChild(childInsts, child, name, selfDebugID);
        }, childInstances);
      } else {
        traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
      }
      return childInstances;
    },
    updateChildren: function(prevChildren, nextChildren, removedNodes, transaction, context) {
      if (!nextChildren && !prevChildren) {
        return;
      }
      var name;
      var prevChild;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        prevChild = prevChildren && prevChildren[name];
        var prevElement = prevChild && prevChild._currentElement;
        var nextElement = nextChildren[name];
        if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
          ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
          nextChildren[name] = prevChild;
        } else {
          if (prevChild) {
            removedNodes[name] = ReactReconciler.getHostNode(prevChild);
            ReactReconciler.unmountComponent(prevChild, false);
          }
          var nextChildInstance = instantiateReactComponent(nextElement, true);
          nextChildren[name] = nextChildInstance;
        }
      }
      for (name in prevChildren) {
        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
          prevChild = prevChildren[name];
          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
          ReactReconciler.unmountComponent(prevChild, false);
        }
      }
    },
    unmountChildren: function(renderedChildren, safely) {
      for (var name in renderedChildren) {
        if (renderedChildren.hasOwnProperty(name)) {
          var renderedChild = renderedChildren[name];
          ReactReconciler.unmountComponent(renderedChild, safely);
        }
      }
    }
  };
  module.exports = ReactChildReconciler;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/flattenChildren.js", ["./KeyEscapeUtils", "./traverseAllChildren", "fbjs/lib/warning", "./ReactComponentTreeDevtool", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var KeyEscapeUtils = $__require('./KeyEscapeUtils');
  var traverseAllChildren = $__require('./traverseAllChildren');
  var warning = $__require('fbjs/lib/warning');
  function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
    if (traverseContext && typeof traverseContext === 'object') {
      var result = traverseContext;
      var keyUnique = result[name] === undefined;
      if ("production" !== 'production') {
        var ReactComponentTreeDevtool = $__require('./ReactComponentTreeDevtool');
        "production" !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeDevtool.getStackAddendumByID(selfDebugID)) : void 0;
      }
      if (keyUnique && child != null) {
        result[name] = child;
      }
    }
  }
  function flattenChildren(children, selfDebugID) {
    if (children == null) {
      return children;
    }
    var result = {};
    if ("production" !== 'production') {
      traverseAllChildren(children, function(traverseContext, child, name) {
        return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
      }, result);
    } else {
      traverseAllChildren(children, flattenSingleChildIntoContext, result);
    }
    return result;
  }
  module.exports = flattenChildren;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactMultiChild.js", ["./reactProdInvariant", "./ReactComponentEnvironment", "./ReactInstanceMap", "./ReactInstrumentation", "./ReactMultiChildUpdateTypes", "./ReactCurrentOwner", "./ReactReconciler", "./ReactChildReconciler", "fbjs/lib/emptyFunction", "./flattenChildren", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var ReactComponentEnvironment = $__require('./ReactComponentEnvironment');
  var ReactInstanceMap = $__require('./ReactInstanceMap');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var ReactMultiChildUpdateTypes = $__require('./ReactMultiChildUpdateTypes');
  var ReactCurrentOwner = $__require('./ReactCurrentOwner');
  var ReactReconciler = $__require('./ReactReconciler');
  var ReactChildReconciler = $__require('./ReactChildReconciler');
  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var flattenChildren = $__require('./flattenChildren');
  var invariant = $__require('fbjs/lib/invariant');
  function makeInsertMarkup(markup, afterNode, toIndex) {
    return {
      type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
      content: markup,
      fromIndex: null,
      fromNode: null,
      toIndex: toIndex,
      afterNode: afterNode
    };
  }
  function makeMove(child, afterNode, toIndex) {
    return {
      type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
      content: null,
      fromIndex: child._mountIndex,
      fromNode: ReactReconciler.getHostNode(child),
      toIndex: toIndex,
      afterNode: afterNode
    };
  }
  function makeRemove(child, node) {
    return {
      type: ReactMultiChildUpdateTypes.REMOVE_NODE,
      content: null,
      fromIndex: child._mountIndex,
      fromNode: node,
      toIndex: null,
      afterNode: null
    };
  }
  function makeSetMarkup(markup) {
    return {
      type: ReactMultiChildUpdateTypes.SET_MARKUP,
      content: markup,
      fromIndex: null,
      fromNode: null,
      toIndex: null,
      afterNode: null
    };
  }
  function makeTextContent(textContent) {
    return {
      type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
      content: textContent,
      fromIndex: null,
      fromNode: null,
      toIndex: null,
      afterNode: null
    };
  }
  function enqueue(queue, update) {
    if (update) {
      queue = queue || [];
      queue.push(update);
    }
    return queue;
  }
  function processQueue(inst, updateQueue) {
    ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
  }
  var setParentForInstrumentation = emptyFunction;
  var setChildrenForInstrumentation = emptyFunction;
  if ("production" !== 'production') {
    var getDebugID = function(inst) {
      if (!inst._debugID) {
        var internal;
        if (internal = ReactInstanceMap.get(inst)) {
          inst = internal;
        }
      }
      return inst._debugID;
    };
    setParentForInstrumentation = function(child) {
      if (child._debugID !== 0) {
        ReactInstrumentation.debugTool.onSetParent(child._debugID, getDebugID(this));
      }
    };
    setChildrenForInstrumentation = function(children) {
      var debugID = getDebugID(this);
      if (debugID !== 0) {
        ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function(key) {
          return children[key]._debugID;
        }) : []);
      }
    };
  }
  var ReactMultiChild = {Mixin: {
      _reconcilerInstantiateChildren: function(nestedChildren, transaction, context) {
        if ("production" !== 'production') {
          if (this._currentElement) {
            try {
              ReactCurrentOwner.current = this._currentElement._owner;
              return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, this._debugID);
            } finally {
              ReactCurrentOwner.current = null;
            }
          }
        }
        return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
      },
      _reconcilerUpdateChildren: function(prevChildren, nextNestedChildrenElements, removedNodes, transaction, context) {
        var nextChildren;
        if ("production" !== 'production') {
          if (this._currentElement) {
            try {
              ReactCurrentOwner.current = this._currentElement._owner;
              nextChildren = flattenChildren(nextNestedChildrenElements, this._debugID);
            } finally {
              ReactCurrentOwner.current = null;
            }
            ReactChildReconciler.updateChildren(prevChildren, nextChildren, removedNodes, transaction, context);
            return nextChildren;
          }
        }
        nextChildren = flattenChildren(nextNestedChildrenElements);
        ReactChildReconciler.updateChildren(prevChildren, nextChildren, removedNodes, transaction, context);
        return nextChildren;
      },
      mountChildren: function(nestedChildren, transaction, context) {
        var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
        this._renderedChildren = children;
        var mountImages = [];
        var index = 0;
        for (var name in children) {
          if (children.hasOwnProperty(name)) {
            var child = children[name];
            if ("production" !== 'production') {
              setParentForInstrumentation.call(this, child);
            }
            var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context);
            child._mountIndex = index++;
            mountImages.push(mountImage);
          }
        }
        if ("production" !== 'production') {
          setChildrenForInstrumentation.call(this, children);
        }
        return mountImages;
      },
      updateTextContent: function(nextContent) {
        var prevChildren = this._renderedChildren;
        ReactChildReconciler.unmountChildren(prevChildren, false);
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            !false ? "production" !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
          }
        }
        var updates = [makeTextContent(nextContent)];
        processQueue(this, updates);
      },
      updateMarkup: function(nextMarkup) {
        var prevChildren = this._renderedChildren;
        ReactChildReconciler.unmountChildren(prevChildren, false);
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            !false ? "production" !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
          }
        }
        var updates = [makeSetMarkup(nextMarkup)];
        processQueue(this, updates);
      },
      updateChildren: function(nextNestedChildrenElements, transaction, context) {
        this._updateChildren(nextNestedChildrenElements, transaction, context);
      },
      _updateChildren: function(nextNestedChildrenElements, transaction, context) {
        var prevChildren = this._renderedChildren;
        var removedNodes = {};
        var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, removedNodes, transaction, context);
        if (!nextChildren && !prevChildren) {
          return;
        }
        var updates = null;
        var name;
        var lastIndex = 0;
        var nextIndex = 0;
        var lastPlacedNode = null;
        for (name in nextChildren) {
          if (!nextChildren.hasOwnProperty(name)) {
            continue;
          }
          var prevChild = prevChildren && prevChildren[name];
          var nextChild = nextChildren[name];
          if (prevChild === nextChild) {
            updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            prevChild._mountIndex = nextIndex;
          } else {
            if (prevChild) {
              lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            }
            updates = enqueue(updates, this._mountChildAtIndex(nextChild, lastPlacedNode, nextIndex, transaction, context));
          }
          nextIndex++;
          lastPlacedNode = ReactReconciler.getHostNode(nextChild);
        }
        for (name in removedNodes) {
          if (removedNodes.hasOwnProperty(name)) {
            updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
          }
        }
        if (updates) {
          processQueue(this, updates);
        }
        this._renderedChildren = nextChildren;
        if ("production" !== 'production') {
          setChildrenForInstrumentation.call(this, nextChildren);
        }
      },
      unmountChildren: function(safely) {
        var renderedChildren = this._renderedChildren;
        ReactChildReconciler.unmountChildren(renderedChildren, safely);
        this._renderedChildren = null;
      },
      moveChild: function(child, afterNode, toIndex, lastIndex) {
        if (child._mountIndex < lastIndex) {
          return makeMove(child, afterNode, toIndex);
        }
      },
      createChild: function(child, afterNode, mountImage) {
        return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
      },
      removeChild: function(child, node) {
        return makeRemove(child, node);
      },
      _mountChildAtIndex: function(child, afterNode, index, transaction, context) {
        var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context);
        child._mountIndex = index;
        return this.createChild(child, afterNode, mountImage);
      },
      _unmountChild: function(child, node) {
        var update = this.removeChild(child, node);
        child._mountIndex = null;
        return update;
      }
    }};
  module.exports = ReactMultiChild;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactServerUpdateQueue.js", ["./ReactUpdateQueue", "./Transaction", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var ReactUpdateQueue = $__require('./ReactUpdateQueue');
  var Transaction = $__require('./Transaction');
  var warning = $__require('fbjs/lib/warning');
  function warnNoop(publicInstance, callerName) {
    if ("production" !== 'production') {
      var constructor = publicInstance.constructor;
      "production" !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
    }
  }
  var ReactServerUpdateQueue = function() {
    function ReactServerUpdateQueue(transaction) {
      _classCallCheck(this, ReactServerUpdateQueue);
      this.transaction = transaction;
    }
    ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
      return false;
    };
    ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
      if (this.transaction.isInTransaction()) {
        ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
      }
    };
    ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
      if (this.transaction.isInTransaction()) {
        ReactUpdateQueue.enqueueForceUpdate(publicInstance);
      } else {
        warnNoop(publicInstance, 'forceUpdate');
      }
    };
    ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
      if (this.transaction.isInTransaction()) {
        ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
      } else {
        warnNoop(publicInstance, 'replaceState');
      }
    };
    ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
      if (this.transaction.isInTransaction()) {
        ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
      } else {
        warnNoop(publicInstance, 'setState');
      }
    };
    return ReactServerUpdateQueue;
  }();
  module.exports = ReactServerUpdateQueue;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactServerRenderingTransaction.js", ["object-assign", "./PooledClass", "./Transaction", "./ReactInstrumentation", "./ReactServerUpdateQueue", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');
  var PooledClass = $__require('./PooledClass');
  var Transaction = $__require('./Transaction');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var ReactServerUpdateQueue = $__require('./ReactServerUpdateQueue');
  var TRANSACTION_WRAPPERS = [];
  if ("production" !== 'production') {
    TRANSACTION_WRAPPERS.push({
      initialize: ReactInstrumentation.debugTool.onBeginFlush,
      close: ReactInstrumentation.debugTool.onEndFlush
    });
  }
  var noopCallbackQueue = {enqueue: function() {}};
  function ReactServerRenderingTransaction(renderToStaticMarkup) {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = renderToStaticMarkup;
    this.useCreateElement = false;
    this.updateQueue = new ReactServerUpdateQueue(this);
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return noopCallbackQueue;
    },
    getUpdateQueue: function() {
      return this.updateQueue;
    },
    destructor: function() {},
    checkpoint: function() {},
    rollback: function() {}
  };
  _assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactServerRenderingTransaction);
  module.exports = ReactServerRenderingTransaction;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMComponent.js", ["./reactProdInvariant", "object-assign", "./AutoFocusUtils", "./CSSPropertyOperations", "./DOMLazyTree", "./DOMNamespaces", "./DOMProperty", "./DOMPropertyOperations", "./EventConstants", "./EventPluginHub", "./EventPluginRegistry", "./ReactBrowserEventEmitter", "./ReactComponentBrowserEnvironment", "./ReactDOMButton", "./ReactDOMComponentFlags", "./ReactDOMComponentTree", "./ReactDOMInput", "./ReactDOMOption", "./ReactDOMSelect", "./ReactDOMTextarea", "./ReactInstrumentation", "./ReactMultiChild", "./ReactServerRenderingTransaction", "fbjs/lib/emptyFunction", "./escapeTextContentForBrowser", "fbjs/lib/invariant", "./isEventSupported", "fbjs/lib/keyOf", "fbjs/lib/shallowEqual", "./validateDOMNesting", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');
  var AutoFocusUtils = $__require('./AutoFocusUtils');
  var CSSPropertyOperations = $__require('./CSSPropertyOperations');
  var DOMLazyTree = $__require('./DOMLazyTree');
  var DOMNamespaces = $__require('./DOMNamespaces');
  var DOMProperty = $__require('./DOMProperty');
  var DOMPropertyOperations = $__require('./DOMPropertyOperations');
  var EventConstants = $__require('./EventConstants');
  var EventPluginHub = $__require('./EventPluginHub');
  var EventPluginRegistry = $__require('./EventPluginRegistry');
  var ReactBrowserEventEmitter = $__require('./ReactBrowserEventEmitter');
  var ReactComponentBrowserEnvironment = $__require('./ReactComponentBrowserEnvironment');
  var ReactDOMButton = $__require('./ReactDOMButton');
  var ReactDOMComponentFlags = $__require('./ReactDOMComponentFlags');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactDOMInput = $__require('./ReactDOMInput');
  var ReactDOMOption = $__require('./ReactDOMOption');
  var ReactDOMSelect = $__require('./ReactDOMSelect');
  var ReactDOMTextarea = $__require('./ReactDOMTextarea');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var ReactMultiChild = $__require('./ReactMultiChild');
  var ReactServerRenderingTransaction = $__require('./ReactServerRenderingTransaction');
  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var escapeTextContentForBrowser = $__require('./escapeTextContentForBrowser');
  var invariant = $__require('fbjs/lib/invariant');
  var isEventSupported = $__require('./isEventSupported');
  var keyOf = $__require('fbjs/lib/keyOf');
  var shallowEqual = $__require('fbjs/lib/shallowEqual');
  var validateDOMNesting = $__require('./validateDOMNesting');
  var warning = $__require('fbjs/lib/warning');
  var Flags = ReactDOMComponentFlags;
  var deleteListener = EventPluginHub.deleteListener;
  var getNode = ReactDOMComponentTree.getNodeFromInstance;
  var listenTo = ReactBrowserEventEmitter.listenTo;
  var registrationNameModules = EventPluginRegistry.registrationNameModules;
  var CONTENT_TYPES = {
    'string': true,
    'number': true
  };
  var STYLE = keyOf({style: null});
  var HTML = keyOf({__html: null});
  var RESERVED_PROPS = {
    children: null,
    dangerouslySetInnerHTML: null,
    suppressContentEditableWarning: null
  };
  var DOC_FRAGMENT_TYPE = 11;
  function getDeclarationErrorAddendum(internalInstance) {
    if (internalInstance) {
      var owner = internalInstance._currentElement._owner || null;
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' This DOM node was rendered by `' + name + '`.';
        }
      }
    }
    return '';
  }
  function friendlyStringify(obj) {
    if (typeof obj === 'object') {
      if (Array.isArray(obj)) {
        return '[' + obj.map(friendlyStringify).join(', ') + ']';
      } else {
        var pairs = [];
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
            pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
          }
        }
        return '{' + pairs.join(', ') + '}';
      }
    } else if (typeof obj === 'string') {
      return JSON.stringify(obj);
    } else if (typeof obj === 'function') {
      return '[function object]';
    }
    return String(obj);
  }
  var styleMutationWarning = {};
  function checkAndWarnForMutatedStyle(style1, style2, component) {
    if (style1 == null || style2 == null) {
      return;
    }
    if (shallowEqual(style1, style2)) {
      return;
    }
    var componentName = component._tag;
    var owner = component._currentElement._owner;
    var ownerName;
    if (owner) {
      ownerName = owner.getName();
    }
    var hash = ownerName + '|' + componentName;
    if (styleMutationWarning.hasOwnProperty(hash)) {
      return;
    }
    styleMutationWarning[hash] = true;
    "production" !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
  }
  function assertValidProps(component, props) {
    if (!props) {
      return;
    }
    if (voidElementTags[component._tag]) {
      !(props.children == null && props.dangerouslySetInnerHTML == null) ? "production" !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
    }
    if (props.dangerouslySetInnerHTML != null) {
      !(props.children == null) ? "production" !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
      !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? "production" !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
    }
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
      "production" !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
      "production" !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
    }
    !(props.style == null || typeof props.style === 'object') ? "production" !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
  }
  function enqueuePutListener(inst, registrationName, listener, transaction) {
    if (transaction instanceof ReactServerRenderingTransaction) {
      return;
    }
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
    }
    var containerInfo = inst._hostContainerInfo;
    var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
    var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
    listenTo(registrationName, doc);
    transaction.getReactMountReady().enqueue(putListener, {
      inst: inst,
      registrationName: registrationName,
      listener: listener
    });
  }
  function putListener() {
    var listenerToPut = this;
    EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
  }
  function inputPostMount() {
    var inst = this;
    ReactDOMInput.postMountWrapper(inst);
  }
  function textareaPostMount() {
    var inst = this;
    ReactDOMTextarea.postMountWrapper(inst);
  }
  function optionPostMount() {
    var inst = this;
    ReactDOMOption.postMountWrapper(inst);
  }
  var setContentChildForInstrumentation = emptyFunction;
  if ("production" !== 'production') {
    setContentChildForInstrumentation = function(content) {
      var hasExistingContent = this._contentDebugID != null;
      var debugID = this._debugID;
      var contentDebugID = debugID + '#text';
      if (content == null) {
        if (hasExistingContent) {
          ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
        }
        this._contentDebugID = null;
        return;
      }
      this._contentDebugID = contentDebugID;
      var text = '' + content;
      ReactInstrumentation.debugTool.onSetDisplayName(contentDebugID, '#text');
      ReactInstrumentation.debugTool.onSetParent(contentDebugID, debugID);
      ReactInstrumentation.debugTool.onSetText(contentDebugID, text);
      if (hasExistingContent) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
        ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
      } else {
        ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content);
        ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
        ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
      }
    };
  }
  var mediaEvents = {
    topAbort: 'abort',
    topCanPlay: 'canplay',
    topCanPlayThrough: 'canplaythrough',
    topDurationChange: 'durationchange',
    topEmptied: 'emptied',
    topEncrypted: 'encrypted',
    topEnded: 'ended',
    topError: 'error',
    topLoadedData: 'loadeddata',
    topLoadedMetadata: 'loadedmetadata',
    topLoadStart: 'loadstart',
    topPause: 'pause',
    topPlay: 'play',
    topPlaying: 'playing',
    topProgress: 'progress',
    topRateChange: 'ratechange',
    topSeeked: 'seeked',
    topSeeking: 'seeking',
    topStalled: 'stalled',
    topSuspend: 'suspend',
    topTimeUpdate: 'timeupdate',
    topVolumeChange: 'volumechange',
    topWaiting: 'waiting'
  };
  function trapBubbledEventsLocal() {
    var inst = this;
    !inst._rootNodeID ? "production" !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
    var node = getNode(inst);
    !node ? "production" !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
    switch (inst._tag) {
      case 'iframe':
      case 'object':
        inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
        break;
      case 'video':
      case 'audio':
        inst._wrapperState.listeners = [];
        for (var event in mediaEvents) {
          if (mediaEvents.hasOwnProperty(event)) {
            inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
          }
        }
        break;
      case 'source':
        inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node)];
        break;
      case 'img':
        inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
        break;
      case 'form':
        inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
        break;
      case 'input':
      case 'select':
      case 'textarea':
        inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topInvalid, 'invalid', node)];
        break;
    }
  }
  function postUpdateSelectWrapper() {
    ReactDOMSelect.postUpdateWrapper(this);
  }
  var omittedCloseTags = {
    'area': true,
    'base': true,
    'br': true,
    'col': true,
    'embed': true,
    'hr': true,
    'img': true,
    'input': true,
    'keygen': true,
    'link': true,
    'meta': true,
    'param': true,
    'source': true,
    'track': true,
    'wbr': true
  };
  var newlineEatingTags = {
    'listing': true,
    'pre': true,
    'textarea': true
  };
  var voidElementTags = _assign({'menuitem': true}, omittedCloseTags);
  var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
  var validatedTagCache = {};
  var hasOwnProperty = {}.hasOwnProperty;
  function validateDangerousTag(tag) {
    if (!hasOwnProperty.call(validatedTagCache, tag)) {
      !VALID_TAG_REGEX.test(tag) ? "production" !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
      validatedTagCache[tag] = true;
    }
  }
  function isCustomComponent(tagName, props) {
    return tagName.indexOf('-') >= 0 || props.is != null;
  }
  var globalIdCounter = 1;
  function ReactDOMComponent(element) {
    var tag = element.type;
    validateDangerousTag(tag);
    this._currentElement = element;
    this._tag = tag.toLowerCase();
    this._namespaceURI = null;
    this._renderedChildren = null;
    this._previousStyle = null;
    this._previousStyleCopy = null;
    this._hostNode = null;
    this._hostParent = null;
    this._rootNodeID = null;
    this._domID = null;
    this._hostContainerInfo = null;
    this._wrapperState = null;
    this._topLevelWrapper = null;
    this._flags = 0;
    if ("production" !== 'production') {
      this._ancestorInfo = null;
      setContentChildForInstrumentation.call(this, null);
    }
  }
  ReactDOMComponent.displayName = 'ReactDOMComponent';
  ReactDOMComponent.Mixin = {
    mountComponent: function(transaction, hostParent, hostContainerInfo, context) {
      this._rootNodeID = globalIdCounter++;
      this._domID = hostContainerInfo._idCounter++;
      this._hostParent = hostParent;
      this._hostContainerInfo = hostContainerInfo;
      var props = this._currentElement.props;
      switch (this._tag) {
        case 'audio':
        case 'form':
        case 'iframe':
        case 'img':
        case 'link':
        case 'object':
        case 'source':
        case 'video':
          this._wrapperState = {listeners: null};
          transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
          break;
        case 'button':
          props = ReactDOMButton.getHostProps(this, props, hostParent);
          break;
        case 'input':
          ReactDOMInput.mountWrapper(this, props, hostParent);
          props = ReactDOMInput.getHostProps(this, props);
          transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
          break;
        case 'option':
          ReactDOMOption.mountWrapper(this, props, hostParent);
          props = ReactDOMOption.getHostProps(this, props);
          break;
        case 'select':
          ReactDOMSelect.mountWrapper(this, props, hostParent);
          props = ReactDOMSelect.getHostProps(this, props);
          transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
          break;
        case 'textarea':
          ReactDOMTextarea.mountWrapper(this, props, hostParent);
          props = ReactDOMTextarea.getHostProps(this, props);
          transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
          break;
      }
      assertValidProps(this, props);
      var namespaceURI;
      var parentTag;
      if (hostParent != null) {
        namespaceURI = hostParent._namespaceURI;
        parentTag = hostParent._tag;
      } else if (hostContainerInfo._tag) {
        namespaceURI = hostContainerInfo._namespaceURI;
        parentTag = hostContainerInfo._tag;
      }
      if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
        namespaceURI = DOMNamespaces.html;
      }
      if (namespaceURI === DOMNamespaces.html) {
        if (this._tag === 'svg') {
          namespaceURI = DOMNamespaces.svg;
        } else if (this._tag === 'math') {
          namespaceURI = DOMNamespaces.mathml;
        }
      }
      this._namespaceURI = namespaceURI;
      if ("production" !== 'production') {
        var parentInfo;
        if (hostParent != null) {
          parentInfo = hostParent._ancestorInfo;
        } else if (hostContainerInfo._tag) {
          parentInfo = hostContainerInfo._ancestorInfo;
        }
        if (parentInfo) {
          validateDOMNesting(this._tag, this, parentInfo);
        }
        this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
      }
      var mountImage;
      if (transaction.useCreateElement) {
        var ownerDocument = hostContainerInfo._ownerDocument;
        var el;
        if (namespaceURI === DOMNamespaces.html) {
          if (this._tag === 'script') {
            var div = ownerDocument.createElement('div');
            var type = this._currentElement.type;
            div.innerHTML = '<' + type + '></' + type + '>';
            el = div.removeChild(div.firstChild);
          } else if (props.is) {
            el = ownerDocument.createElement(this._currentElement.type, props.is);
          } else {
            el = ownerDocument.createElement(this._currentElement.type);
          }
        } else {
          el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
        }
        ReactDOMComponentTree.precacheNode(this, el);
        this._flags |= Flags.hasCachedChildNodes;
        if (!this._hostParent) {
          DOMPropertyOperations.setAttributeForRoot(el);
        }
        this._updateDOMProperties(null, props, transaction);
        var lazyTree = DOMLazyTree(el);
        this._createInitialChildren(transaction, props, context, lazyTree);
        mountImage = lazyTree;
      } else {
        var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
        var tagContent = this._createContentMarkup(transaction, props, context);
        if (!tagContent && omittedCloseTags[this._tag]) {
          mountImage = tagOpen + '/>';
        } else {
          mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
        }
      }
      switch (this._tag) {
        case 'input':
          transaction.getReactMountReady().enqueue(inputPostMount, this);
          if (props.autoFocus) {
            transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
          }
          break;
        case 'textarea':
          transaction.getReactMountReady().enqueue(textareaPostMount, this);
          if (props.autoFocus) {
            transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
          }
          break;
        case 'select':
          if (props.autoFocus) {
            transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
          }
          break;
        case 'button':
          if (props.autoFocus) {
            transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
          }
          break;
        case 'option':
          transaction.getReactMountReady().enqueue(optionPostMount, this);
          break;
      }
      return mountImage;
    },
    _createOpenTagMarkupAndPutListeners: function(transaction, props) {
      var ret = '<' + this._currentElement.type;
      for (var propKey in props) {
        if (!props.hasOwnProperty(propKey)) {
          continue;
        }
        var propValue = props[propKey];
        if (propValue == null) {
          continue;
        }
        if (registrationNameModules.hasOwnProperty(propKey)) {
          if (propValue) {
            enqueuePutListener(this, propKey, propValue, transaction);
          }
        } else {
          if (propKey === STYLE) {
            if (propValue) {
              if ("production" !== 'production') {
                this._previousStyle = propValue;
              }
              propValue = this._previousStyleCopy = _assign({}, props.style);
            }
            propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
          }
          var markup = null;
          if (this._tag != null && isCustomComponent(this._tag, props)) {
            if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
              markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
            }
          } else {
            markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
          }
          if (markup) {
            ret += ' ' + markup;
          }
        }
      }
      if (transaction.renderToStaticMarkup) {
        return ret;
      }
      if (!this._hostParent) {
        ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
      }
      ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
      return ret;
    },
    _createContentMarkup: function(transaction, props, context) {
      var ret = '';
      var innerHTML = props.dangerouslySetInnerHTML;
      if (innerHTML != null) {
        if (innerHTML.__html != null) {
          ret = innerHTML.__html;
        }
      } else {
        var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
        var childrenToUse = contentToUse != null ? null : props.children;
        if (contentToUse != null) {
          ret = escapeTextContentForBrowser(contentToUse);
          if ("production" !== 'production') {
            setContentChildForInstrumentation.call(this, contentToUse);
          }
        } else if (childrenToUse != null) {
          var mountImages = this.mountChildren(childrenToUse, transaction, context);
          ret = mountImages.join('');
        }
      }
      if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
        return '\n' + ret;
      } else {
        return ret;
      }
    },
    _createInitialChildren: function(transaction, props, context, lazyTree) {
      var innerHTML = props.dangerouslySetInnerHTML;
      if (innerHTML != null) {
        if (innerHTML.__html != null) {
          DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
        }
      } else {
        var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
        var childrenToUse = contentToUse != null ? null : props.children;
        if (contentToUse != null) {
          if ("production" !== 'production') {
            setContentChildForInstrumentation.call(this, contentToUse);
          }
          DOMLazyTree.queueText(lazyTree, contentToUse);
        } else if (childrenToUse != null) {
          var mountImages = this.mountChildren(childrenToUse, transaction, context);
          for (var i = 0; i < mountImages.length; i++) {
            DOMLazyTree.queueChild(lazyTree, mountImages[i]);
          }
        }
      }
    },
    receiveComponent: function(nextElement, transaction, context) {
      var prevElement = this._currentElement;
      this._currentElement = nextElement;
      this.updateComponent(transaction, prevElement, nextElement, context);
    },
    updateComponent: function(transaction, prevElement, nextElement, context) {
      var lastProps = prevElement.props;
      var nextProps = this._currentElement.props;
      switch (this._tag) {
        case 'button':
          lastProps = ReactDOMButton.getHostProps(this, lastProps);
          nextProps = ReactDOMButton.getHostProps(this, nextProps);
          break;
        case 'input':
          ReactDOMInput.updateWrapper(this);
          lastProps = ReactDOMInput.getHostProps(this, lastProps);
          nextProps = ReactDOMInput.getHostProps(this, nextProps);
          break;
        case 'option':
          lastProps = ReactDOMOption.getHostProps(this, lastProps);
          nextProps = ReactDOMOption.getHostProps(this, nextProps);
          break;
        case 'select':
          lastProps = ReactDOMSelect.getHostProps(this, lastProps);
          nextProps = ReactDOMSelect.getHostProps(this, nextProps);
          break;
        case 'textarea':
          ReactDOMTextarea.updateWrapper(this);
          lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
          nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
          break;
      }
      assertValidProps(this, nextProps);
      this._updateDOMProperties(lastProps, nextProps, transaction);
      this._updateDOMChildren(lastProps, nextProps, transaction, context);
      if (this._tag === 'select') {
        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
      }
    },
    _updateDOMProperties: function(lastProps, nextProps, transaction) {
      var propKey;
      var styleName;
      var styleUpdates;
      for (propKey in lastProps) {
        if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
          continue;
        }
        if (propKey === STYLE) {
          var lastStyle = this._previousStyleCopy;
          for (styleName in lastStyle) {
            if (lastStyle.hasOwnProperty(styleName)) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          this._previousStyleCopy = null;
        } else if (registrationNameModules.hasOwnProperty(propKey)) {
          if (lastProps[propKey]) {
            deleteListener(this, propKey);
          }
        } else if (isCustomComponent(this._tag, lastProps)) {
          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
            DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
          }
        } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
          DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
        }
      }
      for (propKey in nextProps) {
        var nextProp = nextProps[propKey];
        var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
        if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
          continue;
        }
        if (propKey === STYLE) {
          if (nextProp) {
            if ("production" !== 'production') {
              checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
              this._previousStyle = nextProp;
            }
            nextProp = this._previousStyleCopy = _assign({}, nextProp);
          } else {
            this._previousStyleCopy = null;
          }
          if (lastProp) {
            for (styleName in lastProp) {
              if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = '';
              }
            }
            for (styleName in nextProp) {
              if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = nextProp[styleName];
              }
            }
          } else {
            styleUpdates = nextProp;
          }
        } else if (registrationNameModules.hasOwnProperty(propKey)) {
          if (nextProp) {
            enqueuePutListener(this, propKey, nextProp, transaction);
          } else if (lastProp) {
            deleteListener(this, propKey);
          }
        } else if (isCustomComponent(this._tag, nextProps)) {
          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
            DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
          }
        } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
          var node = getNode(this);
          if (nextProp != null) {
            DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
          } else {
            DOMPropertyOperations.deleteValueForProperty(node, propKey);
          }
        }
      }
      if (styleUpdates) {
        CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
      }
    },
    _updateDOMChildren: function(lastProps, nextProps, transaction, context) {
      var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
      var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
      var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
      var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
      var lastChildren = lastContent != null ? null : lastProps.children;
      var nextChildren = nextContent != null ? null : nextProps.children;
      var lastHasContentOrHtml = lastContent != null || lastHtml != null;
      var nextHasContentOrHtml = nextContent != null || nextHtml != null;
      if (lastChildren != null && nextChildren == null) {
        this.updateChildren(null, transaction, context);
      } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
        this.updateTextContent('');
        if ("production" !== 'production') {
          ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
        }
      }
      if (nextContent != null) {
        if (lastContent !== nextContent) {
          this.updateTextContent('' + nextContent);
          if ("production" !== 'production') {
            setContentChildForInstrumentation.call(this, nextContent);
          }
        }
      } else if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          this.updateMarkup('' + nextHtml);
        }
        if ("production" !== 'production') {
          ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
        }
      } else if (nextChildren != null) {
        if ("production" !== 'production') {
          setContentChildForInstrumentation.call(this, null);
        }
        this.updateChildren(nextChildren, transaction, context);
      }
    },
    getHostNode: function() {
      return getNode(this);
    },
    unmountComponent: function(safely) {
      switch (this._tag) {
        case 'audio':
        case 'form':
        case 'iframe':
        case 'img':
        case 'link':
        case 'object':
        case 'source':
        case 'video':
          var listeners = this._wrapperState.listeners;
          if (listeners) {
            for (var i = 0; i < listeners.length; i++) {
              listeners[i].remove();
            }
          }
          break;
        case 'html':
        case 'head':
        case 'body':
          !false ? "production" !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
          break;
      }
      this.unmountChildren(safely);
      ReactDOMComponentTree.uncacheNode(this);
      EventPluginHub.deleteAllListeners(this);
      ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
      this._rootNodeID = null;
      this._domID = null;
      this._wrapperState = null;
      if ("production" !== 'production') {
        setContentChildForInstrumentation.call(this, null);
      }
    },
    getPublicInstance: function() {
      return getNode(this);
    }
  };
  _assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
  module.exports = ReactDOMComponent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMEmptyComponent.js", ["object-assign", "./DOMLazyTree", "./ReactDOMComponentTree", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');
  var DOMLazyTree = $__require('./DOMLazyTree');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactDOMEmptyComponent = function(instantiate) {
    this._currentElement = null;
    this._hostNode = null;
    this._hostParent = null;
    this._hostContainerInfo = null;
    this._domID = null;
  };
  _assign(ReactDOMEmptyComponent.prototype, {
    mountComponent: function(transaction, hostParent, hostContainerInfo, context) {
      var domID = hostContainerInfo._idCounter++;
      this._domID = domID;
      this._hostParent = hostParent;
      this._hostContainerInfo = hostContainerInfo;
      var nodeValue = ' react-empty: ' + this._domID + ' ';
      if (transaction.useCreateElement) {
        var ownerDocument = hostContainerInfo._ownerDocument;
        var node = ownerDocument.createComment(nodeValue);
        ReactDOMComponentTree.precacheNode(this, node);
        return DOMLazyTree(node);
      } else {
        if (transaction.renderToStaticMarkup) {
          return '';
        }
        return '<!--' + nodeValue + '-->';
      }
    },
    receiveComponent: function() {},
    getHostNode: function() {
      return ReactDOMComponentTree.getNodeFromInstance(this);
    },
    unmountComponent: function() {
      ReactDOMComponentTree.uncacheNode(this);
    }
  });
  module.exports = ReactDOMEmptyComponent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMTreeTraversal.js", ["./reactProdInvariant", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var invariant = $__require('fbjs/lib/invariant');
  function getLowestCommonAncestor(instA, instB) {
    !('_hostNode' in instA) ? "production" !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
    !('_hostNode' in instB) ? "production" !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
    var depthA = 0;
    for (var tempA = instA; tempA; tempA = tempA._hostParent) {
      depthA++;
    }
    var depthB = 0;
    for (var tempB = instB; tempB; tempB = tempB._hostParent) {
      depthB++;
    }
    while (depthA - depthB > 0) {
      instA = instA._hostParent;
      depthA--;
    }
    while (depthB - depthA > 0) {
      instB = instB._hostParent;
      depthB--;
    }
    var depth = depthA;
    while (depth--) {
      if (instA === instB) {
        return instA;
      }
      instA = instA._hostParent;
      instB = instB._hostParent;
    }
    return null;
  }
  function isAncestor(instA, instB) {
    !('_hostNode' in instA) ? "production" !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
    !('_hostNode' in instB) ? "production" !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
    while (instB) {
      if (instB === instA) {
        return true;
      }
      instB = instB._hostParent;
    }
    return false;
  }
  function getParentInstance(inst) {
    !('_hostNode' in inst) ? "production" !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
    return inst._hostParent;
  }
  function traverseTwoPhase(inst, fn, arg) {
    var path = [];
    while (inst) {
      path.push(inst);
      inst = inst._hostParent;
    }
    var i;
    for (i = path.length; i-- > 0; ) {
      fn(path[i], false, arg);
    }
    for (i = 0; i < path.length; i++) {
      fn(path[i], true, arg);
    }
  }
  function traverseEnterLeave(from, to, fn, argFrom, argTo) {
    var common = from && to ? getLowestCommonAncestor(from, to) : null;
    var pathFrom = [];
    while (from && from !== common) {
      pathFrom.push(from);
      from = from._hostParent;
    }
    var pathTo = [];
    while (to && to !== common) {
      pathTo.push(to);
      to = to._hostParent;
    }
    var i;
    for (i = 0; i < pathFrom.length; i++) {
      fn(pathFrom[i], true, argFrom);
    }
    for (i = pathTo.length; i-- > 0; ) {
      fn(pathTo[i], false, argTo);
    }
  }
  module.exports = {
    isAncestor: isAncestor,
    getLowestCommonAncestor: getLowestCommonAncestor,
    getParentInstance: getParentInstance,
    traverseTwoPhase: traverseTwoPhase,
    traverseEnterLeave: traverseEnterLeave
  };
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/createArrayFromMixed.js", ["./invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var invariant = $__require('./invariant');
  function toArray(obj) {
    var length = obj.length;
    !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? "production" !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
    !(typeof length === 'number') ? "production" !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
    !(length === 0 || length - 1 in obj) ? "production" !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
    !(typeof obj.callee !== 'function') ? "production" !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
    if (obj.hasOwnProperty) {
      try {
        return Array.prototype.slice.call(obj);
      } catch (e) {}
    }
    var ret = Array(length);
    for (var ii = 0; ii < length; ii++) {
      ret[ii] = obj[ii];
    }
    return ret;
  }
  function hasArrayNature(obj) {
    return (!!obj && (typeof obj == 'object' || typeof obj == 'function') && 'length' in obj && !('setInterval' in obj) && typeof obj.nodeType != 'number' && (Array.isArray(obj) || 'callee' in obj || 'item' in obj));
  }
  function createArrayFromMixed(obj) {
    if (!hasArrayNature(obj)) {
      return [obj];
    } else if (Array.isArray(obj)) {
      return obj.slice();
    } else {
      return toArray(obj);
    }
  }
  module.exports = createArrayFromMixed;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/getMarkupWrap.js", ["./ExecutionEnvironment", "./invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('./ExecutionEnvironment');
  var invariant = $__require('./invariant');
  var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
  var shouldWrap = {};
  var selectWrap = [1, '<select multiple="true">', '</select>'];
  var tableWrap = [1, '<table>', '</table>'];
  var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
  var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
  var markupWrap = {
    '*': [1, '?<div>', '</div>'],
    'area': [1, '<map>', '</map>'],
    'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
    'legend': [1, '<fieldset>', '</fieldset>'],
    'param': [1, '<object>', '</object>'],
    'tr': [2, '<table><tbody>', '</tbody></table>'],
    'optgroup': selectWrap,
    'option': selectWrap,
    'caption': tableWrap,
    'colgroup': tableWrap,
    'tbody': tableWrap,
    'tfoot': tableWrap,
    'thead': tableWrap,
    'td': trWrap,
    'th': trWrap
  };
  var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
  svgElements.forEach(function(nodeName) {
    markupWrap[nodeName] = svgWrap;
    shouldWrap[nodeName] = true;
  });
  function getMarkupWrap(nodeName) {
    !!!dummyNode ? "production" !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
    if (!markupWrap.hasOwnProperty(nodeName)) {
      nodeName = '*';
    }
    if (!shouldWrap.hasOwnProperty(nodeName)) {
      if (nodeName === '*') {
        dummyNode.innerHTML = '<link />';
      } else {
        dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
      }
      shouldWrap[nodeName] = !dummyNode.firstChild;
    }
    return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
  }
  module.exports = getMarkupWrap;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/createNodesFromMarkup.js", ["./ExecutionEnvironment", "./createArrayFromMixed", "./getMarkupWrap", "./invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('./ExecutionEnvironment');
  var createArrayFromMixed = $__require('./createArrayFromMixed');
  var getMarkupWrap = $__require('./getMarkupWrap');
  var invariant = $__require('./invariant');
  var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
  var nodeNamePattern = /^\s*<(\w+)/;
  function getNodeName(markup) {
    var nodeNameMatch = markup.match(nodeNamePattern);
    return nodeNameMatch && nodeNameMatch[1].toLowerCase();
  }
  function createNodesFromMarkup(markup, handleScript) {
    var node = dummyNode;
    !!!dummyNode ? "production" !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
    var nodeName = getNodeName(markup);
    var wrap = nodeName && getMarkupWrap(nodeName);
    if (wrap) {
      node.innerHTML = wrap[1] + markup + wrap[2];
      var wrapDepth = wrap[0];
      while (wrapDepth--) {
        node = node.lastChild;
      }
    } else {
      node.innerHTML = markup;
    }
    var scripts = node.getElementsByTagName('script');
    if (scripts.length) {
      !handleScript ? "production" !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
      createArrayFromMixed(scripts).forEach(handleScript);
    }
    var nodes = Array.from(node.childNodes);
    while (node.lastChild) {
      node.removeChild(node.lastChild);
    }
    return nodes;
  }
  module.exports = createNodesFromMarkup;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/Danger.js", ["./reactProdInvariant", "./DOMLazyTree", "fbjs/lib/ExecutionEnvironment", "fbjs/lib/createNodesFromMarkup", "fbjs/lib/emptyFunction", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var DOMLazyTree = $__require('./DOMLazyTree');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var createNodesFromMarkup = $__require('fbjs/lib/createNodesFromMarkup');
  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var invariant = $__require('fbjs/lib/invariant');
  var Danger = {dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
      !ExecutionEnvironment.canUseDOM ? "production" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
      !markup ? "production" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
      !(oldChild.nodeName !== 'HTML') ? "production" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
      if (typeof markup === 'string') {
        var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
        oldChild.parentNode.replaceChild(newChild, oldChild);
      } else {
        DOMLazyTree.replaceChildWithTree(oldChild, markup);
      }
    }};
  module.exports = Danger;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactMultiChildUpdateTypes.js", ["fbjs/lib/keyMirror", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var keyMirror = $__require('fbjs/lib/keyMirror');
  var ReactMultiChildUpdateTypes = keyMirror({
    INSERT_MARKUP: null,
    MOVE_EXISTING: null,
    REMOVE_NODE: null,
    SET_MARKUP: null,
    TEXT_CONTENT: null
  });
  module.exports = ReactMultiChildUpdateTypes;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/DOMChildrenOperations.js", ["./DOMLazyTree", "./Danger", "./ReactMultiChildUpdateTypes", "./ReactDOMComponentTree", "./ReactInstrumentation", "./createMicrosoftUnsafeLocalFunction", "./setInnerHTML", "./setTextContent", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMLazyTree = $__require('./DOMLazyTree');
  var Danger = $__require('./Danger');
  var ReactMultiChildUpdateTypes = $__require('./ReactMultiChildUpdateTypes');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var createMicrosoftUnsafeLocalFunction = $__require('./createMicrosoftUnsafeLocalFunction');
  var setInnerHTML = $__require('./setInnerHTML');
  var setTextContent = $__require('./setTextContent');
  function getNodeAfter(parentNode, node) {
    if (Array.isArray(node)) {
      node = node[1];
    }
    return node ? node.nextSibling : parentNode.firstChild;
  }
  var insertChildAt = createMicrosoftUnsafeLocalFunction(function(parentNode, childNode, referenceNode) {
    parentNode.insertBefore(childNode, referenceNode);
  });
  function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
    DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
  }
  function moveChild(parentNode, childNode, referenceNode) {
    if (Array.isArray(childNode)) {
      moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
    } else {
      insertChildAt(parentNode, childNode, referenceNode);
    }
  }
  function removeChild(parentNode, childNode) {
    if (Array.isArray(childNode)) {
      var closingComment = childNode[1];
      childNode = childNode[0];
      removeDelimitedText(parentNode, childNode, closingComment);
      parentNode.removeChild(closingComment);
    }
    parentNode.removeChild(childNode);
  }
  function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
    var node = openingComment;
    while (true) {
      var nextNode = node.nextSibling;
      insertChildAt(parentNode, node, referenceNode);
      if (node === closingComment) {
        break;
      }
      node = nextNode;
    }
  }
  function removeDelimitedText(parentNode, startNode, closingComment) {
    while (true) {
      var node = startNode.nextSibling;
      if (node === closingComment) {
        break;
      } else {
        parentNode.removeChild(node);
      }
    }
  }
  function replaceDelimitedText(openingComment, closingComment, stringText) {
    var parentNode = openingComment.parentNode;
    var nodeAfterComment = openingComment.nextSibling;
    if (nodeAfterComment === closingComment) {
      if (stringText) {
        insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
      }
    } else {
      if (stringText) {
        setTextContent(nodeAfterComment, stringText);
        removeDelimitedText(parentNode, nodeAfterComment, closingComment);
      } else {
        removeDelimitedText(parentNode, openingComment, closingComment);
      }
    }
    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID, 'replace text', stringText);
    }
  }
  var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
  if ("production" !== 'production') {
    dangerouslyReplaceNodeWithMarkup = function(oldChild, markup, prevInstance) {
      Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
      if (prevInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation(prevInstance._debugID, 'replace with', markup.toString());
      } else {
        var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
        if (nextInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onHostOperation(nextInstance._debugID, 'mount', markup.toString());
        }
      }
    };
  }
  var DOMChildrenOperations = {
    dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
    replaceDelimitedText: replaceDelimitedText,
    processUpdates: function(parentNode, updates) {
      if ("production" !== 'production') {
        var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
      }
      for (var k = 0; k < updates.length; k++) {
        var update = updates[k];
        switch (update.type) {
          case ReactMultiChildUpdateTypes.INSERT_MARKUP:
            insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
            if ("production" !== 'production') {
              ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'insert child', {
                toIndex: update.toIndex,
                content: update.content.toString()
              });
            }
            break;
          case ReactMultiChildUpdateTypes.MOVE_EXISTING:
            moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
            if ("production" !== 'production') {
              ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'move child', {
                fromIndex: update.fromIndex,
                toIndex: update.toIndex
              });
            }
            break;
          case ReactMultiChildUpdateTypes.SET_MARKUP:
            setInnerHTML(parentNode, update.content);
            if ("production" !== 'production') {
              ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace children', update.content.toString());
            }
            break;
          case ReactMultiChildUpdateTypes.TEXT_CONTENT:
            setTextContent(parentNode, update.content);
            if ("production" !== 'production') {
              ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace text', update.content.toString());
            }
            break;
          case ReactMultiChildUpdateTypes.REMOVE_NODE:
            removeChild(parentNode, update.fromNode);
            if ("production" !== 'production') {
              ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'remove child', {fromIndex: update.fromIndex});
            }
            break;
        }
      }
    }
  };
  module.exports = DOMChildrenOperations;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMTextComponent.js", ["./reactProdInvariant", "object-assign", "./DOMChildrenOperations", "./DOMLazyTree", "./ReactDOMComponentTree", "./ReactInstrumentation", "./escapeTextContentForBrowser", "fbjs/lib/invariant", "./validateDOMNesting", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');
  var DOMChildrenOperations = $__require('./DOMChildrenOperations');
  var DOMLazyTree = $__require('./DOMLazyTree');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var escapeTextContentForBrowser = $__require('./escapeTextContentForBrowser');
  var invariant = $__require('fbjs/lib/invariant');
  var validateDOMNesting = $__require('./validateDOMNesting');
  var ReactDOMTextComponent = function(text) {
    this._currentElement = text;
    this._stringText = '' + text;
    this._hostNode = null;
    this._hostParent = null;
    this._domID = null;
    this._mountIndex = 0;
    this._closingComment = null;
    this._commentNodes = null;
  };
  _assign(ReactDOMTextComponent.prototype, {
    mountComponent: function(transaction, hostParent, hostContainerInfo, context) {
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onSetText(this._debugID, this._stringText);
        var parentInfo;
        if (hostParent != null) {
          parentInfo = hostParent._ancestorInfo;
        } else if (hostContainerInfo != null) {
          parentInfo = hostContainerInfo._ancestorInfo;
        }
        if (parentInfo) {
          validateDOMNesting('#text', this, parentInfo);
        }
      }
      var domID = hostContainerInfo._idCounter++;
      var openingValue = ' react-text: ' + domID + ' ';
      var closingValue = ' /react-text ';
      this._domID = domID;
      this._hostParent = hostParent;
      if (transaction.useCreateElement) {
        var ownerDocument = hostContainerInfo._ownerDocument;
        var openingComment = ownerDocument.createComment(openingValue);
        var closingComment = ownerDocument.createComment(closingValue);
        var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
        if (this._stringText) {
          DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
        }
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
        ReactDOMComponentTree.precacheNode(this, openingComment);
        this._closingComment = closingComment;
        return lazyTree;
      } else {
        var escapedText = escapeTextContentForBrowser(this._stringText);
        if (transaction.renderToStaticMarkup) {
          return escapedText;
        }
        return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
      }
    },
    receiveComponent: function(nextText, transaction) {
      if (nextText !== this._currentElement) {
        this._currentElement = nextText;
        var nextStringText = '' + nextText;
        if (nextStringText !== this._stringText) {
          this._stringText = nextStringText;
          var commentNodes = this.getHostNode();
          DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onSetText(this._debugID, nextStringText);
          }
        }
      }
    },
    getHostNode: function() {
      var hostNode = this._commentNodes;
      if (hostNode) {
        return hostNode;
      }
      if (!this._closingComment) {
        var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
        var node = openingComment.nextSibling;
        while (true) {
          !(node != null) ? "production" !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
          if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
            this._closingComment = node;
            break;
          }
          node = node.nextSibling;
        }
      }
      hostNode = [this._hostNode, this._closingComment];
      this._commentNodes = hostNode;
      return hostNode;
    },
    unmountComponent: function() {
      this._closingComment = null;
      this._commentNodes = null;
      ReactDOMComponentTree.uncacheNode(this);
    }
  });
  module.exports = ReactDOMTextComponent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDefaultBatchingStrategy.js", ["object-assign", "./ReactUpdates", "./Transaction", "fbjs/lib/emptyFunction", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');
  var ReactUpdates = $__require('./ReactUpdates');
  var Transaction = $__require('./Transaction');
  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var RESET_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: function() {
      ReactDefaultBatchingStrategy.isBatchingUpdates = false;
    }
  };
  var FLUSH_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
  };
  var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
  function ReactDefaultBatchingStrategyTransaction() {
    this.reinitializeTransaction();
  }
  _assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    }});
  var transaction = new ReactDefaultBatchingStrategyTransaction();
  var ReactDefaultBatchingStrategy = {
    isBatchingUpdates: false,
    batchedUpdates: function(callback, a, b, c, d, e) {
      var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
      ReactDefaultBatchingStrategy.isBatchingUpdates = true;
      if (alreadyBatchingUpdates) {
        callback(a, b, c, d, e);
      } else {
        transaction.perform(callback, null, a, b, c, d, e);
      }
    }
  };
  module.exports = ReactDefaultBatchingStrategy;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/getUnboundedScrollPosition.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function getUnboundedScrollPosition(scrollable) {
    if (scrollable === window) {
      return {
        x: window.pageXOffset || document.documentElement.scrollLeft,
        y: window.pageYOffset || document.documentElement.scrollTop
      };
    }
    return {
      x: scrollable.scrollLeft,
      y: scrollable.scrollTop
    };
  }
  module.exports = getUnboundedScrollPosition;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactEventListener.js", ["object-assign", "fbjs/lib/EventListener", "fbjs/lib/ExecutionEnvironment", "./PooledClass", "./ReactDOMComponentTree", "./ReactUpdates", "./getEventTarget", "fbjs/lib/getUnboundedScrollPosition", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');
  var EventListener = $__require('fbjs/lib/EventListener');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var PooledClass = $__require('./PooledClass');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactUpdates = $__require('./ReactUpdates');
  var getEventTarget = $__require('./getEventTarget');
  var getUnboundedScrollPosition = $__require('fbjs/lib/getUnboundedScrollPosition');
  function findParent(inst) {
    while (inst._hostParent) {
      inst = inst._hostParent;
    }
    var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
    var container = rootNode.parentNode;
    return ReactDOMComponentTree.getClosestInstanceFromNode(container);
  }
  function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
    this.topLevelType = topLevelType;
    this.nativeEvent = nativeEvent;
    this.ancestors = [];
  }
  _assign(TopLevelCallbackBookKeeping.prototype, {destructor: function() {
      this.topLevelType = null;
      this.nativeEvent = null;
      this.ancestors.length = 0;
    }});
  PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
  function handleTopLevelImpl(bookKeeping) {
    var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
    var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
    var ancestor = targetInst;
    do {
      bookKeeping.ancestors.push(ancestor);
      ancestor = ancestor && findParent(ancestor);
    } while (ancestor);
    for (var i = 0; i < bookKeeping.ancestors.length; i++) {
      targetInst = bookKeeping.ancestors[i];
      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
    }
  }
  function scrollValueMonitor(cb) {
    var scrollPosition = getUnboundedScrollPosition(window);
    cb(scrollPosition);
  }
  var ReactEventListener = {
    _enabled: true,
    _handleTopLevel: null,
    WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
    setHandleTopLevel: function(handleTopLevel) {
      ReactEventListener._handleTopLevel = handleTopLevel;
    },
    setEnabled: function(enabled) {
      ReactEventListener._enabled = !!enabled;
    },
    isEnabled: function() {
      return ReactEventListener._enabled;
    },
    trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
      var element = handle;
      if (!element) {
        return null;
      }
      return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
    },
    trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
      var element = handle;
      if (!element) {
        return null;
      }
      return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
    },
    monitorScrollValue: function(refresh) {
      var callback = scrollValueMonitor.bind(null, refresh);
      EventListener.listen(window, 'scroll', callback);
    },
    dispatchEvent: function(topLevelType, nativeEvent) {
      if (!ReactEventListener._enabled) {
        return;
      }
      var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
      try {
        ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
      } finally {
        TopLevelCallbackBookKeeping.release(bookKeeping);
      }
    }
  };
  module.exports = ReactEventListener;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactInjection.js", ["./DOMProperty", "./EventPluginHub", "./EventPluginUtils", "./ReactComponentEnvironment", "./ReactClass", "./ReactEmptyComponent", "./ReactBrowserEventEmitter", "./ReactHostComponent", "./ReactUpdates", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMProperty = $__require('./DOMProperty');
  var EventPluginHub = $__require('./EventPluginHub');
  var EventPluginUtils = $__require('./EventPluginUtils');
  var ReactComponentEnvironment = $__require('./ReactComponentEnvironment');
  var ReactClass = $__require('./ReactClass');
  var ReactEmptyComponent = $__require('./ReactEmptyComponent');
  var ReactBrowserEventEmitter = $__require('./ReactBrowserEventEmitter');
  var ReactHostComponent = $__require('./ReactHostComponent');
  var ReactUpdates = $__require('./ReactUpdates');
  var ReactInjection = {
    Component: ReactComponentEnvironment.injection,
    Class: ReactClass.injection,
    DOMProperty: DOMProperty.injection,
    EmptyComponent: ReactEmptyComponent.injection,
    EventPluginHub: EventPluginHub.injection,
    EventPluginUtils: EventPluginUtils.injection,
    EventEmitter: ReactBrowserEventEmitter.injection,
    HostComponent: ReactHostComponent.injection,
    Updates: ReactUpdates.injection
  };
  module.exports = ReactInjection;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactReconcileTransaction.js", ["object-assign", "./CallbackQueue", "./PooledClass", "./ReactBrowserEventEmitter", "./ReactInputSelection", "./ReactInstrumentation", "./Transaction", "./ReactUpdateQueue", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');
  var CallbackQueue = $__require('./CallbackQueue');
  var PooledClass = $__require('./PooledClass');
  var ReactBrowserEventEmitter = $__require('./ReactBrowserEventEmitter');
  var ReactInputSelection = $__require('./ReactInputSelection');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var Transaction = $__require('./Transaction');
  var ReactUpdateQueue = $__require('./ReactUpdateQueue');
  var SELECTION_RESTORATION = {
    initialize: ReactInputSelection.getSelectionInformation,
    close: ReactInputSelection.restoreSelection
  };
  var EVENT_SUPPRESSION = {
    initialize: function() {
      var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
      ReactBrowserEventEmitter.setEnabled(false);
      return currentlyEnabled;
    },
    close: function(previouslyEnabled) {
      ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
    }
  };
  var ON_DOM_READY_QUEUEING = {
    initialize: function() {
      this.reactMountReady.reset();
    },
    close: function() {
      this.reactMountReady.notifyAll();
    }
  };
  var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
  if ("production" !== 'production') {
    TRANSACTION_WRAPPERS.push({
      initialize: ReactInstrumentation.debugTool.onBeginFlush,
      close: ReactInstrumentation.debugTool.onEndFlush
    });
  }
  function ReactReconcileTransaction(useCreateElement) {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = false;
    this.reactMountReady = CallbackQueue.getPooled(null);
    this.useCreateElement = useCreateElement;
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return this.reactMountReady;
    },
    getUpdateQueue: function() {
      return ReactUpdateQueue;
    },
    checkpoint: function() {
      return this.reactMountReady.checkpoint();
    },
    rollback: function(checkpoint) {
      this.reactMountReady.rollback(checkpoint);
    },
    destructor: function() {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
    }
  };
  _assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactReconcileTransaction);
  module.exports = ReactReconcileTransaction;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SVGDOMPropertyConfig.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var NS = {
    xlink: 'http://www.w3.org/1999/xlink',
    xml: 'http://www.w3.org/XML/1998/namespace'
  };
  var ATTRS = {
    accentHeight: 'accent-height',
    accumulate: 0,
    additive: 0,
    alignmentBaseline: 'alignment-baseline',
    allowReorder: 'allowReorder',
    alphabetic: 0,
    amplitude: 0,
    arabicForm: 'arabic-form',
    ascent: 0,
    attributeName: 'attributeName',
    attributeType: 'attributeType',
    autoReverse: 'autoReverse',
    azimuth: 0,
    baseFrequency: 'baseFrequency',
    baseProfile: 'baseProfile',
    baselineShift: 'baseline-shift',
    bbox: 0,
    begin: 0,
    bias: 0,
    by: 0,
    calcMode: 'calcMode',
    capHeight: 'cap-height',
    clip: 0,
    clipPath: 'clip-path',
    clipRule: 'clip-rule',
    clipPathUnits: 'clipPathUnits',
    colorInterpolation: 'color-interpolation',
    colorInterpolationFilters: 'color-interpolation-filters',
    colorProfile: 'color-profile',
    colorRendering: 'color-rendering',
    contentScriptType: 'contentScriptType',
    contentStyleType: 'contentStyleType',
    cursor: 0,
    cx: 0,
    cy: 0,
    d: 0,
    decelerate: 0,
    descent: 0,
    diffuseConstant: 'diffuseConstant',
    direction: 0,
    display: 0,
    divisor: 0,
    dominantBaseline: 'dominant-baseline',
    dur: 0,
    dx: 0,
    dy: 0,
    edgeMode: 'edgeMode',
    elevation: 0,
    enableBackground: 'enable-background',
    end: 0,
    exponent: 0,
    externalResourcesRequired: 'externalResourcesRequired',
    fill: 0,
    fillOpacity: 'fill-opacity',
    fillRule: 'fill-rule',
    filter: 0,
    filterRes: 'filterRes',
    filterUnits: 'filterUnits',
    floodColor: 'flood-color',
    floodOpacity: 'flood-opacity',
    focusable: 0,
    fontFamily: 'font-family',
    fontSize: 'font-size',
    fontSizeAdjust: 'font-size-adjust',
    fontStretch: 'font-stretch',
    fontStyle: 'font-style',
    fontVariant: 'font-variant',
    fontWeight: 'font-weight',
    format: 0,
    from: 0,
    fx: 0,
    fy: 0,
    g1: 0,
    g2: 0,
    glyphName: 'glyph-name',
    glyphOrientationHorizontal: 'glyph-orientation-horizontal',
    glyphOrientationVertical: 'glyph-orientation-vertical',
    glyphRef: 'glyphRef',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    hanging: 0,
    horizAdvX: 'horiz-adv-x',
    horizOriginX: 'horiz-origin-x',
    ideographic: 0,
    imageRendering: 'image-rendering',
    'in': 0,
    in2: 0,
    intercept: 0,
    k: 0,
    k1: 0,
    k2: 0,
    k3: 0,
    k4: 0,
    kernelMatrix: 'kernelMatrix',
    kernelUnitLength: 'kernelUnitLength',
    kerning: 0,
    keyPoints: 'keyPoints',
    keySplines: 'keySplines',
    keyTimes: 'keyTimes',
    lengthAdjust: 'lengthAdjust',
    letterSpacing: 'letter-spacing',
    lightingColor: 'lighting-color',
    limitingConeAngle: 'limitingConeAngle',
    local: 0,
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    markerHeight: 'markerHeight',
    markerUnits: 'markerUnits',
    markerWidth: 'markerWidth',
    mask: 0,
    maskContentUnits: 'maskContentUnits',
    maskUnits: 'maskUnits',
    mathematical: 0,
    mode: 0,
    numOctaves: 'numOctaves',
    offset: 0,
    opacity: 0,
    operator: 0,
    order: 0,
    orient: 0,
    orientation: 0,
    origin: 0,
    overflow: 0,
    overlinePosition: 'overline-position',
    overlineThickness: 'overline-thickness',
    paintOrder: 'paint-order',
    panose1: 'panose-1',
    pathLength: 'pathLength',
    patternContentUnits: 'patternContentUnits',
    patternTransform: 'patternTransform',
    patternUnits: 'patternUnits',
    pointerEvents: 'pointer-events',
    points: 0,
    pointsAtX: 'pointsAtX',
    pointsAtY: 'pointsAtY',
    pointsAtZ: 'pointsAtZ',
    preserveAlpha: 'preserveAlpha',
    preserveAspectRatio: 'preserveAspectRatio',
    primitiveUnits: 'primitiveUnits',
    r: 0,
    radius: 0,
    refX: 'refX',
    refY: 'refY',
    renderingIntent: 'rendering-intent',
    repeatCount: 'repeatCount',
    repeatDur: 'repeatDur',
    requiredExtensions: 'requiredExtensions',
    requiredFeatures: 'requiredFeatures',
    restart: 0,
    result: 0,
    rotate: 0,
    rx: 0,
    ry: 0,
    scale: 0,
    seed: 0,
    shapeRendering: 'shape-rendering',
    slope: 0,
    spacing: 0,
    specularConstant: 'specularConstant',
    specularExponent: 'specularExponent',
    speed: 0,
    spreadMethod: 'spreadMethod',
    startOffset: 'startOffset',
    stdDeviation: 'stdDeviation',
    stemh: 0,
    stemv: 0,
    stitchTiles: 'stitchTiles',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strikethroughPosition: 'strikethrough-position',
    strikethroughThickness: 'strikethrough-thickness',
    string: 0,
    stroke: 0,
    strokeDasharray: 'stroke-dasharray',
    strokeDashoffset: 'stroke-dashoffset',
    strokeLinecap: 'stroke-linecap',
    strokeLinejoin: 'stroke-linejoin',
    strokeMiterlimit: 'stroke-miterlimit',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    surfaceScale: 'surfaceScale',
    systemLanguage: 'systemLanguage',
    tableValues: 'tableValues',
    targetX: 'targetX',
    targetY: 'targetY',
    textAnchor: 'text-anchor',
    textDecoration: 'text-decoration',
    textRendering: 'text-rendering',
    textLength: 'textLength',
    to: 0,
    transform: 0,
    u1: 0,
    u2: 0,
    underlinePosition: 'underline-position',
    underlineThickness: 'underline-thickness',
    unicode: 0,
    unicodeBidi: 'unicode-bidi',
    unicodeRange: 'unicode-range',
    unitsPerEm: 'units-per-em',
    vAlphabetic: 'v-alphabetic',
    vHanging: 'v-hanging',
    vIdeographic: 'v-ideographic',
    vMathematical: 'v-mathematical',
    values: 0,
    vectorEffect: 'vector-effect',
    version: 0,
    vertAdvY: 'vert-adv-y',
    vertOriginX: 'vert-origin-x',
    vertOriginY: 'vert-origin-y',
    viewBox: 'viewBox',
    viewTarget: 'viewTarget',
    visibility: 0,
    widths: 0,
    wordSpacing: 'word-spacing',
    writingMode: 'writing-mode',
    x: 0,
    xHeight: 'x-height',
    x1: 0,
    x2: 0,
    xChannelSelector: 'xChannelSelector',
    xlinkActuate: 'xlink:actuate',
    xlinkArcrole: 'xlink:arcrole',
    xlinkHref: 'xlink:href',
    xlinkRole: 'xlink:role',
    xlinkShow: 'xlink:show',
    xlinkTitle: 'xlink:title',
    xlinkType: 'xlink:type',
    xmlBase: 'xml:base',
    xmlLang: 'xml:lang',
    xmlSpace: 'xml:space',
    y: 0,
    y1: 0,
    y2: 0,
    yChannelSelector: 'yChannelSelector',
    z: 0,
    zoomAndPan: 'zoomAndPan'
  };
  var SVGDOMPropertyConfig = {
    Properties: {},
    DOMAttributeNamespaces: {
      xlinkActuate: NS.xlink,
      xlinkArcrole: NS.xlink,
      xlinkHref: NS.xlink,
      xlinkRole: NS.xlink,
      xlinkShow: NS.xlink,
      xlinkTitle: NS.xlink,
      xlinkType: NS.xlink,
      xmlBase: NS.xml,
      xmlLang: NS.xml,
      xmlSpace: NS.xml
    },
    DOMAttributeNames: {}
  };
  Object.keys(ATTRS).forEach(function(key) {
    SVGDOMPropertyConfig.Properties[key] = 0;
    if (ATTRS[key]) {
      SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
    }
  });
  module.exports = SVGDOMPropertyConfig;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/getNodeForCharacterOffset.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function getLeafNode(node) {
    while (node && node.firstChild) {
      node = node.firstChild;
    }
    return node;
  }
  function getSiblingNode(node) {
    while (node) {
      if (node.nextSibling) {
        return node.nextSibling;
      }
      node = node.parentNode;
    }
  }
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    var nodeStart = 0;
    var nodeEnd = 0;
    while (node) {
      if (node.nodeType === 3) {
        nodeEnd = nodeStart + node.textContent.length;
        if (nodeStart <= offset && nodeEnd >= offset) {
          return {
            node: node,
            offset: offset - nodeStart
          };
        }
        nodeStart = nodeEnd;
      }
      node = getLeafNode(getSiblingNode(node));
    }
  }
  module.exports = getNodeForCharacterOffset;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/getTextContentAccessor.js", ["fbjs/lib/ExecutionEnvironment", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var contentKey = null;
  function getTextContentAccessor() {
    if (!contentKey && ExecutionEnvironment.canUseDOM) {
      contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
    }
    return contentKey;
  }
  module.exports = getTextContentAccessor;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMSelection.js", ["fbjs/lib/ExecutionEnvironment", "./getNodeForCharacterOffset", "./getTextContentAccessor", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var getNodeForCharacterOffset = $__require('./getNodeForCharacterOffset');
  var getTextContentAccessor = $__require('./getTextContentAccessor');
  function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
    return anchorNode === focusNode && anchorOffset === focusOffset;
  }
  function getIEOffsets(node) {
    var selection = document.selection;
    var selectedRange = selection.createRange();
    var selectedLength = selectedRange.text.length;
    var fromStart = selectedRange.duplicate();
    fromStart.moveToElementText(node);
    fromStart.setEndPoint('EndToStart', selectedRange);
    var startOffset = fromStart.text.length;
    var endOffset = startOffset + selectedLength;
    return {
      start: startOffset,
      end: endOffset
    };
  }
  function getModernOffsets(node) {
    var selection = window.getSelection && window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return null;
    }
    var anchorNode = selection.anchorNode;
    var anchorOffset = selection.anchorOffset;
    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;
    var currentRange = selection.getRangeAt(0);
    try {
      currentRange.startContainer.nodeType;
      currentRange.endContainer.nodeType;
    } catch (e) {
      return null;
    }
    var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
    var tempRange = currentRange.cloneRange();
    tempRange.selectNodeContents(node);
    tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
    var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
    var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
    var end = start + rangeLength;
    var detectionRange = document.createRange();
    detectionRange.setStart(anchorNode, anchorOffset);
    detectionRange.setEnd(focusNode, focusOffset);
    var isBackward = detectionRange.collapsed;
    return {
      start: isBackward ? end : start,
      end: isBackward ? start : end
    };
  }
  function setIEOffsets(node, offsets) {
    var range = document.selection.createRange().duplicate();
    var start,
        end;
    if (offsets.end === undefined) {
      start = offsets.start;
      end = start;
    } else if (offsets.start > offsets.end) {
      start = offsets.end;
      end = offsets.start;
    } else {
      start = offsets.start;
      end = offsets.end;
    }
    range.moveToElementText(node);
    range.moveStart('character', start);
    range.setEndPoint('EndToStart', range);
    range.moveEnd('character', end - start);
    range.select();
  }
  function setModernOffsets(node, offsets) {
    if (!window.getSelection) {
      return;
    }
    var selection = window.getSelection();
    var length = node[getTextContentAccessor()].length;
    var start = Math.min(offsets.start, length);
    var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
    if (!selection.extend && start > end) {
      var temp = end;
      end = start;
      start = temp;
    }
    var startMarker = getNodeForCharacterOffset(node, start);
    var endMarker = getNodeForCharacterOffset(node, end);
    if (startMarker && endMarker) {
      var range = document.createRange();
      range.setStart(startMarker.node, startMarker.offset);
      selection.removeAllRanges();
      if (start > end) {
        selection.addRange(range);
        selection.extend(endMarker.node, endMarker.offset);
      } else {
        range.setEnd(endMarker.node, endMarker.offset);
        selection.addRange(range);
      }
    }
  }
  var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
  var ReactDOMSelection = {
    getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
    setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
  };
  module.exports = ReactDOMSelection;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/isNode.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function isNode(object) {
    return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
  }
  module.exports = isNode;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/isTextNode.js", ["./isNode", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var isNode = $__require('./isNode');
  function isTextNode(object) {
    return isNode(object) && object.nodeType == 3;
  }
  module.exports = isTextNode;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/containsNode.js", ["./isTextNode", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var isTextNode = $__require('./isTextNode');
  function containsNode(outerNode, innerNode) {
    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      return containsNode(outerNode, innerNode.parentNode);
    } else if ('contains' in outerNode) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
  module.exports = containsNode;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/focusNode.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function focusNode(node) {
    try {
      node.focus();
    } catch (e) {}
  }
  module.exports = focusNode;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactInputSelection.js", ["./ReactDOMSelection", "fbjs/lib/containsNode", "fbjs/lib/focusNode", "fbjs/lib/getActiveElement", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMSelection = $__require('./ReactDOMSelection');
  var containsNode = $__require('fbjs/lib/containsNode');
  var focusNode = $__require('fbjs/lib/focusNode');
  var getActiveElement = $__require('fbjs/lib/getActiveElement');
  function isInDocument(node) {
    return containsNode(document.documentElement, node);
  }
  var ReactInputSelection = {
    hasSelectionCapabilities: function(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
    },
    getSelectionInformation: function() {
      var focusedElem = getActiveElement();
      return {
        focusedElem: focusedElem,
        selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
      };
    },
    restoreSelection: function(priorSelectionInformation) {
      var curFocusedElem = getActiveElement();
      var priorFocusedElem = priorSelectionInformation.focusedElem;
      var priorSelectionRange = priorSelectionInformation.selectionRange;
      if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
        if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
          ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
        }
        focusNode(priorFocusedElem);
      }
    },
    getSelection: function(input) {
      var selection;
      if ('selectionStart' in input) {
        selection = {
          start: input.selectionStart,
          end: input.selectionEnd
        };
      } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
        var range = document.selection.createRange();
        if (range.parentElement() === input) {
          selection = {
            start: -range.moveStart('character', -input.value.length),
            end: -range.moveEnd('character', -input.value.length)
          };
        }
      } else {
        selection = ReactDOMSelection.getOffsets(input);
      }
      return selection || {
        start: 0,
        end: 0
      };
    },
    setSelection: function(input, offsets) {
      var start = offsets.start;
      var end = offsets.end;
      if (end === undefined) {
        end = start;
      }
      if ('selectionStart' in input) {
        input.selectionStart = start;
        input.selectionEnd = Math.min(end, input.value.length);
      } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveStart('character', start);
        range.moveEnd('character', end - start);
        range.select();
      } else {
        ReactDOMSelection.setOffsets(input, offsets);
      }
    }
  };
  module.exports = ReactInputSelection;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/getActiveElement.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function getActiveElement() {
    if (typeof document === 'undefined') {
      return null;
    }
    try {
      return document.activeElement || document.body;
    } catch (e) {
      return document.body;
    }
  }
  module.exports = getActiveElement;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/isTextInputElement.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var supportedInputTypes = {
    'color': true,
    'date': true,
    'datetime': true,
    'datetime-local': true,
    'email': true,
    'month': true,
    'number': true,
    'password': true,
    'range': true,
    'search': true,
    'tel': true,
    'text': true,
    'time': true,
    'url': true,
    'week': true
  };
  function isTextInputElement(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    if (nodeName === 'input') {
      return !!supportedInputTypes[elem.type];
    }
    if (nodeName === 'textarea') {
      return true;
    }
    return false;
  }
  module.exports = isTextInputElement;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/shallowEqual.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function is(x, y) {
    if (x === y) {
      return x !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }
  function shallowEqual(objA, objB) {
    if (is(objA, objB)) {
      return true;
    }
    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    for (var i = 0; i < keysA.length; i++) {
      if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }
    return true;
  }
  module.exports = shallowEqual;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SelectEventPlugin.js", ["./EventConstants", "./EventPropagators", "fbjs/lib/ExecutionEnvironment", "./ReactDOMComponentTree", "./ReactInputSelection", "./SyntheticEvent", "fbjs/lib/getActiveElement", "./isTextInputElement", "fbjs/lib/keyOf", "fbjs/lib/shallowEqual", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var EventConstants = $__require('./EventConstants');
  var EventPropagators = $__require('./EventPropagators');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactInputSelection = $__require('./ReactInputSelection');
  var SyntheticEvent = $__require('./SyntheticEvent');
  var getActiveElement = $__require('fbjs/lib/getActiveElement');
  var isTextInputElement = $__require('./isTextInputElement');
  var keyOf = $__require('fbjs/lib/keyOf');
  var shallowEqual = $__require('fbjs/lib/shallowEqual');
  var topLevelTypes = EventConstants.topLevelTypes;
  var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
  var eventTypes = {select: {
      phasedRegistrationNames: {
        bubbled: keyOf({onSelect: null}),
        captured: keyOf({onSelectCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
    }};
  var activeElement = null;
  var activeElementInst = null;
  var lastSelection = null;
  var mouseDown = false;
  var hasListener = false;
  var ON_SELECT_KEY = keyOf({onSelect: null});
  function getSelection(node) {
    if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
      return {
        start: node.selectionStart,
        end: node.selectionEnd
      };
    } else if (window.getSelection) {
      var selection = window.getSelection();
      return {
        anchorNode: selection.anchorNode,
        anchorOffset: selection.anchorOffset,
        focusNode: selection.focusNode,
        focusOffset: selection.focusOffset
      };
    } else if (document.selection) {
      var range = document.selection.createRange();
      return {
        parentElement: range.parentElement(),
        text: range.text,
        top: range.boundingTop,
        left: range.boundingLeft
      };
    }
  }
  function constructSelectEvent(nativeEvent, nativeEventTarget) {
    if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
      return null;
    }
    var currentSelection = getSelection(activeElement);
    if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
      lastSelection = currentSelection;
      var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
      syntheticEvent.type = 'select';
      syntheticEvent.target = activeElement;
      EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
      return syntheticEvent;
    }
    return null;
  }
  var SelectEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (!hasListener) {
        return null;
      }
      var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
      switch (topLevelType) {
        case topLevelTypes.topFocus:
          if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
            activeElement = targetNode;
            activeElementInst = targetInst;
            lastSelection = null;
          }
          break;
        case topLevelTypes.topBlur:
          activeElement = null;
          activeElementInst = null;
          lastSelection = null;
          break;
        case topLevelTypes.topMouseDown:
          mouseDown = true;
          break;
        case topLevelTypes.topContextMenu:
        case topLevelTypes.topMouseUp:
          mouseDown = false;
          return constructSelectEvent(nativeEvent, nativeEventTarget);
        case topLevelTypes.topSelectionChange:
          if (skipSelectionChangeEvent) {
            break;
          }
        case topLevelTypes.topKeyDown:
        case topLevelTypes.topKeyUp:
          return constructSelectEvent(nativeEvent, nativeEventTarget);
      }
      return null;
    },
    didPutListener: function(inst, registrationName, listener) {
      if (registrationName === ON_SELECT_KEY) {
        hasListener = true;
      }
    }
  };
  module.exports = SelectEventPlugin;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/EventListener.js", ["./emptyFunction", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var emptyFunction = $__require('./emptyFunction');
  var EventListener = {
    listen: function listen(target, eventType, callback) {
      if (target.addEventListener) {
        target.addEventListener(eventType, callback, false);
        return {remove: function remove() {
            target.removeEventListener(eventType, callback, false);
          }};
      } else if (target.attachEvent) {
        target.attachEvent('on' + eventType, callback);
        return {remove: function remove() {
            target.detachEvent('on' + eventType, callback);
          }};
      }
    },
    capture: function capture(target, eventType, callback) {
      if (target.addEventListener) {
        target.addEventListener(eventType, callback, true);
        return {remove: function remove() {
            target.removeEventListener(eventType, callback, true);
          }};
      } else {
        if ("production" !== 'production') {
          console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
        }
        return {remove: emptyFunction};
      }
    },
    registerDefault: function registerDefault() {}
  };
  module.exports = EventListener;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/EventPropagators.js", ["./EventConstants", "./EventPluginHub", "./EventPluginUtils", "./accumulateInto", "./forEachAccumulated", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var EventConstants = $__require('./EventConstants');
  var EventPluginHub = $__require('./EventPluginHub');
  var EventPluginUtils = $__require('./EventPluginUtils');
  var accumulateInto = $__require('./accumulateInto');
  var forEachAccumulated = $__require('./forEachAccumulated');
  var warning = $__require('fbjs/lib/warning');
  var PropagationPhases = EventConstants.PropagationPhases;
  var getListener = EventPluginHub.getListener;
  function listenerAtPhase(inst, event, propagationPhase) {
    var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
    return getListener(inst, registrationName);
  }
  function accumulateDirectionalDispatches(inst, upwards, event) {
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
    }
    var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
    var listener = listenerAtPhase(inst, event, phase);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
  function accumulateTwoPhaseDispatchesSingle(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
    }
  }
  function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      var targetInst = event._targetInst;
      var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
      EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
    }
  }
  function accumulateDispatches(inst, ignoredDirection, event) {
    if (event && event.dispatchConfig.registrationName) {
      var registrationName = event.dispatchConfig.registrationName;
      var listener = getListener(inst, registrationName);
      if (listener) {
        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
      }
    }
  }
  function accumulateDirectDispatchesSingle(event) {
    if (event && event.dispatchConfig.registrationName) {
      accumulateDispatches(event._targetInst, null, event);
    }
  }
  function accumulateTwoPhaseDispatches(events) {
    forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
  }
  function accumulateTwoPhaseDispatchesSkipTarget(events) {
    forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
  }
  function accumulateEnterLeaveDispatches(leave, enter, from, to) {
    EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
  }
  function accumulateDirectDispatches(events) {
    forEachAccumulated(events, accumulateDirectDispatchesSingle);
  }
  var EventPropagators = {
    accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
    accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
    accumulateDirectDispatches: accumulateDirectDispatches,
    accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
  };
  module.exports = EventPropagators;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SyntheticAnimationEvent.js", ["./SyntheticEvent", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('./SyntheticEvent');
  var AnimationEventInterface = {
    animationName: null,
    elapsedTime: null,
    pseudoElement: null
  };
  function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
  module.exports = SyntheticAnimationEvent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SyntheticClipboardEvent.js", ["./SyntheticEvent", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('./SyntheticEvent');
  var ClipboardEventInterface = {clipboardData: function(event) {
      return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
    }};
  function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
  module.exports = SyntheticClipboardEvent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SyntheticFocusEvent.js", ["./SyntheticUIEvent", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('./SyntheticUIEvent');
  var FocusEventInterface = {relatedTarget: null};
  function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
  module.exports = SyntheticFocusEvent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/getEventKey.js", ["./getEventCharCode", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var getEventCharCode = $__require('./getEventCharCode');
  var normalizeKey = {
    'Esc': 'Escape',
    'Spacebar': ' ',
    'Left': 'ArrowLeft',
    'Up': 'ArrowUp',
    'Right': 'ArrowRight',
    'Down': 'ArrowDown',
    'Del': 'Delete',
    'Win': 'OS',
    'Menu': 'ContextMenu',
    'Apps': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'MozPrintableKey': 'Unidentified'
  };
  var translateToKey = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta'
  };
  function getEventKey(nativeEvent) {
    if (nativeEvent.key) {
      var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
      if (key !== 'Unidentified') {
        return key;
      }
    }
    if (nativeEvent.type === 'keypress') {
      var charCode = getEventCharCode(nativeEvent);
      return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
    }
    if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
      return translateToKey[nativeEvent.keyCode] || 'Unidentified';
    }
    return '';
  }
  module.exports = getEventKey;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SyntheticKeyboardEvent.js", ["./SyntheticUIEvent", "./getEventCharCode", "./getEventKey", "./getEventModifierState", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('./SyntheticUIEvent');
  var getEventCharCode = $__require('./getEventCharCode');
  var getEventKey = $__require('./getEventKey');
  var getEventModifierState = $__require('./getEventModifierState');
  var KeyboardEventInterface = {
    key: getEventKey,
    location: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    repeat: null,
    locale: null,
    getModifierState: getEventModifierState,
    charCode: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      return 0;
    },
    keyCode: function(event) {
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    },
    which: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    }
  };
  function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
  module.exports = SyntheticKeyboardEvent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SyntheticDragEvent.js", ["./SyntheticMouseEvent", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticMouseEvent = $__require('./SyntheticMouseEvent');
  var DragEventInterface = {dataTransfer: null};
  function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
  module.exports = SyntheticDragEvent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SyntheticTouchEvent.js", ["./SyntheticUIEvent", "./getEventModifierState", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('./SyntheticUIEvent');
  var getEventModifierState = $__require('./getEventModifierState');
  var TouchEventInterface = {
    touches: null,
    targetTouches: null,
    changedTouches: null,
    altKey: null,
    metaKey: null,
    ctrlKey: null,
    shiftKey: null,
    getModifierState: getEventModifierState
  };
  function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
  module.exports = SyntheticTouchEvent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SyntheticTransitionEvent.js", ["./SyntheticEvent", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('./SyntheticEvent');
  var TransitionEventInterface = {
    propertyName: null,
    elapsedTime: null,
    pseudoElement: null
  };
  function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
  module.exports = SyntheticTransitionEvent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SyntheticEvent.js", ["object-assign", "./PooledClass", "fbjs/lib/emptyFunction", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');
  var PooledClass = $__require('./PooledClass');
  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var warning = $__require('fbjs/lib/warning');
  var didWarnForAddedNewProperty = false;
  var isProxySupported = typeof Proxy === 'function';
  var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
  var EventInterface = {
    type: null,
    target: null,
    currentTarget: emptyFunction.thatReturnsNull,
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };
  function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
    if ("production" !== 'production') {
      delete this.nativeEvent;
      delete this.preventDefault;
      delete this.stopPropagation;
    }
    this.dispatchConfig = dispatchConfig;
    this._targetInst = targetInst;
    this.nativeEvent = nativeEvent;
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (!Interface.hasOwnProperty(propName)) {
        continue;
      }
      if ("production" !== 'production') {
        delete this[propName];
      }
      var normalize = Interface[propName];
      if (normalize) {
        this[propName] = normalize(nativeEvent);
      } else {
        if (propName === 'target') {
          this.target = nativeEventTarget;
        } else {
          this[propName] = nativeEvent[propName];
        }
      }
    }
    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
    if (defaultPrevented) {
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    } else {
      this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsFalse;
    return this;
  }
  _assign(SyntheticEvent.prototype, {
    preventDefault: function() {
      this.defaultPrevented = true;
      var event = this.nativeEvent;
      if (!event) {
        return;
      }
      if (event.preventDefault) {
        event.preventDefault();
      } else {
        event.returnValue = false;
      }
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    },
    stopPropagation: function() {
      var event = this.nativeEvent;
      if (!event) {
        return;
      }
      if (event.stopPropagation) {
        event.stopPropagation();
      } else {
        event.cancelBubble = true;
      }
      this.isPropagationStopped = emptyFunction.thatReturnsTrue;
    },
    persist: function() {
      this.isPersistent = emptyFunction.thatReturnsTrue;
    },
    isPersistent: emptyFunction.thatReturnsFalse,
    destructor: function() {
      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        if ("production" !== 'production') {
          Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
        } else {
          this[propName] = null;
        }
      }
      for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
        this[shouldBeReleasedProperties[i]] = null;
      }
      if ("production" !== 'production') {
        Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
        Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
        Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
      }
    }
  });
  SyntheticEvent.Interface = EventInterface;
  if ("production" !== 'production') {
    if (isProxySupported) {
      SyntheticEvent = new Proxy(SyntheticEvent, {
        construct: function(target, args) {
          return this.apply(target, Object.create(target.prototype), args);
        },
        apply: function(constructor, that, args) {
          return new Proxy(constructor.apply(that, args), {set: function(target, prop, value) {
              if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
                "production" !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
                didWarnForAddedNewProperty = true;
              }
              target[prop] = value;
              return true;
            }});
        }
      });
    }
  }
  SyntheticEvent.augmentClass = function(Class, Interface) {
    var Super = this;
    var E = function() {};
    E.prototype = Super.prototype;
    var prototype = new E();
    _assign(prototype, Class.prototype);
    Class.prototype = prototype;
    Class.prototype.constructor = Class;
    Class.Interface = _assign({}, Super.Interface, Interface);
    Class.augmentClass = Super.augmentClass;
    PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
  };
  PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
  module.exports = SyntheticEvent;
  function getPooledWarningPropertyDefinition(propName, getVal) {
    var isFunction = typeof getVal === 'function';
    return {
      configurable: true,
      set: set,
      get: get
    };
    function set(val) {
      var action = isFunction ? 'setting the method' : 'setting the property';
      warn(action, 'This is effectively a no-op');
      return val;
    }
    function get() {
      var action = isFunction ? 'accessing the method' : 'accessing the property';
      var result = isFunction ? 'This is a no-op function' : 'This is set to null';
      warn(action, result);
      return getVal;
    }
    function warn(action, result) {
      var warningCondition = false;
      "production" !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
    }
  }
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/getEventTarget.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function getEventTarget(nativeEvent) {
    var target = nativeEvent.target || nativeEvent.srcElement || window;
    if (target.correspondingUseElement) {
      target = target.correspondingUseElement;
    }
    return target.nodeType === 3 ? target.parentNode : target;
  }
  module.exports = getEventTarget;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SyntheticUIEvent.js", ["./SyntheticEvent", "./getEventTarget", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('./SyntheticEvent');
  var getEventTarget = $__require('./getEventTarget');
  var UIEventInterface = {
    view: function(event) {
      if (event.view) {
        return event.view;
      }
      var target = getEventTarget(event);
      if (target.window === target) {
        return target;
      }
      var doc = target.ownerDocument;
      if (doc) {
        return doc.defaultView || doc.parentWindow;
      } else {
        return window;
      }
    },
    detail: function(event) {
      return event.detail || 0;
    }
  };
  function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
  module.exports = SyntheticUIEvent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/getEventModifierState.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var modifierKeyToProp = {
    'Alt': 'altKey',
    'Control': 'ctrlKey',
    'Meta': 'metaKey',
    'Shift': 'shiftKey'
  };
  function modifierStateGetter(keyArg) {
    var syntheticEvent = this;
    var nativeEvent = syntheticEvent.nativeEvent;
    if (nativeEvent.getModifierState) {
      return nativeEvent.getModifierState(keyArg);
    }
    var keyProp = modifierKeyToProp[keyArg];
    return keyProp ? !!nativeEvent[keyProp] : false;
  }
  function getEventModifierState(nativeEvent) {
    return modifierStateGetter;
  }
  module.exports = getEventModifierState;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SyntheticMouseEvent.js", ["./SyntheticUIEvent", "./ViewportMetrics", "./getEventModifierState", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('./SyntheticUIEvent');
  var ViewportMetrics = $__require('./ViewportMetrics');
  var getEventModifierState = $__require('./getEventModifierState');
  var MouseEventInterface = {
    screenX: null,
    screenY: null,
    clientX: null,
    clientY: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    getModifierState: getEventModifierState,
    button: function(event) {
      var button = event.button;
      if ('which' in event) {
        return button;
      }
      return button === 2 ? 2 : button === 4 ? 1 : 0;
    },
    buttons: null,
    relatedTarget: function(event) {
      return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
    },
    pageX: function(event) {
      return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
    },
    pageY: function(event) {
      return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
    }
  };
  function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
  module.exports = SyntheticMouseEvent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SyntheticWheelEvent.js", ["./SyntheticMouseEvent", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticMouseEvent = $__require('./SyntheticMouseEvent');
  var WheelEventInterface = {
    deltaX: function(event) {
      return 'deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
    },
    deltaY: function(event) {
      return 'deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0;
    },
    deltaZ: null,
    deltaMode: null
  };
  function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
  module.exports = SyntheticWheelEvent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/getEventCharCode.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function getEventCharCode(nativeEvent) {
    var charCode;
    var keyCode = nativeEvent.keyCode;
    if ('charCode' in nativeEvent) {
      charCode = nativeEvent.charCode;
      if (charCode === 0 && keyCode === 13) {
        charCode = 13;
      }
    } else {
      charCode = keyCode;
    }
    if (charCode >= 32 || charCode === 13) {
      return charCode;
    }
    return 0;
  }
  module.exports = getEventCharCode;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/SimpleEventPlugin.js", ["./reactProdInvariant", "./EventConstants", "fbjs/lib/EventListener", "./EventPropagators", "./ReactDOMComponentTree", "./SyntheticAnimationEvent", "./SyntheticClipboardEvent", "./SyntheticEvent", "./SyntheticFocusEvent", "./SyntheticKeyboardEvent", "./SyntheticMouseEvent", "./SyntheticDragEvent", "./SyntheticTouchEvent", "./SyntheticTransitionEvent", "./SyntheticUIEvent", "./SyntheticWheelEvent", "fbjs/lib/emptyFunction", "./getEventCharCode", "fbjs/lib/invariant", "fbjs/lib/keyOf", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var EventConstants = $__require('./EventConstants');
  var EventListener = $__require('fbjs/lib/EventListener');
  var EventPropagators = $__require('./EventPropagators');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var SyntheticAnimationEvent = $__require('./SyntheticAnimationEvent');
  var SyntheticClipboardEvent = $__require('./SyntheticClipboardEvent');
  var SyntheticEvent = $__require('./SyntheticEvent');
  var SyntheticFocusEvent = $__require('./SyntheticFocusEvent');
  var SyntheticKeyboardEvent = $__require('./SyntheticKeyboardEvent');
  var SyntheticMouseEvent = $__require('./SyntheticMouseEvent');
  var SyntheticDragEvent = $__require('./SyntheticDragEvent');
  var SyntheticTouchEvent = $__require('./SyntheticTouchEvent');
  var SyntheticTransitionEvent = $__require('./SyntheticTransitionEvent');
  var SyntheticUIEvent = $__require('./SyntheticUIEvent');
  var SyntheticWheelEvent = $__require('./SyntheticWheelEvent');
  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var getEventCharCode = $__require('./getEventCharCode');
  var invariant = $__require('fbjs/lib/invariant');
  var keyOf = $__require('fbjs/lib/keyOf');
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {
    abort: {phasedRegistrationNames: {
        bubbled: keyOf({onAbort: true}),
        captured: keyOf({onAbortCapture: true})
      }},
    animationEnd: {phasedRegistrationNames: {
        bubbled: keyOf({onAnimationEnd: true}),
        captured: keyOf({onAnimationEndCapture: true})
      }},
    animationIteration: {phasedRegistrationNames: {
        bubbled: keyOf({onAnimationIteration: true}),
        captured: keyOf({onAnimationIterationCapture: true})
      }},
    animationStart: {phasedRegistrationNames: {
        bubbled: keyOf({onAnimationStart: true}),
        captured: keyOf({onAnimationStartCapture: true})
      }},
    blur: {phasedRegistrationNames: {
        bubbled: keyOf({onBlur: true}),
        captured: keyOf({onBlurCapture: true})
      }},
    canPlay: {phasedRegistrationNames: {
        bubbled: keyOf({onCanPlay: true}),
        captured: keyOf({onCanPlayCapture: true})
      }},
    canPlayThrough: {phasedRegistrationNames: {
        bubbled: keyOf({onCanPlayThrough: true}),
        captured: keyOf({onCanPlayThroughCapture: true})
      }},
    click: {phasedRegistrationNames: {
        bubbled: keyOf({onClick: true}),
        captured: keyOf({onClickCapture: true})
      }},
    contextMenu: {phasedRegistrationNames: {
        bubbled: keyOf({onContextMenu: true}),
        captured: keyOf({onContextMenuCapture: true})
      }},
    copy: {phasedRegistrationNames: {
        bubbled: keyOf({onCopy: true}),
        captured: keyOf({onCopyCapture: true})
      }},
    cut: {phasedRegistrationNames: {
        bubbled: keyOf({onCut: true}),
        captured: keyOf({onCutCapture: true})
      }},
    doubleClick: {phasedRegistrationNames: {
        bubbled: keyOf({onDoubleClick: true}),
        captured: keyOf({onDoubleClickCapture: true})
      }},
    drag: {phasedRegistrationNames: {
        bubbled: keyOf({onDrag: true}),
        captured: keyOf({onDragCapture: true})
      }},
    dragEnd: {phasedRegistrationNames: {
        bubbled: keyOf({onDragEnd: true}),
        captured: keyOf({onDragEndCapture: true})
      }},
    dragEnter: {phasedRegistrationNames: {
        bubbled: keyOf({onDragEnter: true}),
        captured: keyOf({onDragEnterCapture: true})
      }},
    dragExit: {phasedRegistrationNames: {
        bubbled: keyOf({onDragExit: true}),
        captured: keyOf({onDragExitCapture: true})
      }},
    dragLeave: {phasedRegistrationNames: {
        bubbled: keyOf({onDragLeave: true}),
        captured: keyOf({onDragLeaveCapture: true})
      }},
    dragOver: {phasedRegistrationNames: {
        bubbled: keyOf({onDragOver: true}),
        captured: keyOf({onDragOverCapture: true})
      }},
    dragStart: {phasedRegistrationNames: {
        bubbled: keyOf({onDragStart: true}),
        captured: keyOf({onDragStartCapture: true})
      }},
    drop: {phasedRegistrationNames: {
        bubbled: keyOf({onDrop: true}),
        captured: keyOf({onDropCapture: true})
      }},
    durationChange: {phasedRegistrationNames: {
        bubbled: keyOf({onDurationChange: true}),
        captured: keyOf({onDurationChangeCapture: true})
      }},
    emptied: {phasedRegistrationNames: {
        bubbled: keyOf({onEmptied: true}),
        captured: keyOf({onEmptiedCapture: true})
      }},
    encrypted: {phasedRegistrationNames: {
        bubbled: keyOf({onEncrypted: true}),
        captured: keyOf({onEncryptedCapture: true})
      }},
    ended: {phasedRegistrationNames: {
        bubbled: keyOf({onEnded: true}),
        captured: keyOf({onEndedCapture: true})
      }},
    error: {phasedRegistrationNames: {
        bubbled: keyOf({onError: true}),
        captured: keyOf({onErrorCapture: true})
      }},
    focus: {phasedRegistrationNames: {
        bubbled: keyOf({onFocus: true}),
        captured: keyOf({onFocusCapture: true})
      }},
    input: {phasedRegistrationNames: {
        bubbled: keyOf({onInput: true}),
        captured: keyOf({onInputCapture: true})
      }},
    invalid: {phasedRegistrationNames: {
        bubbled: keyOf({onInvalid: true}),
        captured: keyOf({onInvalidCapture: true})
      }},
    keyDown: {phasedRegistrationNames: {
        bubbled: keyOf({onKeyDown: true}),
        captured: keyOf({onKeyDownCapture: true})
      }},
    keyPress: {phasedRegistrationNames: {
        bubbled: keyOf({onKeyPress: true}),
        captured: keyOf({onKeyPressCapture: true})
      }},
    keyUp: {phasedRegistrationNames: {
        bubbled: keyOf({onKeyUp: true}),
        captured: keyOf({onKeyUpCapture: true})
      }},
    load: {phasedRegistrationNames: {
        bubbled: keyOf({onLoad: true}),
        captured: keyOf({onLoadCapture: true})
      }},
    loadedData: {phasedRegistrationNames: {
        bubbled: keyOf({onLoadedData: true}),
        captured: keyOf({onLoadedDataCapture: true})
      }},
    loadedMetadata: {phasedRegistrationNames: {
        bubbled: keyOf({onLoadedMetadata: true}),
        captured: keyOf({onLoadedMetadataCapture: true})
      }},
    loadStart: {phasedRegistrationNames: {
        bubbled: keyOf({onLoadStart: true}),
        captured: keyOf({onLoadStartCapture: true})
      }},
    mouseDown: {phasedRegistrationNames: {
        bubbled: keyOf({onMouseDown: true}),
        captured: keyOf({onMouseDownCapture: true})
      }},
    mouseMove: {phasedRegistrationNames: {
        bubbled: keyOf({onMouseMove: true}),
        captured: keyOf({onMouseMoveCapture: true})
      }},
    mouseOut: {phasedRegistrationNames: {
        bubbled: keyOf({onMouseOut: true}),
        captured: keyOf({onMouseOutCapture: true})
      }},
    mouseOver: {phasedRegistrationNames: {
        bubbled: keyOf({onMouseOver: true}),
        captured: keyOf({onMouseOverCapture: true})
      }},
    mouseUp: {phasedRegistrationNames: {
        bubbled: keyOf({onMouseUp: true}),
        captured: keyOf({onMouseUpCapture: true})
      }},
    paste: {phasedRegistrationNames: {
        bubbled: keyOf({onPaste: true}),
        captured: keyOf({onPasteCapture: true})
      }},
    pause: {phasedRegistrationNames: {
        bubbled: keyOf({onPause: true}),
        captured: keyOf({onPauseCapture: true})
      }},
    play: {phasedRegistrationNames: {
        bubbled: keyOf({onPlay: true}),
        captured: keyOf({onPlayCapture: true})
      }},
    playing: {phasedRegistrationNames: {
        bubbled: keyOf({onPlaying: true}),
        captured: keyOf({onPlayingCapture: true})
      }},
    progress: {phasedRegistrationNames: {
        bubbled: keyOf({onProgress: true}),
        captured: keyOf({onProgressCapture: true})
      }},
    rateChange: {phasedRegistrationNames: {
        bubbled: keyOf({onRateChange: true}),
        captured: keyOf({onRateChangeCapture: true})
      }},
    reset: {phasedRegistrationNames: {
        bubbled: keyOf({onReset: true}),
        captured: keyOf({onResetCapture: true})
      }},
    scroll: {phasedRegistrationNames: {
        bubbled: keyOf({onScroll: true}),
        captured: keyOf({onScrollCapture: true})
      }},
    seeked: {phasedRegistrationNames: {
        bubbled: keyOf({onSeeked: true}),
        captured: keyOf({onSeekedCapture: true})
      }},
    seeking: {phasedRegistrationNames: {
        bubbled: keyOf({onSeeking: true}),
        captured: keyOf({onSeekingCapture: true})
      }},
    stalled: {phasedRegistrationNames: {
        bubbled: keyOf({onStalled: true}),
        captured: keyOf({onStalledCapture: true})
      }},
    submit: {phasedRegistrationNames: {
        bubbled: keyOf({onSubmit: true}),
        captured: keyOf({onSubmitCapture: true})
      }},
    suspend: {phasedRegistrationNames: {
        bubbled: keyOf({onSuspend: true}),
        captured: keyOf({onSuspendCapture: true})
      }},
    timeUpdate: {phasedRegistrationNames: {
        bubbled: keyOf({onTimeUpdate: true}),
        captured: keyOf({onTimeUpdateCapture: true})
      }},
    touchCancel: {phasedRegistrationNames: {
        bubbled: keyOf({onTouchCancel: true}),
        captured: keyOf({onTouchCancelCapture: true})
      }},
    touchEnd: {phasedRegistrationNames: {
        bubbled: keyOf({onTouchEnd: true}),
        captured: keyOf({onTouchEndCapture: true})
      }},
    touchMove: {phasedRegistrationNames: {
        bubbled: keyOf({onTouchMove: true}),
        captured: keyOf({onTouchMoveCapture: true})
      }},
    touchStart: {phasedRegistrationNames: {
        bubbled: keyOf({onTouchStart: true}),
        captured: keyOf({onTouchStartCapture: true})
      }},
    transitionEnd: {phasedRegistrationNames: {
        bubbled: keyOf({onTransitionEnd: true}),
        captured: keyOf({onTransitionEndCapture: true})
      }},
    volumeChange: {phasedRegistrationNames: {
        bubbled: keyOf({onVolumeChange: true}),
        captured: keyOf({onVolumeChangeCapture: true})
      }},
    waiting: {phasedRegistrationNames: {
        bubbled: keyOf({onWaiting: true}),
        captured: keyOf({onWaitingCapture: true})
      }},
    wheel: {phasedRegistrationNames: {
        bubbled: keyOf({onWheel: true}),
        captured: keyOf({onWheelCapture: true})
      }}
  };
  var topLevelEventsToDispatchConfig = {
    topAbort: eventTypes.abort,
    topAnimationEnd: eventTypes.animationEnd,
    topAnimationIteration: eventTypes.animationIteration,
    topAnimationStart: eventTypes.animationStart,
    topBlur: eventTypes.blur,
    topCanPlay: eventTypes.canPlay,
    topCanPlayThrough: eventTypes.canPlayThrough,
    topClick: eventTypes.click,
    topContextMenu: eventTypes.contextMenu,
    topCopy: eventTypes.copy,
    topCut: eventTypes.cut,
    topDoubleClick: eventTypes.doubleClick,
    topDrag: eventTypes.drag,
    topDragEnd: eventTypes.dragEnd,
    topDragEnter: eventTypes.dragEnter,
    topDragExit: eventTypes.dragExit,
    topDragLeave: eventTypes.dragLeave,
    topDragOver: eventTypes.dragOver,
    topDragStart: eventTypes.dragStart,
    topDrop: eventTypes.drop,
    topDurationChange: eventTypes.durationChange,
    topEmptied: eventTypes.emptied,
    topEncrypted: eventTypes.encrypted,
    topEnded: eventTypes.ended,
    topError: eventTypes.error,
    topFocus: eventTypes.focus,
    topInput: eventTypes.input,
    topInvalid: eventTypes.invalid,
    topKeyDown: eventTypes.keyDown,
    topKeyPress: eventTypes.keyPress,
    topKeyUp: eventTypes.keyUp,
    topLoad: eventTypes.load,
    topLoadedData: eventTypes.loadedData,
    topLoadedMetadata: eventTypes.loadedMetadata,
    topLoadStart: eventTypes.loadStart,
    topMouseDown: eventTypes.mouseDown,
    topMouseMove: eventTypes.mouseMove,
    topMouseOut: eventTypes.mouseOut,
    topMouseOver: eventTypes.mouseOver,
    topMouseUp: eventTypes.mouseUp,
    topPaste: eventTypes.paste,
    topPause: eventTypes.pause,
    topPlay: eventTypes.play,
    topPlaying: eventTypes.playing,
    topProgress: eventTypes.progress,
    topRateChange: eventTypes.rateChange,
    topReset: eventTypes.reset,
    topScroll: eventTypes.scroll,
    topSeeked: eventTypes.seeked,
    topSeeking: eventTypes.seeking,
    topStalled: eventTypes.stalled,
    topSubmit: eventTypes.submit,
    topSuspend: eventTypes.suspend,
    topTimeUpdate: eventTypes.timeUpdate,
    topTouchCancel: eventTypes.touchCancel,
    topTouchEnd: eventTypes.touchEnd,
    topTouchMove: eventTypes.touchMove,
    topTouchStart: eventTypes.touchStart,
    topTransitionEnd: eventTypes.transitionEnd,
    topVolumeChange: eventTypes.volumeChange,
    topWaiting: eventTypes.waiting,
    topWheel: eventTypes.wheel
  };
  for (var type in topLevelEventsToDispatchConfig) {
    topLevelEventsToDispatchConfig[type].dependencies = [type];
  }
  var ON_CLICK_KEY = keyOf({onClick: null});
  var onClickListeners = {};
  var SimpleEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
      if (!dispatchConfig) {
        return null;
      }
      var EventConstructor;
      switch (topLevelType) {
        case topLevelTypes.topAbort:
        case topLevelTypes.topCanPlay:
        case topLevelTypes.topCanPlayThrough:
        case topLevelTypes.topDurationChange:
        case topLevelTypes.topEmptied:
        case topLevelTypes.topEncrypted:
        case topLevelTypes.topEnded:
        case topLevelTypes.topError:
        case topLevelTypes.topInput:
        case topLevelTypes.topInvalid:
        case topLevelTypes.topLoad:
        case topLevelTypes.topLoadedData:
        case topLevelTypes.topLoadedMetadata:
        case topLevelTypes.topLoadStart:
        case topLevelTypes.topPause:
        case topLevelTypes.topPlay:
        case topLevelTypes.topPlaying:
        case topLevelTypes.topProgress:
        case topLevelTypes.topRateChange:
        case topLevelTypes.topReset:
        case topLevelTypes.topSeeked:
        case topLevelTypes.topSeeking:
        case topLevelTypes.topStalled:
        case topLevelTypes.topSubmit:
        case topLevelTypes.topSuspend:
        case topLevelTypes.topTimeUpdate:
        case topLevelTypes.topVolumeChange:
        case topLevelTypes.topWaiting:
          EventConstructor = SyntheticEvent;
          break;
        case topLevelTypes.topKeyPress:
          if (getEventCharCode(nativeEvent) === 0) {
            return null;
          }
        case topLevelTypes.topKeyDown:
        case topLevelTypes.topKeyUp:
          EventConstructor = SyntheticKeyboardEvent;
          break;
        case topLevelTypes.topBlur:
        case topLevelTypes.topFocus:
          EventConstructor = SyntheticFocusEvent;
          break;
        case topLevelTypes.topClick:
          if (nativeEvent.button === 2) {
            return null;
          }
        case topLevelTypes.topContextMenu:
        case topLevelTypes.topDoubleClick:
        case topLevelTypes.topMouseDown:
        case topLevelTypes.topMouseMove:
        case topLevelTypes.topMouseOut:
        case topLevelTypes.topMouseOver:
        case topLevelTypes.topMouseUp:
          EventConstructor = SyntheticMouseEvent;
          break;
        case topLevelTypes.topDrag:
        case topLevelTypes.topDragEnd:
        case topLevelTypes.topDragEnter:
        case topLevelTypes.topDragExit:
        case topLevelTypes.topDragLeave:
        case topLevelTypes.topDragOver:
        case topLevelTypes.topDragStart:
        case topLevelTypes.topDrop:
          EventConstructor = SyntheticDragEvent;
          break;
        case topLevelTypes.topTouchCancel:
        case topLevelTypes.topTouchEnd:
        case topLevelTypes.topTouchMove:
        case topLevelTypes.topTouchStart:
          EventConstructor = SyntheticTouchEvent;
          break;
        case topLevelTypes.topAnimationEnd:
        case topLevelTypes.topAnimationIteration:
        case topLevelTypes.topAnimationStart:
          EventConstructor = SyntheticAnimationEvent;
          break;
        case topLevelTypes.topTransitionEnd:
          EventConstructor = SyntheticTransitionEvent;
          break;
        case topLevelTypes.topScroll:
          EventConstructor = SyntheticUIEvent;
          break;
        case topLevelTypes.topWheel:
          EventConstructor = SyntheticWheelEvent;
          break;
        case topLevelTypes.topCopy:
        case topLevelTypes.topCut:
        case topLevelTypes.topPaste:
          EventConstructor = SyntheticClipboardEvent;
          break;
      }
      !EventConstructor ? "production" !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
      var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    },
    didPutListener: function(inst, registrationName, listener) {
      if (registrationName === ON_CLICK_KEY) {
        var id = inst._rootNodeID;
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        if (!onClickListeners[id]) {
          onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
        }
      }
    },
    willDeleteListener: function(inst, registrationName) {
      if (registrationName === ON_CLICK_KEY) {
        var id = inst._rootNodeID;
        onClickListeners[id].remove();
        delete onClickListeners[id];
      }
    }
  };
  module.exports = SimpleEventPlugin;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDefaultInjection.js", ["./BeforeInputEventPlugin", "./ChangeEventPlugin", "./DefaultEventPluginOrder", "./EnterLeaveEventPlugin", "./HTMLDOMPropertyConfig", "./ReactComponentBrowserEnvironment", "./ReactDOMComponent", "./ReactDOMComponentTree", "./ReactDOMEmptyComponent", "./ReactDOMTreeTraversal", "./ReactDOMTextComponent", "./ReactDefaultBatchingStrategy", "./ReactEventListener", "./ReactInjection", "./ReactReconcileTransaction", "./SVGDOMPropertyConfig", "./SelectEventPlugin", "./SimpleEventPlugin", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var BeforeInputEventPlugin = $__require('./BeforeInputEventPlugin');
  var ChangeEventPlugin = $__require('./ChangeEventPlugin');
  var DefaultEventPluginOrder = $__require('./DefaultEventPluginOrder');
  var EnterLeaveEventPlugin = $__require('./EnterLeaveEventPlugin');
  var HTMLDOMPropertyConfig = $__require('./HTMLDOMPropertyConfig');
  var ReactComponentBrowserEnvironment = $__require('./ReactComponentBrowserEnvironment');
  var ReactDOMComponent = $__require('./ReactDOMComponent');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactDOMEmptyComponent = $__require('./ReactDOMEmptyComponent');
  var ReactDOMTreeTraversal = $__require('./ReactDOMTreeTraversal');
  var ReactDOMTextComponent = $__require('./ReactDOMTextComponent');
  var ReactDefaultBatchingStrategy = $__require('./ReactDefaultBatchingStrategy');
  var ReactEventListener = $__require('./ReactEventListener');
  var ReactInjection = $__require('./ReactInjection');
  var ReactReconcileTransaction = $__require('./ReactReconcileTransaction');
  var SVGDOMPropertyConfig = $__require('./SVGDOMPropertyConfig');
  var SelectEventPlugin = $__require('./SelectEventPlugin');
  var SimpleEventPlugin = $__require('./SimpleEventPlugin');
  var alreadyInjected = false;
  function inject() {
    if (alreadyInjected) {
      return;
    }
    alreadyInjected = true;
    ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
    ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
    ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
    ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
    ReactInjection.EventPluginHub.injectEventPluginsByName({
      SimpleEventPlugin: SimpleEventPlugin,
      EnterLeaveEventPlugin: EnterLeaveEventPlugin,
      ChangeEventPlugin: ChangeEventPlugin,
      SelectEventPlugin: SelectEventPlugin,
      BeforeInputEventPlugin: BeforeInputEventPlugin
    });
    ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
    ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
    ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
    ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
    ReactInjection.EmptyComponent.injectEmptyComponentFactory(function(instantiate) {
      return new ReactDOMEmptyComponent(instantiate);
    });
    ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
    ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
    ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
  }
  module.exports = {inject: inject};
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/findDOMNode.js", ["./reactProdInvariant", "./ReactCurrentOwner", "./ReactDOMComponentTree", "./ReactInstanceMap", "./getHostComponentFromComposite", "fbjs/lib/invariant", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var ReactCurrentOwner = $__require('./ReactCurrentOwner');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactInstanceMap = $__require('./ReactInstanceMap');
  var getHostComponentFromComposite = $__require('./getHostComponentFromComposite');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');
  function findDOMNode(componentOrElement) {
    if ("production" !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        "production" !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
        owner._warnedAboutRefsInRender = true;
      }
    }
    if (componentOrElement == null) {
      return null;
    }
    if (componentOrElement.nodeType === 1) {
      return componentOrElement;
    }
    var inst = ReactInstanceMap.get(componentOrElement);
    if (inst) {
      inst = getHostComponentFromComposite(inst);
      return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
    }
    if (typeof componentOrElement.render === 'function') {
      !false ? "production" !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
    } else {
      !false ? "production" !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
    }
  }
  module.exports = findDOMNode;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/getHostComponentFromComposite.js", ["./ReactNodeTypes", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactNodeTypes = $__require('./ReactNodeTypes');
  function getHostComponentFromComposite(inst) {
    var type;
    while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
      inst = inst._renderedComponent;
    }
    if (type === ReactNodeTypes.HOST) {
      return inst._renderedComponent;
    } else if (type === ReactNodeTypes.EMPTY) {
      return null;
    }
  }
  module.exports = getHostComponentFromComposite;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/escapeTextContentForBrowser.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var matchHtmlRegExp = /["'&<>]/;
  function escapeHtml(string) {
    var str = '' + string;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
      return str;
    }
    var escape;
    var html = '';
    var index = 0;
    var lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          escape = '&quot;';
          break;
        case 38:
          escape = '&amp;';
          break;
        case 39:
          escape = '&#x27;';
          break;
        case 60:
          escape = '&lt;';
          break;
        case 62:
          escape = '&gt;';
          break;
        default:
          continue;
      }
      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }
      lastIndex = index + 1;
      html += escape;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
  function escapeTextContentForBrowser(text) {
    if (typeof text === 'boolean' || typeof text === 'number') {
      return '' + text;
    }
    return escapeHtml(text);
  }
  module.exports = escapeTextContentForBrowser;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/setTextContent.js", ["fbjs/lib/ExecutionEnvironment", "./escapeTextContentForBrowser", "./setInnerHTML", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var escapeTextContentForBrowser = $__require('./escapeTextContentForBrowser');
  var setInnerHTML = $__require('./setInnerHTML');
  var setTextContent = function(node, text) {
    if (text) {
      var firstChild = node.firstChild;
      if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
        firstChild.nodeValue = text;
        return;
      }
    }
    node.textContent = text;
  };
  if (ExecutionEnvironment.canUseDOM) {
    if (!('textContent' in document.documentElement)) {
      setTextContent = function(node, text) {
        setInnerHTML(node, escapeTextContentForBrowser(text));
      };
    }
  }
  module.exports = setTextContent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/DOMLazyTree.js", ["./DOMNamespaces", "./setInnerHTML", "./createMicrosoftUnsafeLocalFunction", "./setTextContent", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMNamespaces = $__require('./DOMNamespaces');
  var setInnerHTML = $__require('./setInnerHTML');
  var createMicrosoftUnsafeLocalFunction = $__require('./createMicrosoftUnsafeLocalFunction');
  var setTextContent = $__require('./setTextContent');
  var ELEMENT_NODE_TYPE = 1;
  var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
  var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
  function insertTreeChildren(tree) {
    if (!enableLazy) {
      return;
    }
    var node = tree.node;
    var children = tree.children;
    if (children.length) {
      for (var i = 0; i < children.length; i++) {
        insertTreeBefore(node, children[i], null);
      }
    } else if (tree.html != null) {
      setInnerHTML(node, tree.html);
    } else if (tree.text != null) {
      setTextContent(node, tree.text);
    }
  }
  var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function(parentNode, tree, referenceNode) {
    if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
      insertTreeChildren(tree);
      parentNode.insertBefore(tree.node, referenceNode);
    } else {
      parentNode.insertBefore(tree.node, referenceNode);
      insertTreeChildren(tree);
    }
  });
  function replaceChildWithTree(oldNode, newTree) {
    oldNode.parentNode.replaceChild(newTree.node, oldNode);
    insertTreeChildren(newTree);
  }
  function queueChild(parentTree, childTree) {
    if (enableLazy) {
      parentTree.children.push(childTree);
    } else {
      parentTree.node.appendChild(childTree.node);
    }
  }
  function queueHTML(tree, html) {
    if (enableLazy) {
      tree.html = html;
    } else {
      setInnerHTML(tree.node, html);
    }
  }
  function queueText(tree, text) {
    if (enableLazy) {
      tree.text = text;
    } else {
      setTextContent(tree.node, text);
    }
  }
  function toString() {
    return this.node.nodeName;
  }
  function DOMLazyTree(node) {
    return {
      node: node,
      children: [],
      html: null,
      text: null,
      toString: toString
    };
  }
  DOMLazyTree.insertTreeBefore = insertTreeBefore;
  DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
  DOMLazyTree.queueChild = queueChild;
  DOMLazyTree.queueHTML = queueHTML;
  DOMLazyTree.queueText = queueText;
  module.exports = DOMLazyTree;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/EventPluginRegistry.js", ["./reactProdInvariant", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var invariant = $__require('fbjs/lib/invariant');
  var EventPluginOrder = null;
  var namesToPlugins = {};
  function recomputePluginOrdering() {
    if (!EventPluginOrder) {
      return;
    }
    for (var pluginName in namesToPlugins) {
      var PluginModule = namesToPlugins[pluginName];
      var pluginIndex = EventPluginOrder.indexOf(pluginName);
      !(pluginIndex > -1) ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
      if (EventPluginRegistry.plugins[pluginIndex]) {
        continue;
      }
      !PluginModule.extractEvents ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
      EventPluginRegistry.plugins[pluginIndex] = PluginModule;
      var publishedEvents = PluginModule.eventTypes;
      for (var eventName in publishedEvents) {
        !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
      }
    }
  }
  function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
    !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? "production" !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
    EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
    var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
    if (phasedRegistrationNames) {
      for (var phaseName in phasedRegistrationNames) {
        if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
          var phasedRegistrationName = phasedRegistrationNames[phaseName];
          publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
        }
      }
      return true;
    } else if (dispatchConfig.registrationName) {
      publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
      return true;
    }
    return false;
  }
  function publishRegistrationName(registrationName, PluginModule, eventName) {
    !!EventPluginRegistry.registrationNameModules[registrationName] ? "production" !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
    EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
    EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
    if ("production" !== 'production') {
      var lowerCasedName = registrationName.toLowerCase();
      EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
      if (registrationName === 'onDoubleClick') {
        EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
      }
    }
  }
  var EventPluginRegistry = {
    plugins: [],
    eventNameDispatchConfigs: {},
    registrationNameModules: {},
    registrationNameDependencies: {},
    possibleRegistrationNames: "production" !== 'production' ? {} : null,
    injectEventPluginOrder: function(InjectedEventPluginOrder) {
      !!EventPluginOrder ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
      EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
      recomputePluginOrdering();
    },
    injectEventPluginsByName: function(injectedNamesToPlugins) {
      var isOrderingDirty = false;
      for (var pluginName in injectedNamesToPlugins) {
        if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
          continue;
        }
        var PluginModule = injectedNamesToPlugins[pluginName];
        if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
          !!namesToPlugins[pluginName] ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
          namesToPlugins[pluginName] = PluginModule;
          isOrderingDirty = true;
        }
      }
      if (isOrderingDirty) {
        recomputePluginOrdering();
      }
    },
    getPluginModuleForEvent: function(event) {
      var dispatchConfig = event.dispatchConfig;
      if (dispatchConfig.registrationName) {
        return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
      }
      for (var phase in dispatchConfig.phasedRegistrationNames) {
        if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
          continue;
        }
        var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
        if (PluginModule) {
          return PluginModule;
        }
      }
      return null;
    },
    _resetEventPlugins: function() {
      EventPluginOrder = null;
      for (var pluginName in namesToPlugins) {
        if (namesToPlugins.hasOwnProperty(pluginName)) {
          delete namesToPlugins[pluginName];
        }
      }
      EventPluginRegistry.plugins.length = 0;
      var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
      for (var eventName in eventNameDispatchConfigs) {
        if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
          delete eventNameDispatchConfigs[eventName];
        }
      }
      var registrationNameModules = EventPluginRegistry.registrationNameModules;
      for (var registrationName in registrationNameModules) {
        if (registrationNameModules.hasOwnProperty(registrationName)) {
          delete registrationNameModules[registrationName];
        }
      }
      if ("production" !== 'production') {
        var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
        for (var lowerCasedName in possibleRegistrationNames) {
          if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
            delete possibleRegistrationNames[lowerCasedName];
          }
        }
      }
    }
  };
  module.exports = EventPluginRegistry;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/EventConstants.js", ["fbjs/lib/keyMirror", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var keyMirror = $__require('fbjs/lib/keyMirror');
  var PropagationPhases = keyMirror({
    bubbled: null,
    captured: null
  });
  var topLevelTypes = keyMirror({
    topAbort: null,
    topAnimationEnd: null,
    topAnimationIteration: null,
    topAnimationStart: null,
    topBlur: null,
    topCanPlay: null,
    topCanPlayThrough: null,
    topChange: null,
    topClick: null,
    topCompositionEnd: null,
    topCompositionStart: null,
    topCompositionUpdate: null,
    topContextMenu: null,
    topCopy: null,
    topCut: null,
    topDoubleClick: null,
    topDrag: null,
    topDragEnd: null,
    topDragEnter: null,
    topDragExit: null,
    topDragLeave: null,
    topDragOver: null,
    topDragStart: null,
    topDrop: null,
    topDurationChange: null,
    topEmptied: null,
    topEncrypted: null,
    topEnded: null,
    topError: null,
    topFocus: null,
    topInput: null,
    topInvalid: null,
    topKeyDown: null,
    topKeyPress: null,
    topKeyUp: null,
    topLoad: null,
    topLoadedData: null,
    topLoadedMetadata: null,
    topLoadStart: null,
    topMouseDown: null,
    topMouseMove: null,
    topMouseOut: null,
    topMouseOver: null,
    topMouseUp: null,
    topPaste: null,
    topPause: null,
    topPlay: null,
    topPlaying: null,
    topProgress: null,
    topRateChange: null,
    topReset: null,
    topScroll: null,
    topSeeked: null,
    topSeeking: null,
    topSelectionChange: null,
    topStalled: null,
    topSubmit: null,
    topSuspend: null,
    topTextInput: null,
    topTimeUpdate: null,
    topTouchCancel: null,
    topTouchEnd: null,
    topTouchMove: null,
    topTouchStart: null,
    topTransitionEnd: null,
    topVolumeChange: null,
    topWaiting: null,
    topWheel: null
  });
  var EventConstants = {
    topLevelTypes: topLevelTypes,
    PropagationPhases: PropagationPhases
  };
  module.exports = EventConstants;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/EventPluginUtils.js", ["./reactProdInvariant", "./EventConstants", "./ReactErrorUtils", "fbjs/lib/invariant", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var EventConstants = $__require('./EventConstants');
  var ReactErrorUtils = $__require('./ReactErrorUtils');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');
  var ComponentTree;
  var TreeTraversal;
  var injection = {
    injectComponentTree: function(Injected) {
      ComponentTree = Injected;
      if ("production" !== 'production') {
        "production" !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
      }
    },
    injectTreeTraversal: function(Injected) {
      TreeTraversal = Injected;
      if ("production" !== 'production') {
        "production" !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
      }
    }
  };
  var topLevelTypes = EventConstants.topLevelTypes;
  function isEndish(topLevelType) {
    return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
  }
  function isMoveish(topLevelType) {
    return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
  }
  function isStartish(topLevelType) {
    return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
  }
  var validateEventDispatches;
  if ("production" !== 'production') {
    validateEventDispatches = function(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;
      var listenersIsArr = Array.isArray(dispatchListeners);
      var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
      var instancesIsArr = Array.isArray(dispatchInstances);
      var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
      "production" !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
    };
  }
  function executeDispatch(event, simulated, listener, inst) {
    var type = event.type || 'unknown-event';
    event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
    if (simulated) {
      ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
    } else {
      ReactErrorUtils.invokeGuardedCallback(type, listener, event);
    }
    event.currentTarget = null;
  }
  function executeDispatchesInOrder(event, simulated) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;
    if ("production" !== 'production') {
      validateEventDispatches(event);
    }
    if (Array.isArray(dispatchListeners)) {
      for (var i = 0; i < dispatchListeners.length; i++) {
        if (event.isPropagationStopped()) {
          break;
        }
        executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
      }
    } else if (dispatchListeners) {
      executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
    }
    event._dispatchListeners = null;
    event._dispatchInstances = null;
  }
  function executeDispatchesInOrderStopAtTrueImpl(event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;
    if ("production" !== 'production') {
      validateEventDispatches(event);
    }
    if (Array.isArray(dispatchListeners)) {
      for (var i = 0; i < dispatchListeners.length; i++) {
        if (event.isPropagationStopped()) {
          break;
        }
        if (dispatchListeners[i](event, dispatchInstances[i])) {
          return dispatchInstances[i];
        }
      }
    } else if (dispatchListeners) {
      if (dispatchListeners(event, dispatchInstances)) {
        return dispatchInstances;
      }
    }
    return null;
  }
  function executeDispatchesInOrderStopAtTrue(event) {
    var ret = executeDispatchesInOrderStopAtTrueImpl(event);
    event._dispatchInstances = null;
    event._dispatchListeners = null;
    return ret;
  }
  function executeDirectDispatch(event) {
    if ("production" !== 'production') {
      validateEventDispatches(event);
    }
    var dispatchListener = event._dispatchListeners;
    var dispatchInstance = event._dispatchInstances;
    !!Array.isArray(dispatchListener) ? "production" !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
    event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
    var res = dispatchListener ? dispatchListener(event) : null;
    event.currentTarget = null;
    event._dispatchListeners = null;
    event._dispatchInstances = null;
    return res;
  }
  function hasDispatches(event) {
    return !!event._dispatchListeners;
  }
  var EventPluginUtils = {
    isEndish: isEndish,
    isMoveish: isMoveish,
    isStartish: isStartish,
    executeDirectDispatch: executeDirectDispatch,
    executeDispatchesInOrder: executeDispatchesInOrder,
    executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
    hasDispatches: hasDispatches,
    getInstanceFromNode: function(node) {
      return ComponentTree.getInstanceFromNode(node);
    },
    getNodeFromInstance: function(node) {
      return ComponentTree.getNodeFromInstance(node);
    },
    isAncestor: function(a, b) {
      return TreeTraversal.isAncestor(a, b);
    },
    getLowestCommonAncestor: function(a, b) {
      return TreeTraversal.getLowestCommonAncestor(a, b);
    },
    getParentInstance: function(inst) {
      return TreeTraversal.getParentInstance(inst);
    },
    traverseTwoPhase: function(target, fn, arg) {
      return TreeTraversal.traverseTwoPhase(target, fn, arg);
    },
    traverseEnterLeave: function(from, to, fn, argFrom, argTo) {
      return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
    },
    injection: injection
  };
  module.exports = EventPluginUtils;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/accumulateInto.js", ["./reactProdInvariant", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var invariant = $__require('fbjs/lib/invariant');
  function accumulateInto(current, next) {
    !(next != null) ? "production" !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
    if (current == null) {
      return next;
    }
    if (Array.isArray(current)) {
      if (Array.isArray(next)) {
        current.push.apply(current, next);
        return current;
      }
      current.push(next);
      return current;
    }
    if (Array.isArray(next)) {
      return [current].concat(next);
    }
    return [current, next];
  }
  module.exports = accumulateInto;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/forEachAccumulated.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function forEachAccumulated(arr, cb, scope) {
    if (Array.isArray(arr)) {
      arr.forEach(cb, scope);
    } else if (arr) {
      cb.call(scope, arr);
    }
  }
  module.exports = forEachAccumulated;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/EventPluginHub.js", ["./reactProdInvariant", "./EventPluginRegistry", "./EventPluginUtils", "./ReactErrorUtils", "./accumulateInto", "./forEachAccumulated", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var EventPluginRegistry = $__require('./EventPluginRegistry');
  var EventPluginUtils = $__require('./EventPluginUtils');
  var ReactErrorUtils = $__require('./ReactErrorUtils');
  var accumulateInto = $__require('./accumulateInto');
  var forEachAccumulated = $__require('./forEachAccumulated');
  var invariant = $__require('fbjs/lib/invariant');
  var listenerBank = {};
  var eventQueue = null;
  var executeDispatchesAndRelease = function(event, simulated) {
    if (event) {
      EventPluginUtils.executeDispatchesInOrder(event, simulated);
      if (!event.isPersistent()) {
        event.constructor.release(event);
      }
    }
  };
  var executeDispatchesAndReleaseSimulated = function(e) {
    return executeDispatchesAndRelease(e, true);
  };
  var executeDispatchesAndReleaseTopLevel = function(e) {
    return executeDispatchesAndRelease(e, false);
  };
  var EventPluginHub = {
    injection: {
      injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
      injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
    },
    putListener: function(inst, registrationName, listener) {
      !(typeof listener === 'function') ? "production" !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;
      var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
      bankForRegistrationName[inst._rootNodeID] = listener;
      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.didPutListener) {
        PluginModule.didPutListener(inst, registrationName, listener);
      }
    },
    getListener: function(inst, registrationName) {
      var bankForRegistrationName = listenerBank[registrationName];
      return bankForRegistrationName && bankForRegistrationName[inst._rootNodeID];
    },
    deleteListener: function(inst, registrationName) {
      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(inst, registrationName);
      }
      var bankForRegistrationName = listenerBank[registrationName];
      if (bankForRegistrationName) {
        delete bankForRegistrationName[inst._rootNodeID];
      }
    },
    deleteAllListeners: function(inst) {
      for (var registrationName in listenerBank) {
        if (!listenerBank.hasOwnProperty(registrationName)) {
          continue;
        }
        if (!listenerBank[registrationName][inst._rootNodeID]) {
          continue;
        }
        var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
        if (PluginModule && PluginModule.willDeleteListener) {
          PluginModule.willDeleteListener(inst, registrationName);
        }
        delete listenerBank[registrationName][inst._rootNodeID];
      }
    },
    extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var events;
      var plugins = EventPluginRegistry.plugins;
      for (var i = 0; i < plugins.length; i++) {
        var possiblePlugin = plugins[i];
        if (possiblePlugin) {
          var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
          if (extractedEvents) {
            events = accumulateInto(events, extractedEvents);
          }
        }
      }
      return events;
    },
    enqueueEvents: function(events) {
      if (events) {
        eventQueue = accumulateInto(eventQueue, events);
      }
    },
    processEventQueue: function(simulated) {
      var processingEventQueue = eventQueue;
      eventQueue = null;
      if (simulated) {
        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
      } else {
        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
      }
      !!eventQueue ? "production" !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
      ReactErrorUtils.rethrowCaughtError();
    },
    __purge: function() {
      listenerBank = {};
    },
    __getListenerBank: function() {
      return listenerBank;
    }
  };
  module.exports = EventPluginHub;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactEventEmitterMixin.js", ["./EventPluginHub", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var EventPluginHub = $__require('./EventPluginHub');
  function runEventQueueInBatch(events) {
    EventPluginHub.enqueueEvents(events);
    EventPluginHub.processEventQueue(false);
  }
  var ReactEventEmitterMixin = {handleTopLevel: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      runEventQueueInBatch(events);
    }};
  module.exports = ReactEventEmitterMixin;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ViewportMetrics.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ViewportMetrics = {
    currentScrollLeft: 0,
    currentScrollTop: 0,
    refreshScrollValues: function(scrollPosition) {
      ViewportMetrics.currentScrollLeft = scrollPosition.x;
      ViewportMetrics.currentScrollTop = scrollPosition.y;
    }
  };
  module.exports = ViewportMetrics;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/getVendorPrefixedEventName.js", ["fbjs/lib/ExecutionEnvironment", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};
    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes['Webkit' + styleProp] = 'webkit' + eventName;
    prefixes['Moz' + styleProp] = 'moz' + eventName;
    prefixes['ms' + styleProp] = 'MS' + eventName;
    prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
    return prefixes;
  }
  var vendorPrefixes = {
    animationend: makePrefixMap('Animation', 'AnimationEnd'),
    animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
    animationstart: makePrefixMap('Animation', 'AnimationStart'),
    transitionend: makePrefixMap('Transition', 'TransitionEnd')
  };
  var prefixedEventNames = {};
  var style = {};
  if (ExecutionEnvironment.canUseDOM) {
    style = document.createElement('div').style;
    if (!('AnimationEvent' in window)) {
      delete vendorPrefixes.animationend.animation;
      delete vendorPrefixes.animationiteration.animation;
      delete vendorPrefixes.animationstart.animation;
    }
    if (!('TransitionEvent' in window)) {
      delete vendorPrefixes.transitionend.transition;
    }
  }
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) {
      return prefixedEventNames[eventName];
    } else if (!vendorPrefixes[eventName]) {
      return eventName;
    }
    var prefixMap = vendorPrefixes[eventName];
    for (var styleProp in prefixMap) {
      if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
        return prefixedEventNames[eventName] = prefixMap[styleProp];
      }
    }
    return '';
  }
  module.exports = getVendorPrefixedEventName;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/isEventSupported.js", ["fbjs/lib/ExecutionEnvironment", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var useHasFeature;
  if (ExecutionEnvironment.canUseDOM) {
    useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature('', '') !== true;
  }
  function isEventSupported(eventNameSuffix, capture) {
    if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
      return false;
    }
    var eventName = 'on' + eventNameSuffix;
    var isSupported = eventName in document;
    if (!isSupported) {
      var element = document.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }
    if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
      isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
    }
    return isSupported;
  }
  module.exports = isEventSupported;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactBrowserEventEmitter.js", ["object-assign", "./EventConstants", "./EventPluginRegistry", "./ReactEventEmitterMixin", "./ViewportMetrics", "./getVendorPrefixedEventName", "./isEventSupported", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');
  var EventConstants = $__require('./EventConstants');
  var EventPluginRegistry = $__require('./EventPluginRegistry');
  var ReactEventEmitterMixin = $__require('./ReactEventEmitterMixin');
  var ViewportMetrics = $__require('./ViewportMetrics');
  var getVendorPrefixedEventName = $__require('./getVendorPrefixedEventName');
  var isEventSupported = $__require('./isEventSupported');
  var hasEventPageXY;
  var alreadyListeningTo = {};
  var isMonitoringScrollValue = false;
  var reactTopListenersCounter = 0;
  var topEventMapping = {
    topAbort: 'abort',
    topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
    topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
    topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
    topBlur: 'blur',
    topCanPlay: 'canplay',
    topCanPlayThrough: 'canplaythrough',
    topChange: 'change',
    topClick: 'click',
    topCompositionEnd: 'compositionend',
    topCompositionStart: 'compositionstart',
    topCompositionUpdate: 'compositionupdate',
    topContextMenu: 'contextmenu',
    topCopy: 'copy',
    topCut: 'cut',
    topDoubleClick: 'dblclick',
    topDrag: 'drag',
    topDragEnd: 'dragend',
    topDragEnter: 'dragenter',
    topDragExit: 'dragexit',
    topDragLeave: 'dragleave',
    topDragOver: 'dragover',
    topDragStart: 'dragstart',
    topDrop: 'drop',
    topDurationChange: 'durationchange',
    topEmptied: 'emptied',
    topEncrypted: 'encrypted',
    topEnded: 'ended',
    topError: 'error',
    topFocus: 'focus',
    topInput: 'input',
    topKeyDown: 'keydown',
    topKeyPress: 'keypress',
    topKeyUp: 'keyup',
    topLoadedData: 'loadeddata',
    topLoadedMetadata: 'loadedmetadata',
    topLoadStart: 'loadstart',
    topMouseDown: 'mousedown',
    topMouseMove: 'mousemove',
    topMouseOut: 'mouseout',
    topMouseOver: 'mouseover',
    topMouseUp: 'mouseup',
    topPaste: 'paste',
    topPause: 'pause',
    topPlay: 'play',
    topPlaying: 'playing',
    topProgress: 'progress',
    topRateChange: 'ratechange',
    topScroll: 'scroll',
    topSeeked: 'seeked',
    topSeeking: 'seeking',
    topSelectionChange: 'selectionchange',
    topStalled: 'stalled',
    topSuspend: 'suspend',
    topTextInput: 'textInput',
    topTimeUpdate: 'timeupdate',
    topTouchCancel: 'touchcancel',
    topTouchEnd: 'touchend',
    topTouchMove: 'touchmove',
    topTouchStart: 'touchstart',
    topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
    topVolumeChange: 'volumechange',
    topWaiting: 'waiting',
    topWheel: 'wheel'
  };
  var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
  function getListeningForDocument(mountAt) {
    if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
      mountAt[topListenersIDKey] = reactTopListenersCounter++;
      alreadyListeningTo[mountAt[topListenersIDKey]] = {};
    }
    return alreadyListeningTo[mountAt[topListenersIDKey]];
  }
  var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
    ReactEventListener: null,
    injection: {injectReactEventListener: function(ReactEventListener) {
        ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
        ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
      }},
    setEnabled: function(enabled) {
      if (ReactBrowserEventEmitter.ReactEventListener) {
        ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
      }
    },
    isEnabled: function() {
      return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
    },
    listenTo: function(registrationName, contentDocumentHandle) {
      var mountAt = contentDocumentHandle;
      var isListening = getListeningForDocument(mountAt);
      var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
      var topLevelTypes = EventConstants.topLevelTypes;
      for (var i = 0; i < dependencies.length; i++) {
        var dependency = dependencies[i];
        if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
          if (dependency === topLevelTypes.topWheel) {
            if (isEventSupported('wheel')) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
            } else if (isEventSupported('mousewheel')) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
            } else {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
            }
          } else if (dependency === topLevelTypes.topScroll) {
            if (isEventSupported('scroll', true)) {
              ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
            } else {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
            }
          } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
            if (isEventSupported('focus', true)) {
              ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
              ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
            } else if (isEventSupported('focusin')) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
            }
            isListening[topLevelTypes.topBlur] = true;
            isListening[topLevelTypes.topFocus] = true;
          } else if (topEventMapping.hasOwnProperty(dependency)) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
          }
          isListening[dependency] = true;
        }
      }
    },
    trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
      return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
    },
    trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
      return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
    },
    ensureScrollValueMonitoring: function() {
      if (hasEventPageXY === undefined) {
        hasEventPageXY = document.createEvent && 'pageX' in document.createEvent('MouseEvent');
      }
      if (!hasEventPageXY && !isMonitoringScrollValue) {
        var refresh = ViewportMetrics.refreshScrollValues;
        ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
        isMonitoringScrollValue = true;
      }
    }
  });
  module.exports = ReactBrowserEventEmitter;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/DOMProperty.js", ["./reactProdInvariant", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var invariant = $__require('fbjs/lib/invariant');
  function checkMask(value, bitmask) {
    return (value & bitmask) === bitmask;
  }
  var DOMPropertyInjection = {
    MUST_USE_PROPERTY: 0x1,
    HAS_BOOLEAN_VALUE: 0x4,
    HAS_NUMERIC_VALUE: 0x8,
    HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
    HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
    injectDOMPropertyConfig: function(domPropertyConfig) {
      var Injection = DOMPropertyInjection;
      var Properties = domPropertyConfig.Properties || {};
      var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
      var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
      var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
      var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
      if (domPropertyConfig.isCustomAttribute) {
        DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
      }
      for (var propName in Properties) {
        !!DOMProperty.properties.hasOwnProperty(propName) ? "production" !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
        var lowerCased = propName.toLowerCase();
        var propConfig = Properties[propName];
        var propertyInfo = {
          attributeName: lowerCased,
          attributeNamespace: null,
          propertyName: propName,
          mutationMethod: null,
          mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
          hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
          hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
          hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
          hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
        };
        !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? "production" !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
        if ("production" !== 'production') {
          DOMProperty.getPossibleStandardName[lowerCased] = propName;
        }
        if (DOMAttributeNames.hasOwnProperty(propName)) {
          var attributeName = DOMAttributeNames[propName];
          propertyInfo.attributeName = attributeName;
          if ("production" !== 'production') {
            DOMProperty.getPossibleStandardName[attributeName] = propName;
          }
        }
        if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
          propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
        }
        if (DOMPropertyNames.hasOwnProperty(propName)) {
          propertyInfo.propertyName = DOMPropertyNames[propName];
        }
        if (DOMMutationMethods.hasOwnProperty(propName)) {
          propertyInfo.mutationMethod = DOMMutationMethods[propName];
        }
        DOMProperty.properties[propName] = propertyInfo;
      }
    }
  };
  var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
  var DOMProperty = {
    ID_ATTRIBUTE_NAME: 'data-reactid',
    ROOT_ATTRIBUTE_NAME: 'data-reactroot',
    ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
    ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
    properties: {},
    getPossibleStandardName: "production" !== 'production' ? {} : null,
    _isCustomAttributeFunctions: [],
    isCustomAttribute: function(attributeName) {
      for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
        var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
        if (isCustomAttributeFn(attributeName)) {
          return true;
        }
      }
      return false;
    },
    injection: DOMPropertyInjection
  };
  module.exports = DOMProperty;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMComponentFlags.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMComponentFlags = {hasCachedChildNodes: 1 << 0};
  module.exports = ReactDOMComponentFlags;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMComponentTree.js", ["./reactProdInvariant", "./DOMProperty", "./ReactDOMComponentFlags", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var DOMProperty = $__require('./DOMProperty');
  var ReactDOMComponentFlags = $__require('./ReactDOMComponentFlags');
  var invariant = $__require('fbjs/lib/invariant');
  var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
  var Flags = ReactDOMComponentFlags;
  var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
  function getRenderedHostOrTextFromComponent(component) {
    var rendered;
    while (rendered = component._renderedComponent) {
      component = rendered;
    }
    return component;
  }
  function precacheNode(inst, node) {
    var hostInst = getRenderedHostOrTextFromComponent(inst);
    hostInst._hostNode = node;
    node[internalInstanceKey] = hostInst;
  }
  function uncacheNode(inst) {
    var node = inst._hostNode;
    if (node) {
      delete node[internalInstanceKey];
      inst._hostNode = null;
    }
  }
  function precacheChildNodes(inst, node) {
    if (inst._flags & Flags.hasCachedChildNodes) {
      return;
    }
    var children = inst._renderedChildren;
    var childNode = node.firstChild;
    outer: for (var name in children) {
      if (!children.hasOwnProperty(name)) {
        continue;
      }
      var childInst = children[name];
      var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
      if (childID == null) {
        continue;
      }
      for (; childNode !== null; childNode = childNode.nextSibling) {
        if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
          precacheNode(childInst, childNode);
          continue outer;
        }
      }
      !false ? "production" !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
    }
    inst._flags |= Flags.hasCachedChildNodes;
  }
  function getClosestInstanceFromNode(node) {
    if (node[internalInstanceKey]) {
      return node[internalInstanceKey];
    }
    var parents = [];
    while (!node[internalInstanceKey]) {
      parents.push(node);
      if (node.parentNode) {
        node = node.parentNode;
      } else {
        return null;
      }
    }
    var closest;
    var inst;
    for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
      closest = inst;
      if (parents.length) {
        precacheChildNodes(inst, node);
      }
    }
    return closest;
  }
  function getInstanceFromNode(node) {
    var inst = getClosestInstanceFromNode(node);
    if (inst != null && inst._hostNode === node) {
      return inst;
    } else {
      return null;
    }
  }
  function getNodeFromInstance(inst) {
    !(inst._hostNode !== undefined) ? "production" !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
    if (inst._hostNode) {
      return inst._hostNode;
    }
    var parents = [];
    while (!inst._hostNode) {
      parents.push(inst);
      !inst._hostParent ? "production" !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
      inst = inst._hostParent;
    }
    for (; parents.length; inst = parents.pop()) {
      precacheChildNodes(inst, inst._hostNode);
    }
    return inst._hostNode;
  }
  var ReactDOMComponentTree = {
    getClosestInstanceFromNode: getClosestInstanceFromNode,
    getInstanceFromNode: getInstanceFromNode,
    getNodeFromInstance: getNodeFromInstance,
    precacheChildNodes: precacheChildNodes,
    precacheNode: precacheNode,
    uncacheNode: uncacheNode
  };
  module.exports = ReactDOMComponentTree;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/validateDOMNesting.js", ["object-assign", "fbjs/lib/emptyFunction", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');
  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var warning = $__require('fbjs/lib/warning');
  var validateDOMNesting = emptyFunction;
  if ("production" !== 'production') {
    var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
    var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template', 'foreignObject', 'desc', 'title'];
    var buttonScopeTags = inScopeTags.concat(['button']);
    var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
    var emptyAncestorInfo = {
      current: null,
      formTag: null,
      aTagInScope: null,
      buttonTagInScope: null,
      nobrTagInScope: null,
      pTagInButtonScope: null,
      listItemTagAutoclosing: null,
      dlItemTagAutoclosing: null
    };
    var updatedAncestorInfo = function(oldInfo, tag, instance) {
      var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
      var info = {
        tag: tag,
        instance: instance
      };
      if (inScopeTags.indexOf(tag) !== -1) {
        ancestorInfo.aTagInScope = null;
        ancestorInfo.buttonTagInScope = null;
        ancestorInfo.nobrTagInScope = null;
      }
      if (buttonScopeTags.indexOf(tag) !== -1) {
        ancestorInfo.pTagInButtonScope = null;
      }
      if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
        ancestorInfo.listItemTagAutoclosing = null;
        ancestorInfo.dlItemTagAutoclosing = null;
      }
      ancestorInfo.current = info;
      if (tag === 'form') {
        ancestorInfo.formTag = info;
      }
      if (tag === 'a') {
        ancestorInfo.aTagInScope = info;
      }
      if (tag === 'button') {
        ancestorInfo.buttonTagInScope = info;
      }
      if (tag === 'nobr') {
        ancestorInfo.nobrTagInScope = info;
      }
      if (tag === 'p') {
        ancestorInfo.pTagInButtonScope = info;
      }
      if (tag === 'li') {
        ancestorInfo.listItemTagAutoclosing = info;
      }
      if (tag === 'dd' || tag === 'dt') {
        ancestorInfo.dlItemTagAutoclosing = info;
      }
      return ancestorInfo;
    };
    var isTagValidWithParent = function(tag, parentTag) {
      switch (parentTag) {
        case 'select':
          return tag === 'option' || tag === 'optgroup' || tag === '#text';
        case 'optgroup':
          return tag === 'option' || tag === '#text';
        case 'option':
          return tag === '#text';
        case 'tr':
          return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
        case 'tbody':
        case 'thead':
        case 'tfoot':
          return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
        case 'colgroup':
          return tag === 'col' || tag === 'template';
        case 'table':
          return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
        case 'head':
          return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
        case 'html':
          return tag === 'head' || tag === 'body';
        case '#document':
          return tag === 'html';
      }
      switch (tag) {
        case 'h1':
        case 'h2':
        case 'h3':
        case 'h4':
        case 'h5':
        case 'h6':
          return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
        case 'rp':
        case 'rt':
          return impliedEndTags.indexOf(parentTag) === -1;
        case 'body':
        case 'caption':
        case 'col':
        case 'colgroup':
        case 'frame':
        case 'head':
        case 'html':
        case 'tbody':
        case 'td':
        case 'tfoot':
        case 'th':
        case 'thead':
        case 'tr':
          return parentTag == null;
      }
      return true;
    };
    var findInvalidAncestorForTag = function(tag, ancestorInfo) {
      switch (tag) {
        case 'address':
        case 'article':
        case 'aside':
        case 'blockquote':
        case 'center':
        case 'details':
        case 'dialog':
        case 'dir':
        case 'div':
        case 'dl':
        case 'fieldset':
        case 'figcaption':
        case 'figure':
        case 'footer':
        case 'header':
        case 'hgroup':
        case 'main':
        case 'menu':
        case 'nav':
        case 'ol':
        case 'p':
        case 'section':
        case 'summary':
        case 'ul':
        case 'pre':
        case 'listing':
        case 'table':
        case 'hr':
        case 'xmp':
        case 'h1':
        case 'h2':
        case 'h3':
        case 'h4':
        case 'h5':
        case 'h6':
          return ancestorInfo.pTagInButtonScope;
        case 'form':
          return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
        case 'li':
          return ancestorInfo.listItemTagAutoclosing;
        case 'dd':
        case 'dt':
          return ancestorInfo.dlItemTagAutoclosing;
        case 'button':
          return ancestorInfo.buttonTagInScope;
        case 'a':
          return ancestorInfo.aTagInScope;
        case 'nobr':
          return ancestorInfo.nobrTagInScope;
      }
      return null;
    };
    var findOwnerStack = function(instance) {
      if (!instance) {
        return [];
      }
      var stack = [];
      do {
        stack.push(instance);
      } while (instance = instance._currentElement._owner);
      stack.reverse();
      return stack;
    };
    var didWarn = {};
    validateDOMNesting = function(childTag, childInstance, ancestorInfo) {
      ancestorInfo = ancestorInfo || emptyAncestorInfo;
      var parentInfo = ancestorInfo.current;
      var parentTag = parentInfo && parentInfo.tag;
      var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
      var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
      var problematic = invalidParent || invalidAncestor;
      if (problematic) {
        var ancestorTag = problematic.tag;
        var ancestorInstance = problematic.instance;
        var childOwner = childInstance && childInstance._currentElement._owner;
        var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
        var childOwners = findOwnerStack(childOwner);
        var ancestorOwners = findOwnerStack(ancestorOwner);
        var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
        var i;
        var deepestCommon = -1;
        for (i = 0; i < minStackLen; i++) {
          if (childOwners[i] === ancestorOwners[i]) {
            deepestCommon = i;
          } else {
            break;
          }
        }
        var UNKNOWN = '(unknown)';
        var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function(inst) {
          return inst.getName() || UNKNOWN;
        });
        var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function(inst) {
          return inst.getName() || UNKNOWN;
        });
        var ownerInfo = [].concat(deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag, invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
        var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
        if (didWarn[warnKey]) {
          return;
        }
        didWarn[warnKey] = true;
        var tagDisplayName = childTag;
        if (childTag !== '#text') {
          tagDisplayName = '<' + childTag + '>';
        }
        if (invalidParent) {
          var info = '';
          if (ancestorTag === 'table' && childTag === 'tr') {
            info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
          }
          "production" !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>. ' + 'See %s.%s', tagDisplayName, ancestorTag, ownerInfo, info) : void 0;
        } else {
          "production" !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
        }
      }
    };
    validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
    validateDOMNesting.isTagValidInContext = function(tag, ancestorInfo) {
      ancestorInfo = ancestorInfo || emptyAncestorInfo;
      var parentInfo = ancestorInfo.current;
      var parentTag = parentInfo && parentInfo.tag;
      return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
    };
  }
  module.exports = validateDOMNesting;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMContainerInfo.js", ["./validateDOMNesting", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var validateDOMNesting = $__require('./validateDOMNesting');
  var DOC_NODE_TYPE = 9;
  function ReactDOMContainerInfo(topLevelWrapper, node) {
    var info = {
      _topLevelWrapper: topLevelWrapper,
      _idCounter: 1,
      _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
      _node: node,
      _tag: node ? node.nodeName.toLowerCase() : null,
      _namespaceURI: node ? node.namespaceURI : null
    };
    if ("production" !== 'production') {
      info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
    }
    return info;
  }
  module.exports = ReactDOMContainerInfo;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMFeatureFlags.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMFeatureFlags = {useCreateElement: true};
  module.exports = ReactDOMFeatureFlags;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/adler32.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var MOD = 65521;
  function adler32(data) {
    var a = 1;
    var b = 0;
    var i = 0;
    var l = data.length;
    var m = l & ~0x3;
    while (i < m) {
      var n = Math.min(i + 4096, m);
      for (; i < n; i += 4) {
        b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
      }
      a %= MOD;
      b %= MOD;
    }
    for (; i < l; i++) {
      b += a += data.charCodeAt(i);
    }
    a %= MOD;
    b %= MOD;
    return a | b << 16;
  }
  module.exports = adler32;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactMarkupChecksum.js", ["./adler32", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var adler32 = $__require('./adler32');
  var TAG_END = /\/?>/;
  var COMMENT_START = /^<\!\-\-/;
  var ReactMarkupChecksum = {
    CHECKSUM_ATTR_NAME: 'data-react-checksum',
    addChecksumToMarkup: function(markup) {
      var checksum = adler32(markup);
      if (COMMENT_START.test(markup)) {
        return markup;
      } else {
        return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
      }
    },
    canReuseMarkup: function(markup, element) {
      var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
      existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
      var markupChecksum = adler32(markup);
      return markupChecksum === existingChecksum;
    }
  };
  module.exports = ReactMarkupChecksum;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactUpdateQueue.js", ["./reactProdInvariant", "./ReactCurrentOwner", "./ReactInstanceMap", "./ReactInstrumentation", "./ReactUpdates", "fbjs/lib/invariant", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var ReactCurrentOwner = $__require('./ReactCurrentOwner');
  var ReactInstanceMap = $__require('./ReactInstanceMap');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var ReactUpdates = $__require('./ReactUpdates');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');
  function enqueueUpdate(internalInstance) {
    ReactUpdates.enqueueUpdate(internalInstance);
  }
  function formatUnexpectedArgument(arg) {
    var type = typeof arg;
    if (type !== 'object') {
      return type;
    }
    var displayName = arg.constructor && arg.constructor.name || type;
    var keys = Object.keys(arg);
    if (keys.length > 0 && keys.length < 20) {
      return displayName + ' (keys: ' + keys.join(', ') + ')';
    }
    return displayName;
  }
  function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (!internalInstance) {
      if ("production" !== 'production') {
        "production" !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : void 0;
      }
      return null;
    }
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
    }
    return internalInstance;
  }
  var ReactUpdateQueue = {
    isMounted: function(publicInstance) {
      if ("production" !== 'production') {
        var owner = ReactCurrentOwner.current;
        if (owner !== null) {
          "production" !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
          owner._warnedAboutRefsInRender = true;
        }
      }
      var internalInstance = ReactInstanceMap.get(publicInstance);
      if (internalInstance) {
        return !!internalInstance._renderedComponent;
      } else {
        return false;
      }
    },
    enqueueCallback: function(publicInstance, callback, callerName) {
      ReactUpdateQueue.validateCallback(callback, callerName);
      var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
      if (!internalInstance) {
        return null;
      }
      if (internalInstance._pendingCallbacks) {
        internalInstance._pendingCallbacks.push(callback);
      } else {
        internalInstance._pendingCallbacks = [callback];
      }
      enqueueUpdate(internalInstance);
    },
    enqueueCallbackInternal: function(internalInstance, callback) {
      if (internalInstance._pendingCallbacks) {
        internalInstance._pendingCallbacks.push(callback);
      } else {
        internalInstance._pendingCallbacks = [callback];
      }
      enqueueUpdate(internalInstance);
    },
    enqueueForceUpdate: function(publicInstance) {
      var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
      if (!internalInstance) {
        return;
      }
      internalInstance._pendingForceUpdate = true;
      enqueueUpdate(internalInstance);
    },
    enqueueReplaceState: function(publicInstance, completeState) {
      var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
      if (!internalInstance) {
        return;
      }
      internalInstance._pendingStateQueue = [completeState];
      internalInstance._pendingReplaceState = true;
      enqueueUpdate(internalInstance);
    },
    enqueueSetState: function(publicInstance, partialState) {
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onSetState();
        "production" !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
      }
      var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
      if (!internalInstance) {
        return;
      }
      var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
      queue.push(partialState);
      enqueueUpdate(internalInstance);
    },
    enqueueElementInternal: function(internalInstance, nextElement, nextContext) {
      internalInstance._pendingElement = nextElement;
      internalInstance._context = nextContext;
      enqueueUpdate(internalInstance);
    },
    validateCallback: function(callback, callerName) {
      !(!callback || typeof callback === 'function') ? "production" !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
    }
  };
  module.exports = ReactUpdateQueue;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/CallbackQueue.js", ["./reactProdInvariant", "object-assign", "./PooledClass", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');
  var PooledClass = $__require('./PooledClass');
  var invariant = $__require('fbjs/lib/invariant');
  function CallbackQueue() {
    this._callbacks = null;
    this._contexts = null;
  }
  _assign(CallbackQueue.prototype, {
    enqueue: function(callback, context) {
      this._callbacks = this._callbacks || [];
      this._contexts = this._contexts || [];
      this._callbacks.push(callback);
      this._contexts.push(context);
    },
    notifyAll: function() {
      var callbacks = this._callbacks;
      var contexts = this._contexts;
      if (callbacks) {
        !(callbacks.length === contexts.length) ? "production" !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
        this._callbacks = null;
        this._contexts = null;
        for (var i = 0; i < callbacks.length; i++) {
          callbacks[i].call(contexts[i]);
        }
        callbacks.length = 0;
        contexts.length = 0;
      }
    },
    checkpoint: function() {
      return this._callbacks ? this._callbacks.length : 0;
    },
    rollback: function(len) {
      if (this._callbacks) {
        this._callbacks.length = len;
        this._contexts.length = len;
      }
    },
    reset: function() {
      this._callbacks = null;
      this._contexts = null;
    },
    destructor: function() {
      this.reset();
    }
  });
  PooledClass.addPoolingTo(CallbackQueue);
  module.exports = CallbackQueue;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactFeatureFlags.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactFeatureFlags = {logTopLevelRenders: false};
  module.exports = ReactFeatureFlags;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/Transaction.js", ["./reactProdInvariant", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var invariant = $__require('fbjs/lib/invariant');
  var Mixin = {
    reinitializeTransaction: function() {
      this.transactionWrappers = this.getTransactionWrappers();
      if (this.wrapperInitData) {
        this.wrapperInitData.length = 0;
      } else {
        this.wrapperInitData = [];
      }
      this._isInTransaction = false;
    },
    _isInTransaction: false,
    getTransactionWrappers: null,
    isInTransaction: function() {
      return !!this._isInTransaction;
    },
    perform: function(method, scope, a, b, c, d, e, f) {
      !!this.isInTransaction() ? "production" !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
      var errorThrown;
      var ret;
      try {
        this._isInTransaction = true;
        errorThrown = true;
        this.initializeAll(0);
        ret = method.call(scope, a, b, c, d, e, f);
        errorThrown = false;
      } finally {
        try {
          if (errorThrown) {
            try {
              this.closeAll(0);
            } catch (err) {}
          } else {
            this.closeAll(0);
          }
        } finally {
          this._isInTransaction = false;
        }
      }
      return ret;
    },
    initializeAll: function(startIndex) {
      var transactionWrappers = this.transactionWrappers;
      for (var i = startIndex; i < transactionWrappers.length; i++) {
        var wrapper = transactionWrappers[i];
        try {
          this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
          this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
        } finally {
          if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
            try {
              this.initializeAll(i + 1);
            } catch (err) {}
          }
        }
      }
    },
    closeAll: function(startIndex) {
      !this.isInTransaction() ? "production" !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
      var transactionWrappers = this.transactionWrappers;
      for (var i = startIndex; i < transactionWrappers.length; i++) {
        var wrapper = transactionWrappers[i];
        var initData = this.wrapperInitData[i];
        var errorThrown;
        try {
          errorThrown = true;
          if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
            wrapper.close.call(this, initData);
          }
          errorThrown = false;
        } finally {
          if (errorThrown) {
            try {
              this.closeAll(i + 1);
            } catch (e) {}
          }
        }
      }
      this.wrapperInitData.length = 0;
    }
  };
  var Transaction = {
    Mixin: Mixin,
    OBSERVED_ERROR: {}
  };
  module.exports = Transaction;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactUpdates.js", ["./reactProdInvariant", "object-assign", "./CallbackQueue", "./PooledClass", "./ReactFeatureFlags", "./ReactReconciler", "./Transaction", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');
  var CallbackQueue = $__require('./CallbackQueue');
  var PooledClass = $__require('./PooledClass');
  var ReactFeatureFlags = $__require('./ReactFeatureFlags');
  var ReactReconciler = $__require('./ReactReconciler');
  var Transaction = $__require('./Transaction');
  var invariant = $__require('fbjs/lib/invariant');
  var dirtyComponents = [];
  var updateBatchNumber = 0;
  var asapCallbackQueue = CallbackQueue.getPooled();
  var asapEnqueued = false;
  var batchingStrategy = null;
  function ensureInjected() {
    !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
  }
  var NESTED_UPDATES = {
    initialize: function() {
      this.dirtyComponentsLength = dirtyComponents.length;
    },
    close: function() {
      if (this.dirtyComponentsLength !== dirtyComponents.length) {
        dirtyComponents.splice(0, this.dirtyComponentsLength);
        flushBatchedUpdates();
      } else {
        dirtyComponents.length = 0;
      }
    }
  };
  var UPDATE_QUEUEING = {
    initialize: function() {
      this.callbackQueue.reset();
    },
    close: function() {
      this.callbackQueue.notifyAll();
    }
  };
  var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
  function ReactUpdatesFlushTransaction() {
    this.reinitializeTransaction();
    this.dirtyComponentsLength = null;
    this.callbackQueue = CallbackQueue.getPooled();
    this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(true);
  }
  _assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    destructor: function() {
      this.dirtyComponentsLength = null;
      CallbackQueue.release(this.callbackQueue);
      this.callbackQueue = null;
      ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
      this.reconcileTransaction = null;
    },
    perform: function(method, scope, a) {
      return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
    }
  });
  PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
  function batchedUpdates(callback, a, b, c, d, e) {
    ensureInjected();
    batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
  }
  function mountOrderComparator(c1, c2) {
    return c1._mountOrder - c2._mountOrder;
  }
  function runBatchedUpdates(transaction) {
    var len = transaction.dirtyComponentsLength;
    !(len === dirtyComponents.length) ? "production" !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
    dirtyComponents.sort(mountOrderComparator);
    updateBatchNumber++;
    for (var i = 0; i < len; i++) {
      var component = dirtyComponents[i];
      var callbacks = component._pendingCallbacks;
      component._pendingCallbacks = null;
      var markerName;
      if (ReactFeatureFlags.logTopLevelRenders) {
        var namedComponent = component;
        if (component._currentElement.props === component._renderedComponent._currentElement) {
          namedComponent = component._renderedComponent;
        }
        markerName = 'React update: ' + namedComponent.getName();
        console.time(markerName);
      }
      ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
      if (markerName) {
        console.timeEnd(markerName);
      }
      if (callbacks) {
        for (var j = 0; j < callbacks.length; j++) {
          transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
        }
      }
    }
  }
  var flushBatchedUpdates = function() {
    while (dirtyComponents.length || asapEnqueued) {
      if (dirtyComponents.length) {
        var transaction = ReactUpdatesFlushTransaction.getPooled();
        transaction.perform(runBatchedUpdates, null, transaction);
        ReactUpdatesFlushTransaction.release(transaction);
      }
      if (asapEnqueued) {
        asapEnqueued = false;
        var queue = asapCallbackQueue;
        asapCallbackQueue = CallbackQueue.getPooled();
        queue.notifyAll();
        CallbackQueue.release(queue);
      }
    }
  };
  function enqueueUpdate(component) {
    ensureInjected();
    if (!batchingStrategy.isBatchingUpdates) {
      batchingStrategy.batchedUpdates(enqueueUpdate, component);
      return;
    }
    dirtyComponents.push(component);
    if (component._updateBatchNumber == null) {
      component._updateBatchNumber = updateBatchNumber + 1;
    }
  }
  function asap(callback, context) {
    !batchingStrategy.isBatchingUpdates ? "production" !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
    asapCallbackQueue.enqueue(callback, context);
    asapEnqueued = true;
  }
  var ReactUpdatesInjection = {
    injectReconcileTransaction: function(ReconcileTransaction) {
      !ReconcileTransaction ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
      ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
    },
    injectBatchingStrategy: function(_batchingStrategy) {
      !_batchingStrategy ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
      !(typeof _batchingStrategy.batchedUpdates === 'function') ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
      !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
      batchingStrategy = _batchingStrategy;
    }
  };
  var ReactUpdates = {
    ReactReconcileTransaction: null,
    batchedUpdates: batchedUpdates,
    enqueueUpdate: enqueueUpdate,
    flushBatchedUpdates: flushBatchedUpdates,
    injection: ReactUpdatesInjection,
    asap: asap
  };
  module.exports = ReactUpdates;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactComponentEnvironment.js", ["./reactProdInvariant", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var invariant = $__require('fbjs/lib/invariant');
  var injected = false;
  var ReactComponentEnvironment = {
    unmountIDFromEnvironment: null,
    replaceNodeWithMarkup: null,
    processChildrenUpdates: null,
    injection: {injectEnvironment: function(environment) {
        !!injected ? "production" !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
        ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
        ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
        ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
        injected = true;
      }}
  };
  module.exports = ReactComponentEnvironment;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactErrorUtils.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var caughtError = null;
  function invokeGuardedCallback(name, func, a, b) {
    try {
      return func(a, b);
    } catch (x) {
      if (caughtError === null) {
        caughtError = x;
      }
      return undefined;
    }
  }
  var ReactErrorUtils = {
    invokeGuardedCallback: invokeGuardedCallback,
    invokeGuardedCallbackWithCatch: invokeGuardedCallback,
    rethrowCaughtError: function() {
      if (caughtError) {
        var error = caughtError;
        caughtError = null;
        throw error;
      }
    }
  };
  if ("production" !== 'production') {
    if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
      var fakeNode = document.createElement('react');
      ReactErrorUtils.invokeGuardedCallback = function(name, func, a, b) {
        var boundFunc = func.bind(null, a, b);
        var evtType = 'react-' + name;
        fakeNode.addEventListener(evtType, boundFunc, false);
        var evt = document.createEvent('Event');
        evt.initEvent(evtType, false, false);
        fakeNode.dispatchEvent(evt);
        fakeNode.removeEventListener(evtType, boundFunc, false);
      };
    }
  }
  module.exports = ReactErrorUtils;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactInstanceMap.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactInstanceMap = {
    remove: function(key) {
      key._reactInternalInstance = undefined;
    },
    get: function(key) {
      return key._reactInternalInstance;
    },
    has: function(key) {
      return key._reactInternalInstance !== undefined;
    },
    set: function(key, value) {
      key._reactInternalInstance = value;
    }
  };
  module.exports = ReactInstanceMap;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactNodeTypes.js", ["./reactProdInvariant", "./ReactElement", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var ReactElement = $__require('./ReactElement');
  var invariant = $__require('fbjs/lib/invariant');
  var ReactNodeTypes = {
    HOST: 0,
    COMPOSITE: 1,
    EMPTY: 2,
    getType: function(node) {
      if (node === null || node === false) {
        return ReactNodeTypes.EMPTY;
      } else if (ReactElement.isValidElement(node)) {
        if (typeof node.type === 'function') {
          return ReactNodeTypes.COMPOSITE;
        } else {
          return ReactNodeTypes.HOST;
        }
      }
      !false ? "production" !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
    }
  };
  module.exports = ReactNodeTypes;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactOwner.js", ["./reactProdInvariant", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var invariant = $__require('fbjs/lib/invariant');
  var ReactOwner = {
    isValidOwner: function(object) {
      return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
    },
    addComponentAsRefTo: function(component, ref, owner) {
      !ReactOwner.isValidOwner(owner) ? "production" !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
      owner.attachRef(ref, component);
    },
    removeComponentAsRefFrom: function(component, ref, owner) {
      !ReactOwner.isValidOwner(owner) ? "production" !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
      var ownerPublicInstance = owner.getPublicInstance();
      if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
        owner.detachRef(ref);
      }
    }
  };
  module.exports = ReactOwner;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactRef.js", ["./ReactOwner", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactOwner = $__require('./ReactOwner');
  var ReactRef = {};
  function attachRef(ref, component, owner) {
    if (typeof ref === 'function') {
      ref(component.getPublicInstance());
    } else {
      ReactOwner.addComponentAsRefTo(component, ref, owner);
    }
  }
  function detachRef(ref, component, owner) {
    if (typeof ref === 'function') {
      ref(null);
    } else {
      ReactOwner.removeComponentAsRefFrom(component, ref, owner);
    }
  }
  ReactRef.attachRefs = function(instance, element) {
    if (element === null || element === false) {
      return;
    }
    var ref = element.ref;
    if (ref != null) {
      attachRef(ref, instance, element._owner);
    }
  };
  ReactRef.shouldUpdateRefs = function(prevElement, nextElement) {
    var prevEmpty = prevElement === null || prevElement === false;
    var nextEmpty = nextElement === null || nextElement === false;
    return (prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref);
  };
  ReactRef.detachRefs = function(instance, element) {
    if (element === null || element === false) {
      return;
    }
    var ref = element.ref;
    if (ref != null) {
      detachRef(ref, instance, element._owner);
    }
  };
  module.exports = ReactRef;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactReconciler.js", ["./reactProdInvariant", "./ReactRef", "./ReactInstrumentation", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var ReactRef = $__require('./ReactRef');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var invariant = $__require('fbjs/lib/invariant');
  function attachRefs() {
    ReactRef.attachRefs(this, this._currentElement);
  }
  var ReactReconciler = {
    mountComponent: function(internalInstance, transaction, hostParent, hostContainerInfo, context) {
      if ("production" !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement);
          ReactInstrumentation.debugTool.onBeginReconcilerTimer(internalInstance._debugID, 'mountComponent');
        }
      }
      var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context);
      if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
        transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
      }
      if ("production" !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onEndReconcilerTimer(internalInstance._debugID, 'mountComponent');
          ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
        }
      }
      return markup;
    },
    getHostNode: function(internalInstance) {
      return internalInstance.getHostNode();
    },
    unmountComponent: function(internalInstance, safely) {
      if ("production" !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeginReconcilerTimer(internalInstance._debugID, 'unmountComponent');
        }
      }
      ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
      internalInstance.unmountComponent(safely);
      if ("production" !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onEndReconcilerTimer(internalInstance._debugID, 'unmountComponent');
          ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
        }
      }
    },
    receiveComponent: function(internalInstance, nextElement, transaction, context) {
      var prevElement = internalInstance._currentElement;
      if (nextElement === prevElement && context === internalInstance._context) {
        return;
      }
      if ("production" !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
          ReactInstrumentation.debugTool.onBeginReconcilerTimer(internalInstance._debugID, 'receiveComponent');
        }
      }
      var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
      if (refsChanged) {
        ReactRef.detachRefs(internalInstance, prevElement);
      }
      internalInstance.receiveComponent(nextElement, transaction, context);
      if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
        transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
      }
      if ("production" !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onEndReconcilerTimer(internalInstance._debugID, 'receiveComponent');
          ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
        }
      }
    },
    performUpdateIfNecessary: function(internalInstance, transaction, updateBatchNumber) {
      if (internalInstance._updateBatchNumber !== updateBatchNumber) {
        !(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1) ? "production" !== 'production' ? invariant(false, 'performUpdateIfNecessary: Unexpected batch number (current %s, pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : _prodInvariant('121', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
        return;
      }
      if ("production" !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeginReconcilerTimer(internalInstance._debugID, 'performUpdateIfNecessary');
          ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
        }
      }
      internalInstance.performUpdateIfNecessary(transaction);
      if ("production" !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onEndReconcilerTimer(internalInstance._debugID, 'performUpdateIfNecessary');
          ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
        }
      }
    }
  };
  module.exports = ReactReconciler;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactCompositeComponent.js", ["./reactProdInvariant", "object-assign", "./ReactComponentEnvironment", "./ReactCurrentOwner", "./ReactElement", "./ReactErrorUtils", "./ReactInstanceMap", "./ReactInstrumentation", "./ReactNodeTypes", "./ReactPropTypeLocations", "./ReactReconciler", "./checkReactTypeSpec", "fbjs/lib/emptyObject", "fbjs/lib/invariant", "./shouldUpdateReactComponent", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');
  var ReactComponentEnvironment = $__require('./ReactComponentEnvironment');
  var ReactCurrentOwner = $__require('./ReactCurrentOwner');
  var ReactElement = $__require('./ReactElement');
  var ReactErrorUtils = $__require('./ReactErrorUtils');
  var ReactInstanceMap = $__require('./ReactInstanceMap');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var ReactNodeTypes = $__require('./ReactNodeTypes');
  var ReactPropTypeLocations = $__require('./ReactPropTypeLocations');
  var ReactReconciler = $__require('./ReactReconciler');
  var checkReactTypeSpec = $__require('./checkReactTypeSpec');
  var emptyObject = $__require('fbjs/lib/emptyObject');
  var invariant = $__require('fbjs/lib/invariant');
  var shouldUpdateReactComponent = $__require('./shouldUpdateReactComponent');
  var warning = $__require('fbjs/lib/warning');
  function StatelessComponent(Component) {}
  StatelessComponent.prototype.render = function() {
    var Component = ReactInstanceMap.get(this)._currentElement.type;
    var element = Component(this.props, this.context, this.updater);
    warnIfInvalidElement(Component, element);
    return element;
  };
  function warnIfInvalidElement(Component, element) {
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(element === null || element === false || ReactElement.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
      "production" !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
    }
  }
  function invokeComponentDidMountWithTimer() {
    var publicInstance = this._instance;
    if (this._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidMount');
    }
    publicInstance.componentDidMount();
    if (this._debugID !== 0) {
      ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidMount');
    }
  }
  function invokeComponentDidUpdateWithTimer(prevProps, prevState, prevContext) {
    var publicInstance = this._instance;
    if (this._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidUpdate');
    }
    publicInstance.componentDidUpdate(prevProps, prevState, prevContext);
    if (this._debugID !== 0) {
      ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidUpdate');
    }
  }
  function shouldConstruct(Component) {
    return Component.prototype && Component.prototype.isReactComponent;
  }
  var nextMountID = 1;
  var ReactCompositeComponentMixin = {
    construct: function(element) {
      this._currentElement = element;
      this._rootNodeID = null;
      this._instance = null;
      this._hostParent = null;
      this._hostContainerInfo = null;
      this._updateBatchNumber = null;
      this._pendingElement = null;
      this._pendingStateQueue = null;
      this._pendingReplaceState = false;
      this._pendingForceUpdate = false;
      this._renderedNodeType = null;
      this._renderedComponent = null;
      this._context = null;
      this._mountOrder = 0;
      this._topLevelWrapper = null;
      this._pendingCallbacks = null;
      this._calledComponentWillUnmount = false;
      if ("production" !== 'production') {
        this._warnedAboutRefsInRender = false;
      }
    },
    mountComponent: function(transaction, hostParent, hostContainerInfo, context) {
      this._context = context;
      this._mountOrder = nextMountID++;
      this._hostParent = hostParent;
      this._hostContainerInfo = hostContainerInfo;
      var publicProps = this._currentElement.props;
      var publicContext = this._processContext(context);
      var Component = this._currentElement.type;
      var updateQueue = transaction.getUpdateQueue();
      var inst = this._constructComponent(publicProps, publicContext, updateQueue);
      var renderedElement;
      if (!shouldConstruct(Component) && (inst == null || inst.render == null)) {
        renderedElement = inst;
        warnIfInvalidElement(Component, renderedElement);
        !(inst === null || inst === false || ReactElement.isValidElement(inst)) ? "production" !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
        inst = new StatelessComponent(Component);
      }
      if ("production" !== 'production') {
        if (inst.render == null) {
          "production" !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
        }
        var propsMutated = inst.props !== publicProps;
        var componentName = Component.displayName || Component.name || 'Component';
        "production" !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
      }
      inst.props = publicProps;
      inst.context = publicContext;
      inst.refs = emptyObject;
      inst.updater = updateQueue;
      this._instance = inst;
      ReactInstanceMap.set(inst, this);
      if ("production" !== 'production') {
        "production" !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
        "production" !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
        "production" !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
        "production" !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
        "production" !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
        "production" !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
        "production" !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
      }
      var initialState = inst.state;
      if (initialState === undefined) {
        inst.state = initialState = null;
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? "production" !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
      this._pendingStateQueue = null;
      this._pendingReplaceState = false;
      this._pendingForceUpdate = false;
      var markup;
      if (inst.unstable_handleError) {
        markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
      } else {
        markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
      }
      if (inst.componentDidMount) {
        if ("production" !== 'production') {
          transaction.getReactMountReady().enqueue(invokeComponentDidMountWithTimer, this);
        } else {
          transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
        }
      }
      return markup;
    },
    _constructComponent: function(publicProps, publicContext, updateQueue) {
      if ("production" !== 'production') {
        ReactCurrentOwner.current = this;
        try {
          return this._constructComponentWithoutOwner(publicProps, publicContext, updateQueue);
        } finally {
          ReactCurrentOwner.current = null;
        }
      } else {
        return this._constructComponentWithoutOwner(publicProps, publicContext, updateQueue);
      }
    },
    _constructComponentWithoutOwner: function(publicProps, publicContext, updateQueue) {
      var Component = this._currentElement.type;
      var instanceOrElement;
      if (shouldConstruct(Component)) {
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'ctor');
          }
        }
        instanceOrElement = new Component(publicProps, publicContext, updateQueue);
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'ctor');
          }
        }
      } else {
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
          }
        }
        instanceOrElement = Component(publicProps, publicContext, updateQueue);
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
          }
        }
      }
      return instanceOrElement;
    },
    performInitialMountWithErrorHandling: function(renderedElement, hostParent, hostContainerInfo, transaction, context) {
      var markup;
      var checkpoint = transaction.checkpoint();
      try {
        markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
      } catch (e) {
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onError();
          }
        }
        transaction.rollback(checkpoint);
        this._instance.unstable_handleError(e);
        if (this._pendingStateQueue) {
          this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
        }
        checkpoint = transaction.checkpoint();
        this._renderedComponent.unmountComponent(true);
        transaction.rollback(checkpoint);
        markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
      }
      return markup;
    },
    performInitialMount: function(renderedElement, hostParent, hostContainerInfo, transaction, context) {
      var inst = this._instance;
      if (inst.componentWillMount) {
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillMount');
          }
        }
        inst.componentWillMount();
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillMount');
          }
        }
        if (this._pendingStateQueue) {
          inst.state = this._processPendingState(inst.props, inst.context);
        }
      }
      if (renderedElement === undefined) {
        renderedElement = this._renderValidatedComponent();
      }
      var nodeType = ReactNodeTypes.getType(renderedElement);
      this._renderedNodeType = nodeType;
      var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY);
      this._renderedComponent = child;
      if ("production" !== 'production') {
        if (child._debugID !== 0 && this._debugID !== 0) {
          ReactInstrumentation.debugTool.onSetParent(child._debugID, this._debugID);
        }
      }
      var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context));
      if ("production" !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
        }
      }
      return markup;
    },
    getHostNode: function() {
      return ReactReconciler.getHostNode(this._renderedComponent);
    },
    unmountComponent: function(safely) {
      if (!this._renderedComponent) {
        return;
      }
      var inst = this._instance;
      if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
        inst._calledComponentWillUnmount = true;
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUnmount');
          }
        }
        if (safely) {
          var name = this.getName() + '.componentWillUnmount()';
          ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
        } else {
          inst.componentWillUnmount();
        }
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUnmount');
          }
        }
      }
      if (this._renderedComponent) {
        ReactReconciler.unmountComponent(this._renderedComponent, safely);
        this._renderedNodeType = null;
        this._renderedComponent = null;
        this._instance = null;
      }
      this._pendingStateQueue = null;
      this._pendingReplaceState = false;
      this._pendingForceUpdate = false;
      this._pendingCallbacks = null;
      this._pendingElement = null;
      this._context = null;
      this._rootNodeID = null;
      this._topLevelWrapper = null;
      ReactInstanceMap.remove(inst);
    },
    _maskContext: function(context) {
      var Component = this._currentElement.type;
      var contextTypes = Component.contextTypes;
      if (!contextTypes) {
        return emptyObject;
      }
      var maskedContext = {};
      for (var contextName in contextTypes) {
        maskedContext[contextName] = context[contextName];
      }
      return maskedContext;
    },
    _processContext: function(context) {
      var maskedContext = this._maskContext(context);
      if ("production" !== 'production') {
        var Component = this._currentElement.type;
        if (Component.contextTypes) {
          this._checkContextTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
        }
      }
      return maskedContext;
    },
    _processChildContext: function(currentContext) {
      var Component = this._currentElement.type;
      var inst = this._instance;
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
      }
      var childContext = inst.getChildContext && inst.getChildContext();
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onEndProcessingChildContext();
      }
      if (childContext) {
        !(typeof Component.childContextTypes === 'object') ? "production" !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
        if ("production" !== 'production') {
          this._checkContextTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
        }
        for (var name in childContext) {
          !(name in Component.childContextTypes) ? "production" !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
        }
        return _assign({}, currentContext, childContext);
      }
      return currentContext;
    },
    _checkContextTypes: function(typeSpecs, values, location) {
      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
    },
    receiveComponent: function(nextElement, transaction, nextContext) {
      var prevElement = this._currentElement;
      var prevContext = this._context;
      this._pendingElement = null;
      this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
    },
    performUpdateIfNecessary: function(transaction) {
      if (this._pendingElement != null) {
        ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
      } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
        this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
      } else {
        this._updateBatchNumber = null;
      }
    },
    updateComponent: function(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
      var inst = this._instance;
      !(inst != null) ? "production" !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
      var willReceive = false;
      var nextContext;
      var nextProps;
      if (this._context === nextUnmaskedContext) {
        nextContext = inst.context;
      } else {
        nextContext = this._processContext(nextUnmaskedContext);
        willReceive = true;
      }
      nextProps = nextParentElement.props;
      if (prevParentElement !== nextParentElement) {
        willReceive = true;
      }
      if (willReceive && inst.componentWillReceiveProps) {
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
          }
        }
        inst.componentWillReceiveProps(nextProps, nextContext);
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
          }
        }
      }
      var nextState = this._processPendingState(nextProps, nextContext);
      var shouldUpdate = true;
      if (!this._pendingForceUpdate && inst.shouldComponentUpdate) {
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
          }
        }
        shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
          }
        }
      }
      if ("production" !== 'production') {
        "production" !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
      }
      this._updateBatchNumber = null;
      if (shouldUpdate) {
        this._pendingForceUpdate = false;
        this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
      } else {
        this._currentElement = nextParentElement;
        this._context = nextUnmaskedContext;
        inst.props = nextProps;
        inst.state = nextState;
        inst.context = nextContext;
      }
    },
    _processPendingState: function(props, context) {
      var inst = this._instance;
      var queue = this._pendingStateQueue;
      var replace = this._pendingReplaceState;
      this._pendingReplaceState = false;
      this._pendingStateQueue = null;
      if (!queue) {
        return inst.state;
      }
      if (replace && queue.length === 1) {
        return queue[0];
      }
      var nextState = _assign({}, replace ? queue[0] : inst.state);
      for (var i = replace ? 1 : 0; i < queue.length; i++) {
        var partial = queue[i];
        _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
      }
      return nextState;
    },
    _performComponentUpdate: function(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
      var inst = this._instance;
      var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
      var prevProps;
      var prevState;
      var prevContext;
      if (hasComponentDidUpdate) {
        prevProps = inst.props;
        prevState = inst.state;
        prevContext = inst.context;
      }
      if (inst.componentWillUpdate) {
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUpdate');
          }
        }
        inst.componentWillUpdate(nextProps, nextState, nextContext);
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUpdate');
          }
        }
      }
      this._currentElement = nextElement;
      this._context = unmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
      this._updateRenderedComponent(transaction, unmaskedContext);
      if (hasComponentDidUpdate) {
        if ("production" !== 'production') {
          transaction.getReactMountReady().enqueue(invokeComponentDidUpdateWithTimer.bind(this, prevProps, prevState, prevContext), this);
        } else {
          transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
        }
      }
    },
    _updateRenderedComponent: function(transaction, context) {
      var prevComponentInstance = this._renderedComponent;
      var prevRenderedElement = prevComponentInstance._currentElement;
      var nextRenderedElement = this._renderValidatedComponent();
      if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
        ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
      } else {
        var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
        ReactReconciler.unmountComponent(prevComponentInstance, false);
        var nodeType = ReactNodeTypes.getType(nextRenderedElement);
        this._renderedNodeType = nodeType;
        var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY);
        this._renderedComponent = child;
        if ("production" !== 'production') {
          if (child._debugID !== 0 && this._debugID !== 0) {
            ReactInstrumentation.debugTool.onSetParent(child._debugID, this._debugID);
          }
        }
        var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context));
        if ("production" !== 'production') {
          if (this._debugID !== 0) {
            ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
          }
        }
        this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
      }
    },
    _replaceNodeWithMarkup: function(oldHostNode, nextMarkup, prevInstance) {
      ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
    },
    _renderValidatedComponentWithoutOwnerOrContext: function() {
      var inst = this._instance;
      if ("production" !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
        }
      }
      var renderedComponent = inst.render();
      if ("production" !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
        }
      }
      if ("production" !== 'production') {
        if (renderedComponent === undefined && inst.render._isMockFunction) {
          renderedComponent = null;
        }
      }
      return renderedComponent;
    },
    _renderValidatedComponent: function() {
      var renderedComponent;
      ReactCurrentOwner.current = this;
      try {
        renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
      } finally {
        ReactCurrentOwner.current = null;
      }
      !(renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? "production" !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
      return renderedComponent;
    },
    attachRef: function(ref, component) {
      var inst = this.getPublicInstance();
      !(inst != null) ? "production" !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
      var publicComponentInstance = component.getPublicInstance();
      if ("production" !== 'production') {
        var componentName = component && component.getName ? component.getName() : 'a component';
        "production" !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
      }
      var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
      refs[ref] = publicComponentInstance;
    },
    detachRef: function(ref) {
      var refs = this.getPublicInstance().refs;
      delete refs[ref];
    },
    getName: function() {
      var type = this._currentElement.type;
      var constructor = this._instance && this._instance.constructor;
      return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
    },
    getPublicInstance: function() {
      var inst = this._instance;
      if (inst instanceof StatelessComponent) {
        return null;
      }
      return inst;
    },
    _instantiateReactComponent: null
  };
  var ReactCompositeComponent = {Mixin: ReactCompositeComponentMixin};
  module.exports = ReactCompositeComponent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactEmptyComponent.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var emptyComponentFactory;
  var ReactEmptyComponentInjection = {injectEmptyComponentFactory: function(factory) {
      emptyComponentFactory = factory;
    }};
  var ReactEmptyComponent = {create: function(instantiate) {
      return emptyComponentFactory(instantiate);
    }};
  ReactEmptyComponent.injection = ReactEmptyComponentInjection;
  module.exports = ReactEmptyComponent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactHostComponent.js", ["./reactProdInvariant", "object-assign", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');
  var invariant = $__require('fbjs/lib/invariant');
  var genericComponentClass = null;
  var tagToComponentClass = {};
  var textComponentClass = null;
  var ReactHostComponentInjection = {
    injectGenericComponentClass: function(componentClass) {
      genericComponentClass = componentClass;
    },
    injectTextComponentClass: function(componentClass) {
      textComponentClass = componentClass;
    },
    injectComponentClasses: function(componentClasses) {
      _assign(tagToComponentClass, componentClasses);
    }
  };
  function createInternalComponent(element) {
    !genericComponentClass ? "production" !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
    return new genericComponentClass(element);
  }
  function createInstanceForText(text) {
    return new textComponentClass(text);
  }
  function isTextComponent(component) {
    return component instanceof textComponentClass;
  }
  var ReactHostComponent = {
    createInternalComponent: createInternalComponent,
    createInstanceForText: createInstanceForText,
    isTextComponent: isTextComponent,
    injection: ReactHostComponentInjection
  };
  module.exports = ReactHostComponent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactInvalidSetStateWarningDevTool.js", ["fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var warning = $__require('fbjs/lib/warning');
  if ("production" !== 'production') {
    var processingChildContext = false;
    var warnInvalidSetState = function() {
      "production" !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
    };
  }
  var ReactInvalidSetStateWarningDevTool = {
    onBeginProcessingChildContext: function() {
      processingChildContext = true;
    },
    onEndProcessingChildContext: function() {
      processingChildContext = false;
    },
    onSetState: function() {
      warnInvalidSetState();
    }
  };
  module.exports = ReactInvalidSetStateWarningDevTool;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactHostOperationHistoryDevtool.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var history = [];
  var ReactHostOperationHistoryDevtool = {
    onHostOperation: function(debugID, type, payload) {
      history.push({
        instanceID: debugID,
        type: type,
        payload: payload
      });
    },
    clearHistory: function() {
      if (ReactHostOperationHistoryDevtool._preventClearing) {
        return;
      }
      history = [];
    },
    getHistory: function() {
      return history;
    }
  };
  module.exports = ReactHostOperationHistoryDevtool;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/performance.js", ["./ExecutionEnvironment", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('./ExecutionEnvironment');
  var performance;
  if (ExecutionEnvironment.canUseDOM) {
    performance = window.performance || window.msPerformance || window.webkitPerformance;
  }
  module.exports = performance || {};
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/performanceNow.js", ["./performance", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var performance = $__require('./performance');
  var performanceNow;
  if (performance.now) {
    performanceNow = function performanceNow() {
      return performance.now();
    };
  } else {
    performanceNow = function performanceNow() {
      return Date.now();
    };
  }
  module.exports = performanceNow;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDebugTool.js", ["./ReactInvalidSetStateWarningDevTool", "./ReactHostOperationHistoryDevtool", "./ReactComponentTreeDevtool", "fbjs/lib/ExecutionEnvironment", "fbjs/lib/performanceNow", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactInvalidSetStateWarningDevTool = $__require('./ReactInvalidSetStateWarningDevTool');
  var ReactHostOperationHistoryDevtool = $__require('./ReactHostOperationHistoryDevtool');
  var ReactComponentTreeDevtool = $__require('./ReactComponentTreeDevtool');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var performanceNow = $__require('fbjs/lib/performanceNow');
  var warning = $__require('fbjs/lib/warning');
  var eventHandlers = [];
  var handlerDoesThrowForEvent = {};
  function emitEvent(handlerFunctionName, arg1, arg2, arg3, arg4, arg5) {
    eventHandlers.forEach(function(handler) {
      try {
        if (handler[handlerFunctionName]) {
          handler[handlerFunctionName](arg1, arg2, arg3, arg4, arg5);
        }
      } catch (e) {
        "production" !== 'production' ? warning(handlerDoesThrowForEvent[handlerFunctionName], 'exception thrown by devtool while handling %s: %s', handlerFunctionName, e + '\n' + e.stack) : void 0;
        handlerDoesThrowForEvent[handlerFunctionName] = true;
      }
    });
  }
  var isProfiling = false;
  var flushHistory = [];
  var lifeCycleTimerStack = [];
  var currentFlushNesting = 0;
  var currentFlushMeasurements = null;
  var currentFlushStartTime = null;
  var currentTimerDebugID = null;
  var currentTimerStartTime = null;
  var currentTimerNestedFlushDuration = null;
  var currentTimerType = null;
  function clearHistory() {
    ReactComponentTreeDevtool.purgeUnmountedComponents();
    ReactHostOperationHistoryDevtool.clearHistory();
  }
  function getTreeSnapshot(registeredIDs) {
    return registeredIDs.reduce(function(tree, id) {
      var ownerID = ReactComponentTreeDevtool.getOwnerID(id);
      var parentID = ReactComponentTreeDevtool.getParentID(id);
      tree[id] = {
        displayName: ReactComponentTreeDevtool.getDisplayName(id),
        text: ReactComponentTreeDevtool.getText(id),
        updateCount: ReactComponentTreeDevtool.getUpdateCount(id),
        childIDs: ReactComponentTreeDevtool.getChildIDs(id),
        ownerID: ownerID || ReactComponentTreeDevtool.getOwnerID(parentID),
        parentID: parentID
      };
      return tree;
    }, {});
  }
  function resetMeasurements() {
    var previousStartTime = currentFlushStartTime;
    var previousMeasurements = currentFlushMeasurements || [];
    var previousOperations = ReactHostOperationHistoryDevtool.getHistory();
    if (currentFlushNesting === 0) {
      currentFlushStartTime = null;
      currentFlushMeasurements = null;
      clearHistory();
      return;
    }
    if (previousMeasurements.length || previousOperations.length) {
      var registeredIDs = ReactComponentTreeDevtool.getRegisteredIDs();
      flushHistory.push({
        duration: performanceNow() - previousStartTime,
        measurements: previousMeasurements || [],
        operations: previousOperations || [],
        treeSnapshot: getTreeSnapshot(registeredIDs)
      });
    }
    clearHistory();
    currentFlushStartTime = performanceNow();
    currentFlushMeasurements = [];
  }
  function checkDebugID(debugID) {
    "production" !== 'production' ? warning(debugID, 'ReactDebugTool: debugID may not be empty.') : void 0;
  }
  function beginLifeCycleTimer(debugID, timerType) {
    if (currentFlushNesting === 0) {
      return;
    }
    "production" !== 'production' ? warning(!currentTimerType, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    currentTimerStartTime = performanceNow();
    currentTimerNestedFlushDuration = 0;
    currentTimerDebugID = debugID;
    currentTimerType = timerType;
  }
  function endLifeCycleTimer(debugID, timerType) {
    if (currentFlushNesting === 0) {
      return;
    }
    "production" !== 'production' ? warning(currentTimerType === timerType, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    if (isProfiling) {
      currentFlushMeasurements.push({
        timerType: timerType,
        instanceID: debugID,
        duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
      });
    }
    currentTimerStartTime = null;
    currentTimerNestedFlushDuration = null;
    currentTimerDebugID = null;
    currentTimerType = null;
  }
  function pauseCurrentLifeCycleTimer() {
    var currentTimer = {
      startTime: currentTimerStartTime,
      nestedFlushStartTime: performanceNow(),
      debugID: currentTimerDebugID,
      timerType: currentTimerType
    };
    lifeCycleTimerStack.push(currentTimer);
    currentTimerStartTime = null;
    currentTimerNestedFlushDuration = null;
    currentTimerDebugID = null;
    currentTimerType = null;
  }
  function resumeCurrentLifeCycleTimer() {
    var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop();
    var startTime = _lifeCycleTimerStack$.startTime;
    var nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime;
    var debugID = _lifeCycleTimerStack$.debugID;
    var timerType = _lifeCycleTimerStack$.timerType;
    var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
    currentTimerStartTime = startTime;
    currentTimerNestedFlushDuration += nestedFlushDuration;
    currentTimerDebugID = debugID;
    currentTimerType = timerType;
  }
  var ReactDebugTool = {
    addDevtool: function(devtool) {
      eventHandlers.push(devtool);
    },
    removeDevtool: function(devtool) {
      for (var i = 0; i < eventHandlers.length; i++) {
        if (eventHandlers[i] === devtool) {
          eventHandlers.splice(i, 1);
          i--;
        }
      }
    },
    isProfiling: function() {
      return isProfiling;
    },
    beginProfiling: function() {
      if (isProfiling) {
        return;
      }
      isProfiling = true;
      flushHistory.length = 0;
      resetMeasurements();
      ReactDebugTool.addDevtool(ReactHostOperationHistoryDevtool);
    },
    endProfiling: function() {
      if (!isProfiling) {
        return;
      }
      isProfiling = false;
      resetMeasurements();
      ReactDebugTool.removeDevtool(ReactHostOperationHistoryDevtool);
    },
    getFlushHistory: function() {
      return flushHistory;
    },
    onBeginFlush: function() {
      currentFlushNesting++;
      resetMeasurements();
      pauseCurrentLifeCycleTimer();
      emitEvent('onBeginFlush');
    },
    onEndFlush: function() {
      resetMeasurements();
      currentFlushNesting--;
      resumeCurrentLifeCycleTimer();
      emitEvent('onEndFlush');
    },
    onBeginLifeCycleTimer: function(debugID, timerType) {
      checkDebugID(debugID);
      emitEvent('onBeginLifeCycleTimer', debugID, timerType);
      beginLifeCycleTimer(debugID, timerType);
    },
    onEndLifeCycleTimer: function(debugID, timerType) {
      checkDebugID(debugID);
      endLifeCycleTimer(debugID, timerType);
      emitEvent('onEndLifeCycleTimer', debugID, timerType);
    },
    onBeginReconcilerTimer: function(debugID, timerType) {
      checkDebugID(debugID);
      emitEvent('onBeginReconcilerTimer', debugID, timerType);
    },
    onEndReconcilerTimer: function(debugID, timerType) {
      checkDebugID(debugID);
      emitEvent('onEndReconcilerTimer', debugID, timerType);
    },
    onError: function(debugID) {
      if (currentTimerDebugID != null) {
        endLifeCycleTimer(currentTimerDebugID, currentTimerType);
      }
      emitEvent('onError', debugID);
    },
    onBeginProcessingChildContext: function() {
      emitEvent('onBeginProcessingChildContext');
    },
    onEndProcessingChildContext: function() {
      emitEvent('onEndProcessingChildContext');
    },
    onHostOperation: function(debugID, type, payload) {
      checkDebugID(debugID);
      emitEvent('onHostOperation', debugID, type, payload);
    },
    onSetState: function() {
      emitEvent('onSetState');
    },
    onSetDisplayName: function(debugID, displayName) {
      checkDebugID(debugID);
      emitEvent('onSetDisplayName', debugID, displayName);
    },
    onSetChildren: function(debugID, childDebugIDs) {
      checkDebugID(debugID);
      childDebugIDs.forEach(checkDebugID);
      emitEvent('onSetChildren', debugID, childDebugIDs);
    },
    onSetOwner: function(debugID, ownerDebugID) {
      checkDebugID(debugID);
      emitEvent('onSetOwner', debugID, ownerDebugID);
    },
    onSetParent: function(debugID, parentDebugID) {
      checkDebugID(debugID);
      emitEvent('onSetParent', debugID, parentDebugID);
    },
    onSetText: function(debugID, text) {
      checkDebugID(debugID);
      emitEvent('onSetText', debugID, text);
    },
    onMountRootComponent: function(debugID) {
      checkDebugID(debugID);
      emitEvent('onMountRootComponent', debugID);
    },
    onBeforeMountComponent: function(debugID, element) {
      checkDebugID(debugID);
      emitEvent('onBeforeMountComponent', debugID, element);
    },
    onMountComponent: function(debugID) {
      checkDebugID(debugID);
      emitEvent('onMountComponent', debugID);
    },
    onBeforeUpdateComponent: function(debugID, element) {
      checkDebugID(debugID);
      emitEvent('onBeforeUpdateComponent', debugID, element);
    },
    onUpdateComponent: function(debugID) {
      checkDebugID(debugID);
      emitEvent('onUpdateComponent', debugID);
    },
    onUnmountComponent: function(debugID) {
      checkDebugID(debugID);
      emitEvent('onUnmountComponent', debugID);
    },
    onTestEvent: function() {
      emitEvent('onTestEvent');
    }
  };
  ReactDebugTool.addDevtool(ReactInvalidSetStateWarningDevTool);
  ReactDebugTool.addDevtool(ReactComponentTreeDevtool);
  var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
  if (/[?&]react_perf\b/.test(url)) {
    ReactDebugTool.beginProfiling();
  }
  module.exports = ReactDebugTool;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactInstrumentation.js", ["./ReactDebugTool", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var debugTool = null;
  if ("production" !== 'production') {
    var ReactDebugTool = $__require('./ReactDebugTool');
    debugTool = ReactDebugTool;
  }
  module.exports = {debugTool: debugTool};
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/instantiateReactComponent.js", ["./reactProdInvariant", "object-assign", "./ReactCompositeComponent", "./ReactEmptyComponent", "./ReactHostComponent", "./ReactInstrumentation", "fbjs/lib/invariant", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');
  var ReactCompositeComponent = $__require('./ReactCompositeComponent');
  var ReactEmptyComponent = $__require('./ReactEmptyComponent');
  var ReactHostComponent = $__require('./ReactHostComponent');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');
  var ReactCompositeComponentWrapper = function(element) {
    this.construct(element);
  };
  _assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {_instantiateReactComponent: instantiateReactComponent});
  function getDeclarationErrorAddendum(owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  }
  function getDisplayName(instance) {
    var element = instance._currentElement;
    if (element == null) {
      return '#empty';
    } else if (typeof element === 'string' || typeof element === 'number') {
      return '#text';
    } else if (typeof element.type === 'string') {
      return element.type;
    } else if (instance.getName) {
      return instance.getName() || 'Unknown';
    } else {
      return element.type.displayName || element.type.name || 'Unknown';
    }
  }
  function isInternalComponentType(type) {
    return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
  }
  var nextDebugID = 1;
  function instantiateReactComponent(node, shouldHaveDebugID) {
    var instance;
    if (node === null || node === false) {
      instance = ReactEmptyComponent.create(instantiateReactComponent);
    } else if (typeof node === 'object') {
      var element = node;
      !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? "production" !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : void 0;
      if (typeof element.type === 'string') {
        instance = ReactHostComponent.createInternalComponent(element);
      } else if (isInternalComponentType(element.type)) {
        instance = new element.type(element);
        if (!instance.getHostNode) {
          instance.getHostNode = instance.getNativeNode;
        }
      } else {
        instance = new ReactCompositeComponentWrapper(element);
      }
    } else if (typeof node === 'string' || typeof node === 'number') {
      instance = ReactHostComponent.createInstanceForText(node);
    } else {
      !false ? "production" !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
    }
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
    }
    instance._mountIndex = 0;
    instance._mountImage = null;
    if ("production" !== 'production') {
      if (shouldHaveDebugID) {
        var debugID = nextDebugID++;
        instance._debugID = debugID;
        var displayName = getDisplayName(instance);
        ReactInstrumentation.debugTool.onSetDisplayName(debugID, displayName);
        var owner = node && node._owner;
        if (owner) {
          ReactInstrumentation.debugTool.onSetOwner(debugID, owner._debugID);
        }
      } else {
        instance._debugID = 0;
      }
    }
    if ("production" !== 'production') {
      if (Object.preventExtensions) {
        Object.preventExtensions(instance);
      }
    }
    return instance;
  }
  module.exports = instantiateReactComponent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/DOMNamespaces.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMNamespaces = {
    html: 'http://www.w3.org/1999/xhtml',
    mathml: 'http://www.w3.org/1998/Math/MathML',
    svg: 'http://www.w3.org/2000/svg'
  };
  module.exports = DOMNamespaces;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/createMicrosoftUnsafeLocalFunction.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var createMicrosoftUnsafeLocalFunction = function(func) {
    if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
      return function(arg0, arg1, arg2, arg3) {
        MSApp.execUnsafeLocalFunction(function() {
          return func(arg0, arg1, arg2, arg3);
        });
      };
    } else {
      return func;
    }
  };
  module.exports = createMicrosoftUnsafeLocalFunction;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/setInnerHTML.js", ["fbjs/lib/ExecutionEnvironment", "./DOMNamespaces", "./createMicrosoftUnsafeLocalFunction", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var DOMNamespaces = $__require('./DOMNamespaces');
  var WHITESPACE_TEST = /^[ \r\n\t\f]/;
  var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
  var createMicrosoftUnsafeLocalFunction = $__require('./createMicrosoftUnsafeLocalFunction');
  var reusableSVGContainer;
  var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
    if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
      reusableSVGContainer = reusableSVGContainer || document.createElement('div');
      reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
      var newNodes = reusableSVGContainer.firstChild.childNodes;
      for (var i = 0; i < newNodes.length; i++) {
        node.appendChild(newNodes[i]);
      }
    } else {
      node.innerHTML = html;
    }
  });
  if (ExecutionEnvironment.canUseDOM) {
    var testElement = document.createElement('div');
    testElement.innerHTML = ' ';
    if (testElement.innerHTML === '') {
      setInnerHTML = function(node, html) {
        if (node.parentNode) {
          node.parentNode.replaceChild(node, node);
        }
        if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
          node.innerHTML = String.fromCharCode(0xFEFF) + html;
          var textNode = node.firstChild;
          if (textNode.data.length === 1) {
            node.removeChild(textNode);
          } else {
            textNode.deleteData(0, 1);
          }
        } else {
          node.innerHTML = html;
        }
      };
    }
    testElement = null;
  }
  module.exports = setInnerHTML;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/shouldUpdateReactComponent.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function shouldUpdateReactComponent(prevElement, nextElement) {
    var prevEmpty = prevElement === null || prevElement === false;
    var nextEmpty = nextElement === null || nextElement === false;
    if (prevEmpty || nextEmpty) {
      return prevEmpty === nextEmpty;
    }
    var prevType = typeof prevElement;
    var nextType = typeof nextElement;
    if (prevType === 'string' || prevType === 'number') {
      return nextType === 'string' || nextType === 'number';
    } else {
      return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
    }
  }
  module.exports = shouldUpdateReactComponent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactMount.js", ["./reactProdInvariant", "./DOMLazyTree", "./DOMProperty", "./ReactBrowserEventEmitter", "./ReactCurrentOwner", "./ReactDOMComponentTree", "./ReactDOMContainerInfo", "./ReactDOMFeatureFlags", "./ReactElement", "./ReactFeatureFlags", "./ReactInstanceMap", "./ReactInstrumentation", "./ReactMarkupChecksum", "./ReactReconciler", "./ReactUpdateQueue", "./ReactUpdates", "fbjs/lib/emptyObject", "./instantiateReactComponent", "fbjs/lib/invariant", "./setInnerHTML", "./shouldUpdateReactComponent", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var DOMLazyTree = $__require('./DOMLazyTree');
  var DOMProperty = $__require('./DOMProperty');
  var ReactBrowserEventEmitter = $__require('./ReactBrowserEventEmitter');
  var ReactCurrentOwner = $__require('./ReactCurrentOwner');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactDOMContainerInfo = $__require('./ReactDOMContainerInfo');
  var ReactDOMFeatureFlags = $__require('./ReactDOMFeatureFlags');
  var ReactElement = $__require('./ReactElement');
  var ReactFeatureFlags = $__require('./ReactFeatureFlags');
  var ReactInstanceMap = $__require('./ReactInstanceMap');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var ReactMarkupChecksum = $__require('./ReactMarkupChecksum');
  var ReactReconciler = $__require('./ReactReconciler');
  var ReactUpdateQueue = $__require('./ReactUpdateQueue');
  var ReactUpdates = $__require('./ReactUpdates');
  var emptyObject = $__require('fbjs/lib/emptyObject');
  var instantiateReactComponent = $__require('./instantiateReactComponent');
  var invariant = $__require('fbjs/lib/invariant');
  var setInnerHTML = $__require('./setInnerHTML');
  var shouldUpdateReactComponent = $__require('./shouldUpdateReactComponent');
  var warning = $__require('fbjs/lib/warning');
  var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
  var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
  var ELEMENT_NODE_TYPE = 1;
  var DOC_NODE_TYPE = 9;
  var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
  var instancesByReactRootID = {};
  function firstDifferenceIndex(string1, string2) {
    var minLen = Math.min(string1.length, string2.length);
    for (var i = 0; i < minLen; i++) {
      if (string1.charAt(i) !== string2.charAt(i)) {
        return i;
      }
    }
    return string1.length === string2.length ? -1 : minLen;
  }
  function getReactRootElementInContainer(container) {
    if (!container) {
      return null;
    }
    if (container.nodeType === DOC_NODE_TYPE) {
      return container.documentElement;
    } else {
      return container.firstChild;
    }
  }
  function internalGetID(node) {
    return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
  }
  function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
    var markerName;
    if (ReactFeatureFlags.logTopLevelRenders) {
      var wrappedElement = wrapperInstance._currentElement.props;
      var type = wrappedElement.type;
      markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
      console.time(markerName);
    }
    var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context);
    if (markerName) {
      console.timeEnd(markerName);
    }
    wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
    ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
  }
  function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
    var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(!shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
    transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
    ReactUpdates.ReactReconcileTransaction.release(transaction);
  }
  function unmountComponentFromNode(instance, container, safely) {
    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onBeginFlush();
    }
    ReactReconciler.unmountComponent(instance, safely);
    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onEndFlush();
    }
    if (container.nodeType === DOC_NODE_TYPE) {
      container = container.documentElement;
    }
    while (container.lastChild) {
      container.removeChild(container.lastChild);
    }
  }
  function hasNonRootReactChild(container) {
    var rootEl = getReactRootElementInContainer(container);
    if (rootEl) {
      var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
      return !!(inst && inst._hostParent);
    }
  }
  function getHostRootInstanceInContainer(container) {
    var rootEl = getReactRootElementInContainer(container);
    var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
    return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
  }
  function getTopLevelWrapperInContainer(container) {
    var root = getHostRootInstanceInContainer(container);
    return root ? root._hostContainerInfo._topLevelWrapper : null;
  }
  var topLevelRootCounter = 1;
  var TopLevelWrapper = function() {
    this.rootID = topLevelRootCounter++;
  };
  TopLevelWrapper.prototype.isReactComponent = {};
  if ("production" !== 'production') {
    TopLevelWrapper.displayName = 'TopLevelWrapper';
  }
  TopLevelWrapper.prototype.render = function() {
    return this.props;
  };
  var ReactMount = {
    TopLevelWrapper: TopLevelWrapper,
    _instancesByReactRootID: instancesByReactRootID,
    scrollMonitor: function(container, renderCallback) {
      renderCallback();
    },
    _updateRootComponent: function(prevComponent, nextElement, nextContext, container, callback) {
      ReactMount.scrollMonitor(container, function() {
        ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
        if (callback) {
          ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
        }
      });
      return prevComponent;
    },
    _renderNewRootComponent: function(nextElement, container, shouldReuseMarkup, context) {
      "production" !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
      !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? "production" !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
      ReactBrowserEventEmitter.ensureScrollValueMonitoring();
      var componentInstance = instantiateReactComponent(nextElement, false);
      ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
      var wrapperID = componentInstance._instance.rootID;
      instancesByReactRootID[wrapperID] = componentInstance;
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onMountRootComponent(componentInstance._renderedComponent._debugID);
      }
      return componentInstance;
    },
    renderSubtreeIntoContainer: function(parentComponent, nextElement, container, callback) {
      !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? "production" !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
      return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
    },
    _renderSubtreeIntoContainer: function(parentComponent, nextElement, container, callback) {
      ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
      !ReactElement.isValidElement(nextElement) ? "production" !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
      "production" !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
      var nextWrappedElement = ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
      var nextContext;
      if (parentComponent) {
        var parentInst = ReactInstanceMap.get(parentComponent);
        nextContext = parentInst._processChildContext(parentInst._context);
      } else {
        nextContext = emptyObject;
      }
      var prevComponent = getTopLevelWrapperInContainer(container);
      if (prevComponent) {
        var prevWrappedElement = prevComponent._currentElement;
        var prevElement = prevWrappedElement.props;
        if (shouldUpdateReactComponent(prevElement, nextElement)) {
          var publicInst = prevComponent._renderedComponent.getPublicInstance();
          var updatedCallback = callback && function() {
            callback.call(publicInst);
          };
          ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
          return publicInst;
        } else {
          ReactMount.unmountComponentAtNode(container);
        }
      }
      var reactRootElement = getReactRootElementInContainer(container);
      var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
      var containerHasNonRootReactChild = hasNonRootReactChild(container);
      if ("production" !== 'production') {
        "production" !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
        if (!containerHasReactMarkup || reactRootElement.nextSibling) {
          var rootElementSibling = reactRootElement;
          while (rootElementSibling) {
            if (internalGetID(rootElementSibling)) {
              "production" !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
              break;
            }
            rootElementSibling = rootElementSibling.nextSibling;
          }
        }
      }
      var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
      var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
      if (callback) {
        callback.call(component);
      }
      return component;
    },
    render: function(nextElement, container, callback) {
      return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
    },
    unmountComponentAtNode: function(container) {
      "production" !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
      !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? "production" !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
      var prevComponent = getTopLevelWrapperInContainer(container);
      if (!prevComponent) {
        var containerHasNonRootReactChild = hasNonRootReactChild(container);
        var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
        if ("production" !== 'production') {
          "production" !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
        }
        return false;
      }
      delete instancesByReactRootID[prevComponent._instance.rootID];
      ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
      return true;
    },
    _mountImageIntoNode: function(markup, container, instance, shouldReuseMarkup, transaction) {
      !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? "production" !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
      if (shouldReuseMarkup) {
        var rootElement = getReactRootElementInContainer(container);
        if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
          ReactDOMComponentTree.precacheNode(instance, rootElement);
          return;
        } else {
          var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
          rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
          var rootMarkup = rootElement.outerHTML;
          rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
          var normalizedMarkup = markup;
          if ("production" !== 'production') {
            var normalizer;
            if (container.nodeType === ELEMENT_NODE_TYPE) {
              normalizer = document.createElement('div');
              normalizer.innerHTML = markup;
              normalizedMarkup = normalizer.innerHTML;
            } else {
              normalizer = document.createElement('iframe');
              document.body.appendChild(normalizer);
              normalizer.contentDocument.write(markup);
              normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
              document.body.removeChild(normalizer);
            }
          }
          var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
          var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
          !(container.nodeType !== DOC_NODE_TYPE) ? "production" !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
          if ("production" !== 'production') {
            "production" !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
          }
        }
      }
      !(container.nodeType !== DOC_NODE_TYPE) ? "production" !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
      if (transaction.useCreateElement) {
        while (container.lastChild) {
          container.removeChild(container.lastChild);
        }
        DOMLazyTree.insertTreeBefore(container, markup, null);
      } else {
        setInnerHTML(container, markup);
        ReactDOMComponentTree.precacheNode(instance, container.firstChild);
      }
      if ("production" !== 'production') {
        var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
        if (hostNode._debugID !== 0) {
          ReactInstrumentation.debugTool.onHostOperation(hostNode._debugID, 'mount', markup.toString());
        }
      }
    }
  };
  module.exports = ReactMount;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/renderSubtreeIntoContainer.js", ["./ReactMount", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactMount = $__require('./ReactMount');
  module.exports = ReactMount.renderSubtreeIntoContainer;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/ExecutionEnvironment.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  var ExecutionEnvironment = {
    canUseDOM: canUseDOM,
    canUseWorkers: typeof Worker !== 'undefined',
    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
    canUseViewport: canUseDOM && !!window.screen,
    isInWorker: !canUseDOM
  };
  module.exports = ExecutionEnvironment;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOM.js", ["./ReactDOMComponentTree", "./ReactDefaultInjection", "./ReactMount", "./ReactReconciler", "./ReactUpdates", "./ReactVersion", "./findDOMNode", "./getHostComponentFromComposite", "./renderSubtreeIntoContainer", "fbjs/lib/warning", "fbjs/lib/ExecutionEnvironment", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactDefaultInjection = $__require('./ReactDefaultInjection');
  var ReactMount = $__require('./ReactMount');
  var ReactReconciler = $__require('./ReactReconciler');
  var ReactUpdates = $__require('./ReactUpdates');
  var ReactVersion = $__require('./ReactVersion');
  var findDOMNode = $__require('./findDOMNode');
  var getHostComponentFromComposite = $__require('./getHostComponentFromComposite');
  var renderSubtreeIntoContainer = $__require('./renderSubtreeIntoContainer');
  var warning = $__require('fbjs/lib/warning');
  ReactDefaultInjection.inject();
  var React = {
    findDOMNode: findDOMNode,
    render: ReactMount.render,
    unmountComponentAtNode: ReactMount.unmountComponentAtNode,
    version: ReactVersion,
    unstable_batchedUpdates: ReactUpdates.batchedUpdates,
    unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
      ComponentTree: {
        getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
        getNodeFromInstance: function(inst) {
          if (inst._renderedComponent) {
            inst = getHostComponentFromComposite(inst);
          }
          if (inst) {
            return ReactDOMComponentTree.getNodeFromInstance(inst);
          } else {
            return null;
          }
        }
      },
      Mount: ReactMount,
      Reconciler: ReactReconciler
    });
  }
  if ("production" !== 'production') {
    var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
    if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
        if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
          var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
          console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
        }
      }
      var testFunc = function testFn() {};
      "production" !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
      var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
      "production" !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
      var expectedFeatures = [Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim];
      for (var i = 0; i < expectedFeatures.length; i++) {
        if (!expectedFeatures[i]) {
          "production" !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
          break;
        }
      }
    }
  }
  module.exports = React;
  return module.exports;
});

System.registerDynamic("npm:react-dom@15.2.1.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:react-dom@15.2.1/index.js", ["react/lib/ReactDOM"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('react/lib/ReactDOM');
  return module.exports;
});

System.registerDynamic("npm:react-input-autosize@0.6.13.json", [], false, function() {
  return {
    "main": "lib/AutosizeInput.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      },
      "dist/react-input-autosize.js": {
        "cjsRequireDetection": false
      }
    }
  };
});

System.registerDynamic("npm:react-input-autosize@0.6.13/lib/AutosizeInput.js", ["react"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var React = $__require('react');
  var sizerStyle = {
    position: 'absolute',
    visibility: 'hidden',
    height: 0,
    width: 0,
    overflow: 'scroll',
    whiteSpace: 'pre'
  };
  var nextFrame = typeof window !== 'undefined' ? (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
      window.setTimeout(callback, 1000 / 60);
    };
  })().bind(window) : undefined;
  var AutosizeInput = React.createClass({
    displayName: 'AutosizeInput',
    propTypes: {
      value: React.PropTypes.any,
      defaultValue: React.PropTypes.any,
      onChange: React.PropTypes.func,
      style: React.PropTypes.object,
      className: React.PropTypes.string,
      minWidth: React.PropTypes.oneOfType([React.PropTypes.number, React.PropTypes.string]),
      inputStyle: React.PropTypes.object,
      inputClassName: React.PropTypes.string
    },
    getDefaultProps: function getDefaultProps() {
      return {minWidth: 1};
    },
    getInitialState: function getInitialState() {
      return {inputWidth: this.props.minWidth};
    },
    componentDidMount: function componentDidMount() {
      this.copyInputStyles();
      this.updateInputWidth();
    },
    componentDidUpdate: function componentDidUpdate() {
      this.updateInputWidth();
    },
    copyInputStyles: function copyInputStyles() {
      if (!this.isMounted() || !window.getComputedStyle) {
        return;
      }
      var inputStyle = window.getComputedStyle(this.refs.input);
      if (!inputStyle) {
        return;
      }
      var widthNode = this.refs.sizer;
      widthNode.style.fontSize = inputStyle.fontSize;
      widthNode.style.fontFamily = inputStyle.fontFamily;
      widthNode.style.fontWeight = inputStyle.fontWeight;
      widthNode.style.fontStyle = inputStyle.fontStyle;
      widthNode.style.letterSpacing = inputStyle.letterSpacing;
      if (this.props.placeholder) {
        var placeholderNode = this.refs.placeholderSizer;
        placeholderNode.style.fontSize = inputStyle.fontSize;
        placeholderNode.style.fontFamily = inputStyle.fontFamily;
        placeholderNode.style.fontWeight = inputStyle.fontWeight;
        placeholderNode.style.fontStyle = inputStyle.fontStyle;
        placeholderNode.style.letterSpacing = inputStyle.letterSpacing;
      }
    },
    updateInputWidth: function updateInputWidth() {
      if (!this.isMounted() || typeof this.refs.sizer.scrollWidth === 'undefined') {
        return;
      }
      var newInputWidth = undefined;
      if (this.props.placeholder) {
        newInputWidth = Math.max(this.refs.sizer.scrollWidth, this.refs.placeholderSizer.scrollWidth) + 2;
      } else {
        newInputWidth = this.refs.sizer.scrollWidth + 2;
      }
      if (newInputWidth < this.props.minWidth) {
        newInputWidth = this.props.minWidth;
      }
      if (newInputWidth !== this.state.inputWidth) {
        this.setState({inputWidth: newInputWidth});
      }
    },
    getInput: function getInput() {
      return this.refs.input;
    },
    focus: function focus() {
      this.refs.input.focus();
    },
    blur: function blur() {
      this.refs.input.blur();
    },
    select: function select() {
      this.refs.input.select();
    },
    render: function render() {
      var sizerValue = this.props.defaultValue || this.props.value || '';
      var wrapperStyle = this.props.style || {};
      if (!wrapperStyle.display)
        wrapperStyle.display = 'inline-block';
      var inputStyle = _extends({}, this.props.inputStyle);
      inputStyle.width = this.state.inputWidth + 'px';
      inputStyle.boxSizing = 'content-box';
      var placeholder = this.props.placeholder ? React.createElement('div', {
        ref: 'placeholderSizer',
        style: sizerStyle
      }, this.props.placeholder) : null;
      return React.createElement('div', {
        className: this.props.className,
        style: wrapperStyle
      }, React.createElement('input', _extends({}, this.props, {
        ref: 'input',
        className: this.props.inputClassName,
        style: inputStyle
      })), React.createElement('div', {
        ref: 'sizer',
        style: sizerStyle
      }, sizerValue), placeholder);
    }
  });
  module.exports = AutosizeInput;
  return module.exports;
});

System.registerDynamic("npm:react-select@1.0.0-beta13/lib/Option.js", ["react", "classnames"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _classnames = $__require('classnames');
  var _classnames2 = _interopRequireDefault(_classnames);
  var Option = _react2['default'].createClass({
    displayName: 'Option',
    propTypes: {
      children: _react2['default'].PropTypes.node,
      className: _react2['default'].PropTypes.string,
      isDisabled: _react2['default'].PropTypes.bool,
      isFocused: _react2['default'].PropTypes.bool,
      isSelected: _react2['default'].PropTypes.bool,
      onFocus: _react2['default'].PropTypes.func,
      onSelect: _react2['default'].PropTypes.func,
      onUnfocus: _react2['default'].PropTypes.func,
      option: _react2['default'].PropTypes.object.isRequired
    },
    blockEvent: function blockEvent(event) {
      event.preventDefault();
      event.stopPropagation();
      if (event.target.tagName !== 'A' || !('href' in event.target)) {
        return;
      }
      if (event.target.target) {
        window.open(event.target.href, event.target.target);
      } else {
        window.location.href = event.target.href;
      }
    },
    handleMouseDown: function handleMouseDown(event) {
      event.preventDefault();
      event.stopPropagation();
      this.props.onSelect(this.props.option, event);
    },
    handleMouseEnter: function handleMouseEnter(event) {
      this.onFocus(event);
    },
    handleMouseMove: function handleMouseMove(event) {
      this.onFocus(event);
    },
    handleTouchEnd: function handleTouchEnd(event) {
      if (this.dragging)
        return;
      this.handleMouseDown(event);
    },
    handleTouchMove: function handleTouchMove(event) {
      this.dragging = true;
    },
    handleTouchStart: function handleTouchStart(event) {
      this.dragging = false;
    },
    onFocus: function onFocus(event) {
      if (!this.props.isFocused) {
        this.props.onFocus(this.props.option, event);
      }
    },
    render: function render() {
      var option = this.props.option;
      var className = (0, _classnames2['default'])(this.props.className, option.className);
      return option.disabled ? _react2['default'].createElement('div', {
        className: className,
        onMouseDown: this.blockEvent,
        onClick: this.blockEvent
      }, this.props.children) : _react2['default'].createElement('div', {
        className: className,
        style: option.style,
        onMouseDown: this.handleMouseDown,
        onMouseEnter: this.handleMouseEnter,
        onMouseMove: this.handleMouseMove,
        onTouchStart: this.handleTouchStart,
        onTouchMove: this.handleTouchMove,
        onTouchEnd: this.handleTouchEnd,
        title: option.title
      }, this.props.children);
    }
  });
  module.exports = Option;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/PooledClass.js", ["./reactProdInvariant", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var invariant = $__require('fbjs/lib/invariant');
  var oneArgumentPooler = function(copyFieldsFrom) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, copyFieldsFrom);
      return instance;
    } else {
      return new Klass(copyFieldsFrom);
    }
  };
  var twoArgumentPooler = function(a1, a2) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2);
      return instance;
    } else {
      return new Klass(a1, a2);
    }
  };
  var threeArgumentPooler = function(a1, a2, a3) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2, a3);
      return instance;
    } else {
      return new Klass(a1, a2, a3);
    }
  };
  var fourArgumentPooler = function(a1, a2, a3, a4) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2, a3, a4);
      return instance;
    } else {
      return new Klass(a1, a2, a3, a4);
    }
  };
  var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2, a3, a4, a5);
      return instance;
    } else {
      return new Klass(a1, a2, a3, a4, a5);
    }
  };
  var standardReleaser = function(instance) {
    var Klass = this;
    !(instance instanceof Klass) ? "production" !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
    instance.destructor();
    if (Klass.instancePool.length < Klass.poolSize) {
      Klass.instancePool.push(instance);
    }
  };
  var DEFAULT_POOL_SIZE = 10;
  var DEFAULT_POOLER = oneArgumentPooler;
  var addPoolingTo = function(CopyConstructor, pooler) {
    var NewKlass = CopyConstructor;
    NewKlass.instancePool = [];
    NewKlass.getPooled = pooler || DEFAULT_POOLER;
    if (!NewKlass.poolSize) {
      NewKlass.poolSize = DEFAULT_POOL_SIZE;
    }
    NewKlass.release = standardReleaser;
    return NewKlass;
  };
  var PooledClass = {
    addPoolingTo: addPoolingTo,
    oneArgumentPooler: oneArgumentPooler,
    twoArgumentPooler: twoArgumentPooler,
    threeArgumentPooler: threeArgumentPooler,
    fourArgumentPooler: fourArgumentPooler,
    fiveArgumentPooler: fiveArgumentPooler
  };
  module.exports = PooledClass;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/KeyEscapeUtils.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function escape(key) {
    var escapeRegex = /[=:]/g;
    var escaperLookup = {
      '=': '=0',
      ':': '=2'
    };
    var escapedString = ('' + key).replace(escapeRegex, function(match) {
      return escaperLookup[match];
    });
    return '$' + escapedString;
  }
  function unescape(key) {
    var unescapeRegex = /(=0|=2)/g;
    var unescaperLookup = {
      '=0': '=',
      '=2': ':'
    };
    var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
    return ('' + keySubstring).replace(unescapeRegex, function(match) {
      return unescaperLookup[match];
    });
  }
  var KeyEscapeUtils = {
    escape: escape,
    unescape: unescape
  };
  module.exports = KeyEscapeUtils;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/traverseAllChildren.js", ["./reactProdInvariant", "./ReactCurrentOwner", "./ReactElement", "./getIteratorFn", "fbjs/lib/invariant", "./KeyEscapeUtils", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var ReactCurrentOwner = $__require('./ReactCurrentOwner');
  var ReactElement = $__require('./ReactElement');
  var getIteratorFn = $__require('./getIteratorFn');
  var invariant = $__require('fbjs/lib/invariant');
  var KeyEscapeUtils = $__require('./KeyEscapeUtils');
  var warning = $__require('fbjs/lib/warning');
  var SEPARATOR = '.';
  var SUBSEPARATOR = ':';
  var didWarnAboutMaps = false;
  function getComponentKey(component, index) {
    if (component && typeof component === 'object' && component.key != null) {
      return KeyEscapeUtils.escape(component.key);
    }
    return index.toString(36);
  }
  function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
    var type = typeof children;
    if (type === 'undefined' || type === 'boolean') {
      children = null;
    }
    if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
      callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
      return 1;
    }
    var child;
    var nextName;
    var subtreeCount = 0;
    var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        nextName = nextNamePrefix + getComponentKey(child, i);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else {
      var iteratorFn = getIteratorFn(children);
      if (iteratorFn) {
        var iterator = iteratorFn.call(children);
        var step;
        if (iteratorFn !== children.entries) {
          var ii = 0;
          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else {
          if ("production" !== 'production') {
            "production" !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : void 0;
            didWarnAboutMaps = true;
          }
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              child = entry[1];
              nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          }
        }
      } else if (type === 'object') {
        var addendum = '';
        if ("production" !== 'production') {
          addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
          if (children._isReactElement) {
            addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
          }
          if (ReactCurrentOwner.current) {
            var name = ReactCurrentOwner.current.getName();
            if (name) {
              addendum += ' Check the render method of `' + name + '`.';
            }
          }
        }
        var childrenString = String(children);
        !false ? "production" !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
      }
    }
    return subtreeCount;
  }
  function traverseAllChildren(children, callback, traverseContext) {
    if (children == null) {
      return 0;
    }
    return traverseAllChildrenImpl(children, '', callback, traverseContext);
  }
  module.exports = traverseAllChildren;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactChildren.js", ["./PooledClass", "./ReactElement", "fbjs/lib/emptyFunction", "./traverseAllChildren", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var PooledClass = $__require('./PooledClass');
  var ReactElement = $__require('./ReactElement');
  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var traverseAllChildren = $__require('./traverseAllChildren');
  var twoArgumentPooler = PooledClass.twoArgumentPooler;
  var fourArgumentPooler = PooledClass.fourArgumentPooler;
  var userProvidedKeyEscapeRegex = /\/+/g;
  function escapeUserProvidedKey(text) {
    return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
  }
  function ForEachBookKeeping(forEachFunction, forEachContext) {
    this.func = forEachFunction;
    this.context = forEachContext;
    this.count = 0;
  }
  ForEachBookKeeping.prototype.destructor = function() {
    this.func = null;
    this.context = null;
    this.count = 0;
  };
  PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
  function forEachSingleChild(bookKeeping, child, name) {
    var func = bookKeeping.func;
    var context = bookKeeping.context;
    func.call(context, child, bookKeeping.count++);
  }
  function forEachChildren(children, forEachFunc, forEachContext) {
    if (children == null) {
      return children;
    }
    var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
    traverseAllChildren(children, forEachSingleChild, traverseContext);
    ForEachBookKeeping.release(traverseContext);
  }
  function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
    this.result = mapResult;
    this.keyPrefix = keyPrefix;
    this.func = mapFunction;
    this.context = mapContext;
    this.count = 0;
  }
  MapBookKeeping.prototype.destructor = function() {
    this.result = null;
    this.keyPrefix = null;
    this.func = null;
    this.context = null;
    this.count = 0;
  };
  PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
  function mapSingleChildIntoContext(bookKeeping, child, childKey) {
    var result = bookKeeping.result;
    var keyPrefix = bookKeeping.keyPrefix;
    var func = bookKeeping.func;
    var context = bookKeeping.context;
    var mappedChild = func.call(context, child, bookKeeping.count++);
    if (Array.isArray(mappedChild)) {
      mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
    } else if (mappedChild != null) {
      if (ReactElement.isValidElement(mappedChild)) {
        mappedChild = ReactElement.cloneAndReplaceKey(mappedChild, keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
      }
      result.push(mappedChild);
    }
  }
  function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
    var escapedPrefix = '';
    if (prefix != null) {
      escapedPrefix = escapeUserProvidedKey(prefix) + '/';
    }
    var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
    traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
    MapBookKeeping.release(traverseContext);
  }
  function mapChildren(children, func, context) {
    if (children == null) {
      return children;
    }
    var result = [];
    mapIntoWithKeyPrefixInternal(children, result, null, func, context);
    return result;
  }
  function forEachSingleChildDummy(traverseContext, child, name) {
    return null;
  }
  function countChildren(children, context) {
    return traverseAllChildren(children, forEachSingleChildDummy, null);
  }
  function toArray(children) {
    var result = [];
    mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
    return result;
  }
  var ReactChildren = {
    forEach: forEachChildren,
    map: mapChildren,
    mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
    count: countChildren,
    toArray: toArray
  };
  module.exports = ReactChildren;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactComponent.js", ["./reactProdInvariant", "./ReactNoopUpdateQueue", "./canDefineProperty", "fbjs/lib/emptyObject", "fbjs/lib/invariant", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var ReactNoopUpdateQueue = $__require('./ReactNoopUpdateQueue');
  var canDefineProperty = $__require('./canDefineProperty');
  var emptyObject = $__require('fbjs/lib/emptyObject');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');
  function ReactComponent(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  ReactComponent.prototype.isReactComponent = {};
  ReactComponent.prototype.setState = function(partialState, callback) {
    !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? "production" !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
    this.updater.enqueueSetState(this, partialState);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'setState');
    }
  };
  ReactComponent.prototype.forceUpdate = function(callback) {
    this.updater.enqueueForceUpdate(this);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'forceUpdate');
    }
  };
  if ("production" !== 'production') {
    var deprecatedAPIs = {
      isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
      replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
    };
    var defineDeprecationWarning = function(methodName, info) {
      if (canDefineProperty) {
        Object.defineProperty(ReactComponent.prototype, methodName, {get: function() {
            "production" !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
            return undefined;
          }});
      }
    };
    for (var fnName in deprecatedAPIs) {
      if (deprecatedAPIs.hasOwnProperty(fnName)) {
        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      }
    }
  }
  module.exports = ReactComponent;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactNoopUpdateQueue.js", ["fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var warning = $__require('fbjs/lib/warning');
  function warnNoop(publicInstance, callerName) {
    if ("production" !== 'production') {
      var constructor = publicInstance.constructor;
      "production" !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
    }
  }
  var ReactNoopUpdateQueue = {
    isMounted: function(publicInstance) {
      return false;
    },
    enqueueCallback: function(publicInstance, callback) {},
    enqueueForceUpdate: function(publicInstance) {
      warnNoop(publicInstance, 'forceUpdate');
    },
    enqueueReplaceState: function(publicInstance, completeState) {
      warnNoop(publicInstance, 'replaceState');
    },
    enqueueSetState: function(publicInstance, partialState) {
      warnNoop(publicInstance, 'setState');
    }
  };
  module.exports = ReactNoopUpdateQueue;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/emptyObject.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var emptyObject = {};
  if ("production" !== 'production') {
    Object.freeze(emptyObject);
  }
  module.exports = emptyObject;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/keyOf.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var keyOf = function keyOf(oneKeyObj) {
    var key;
    for (key in oneKeyObj) {
      if (!oneKeyObj.hasOwnProperty(key)) {
        continue;
      }
      return key;
    }
    return null;
  };
  module.exports = keyOf;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactClass.js", ["./reactProdInvariant", "object-assign", "./ReactComponent", "./ReactElement", "./ReactPropTypeLocations", "./ReactPropTypeLocationNames", "./ReactNoopUpdateQueue", "fbjs/lib/emptyObject", "fbjs/lib/invariant", "fbjs/lib/keyMirror", "fbjs/lib/keyOf", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');
  var ReactComponent = $__require('./ReactComponent');
  var ReactElement = $__require('./ReactElement');
  var ReactPropTypeLocations = $__require('./ReactPropTypeLocations');
  var ReactPropTypeLocationNames = $__require('./ReactPropTypeLocationNames');
  var ReactNoopUpdateQueue = $__require('./ReactNoopUpdateQueue');
  var emptyObject = $__require('fbjs/lib/emptyObject');
  var invariant = $__require('fbjs/lib/invariant');
  var keyMirror = $__require('fbjs/lib/keyMirror');
  var keyOf = $__require('fbjs/lib/keyOf');
  var warning = $__require('fbjs/lib/warning');
  var MIXINS_KEY = keyOf({mixins: null});
  var SpecPolicy = keyMirror({
    DEFINE_ONCE: null,
    DEFINE_MANY: null,
    OVERRIDE_BASE: null,
    DEFINE_MANY_MERGED: null
  });
  var injectedMixins = [];
  var ReactClassInterface = {
    mixins: SpecPolicy.DEFINE_MANY,
    statics: SpecPolicy.DEFINE_MANY,
    propTypes: SpecPolicy.DEFINE_MANY,
    contextTypes: SpecPolicy.DEFINE_MANY,
    childContextTypes: SpecPolicy.DEFINE_MANY,
    getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
    getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
    getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
    render: SpecPolicy.DEFINE_ONCE,
    componentWillMount: SpecPolicy.DEFINE_MANY,
    componentDidMount: SpecPolicy.DEFINE_MANY,
    componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
    shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
    componentWillUpdate: SpecPolicy.DEFINE_MANY,
    componentDidUpdate: SpecPolicy.DEFINE_MANY,
    componentWillUnmount: SpecPolicy.DEFINE_MANY,
    updateComponent: SpecPolicy.OVERRIDE_BASE
  };
  var RESERVED_SPEC_KEYS = {
    displayName: function(Constructor, displayName) {
      Constructor.displayName = displayName;
    },
    mixins: function(Constructor, mixins) {
      if (mixins) {
        for (var i = 0; i < mixins.length; i++) {
          mixSpecIntoComponent(Constructor, mixins[i]);
        }
      }
    },
    childContextTypes: function(Constructor, childContextTypes) {
      if ("production" !== 'production') {
        validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
      }
      Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
    },
    contextTypes: function(Constructor, contextTypes) {
      if ("production" !== 'production') {
        validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
      }
      Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
    },
    getDefaultProps: function(Constructor, getDefaultProps) {
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
      } else {
        Constructor.getDefaultProps = getDefaultProps;
      }
    },
    propTypes: function(Constructor, propTypes) {
      if ("production" !== 'production') {
        validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
      }
      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
    },
    statics: function(Constructor, statics) {
      mixStaticSpecIntoComponent(Constructor, statics);
    },
    autobind: function() {}
  };
  function validateTypeDef(Constructor, typeDef, location) {
    for (var propName in typeDef) {
      if (typeDef.hasOwnProperty(propName)) {
        "production" !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
      }
    }
  }
  function validateMethodOverride(isAlreadyDefined, name) {
    var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
    if (ReactClassMixin.hasOwnProperty(name)) {
      !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? "production" !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
    }
    if (isAlreadyDefined) {
      !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? "production" !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
    }
  }
  function mixSpecIntoComponent(Constructor, spec) {
    if (!spec) {
      return;
    }
    !(typeof spec !== 'function') ? "production" !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
    !!ReactElement.isValidElement(spec) ? "production" !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;
    var proto = Constructor.prototype;
    var autoBindPairs = proto.__reactAutoBindPairs;
    if (spec.hasOwnProperty(MIXINS_KEY)) {
      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
    }
    for (var name in spec) {
      if (!spec.hasOwnProperty(name)) {
        continue;
      }
      if (name === MIXINS_KEY) {
        continue;
      }
      var property = spec[name];
      var isAlreadyDefined = proto.hasOwnProperty(name);
      validateMethodOverride(isAlreadyDefined, name);
      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
        RESERVED_SPEC_KEYS[name](Constructor, property);
      } else {
        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
        var isFunction = typeof property === 'function';
        var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
        if (shouldAutoBind) {
          autoBindPairs.push(name, property);
          proto[name] = property;
        } else {
          if (isAlreadyDefined) {
            var specPolicy = ReactClassInterface[name];
            !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? "production" !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;
            if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
              proto[name] = createMergedResultFunction(proto[name], property);
            } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
              proto[name] = createChainedFunction(proto[name], property);
            }
          } else {
            proto[name] = property;
            if ("production" !== 'production') {
              if (typeof property === 'function' && spec.displayName) {
                proto[name].displayName = spec.displayName + '_' + name;
              }
            }
          }
        }
      }
    }
  }
  function mixStaticSpecIntoComponent(Constructor, statics) {
    if (!statics) {
      return;
    }
    for (var name in statics) {
      var property = statics[name];
      if (!statics.hasOwnProperty(name)) {
        continue;
      }
      var isReserved = name in RESERVED_SPEC_KEYS;
      !!isReserved ? "production" !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;
      var isInherited = name in Constructor;
      !!isInherited ? "production" !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
      Constructor[name] = property;
    }
  }
  function mergeIntoWithNoDuplicateKeys(one, two) {
    !(one && two && typeof one === 'object' && typeof two === 'object') ? "production" !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;
    for (var key in two) {
      if (two.hasOwnProperty(key)) {
        !(one[key] === undefined) ? "production" !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
        one[key] = two[key];
      }
    }
    return one;
  }
  function createMergedResultFunction(one, two) {
    return function mergedResult() {
      var a = one.apply(this, arguments);
      var b = two.apply(this, arguments);
      if (a == null) {
        return b;
      } else if (b == null) {
        return a;
      }
      var c = {};
      mergeIntoWithNoDuplicateKeys(c, a);
      mergeIntoWithNoDuplicateKeys(c, b);
      return c;
    };
  }
  function createChainedFunction(one, two) {
    return function chainedFunction() {
      one.apply(this, arguments);
      two.apply(this, arguments);
    };
  }
  function bindAutoBindMethod(component, method) {
    var boundMethod = method.bind(component);
    if ("production" !== 'production') {
      boundMethod.__reactBoundContext = component;
      boundMethod.__reactBoundMethod = method;
      boundMethod.__reactBoundArguments = null;
      var componentName = component.constructor.displayName;
      var _bind = boundMethod.bind;
      boundMethod.bind = function(newThis) {
        for (var _len = arguments.length,
            args = Array(_len > 1 ? _len - 1 : 0),
            _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        if (newThis !== component && newThis !== null) {
          "production" !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
        } else if (!args.length) {
          "production" !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
          return boundMethod;
        }
        var reboundMethod = _bind.apply(boundMethod, arguments);
        reboundMethod.__reactBoundContext = component;
        reboundMethod.__reactBoundMethod = method;
        reboundMethod.__reactBoundArguments = args;
        return reboundMethod;
      };
    }
    return boundMethod;
  }
  function bindAutoBindMethods(component) {
    var pairs = component.__reactAutoBindPairs;
    for (var i = 0; i < pairs.length; i += 2) {
      var autoBindKey = pairs[i];
      var method = pairs[i + 1];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }
  var ReactClassMixin = {
    replaceState: function(newState, callback) {
      this.updater.enqueueReplaceState(this, newState);
      if (callback) {
        this.updater.enqueueCallback(this, callback, 'replaceState');
      }
    },
    isMounted: function() {
      return this.updater.isMounted(this);
    }
  };
  var ReactClassComponent = function() {};
  _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
  var ReactClass = {
    createClass: function(spec) {
      var Constructor = function(props, context, updater) {
        if ("production" !== 'production') {
          "production" !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
        }
        if (this.__reactAutoBindPairs.length) {
          bindAutoBindMethods(this);
        }
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
        this.state = null;
        var initialState = this.getInitialState ? this.getInitialState() : null;
        if ("production" !== 'production') {
          if (initialState === undefined && this.getInitialState._isMockFunction) {
            initialState = null;
          }
        }
        !(typeof initialState === 'object' && !Array.isArray(initialState)) ? "production" !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
        this.state = initialState;
      };
      Constructor.prototype = new ReactClassComponent();
      Constructor.prototype.constructor = Constructor;
      Constructor.prototype.__reactAutoBindPairs = [];
      injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
      mixSpecIntoComponent(Constructor, spec);
      if (Constructor.getDefaultProps) {
        Constructor.defaultProps = Constructor.getDefaultProps();
      }
      if ("production" !== 'production') {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps.isReactClassApproved = {};
        }
        if (Constructor.prototype.getInitialState) {
          Constructor.prototype.getInitialState.isReactClassApproved = {};
        }
      }
      !Constructor.prototype.render ? "production" !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;
      if ("production" !== 'production') {
        "production" !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
        "production" !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
      }
      for (var methodName in ReactClassInterface) {
        if (!Constructor.prototype[methodName]) {
          Constructor.prototype[methodName] = null;
        }
      }
      return Constructor;
    },
    injection: {injectMixin: function(mixin) {
        injectedMixins.push(mixin);
      }}
  };
  module.exports = ReactClass;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/mapObject.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function mapObject(object, callback, context) {
    if (!object) {
      return null;
    }
    var result = {};
    for (var name in object) {
      if (hasOwnProperty.call(object, name)) {
        result[name] = callback.call(context, object[name], name, object);
      }
    }
    return result;
  }
  module.exports = mapObject;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactDOMFactories.js", ["./ReactElement", "fbjs/lib/mapObject", "./ReactElementValidator", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactElement = $__require('./ReactElement');
  var mapObject = $__require('fbjs/lib/mapObject');
  function createDOMFactory(tag) {
    if ("production" !== 'production') {
      var ReactElementValidator = $__require('./ReactElementValidator');
      return ReactElementValidator.createFactory(tag);
    }
    return ReactElement.createFactory(tag);
  }
  var ReactDOMFactories = mapObject({
    a: 'a',
    abbr: 'abbr',
    address: 'address',
    area: 'area',
    article: 'article',
    aside: 'aside',
    audio: 'audio',
    b: 'b',
    base: 'base',
    bdi: 'bdi',
    bdo: 'bdo',
    big: 'big',
    blockquote: 'blockquote',
    body: 'body',
    br: 'br',
    button: 'button',
    canvas: 'canvas',
    caption: 'caption',
    cite: 'cite',
    code: 'code',
    col: 'col',
    colgroup: 'colgroup',
    data: 'data',
    datalist: 'datalist',
    dd: 'dd',
    del: 'del',
    details: 'details',
    dfn: 'dfn',
    dialog: 'dialog',
    div: 'div',
    dl: 'dl',
    dt: 'dt',
    em: 'em',
    embed: 'embed',
    fieldset: 'fieldset',
    figcaption: 'figcaption',
    figure: 'figure',
    footer: 'footer',
    form: 'form',
    h1: 'h1',
    h2: 'h2',
    h3: 'h3',
    h4: 'h4',
    h5: 'h5',
    h6: 'h6',
    head: 'head',
    header: 'header',
    hgroup: 'hgroup',
    hr: 'hr',
    html: 'html',
    i: 'i',
    iframe: 'iframe',
    img: 'img',
    input: 'input',
    ins: 'ins',
    kbd: 'kbd',
    keygen: 'keygen',
    label: 'label',
    legend: 'legend',
    li: 'li',
    link: 'link',
    main: 'main',
    map: 'map',
    mark: 'mark',
    menu: 'menu',
    menuitem: 'menuitem',
    meta: 'meta',
    meter: 'meter',
    nav: 'nav',
    noscript: 'noscript',
    object: 'object',
    ol: 'ol',
    optgroup: 'optgroup',
    option: 'option',
    output: 'output',
    p: 'p',
    param: 'param',
    picture: 'picture',
    pre: 'pre',
    progress: 'progress',
    q: 'q',
    rp: 'rp',
    rt: 'rt',
    ruby: 'ruby',
    s: 's',
    samp: 'samp',
    script: 'script',
    section: 'section',
    select: 'select',
    small: 'small',
    source: 'source',
    span: 'span',
    strong: 'strong',
    style: 'style',
    sub: 'sub',
    summary: 'summary',
    sup: 'sup',
    table: 'table',
    tbody: 'tbody',
    td: 'td',
    textarea: 'textarea',
    tfoot: 'tfoot',
    th: 'th',
    thead: 'thead',
    time: 'time',
    title: 'title',
    tr: 'tr',
    track: 'track',
    u: 'u',
    ul: 'ul',
    'var': 'var',
    video: 'video',
    wbr: 'wbr',
    circle: 'circle',
    clipPath: 'clipPath',
    defs: 'defs',
    ellipse: 'ellipse',
    g: 'g',
    image: 'image',
    line: 'line',
    linearGradient: 'linearGradient',
    mask: 'mask',
    path: 'path',
    pattern: 'pattern',
    polygon: 'polygon',
    polyline: 'polyline',
    radialGradient: 'radialGradient',
    rect: 'rect',
    stop: 'stop',
    svg: 'svg',
    text: 'text',
    tspan: 'tspan'
  }, createDOMFactory);
  module.exports = ReactDOMFactories;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactPropTypes.js", ["./ReactElement", "./ReactPropTypeLocationNames", "fbjs/lib/emptyFunction", "./getIteratorFn", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactElement = $__require('./ReactElement');
  var ReactPropTypeLocationNames = $__require('./ReactPropTypeLocationNames');
  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var getIteratorFn = $__require('./getIteratorFn');
  var ANONYMOUS = '<<anonymous>>';
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),
    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker
  };
  function is(x, y) {
    if (x === y) {
      return x !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }
  function createChainableTypeChecker(validate) {
    function checkType(isRequired, props, propName, componentName, location, propFullName) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;
      if (props[propName] == null) {
        var locationName = ReactPropTypeLocationNames[location];
        if (isRequired) {
          return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }
    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }
  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        var locationName = ReactPropTypeLocationNames[location];
        var preciseType = getPreciseType(propValue);
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturns(null));
  }
  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new Error('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var locationName = ReactPropTypeLocationNames[location];
        var propType = getPropType(propValue);
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!ReactElement.isValidElement(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var locationName = ReactPropTypeLocationNames[location];
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      return createChainableTypeChecker(function() {
        return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
      });
    }
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      var valuesString = JSON.stringify(expectedValues);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }
  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new Error('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      return createChainableTypeChecker(function() {
        return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
      });
    }
    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName) == null) {
          return null;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }
  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || ReactElement.isValidElement(propValue)) {
          return true;
        }
        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }
        return true;
      default:
        return false;
    }
  }
  function isSymbol(propType, propValue) {
    if (propType === 'symbol') {
      return true;
    }
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }
    return false;
  }
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }
  function getPreciseType(propValue) {
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }
  module.exports = ReactPropTypes;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactVersion.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = '15.2.1';
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/onlyChild.js", ["./reactProdInvariant", "./ReactElement", "fbjs/lib/invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var ReactElement = $__require('./ReactElement');
  var invariant = $__require('fbjs/lib/invariant');
  function onlyChild(children) {
    !ReactElement.isValidElement(children) ? "production" !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : _prodInvariant('23') : void 0;
    return children;
  }
  module.exports = onlyChild;
  return module.exports;
});

System.registerDynamic("npm:object-assign@4.1.0.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:object-assign@4.1.0/index.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError('Object.assign cannot be called with null or undefined');
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String('abc');
      test1[5] = 'de';
      if (Object.getOwnPropertyNames(test1)[0] === '5') {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2['_' + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join('') !== '0123456789') {
        return false;
      }
      var test3 = {};
      'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
        return false;
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  module.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (Object.getOwnPropertySymbols) {
        symbols = Object.getOwnPropertySymbols(from);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }
    return to;
  };
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactElement.js", ["object-assign", "./ReactCurrentOwner", "fbjs/lib/warning", "./canDefineProperty", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');
  var ReactCurrentOwner = $__require('./ReactCurrentOwner');
  var warning = $__require('fbjs/lib/warning');
  var canDefineProperty = $__require('./canDefineProperty');
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
  var RESERVED_PROPS = {
    key: true,
    ref: true,
    __self: true,
    __source: true
  };
  var specialPropKeyWarningShown,
      specialPropRefWarningShown;
  function hasValidRef(config) {
    if ("production" !== 'production') {
      if (hasOwnProperty.call(config, 'ref')) {
        var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
        if (getter && getter.isReactWarning) {
          return false;
        }
      }
    }
    return config.ref !== undefined;
  }
  function hasValidKey(config) {
    if ("production" !== 'production') {
      if (hasOwnProperty.call(config, 'key')) {
        var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
        if (getter && getter.isReactWarning) {
          return false;
        }
      }
    }
    return config.key !== undefined;
  }
  var ReactElement = function(type, key, ref, self, source, owner, props) {
    var element = {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key,
      ref: ref,
      props: props,
      _owner: owner
    };
    if ("production" !== 'production') {
      element._store = {};
      if (canDefineProperty) {
        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        });
        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        });
        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });
      } else {
        element._store.validated = false;
        element._self = self;
        element._source = source;
      }
      if (Object.freeze) {
        Object.freeze(element.props);
        Object.freeze(element);
      }
    }
    return element;
  };
  ReactElement.createElement = function(type, config, children) {
    var propName;
    var props = {};
    var key = null;
    var ref = null;
    var self = null;
    var source = null;
    if (config != null) {
      if ("production" !== 'production') {
        "production" !== 'production' ? warning(config.__proto__ == null || config.__proto__ === Object.prototype, 'React.createElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
      }
      if (hasValidRef(config)) {
        ref = config.ref;
      }
      if (hasValidKey(config)) {
        key = '' + config.key;
      }
      self = config.__self === undefined ? null : config.__self;
      source = config.__source === undefined ? null : config.__source;
      for (propName in config) {
        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
          props[propName] = config[propName];
        }
      }
    }
    var childrenLength = arguments.length - 2;
    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);
      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 2];
      }
      props.children = childArray;
    }
    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;
      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }
    if ("production" !== 'production') {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
      var warnAboutAccessingKey = function() {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          "production" !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
        }
        return undefined;
      };
      warnAboutAccessingKey.isReactWarning = true;
      var warnAboutAccessingRef = function() {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          "production" !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
        }
        return undefined;
      };
      warnAboutAccessingRef.isReactWarning = true;
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        if (!props.hasOwnProperty('key')) {
          Object.defineProperty(props, 'key', {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        if (!props.hasOwnProperty('ref')) {
          Object.defineProperty(props, 'ref', {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
    }
    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  };
  ReactElement.createFactory = function(type) {
    var factory = ReactElement.createElement.bind(null, type);
    factory.type = type;
    return factory;
  };
  ReactElement.cloneAndReplaceKey = function(oldElement, newKey) {
    var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
    return newElement;
  };
  ReactElement.cloneElement = function(element, config, children) {
    var propName;
    var props = _assign({}, element.props);
    var key = element.key;
    var ref = element.ref;
    var self = element._self;
    var source = element._source;
    var owner = element._owner;
    if (config != null) {
      if ("production" !== 'production') {
        "production" !== 'production' ? warning(config.__proto__ == null || config.__proto__ === Object.prototype, 'React.cloneElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
      }
      if (hasValidRef(config)) {
        ref = config.ref;
        owner = ReactCurrentOwner.current;
      }
      if (hasValidKey(config)) {
        key = '' + config.key;
      }
      var defaultProps;
      if (element.type && element.type.defaultProps) {
        defaultProps = element.type.defaultProps;
      }
      for (propName in config) {
        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
          if (config[propName] === undefined && defaultProps !== undefined) {
            props[propName] = defaultProps[propName];
          } else {
            props[propName] = config[propName];
          }
        }
      }
    }
    var childrenLength = arguments.length - 2;
    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);
      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 2];
      }
      props.children = childArray;
    }
    return ReactElement(element.type, key, ref, self, source, owner, props);
  };
  ReactElement.isValidElement = function(object) {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };
  ReactElement.REACT_ELEMENT_TYPE = REACT_ELEMENT_TYPE;
  module.exports = ReactElement;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/keyMirror.js", ["./invariant", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var invariant = $__require('./invariant');
  var keyMirror = function keyMirror(obj) {
    var ret = {};
    var key;
    !(obj instanceof Object && !Array.isArray(obj)) ? "production" !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : void 0;
    for (key in obj) {
      if (!obj.hasOwnProperty(key)) {
        continue;
      }
      ret[key] = key;
    }
    return ret;
  };
  module.exports = keyMirror;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactPropTypeLocations.js", ["fbjs/lib/keyMirror", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var keyMirror = $__require('fbjs/lib/keyMirror');
  var ReactPropTypeLocations = keyMirror({
    prop: null,
    context: null,
    childContext: null
  });
  module.exports = ReactPropTypeLocations;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactPropTypeLocationNames.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactPropTypeLocationNames = {};
  if ("production" !== 'production') {
    ReactPropTypeLocationNames = {
      prop: 'prop',
      context: 'context',
      childContext: 'child context'
    };
  }
  module.exports = ReactPropTypeLocationNames;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/reactProdInvariant.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function reactProdInvariant(code) {
    var argCount = arguments.length - 1;
    var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
    for (var argIdx = 0; argIdx < argCount; argIdx++) {
      message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
    }
    message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
    var error = new Error(message);
    error.name = 'Invariant Violation';
    error.framesToPop = 1;
    throw error;
  }
  module.exports = reactProdInvariant;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactCurrentOwner.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactCurrentOwner = {current: null};
  module.exports = ReactCurrentOwner;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/invariant.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function invariant(condition, format, a, b, c, d, e, f) {
    if ("production" !== 'production') {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function() {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }
      error.framesToPop = 1;
      throw error;
    }
  }
  module.exports = invariant;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactComponentTreeDevtool.js", ["./reactProdInvariant", "./ReactCurrentOwner", "fbjs/lib/invariant", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var ReactCurrentOwner = $__require('./ReactCurrentOwner');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');
  var tree = {};
  var unmountedIDs = {};
  var rootIDs = {};
  function updateTree(id, update) {
    if (!tree[id]) {
      tree[id] = {
        element: null,
        parentID: null,
        ownerID: null,
        text: null,
        childIDs: [],
        displayName: 'Unknown',
        isMounted: false,
        updateCount: 0
      };
    }
    update(tree[id]);
  }
  function purgeDeep(id) {
    var item = tree[id];
    if (item) {
      var childIDs = item.childIDs;
      delete tree[id];
      childIDs.forEach(purgeDeep);
    }
  }
  function describeComponentFrame(name, source, ownerName) {
    return '\n    in ' + name + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
  }
  function describeID(id) {
    var name = ReactComponentTreeDevtool.getDisplayName(id);
    var element = ReactComponentTreeDevtool.getElement(id);
    var ownerID = ReactComponentTreeDevtool.getOwnerID(id);
    var ownerName;
    if (ownerID) {
      ownerName = ReactComponentTreeDevtool.getDisplayName(ownerID);
    }
    "production" !== 'production' ? warning(element, 'ReactComponentTreeDevtool: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
    return describeComponentFrame(name, element && element._source, ownerName);
  }
  var ReactComponentTreeDevtool = {
    onSetDisplayName: function(id, displayName) {
      updateTree(id, function(item) {
        return item.displayName = displayName;
      });
    },
    onSetChildren: function(id, nextChildIDs) {
      updateTree(id, function(item) {
        item.childIDs = nextChildIDs;
        nextChildIDs.forEach(function(nextChildID) {
          var nextChild = tree[nextChildID];
          !nextChild ? "production" !== 'production' ? invariant(false, 'Expected devtool events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('68') : void 0;
          !(nextChild.displayName != null) ? "production" !== 'production' ? invariant(false, 'Expected onSetDisplayName() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('69') : void 0;
          !(nextChild.childIDs != null || nextChild.text != null) ? "production" !== 'production' ? invariant(false, 'Expected onSetChildren() or onSetText() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('70') : void 0;
          !nextChild.isMounted ? "production" !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
          if (nextChild.parentID == null) {
            nextChild.parentID = id;
          }
          !(nextChild.parentID === id) ? "production" !== 'production' ? invariant(false, 'Expected onSetParent() and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('72', nextChildID, nextChild.parentID, id) : void 0;
        });
      });
    },
    onSetOwner: function(id, ownerID) {
      updateTree(id, function(item) {
        return item.ownerID = ownerID;
      });
    },
    onSetParent: function(id, parentID) {
      updateTree(id, function(item) {
        return item.parentID = parentID;
      });
    },
    onSetText: function(id, text) {
      updateTree(id, function(item) {
        return item.text = text;
      });
    },
    onBeforeMountComponent: function(id, element) {
      updateTree(id, function(item) {
        return item.element = element;
      });
    },
    onBeforeUpdateComponent: function(id, element) {
      updateTree(id, function(item) {
        return item.element = element;
      });
    },
    onMountComponent: function(id) {
      updateTree(id, function(item) {
        return item.isMounted = true;
      });
    },
    onMountRootComponent: function(id) {
      rootIDs[id] = true;
    },
    onUpdateComponent: function(id) {
      updateTree(id, function(item) {
        return item.updateCount++;
      });
    },
    onUnmountComponent: function(id) {
      updateTree(id, function(item) {
        return item.isMounted = false;
      });
      unmountedIDs[id] = true;
      delete rootIDs[id];
    },
    purgeUnmountedComponents: function() {
      if (ReactComponentTreeDevtool._preventPurging) {
        return;
      }
      for (var id in unmountedIDs) {
        purgeDeep(id);
      }
      unmountedIDs = {};
    },
    isMounted: function(id) {
      var item = tree[id];
      return item ? item.isMounted : false;
    },
    getCurrentStackAddendum: function(topElement) {
      var info = '';
      if (topElement) {
        var type = topElement.type;
        var name = typeof type === 'function' ? type.displayName || type.name : type;
        var owner = topElement._owner;
        info += describeComponentFrame(name || 'Unknown', topElement._source, owner && owner.getName());
      }
      var currentOwner = ReactCurrentOwner.current;
      var id = currentOwner && currentOwner._debugID;
      info += ReactComponentTreeDevtool.getStackAddendumByID(id);
      return info;
    },
    getStackAddendumByID: function(id) {
      var info = '';
      while (id) {
        info += describeID(id);
        id = ReactComponentTreeDevtool.getParentID(id);
      }
      return info;
    },
    getChildIDs: function(id) {
      var item = tree[id];
      return item ? item.childIDs : [];
    },
    getDisplayName: function(id) {
      var item = tree[id];
      return item ? item.displayName : 'Unknown';
    },
    getElement: function(id) {
      var item = tree[id];
      return item ? item.element : null;
    },
    getOwnerID: function(id) {
      var item = tree[id];
      return item ? item.ownerID : null;
    },
    getParentID: function(id) {
      var item = tree[id];
      return item ? item.parentID : null;
    },
    getSource: function(id) {
      var item = tree[id];
      var element = item ? item.element : null;
      var source = element != null ? element._source : null;
      return source;
    },
    getText: function(id) {
      var item = tree[id];
      return item ? item.text : null;
    },
    getUpdateCount: function(id) {
      var item = tree[id];
      return item ? item.updateCount : 0;
    },
    getRootIDs: function() {
      return Object.keys(rootIDs);
    },
    getRegisteredIDs: function() {
      return Object.keys(tree);
    }
  };
  module.exports = ReactComponentTreeDevtool;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/checkReactTypeSpec.js", ["./reactProdInvariant", "./ReactPropTypeLocationNames", "fbjs/lib/invariant", "fbjs/lib/warning", "./ReactComponentTreeDevtool", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');
  var ReactPropTypeLocationNames = $__require('./ReactPropTypeLocationNames');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');
  var loggedTypeFailures = {};
  function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        try {
          !(typeof typeSpecs[typeSpecName] === 'function') ? "production" !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location);
        } catch (ex) {
          error = ex;
        }
        "production" !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          loggedTypeFailures[error.message] = true;
          var componentStackInfo = '';
          if ("production" !== 'production') {
            var ReactComponentTreeDevtool = $__require('./ReactComponentTreeDevtool');
            if (debugID !== null) {
              componentStackInfo = ReactComponentTreeDevtool.getStackAddendumByID(debugID);
            } else if (element !== null) {
              componentStackInfo = ReactComponentTreeDevtool.getCurrentStackAddendum(element);
            }
          }
          "production" !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
        }
      }
    }
  }
  module.exports = checkReactTypeSpec;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/canDefineProperty.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var canDefineProperty = false;
  if ("production" !== 'production') {
    try {
      Object.defineProperty({}, 'x', {get: function() {}});
      canDefineProperty = true;
    } catch (x) {}
  }
  module.exports = canDefineProperty;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/getIteratorFn.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }
  module.exports = getIteratorFn;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3/lib/emptyFunction.js", ["process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function makeEmptyFunction(arg) {
    return function() {
      return arg;
    };
  }
  var emptyFunction = function emptyFunction() {};
  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function() {
    return this;
  };
  emptyFunction.thatReturnsArgument = function(arg) {
    return arg;
  };
  module.exports = emptyFunction;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.8.3.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:fbjs@0.8.3/lib/warning.js", ["./emptyFunction", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var emptyFunction = $__require('./emptyFunction');
  var warning = emptyFunction;
  if ("production" !== 'production') {
    warning = function warning(condition, format) {
      for (var _len = arguments.length,
          args = Array(_len > 2 ? _len - 2 : 0),
          _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }
      if (format.indexOf('Failed Composite propType: ') === 0) {
        return;
      }
      if (!condition) {
        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {}
      }
    };
  }
  module.exports = warning;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/ReactElementValidator.js", ["./ReactCurrentOwner", "./ReactComponentTreeDevtool", "./ReactElement", "./ReactPropTypeLocations", "./checkReactTypeSpec", "./canDefineProperty", "./getIteratorFn", "fbjs/lib/warning", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactCurrentOwner = $__require('./ReactCurrentOwner');
  var ReactComponentTreeDevtool = $__require('./ReactComponentTreeDevtool');
  var ReactElement = $__require('./ReactElement');
  var ReactPropTypeLocations = $__require('./ReactPropTypeLocations');
  var checkReactTypeSpec = $__require('./checkReactTypeSpec');
  var canDefineProperty = $__require('./canDefineProperty');
  var getIteratorFn = $__require('./getIteratorFn');
  var warning = $__require('fbjs/lib/warning');
  function getDeclarationErrorAddendum() {
    if (ReactCurrentOwner.current) {
      var name = ReactCurrentOwner.current.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  }
  var ownerHasKeyUseWarning = {};
  function getCurrentComponentErrorInfo(parentType) {
    var info = getDeclarationErrorAddendum();
    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
      if (parentName) {
        info = ' Check the top-level render call using <' + parentName + '>.';
      }
    }
    return info;
  }
  function validateExplicitKey(element, parentType) {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }
    element._store.validated = true;
    var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
    if (memoizer[currentComponentErrorInfo]) {
      return;
    }
    memoizer[currentComponentErrorInfo] = true;
    var childOwner = '';
    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
      childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
    }
    "production" !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeDevtool.getCurrentStackAddendum(element)) : void 0;
  }
  function validateChildKeys(node, parentType) {
    if (typeof node !== 'object') {
      return;
    }
    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];
        if (ReactElement.isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (ReactElement.isValidElement(node)) {
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);
      if (iteratorFn) {
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;
          while (!(step = iterator.next()).done) {
            if (ReactElement.isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
  function validatePropTypes(element) {
    var componentClass = element.type;
    if (typeof componentClass !== 'function') {
      return;
    }
    var name = componentClass.displayName || componentClass.name;
    if (componentClass.propTypes) {
      checkReactTypeSpec(componentClass.propTypes, element.props, ReactPropTypeLocations.prop, name, element, null);
    }
    if (typeof componentClass.getDefaultProps === 'function') {
      "production" !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
    }
  }
  var ReactElementValidator = {
    createElement: function(type, props, children) {
      var validType = typeof type === 'string' || typeof type === 'function';
      "production" !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
      var element = ReactElement.createElement.apply(this, arguments);
      if (element == null) {
        return element;
      }
      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }
      validatePropTypes(element);
      return element;
    },
    createFactory: function(type) {
      var validatedFactory = ReactElementValidator.createElement.bind(null, type);
      validatedFactory.type = type;
      if ("production" !== 'production') {
        if (canDefineProperty) {
          Object.defineProperty(validatedFactory, 'type', {
            enumerable: false,
            get: function() {
              "production" !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
              Object.defineProperty(this, 'type', {value: type});
              return type;
            }
          });
        }
      }
      return validatedFactory;
    },
    cloneElement: function(element, props, children) {
      var newElement = ReactElement.cloneElement.apply(this, arguments);
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }
      validatePropTypes(newElement);
      return newElement;
    }
  };
  module.exports = ReactElementValidator;
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1/lib/React.js", ["object-assign", "./ReactChildren", "./ReactComponent", "./ReactClass", "./ReactDOMFactories", "./ReactElement", "./ReactPropTypes", "./ReactVersion", "./onlyChild", "fbjs/lib/warning", "./ReactElementValidator", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');
  var ReactChildren = $__require('./ReactChildren');
  var ReactComponent = $__require('./ReactComponent');
  var ReactClass = $__require('./ReactClass');
  var ReactDOMFactories = $__require('./ReactDOMFactories');
  var ReactElement = $__require('./ReactElement');
  var ReactPropTypes = $__require('./ReactPropTypes');
  var ReactVersion = $__require('./ReactVersion');
  var onlyChild = $__require('./onlyChild');
  var warning = $__require('fbjs/lib/warning');
  var createElement = ReactElement.createElement;
  var createFactory = ReactElement.createFactory;
  var cloneElement = ReactElement.cloneElement;
  if ("production" !== 'production') {
    var ReactElementValidator = $__require('./ReactElementValidator');
    createElement = ReactElementValidator.createElement;
    createFactory = ReactElementValidator.createFactory;
    cloneElement = ReactElementValidator.cloneElement;
  }
  var __spread = _assign;
  if ("production" !== 'production') {
    var warned = false;
    __spread = function() {
      "production" !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
      warned = true;
      return _assign.apply(null, arguments);
    };
  }
  var React = {
    Children: {
      map: ReactChildren.map,
      forEach: ReactChildren.forEach,
      count: ReactChildren.count,
      toArray: ReactChildren.toArray,
      only: onlyChild
    },
    Component: ReactComponent,
    createElement: createElement,
    cloneElement: cloneElement,
    isValidElement: ReactElement.isValidElement,
    PropTypes: ReactPropTypes,
    createClass: ReactClass.createClass,
    createFactory: createFactory,
    createMixin: function(mixin) {
      return mixin;
    },
    DOM: ReactDOMFactories,
    version: ReactVersion,
    __spread: __spread
  };
  module.exports = React;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.2.0-alpha.json", [], false, function() {
  return {
    "main": "./process.js"
  };
});

System.registerDynamic("github:jspm/nodelibs-process@0.2.0-alpha/process.js", ["@system-env"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var productionEnv = $__require('@system-env').production;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {NODE_ENV: productionEnv ? 'production' : 'development'};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  return module.exports;
});

System.registerDynamic("npm:react@15.2.1.json", [], false, function() {
  return {
    "main": "react.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      },
      "dist/react-with-addons.js": {
        "cjsRequireDetection": false
      },
      "dist/react.js": {
        "cjsRequireDetection": false
      }
    }
  };
});

System.registerDynamic("npm:react@15.2.1/react.js", ["./lib/React", "process"], true, function($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./lib/React');
  return module.exports;
});

System.registerDynamic("npm:classnames@2.2.5.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:classnames@2.2.5/index.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  (function() {
    'use strict';
    var hasOwn = {}.hasOwnProperty;
    function classNames() {
      var classes = [];
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === 'string' || argType === 'number') {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          classes.push(classNames.apply(null, arg));
        } else if (argType === 'object') {
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        }
      }
      return classes.join(' ');
    }
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = classNames;
    } else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
      define('classnames', [], function() {
        return classNames;
      });
    } else {
      window.classNames = classNames;
    }
  }());
  return module.exports;
});

System.registerDynamic("npm:react-select@1.0.0-beta13/lib/Value.js", ["react", "classnames"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _classnames = $__require('classnames');
  var _classnames2 = _interopRequireDefault(_classnames);
  var Value = _react2['default'].createClass({
    displayName: 'Value',
    propTypes: {
      children: _react2['default'].PropTypes.node,
      disabled: _react2['default'].PropTypes.bool,
      onClick: _react2['default'].PropTypes.func,
      onRemove: _react2['default'].PropTypes.func,
      value: _react2['default'].PropTypes.object.isRequired
    },
    handleMouseDown: function handleMouseDown(event) {
      if (event.type === 'mousedown' && event.button !== 0) {
        return;
      }
      if (this.props.onClick) {
        event.stopPropagation();
        this.props.onClick(this.props.value, event);
        return;
      }
      if (this.props.value.href) {
        event.stopPropagation();
      }
    },
    onRemove: function onRemove(event) {
      event.preventDefault();
      event.stopPropagation();
      this.props.onRemove(this.props.value);
    },
    handleTouchEndRemove: function handleTouchEndRemove(event) {
      if (this.dragging)
        return;
      this.onRemove(event);
    },
    handleTouchMove: function handleTouchMove(event) {
      this.dragging = true;
    },
    handleTouchStart: function handleTouchStart(event) {
      this.dragging = false;
    },
    renderRemoveIcon: function renderRemoveIcon() {
      if (this.props.disabled || !this.props.onRemove)
        return;
      return _react2['default'].createElement('span', {
        className: 'Select-value-icon',
        onMouseDown: this.onRemove,
        onTouchEnd: this.handleTouchEndRemove,
        onTouchStart: this.handleTouchStart,
        onTouchMove: this.handleTouchMove
      }, '');
    },
    renderLabel: function renderLabel() {
      var className = 'Select-value-label';
      return this.props.onClick || this.props.value.href ? _react2['default'].createElement('a', {
        className: className,
        href: this.props.value.href,
        target: this.props.value.target,
        onMouseDown: this.handleMouseDown,
        onTouchEnd: this.handleMouseDown
      }, this.props.children) : _react2['default'].createElement('span', {className: className}, this.props.children);
    },
    render: function render() {
      return _react2['default'].createElement('div', {
        className: (0, _classnames2['default'])('Select-value', this.props.value.className),
        style: this.props.value.style,
        title: this.props.value.title
      }, this.renderRemoveIcon(), this.renderLabel());
    }
  });
  module.exports = Value;
  return module.exports;
});

System.registerDynamic("npm:react-select@1.0.0-beta13/lib/Select.js", ["react", "react-dom", "react-input-autosize", "classnames", "./utils/stripDiacritics", "./Async", "./Option", "./Value"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', {value: true});
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _reactDom = $__require('react-dom');
  var _reactDom2 = _interopRequireDefault(_reactDom);
  var _reactInputAutosize = $__require('react-input-autosize');
  var _reactInputAutosize2 = _interopRequireDefault(_reactInputAutosize);
  var _classnames = $__require('classnames');
  var _classnames2 = _interopRequireDefault(_classnames);
  var _utilsStripDiacritics = $__require('./utils/stripDiacritics');
  var _utilsStripDiacritics2 = _interopRequireDefault(_utilsStripDiacritics);
  var _Async = $__require('./Async');
  var _Async2 = _interopRequireDefault(_Async);
  var _Option = $__require('./Option');
  var _Option2 = _interopRequireDefault(_Option);
  var _Value = $__require('./Value');
  var _Value2 = _interopRequireDefault(_Value);
  function stringifyValue(value) {
    if (typeof value === 'object') {
      return JSON.stringify(value);
    } else {
      return value;
    }
  }
  var stringOrNode = _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.string, _react2['default'].PropTypes.node]);
  var Select = _react2['default'].createClass({
    displayName: 'Select',
    propTypes: {
      addLabelText: _react2['default'].PropTypes.string,
      allowCreate: _react2['default'].PropTypes.bool,
      autoBlur: _react2['default'].PropTypes.bool,
      autofocus: _react2['default'].PropTypes.bool,
      autosize: _react2['default'].PropTypes.bool,
      backspaceRemoves: _react2['default'].PropTypes.bool,
      className: _react2['default'].PropTypes.string,
      clearAllText: stringOrNode,
      clearValueText: stringOrNode,
      clearable: _react2['default'].PropTypes.bool,
      delimiter: _react2['default'].PropTypes.string,
      disabled: _react2['default'].PropTypes.bool,
      escapeClearsValue: _react2['default'].PropTypes.bool,
      filterOption: _react2['default'].PropTypes.func,
      filterOptions: _react2['default'].PropTypes.any,
      ignoreAccents: _react2['default'].PropTypes.bool,
      ignoreCase: _react2['default'].PropTypes.bool,
      inputProps: _react2['default'].PropTypes.object,
      inputRenderer: _react2['default'].PropTypes.func,
      isLoading: _react2['default'].PropTypes.bool,
      joinValues: _react2['default'].PropTypes.bool,
      labelKey: _react2['default'].PropTypes.string,
      matchPos: _react2['default'].PropTypes.string,
      matchProp: _react2['default'].PropTypes.string,
      menuBuffer: _react2['default'].PropTypes.number,
      menuContainerStyle: _react2['default'].PropTypes.object,
      menuRenderer: _react2['default'].PropTypes.func,
      menuStyle: _react2['default'].PropTypes.object,
      multi: _react2['default'].PropTypes.bool,
      name: _react2['default'].PropTypes.string,
      newOptionCreator: _react2['default'].PropTypes.func,
      noResultsText: stringOrNode,
      onBlur: _react2['default'].PropTypes.func,
      onBlurResetsInput: _react2['default'].PropTypes.bool,
      onChange: _react2['default'].PropTypes.func,
      onClose: _react2['default'].PropTypes.func,
      onFocus: _react2['default'].PropTypes.func,
      onInputChange: _react2['default'].PropTypes.func,
      onMenuScrollToBottom: _react2['default'].PropTypes.func,
      onOpen: _react2['default'].PropTypes.func,
      onValueClick: _react2['default'].PropTypes.func,
      openAfterFocus: _react2['default'].PropTypes.bool,
      openOnFocus: _react2['default'].PropTypes.bool,
      optionClassName: _react2['default'].PropTypes.string,
      optionComponent: _react2['default'].PropTypes.func,
      optionRenderer: _react2['default'].PropTypes.func,
      options: _react2['default'].PropTypes.array,
      placeholder: stringOrNode,
      required: _react2['default'].PropTypes.bool,
      resetValue: _react2['default'].PropTypes.any,
      scrollMenuIntoView: _react2['default'].PropTypes.bool,
      searchable: _react2['default'].PropTypes.bool,
      simpleValue: _react2['default'].PropTypes.bool,
      style: _react2['default'].PropTypes.object,
      tabIndex: _react2['default'].PropTypes.string,
      tabSelectsValue: _react2['default'].PropTypes.bool,
      value: _react2['default'].PropTypes.any,
      valueComponent: _react2['default'].PropTypes.func,
      valueKey: _react2['default'].PropTypes.string,
      valueRenderer: _react2['default'].PropTypes.func,
      wrapperStyle: _react2['default'].PropTypes.object
    },
    statics: {Async: _Async2['default']},
    getDefaultProps: function getDefaultProps() {
      return {
        addLabelText: 'Add "{label}"?',
        autosize: true,
        allowCreate: false,
        backspaceRemoves: true,
        clearable: true,
        clearAllText: 'Clear all',
        clearValueText: 'Clear value',
        delimiter: ',',
        disabled: false,
        escapeClearsValue: true,
        filterOptions: true,
        ignoreAccents: true,
        ignoreCase: true,
        inputProps: {},
        isLoading: false,
        joinValues: false,
        labelKey: 'label',
        matchPos: 'any',
        matchProp: 'any',
        menuBuffer: 0,
        multi: false,
        noResultsText: 'No results found',
        onBlurResetsInput: true,
        openAfterFocus: false,
        optionComponent: _Option2['default'],
        placeholder: 'Select...',
        required: false,
        resetValue: null,
        scrollMenuIntoView: true,
        searchable: true,
        simpleValue: false,
        tabSelectsValue: true,
        valueComponent: _Value2['default'],
        valueKey: 'value'
      };
    },
    getInitialState: function getInitialState() {
      return {
        inputValue: '',
        isFocused: false,
        isLoading: false,
        isOpen: false,
        isPseudoFocused: false,
        required: false
      };
    },
    componentWillMount: function componentWillMount() {
      var valueArray = this.getValueArray(this.props.value);
      if (this.props.required) {
        this.setState({required: this.handleRequired(valueArray[0], this.props.multi)});
      }
    },
    componentDidMount: function componentDidMount() {
      if (this.props.autofocus) {
        this.focus();
      }
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      var valueArray = this.getValueArray(nextProps.value);
      if (nextProps.required) {
        this.setState({required: this.handleRequired(valueArray[0], nextProps.multi)});
      }
    },
    componentWillUpdate: function componentWillUpdate(nextProps, nextState) {
      if (nextState.isOpen !== this.state.isOpen) {
        var handler = nextState.isOpen ? nextProps.onOpen : nextProps.onClose;
        handler && handler();
      }
    },
    componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
      if (this.refs.menu && this.refs.focused && this.state.isOpen && !this.hasScrolledToOption) {
        var focusedOptionNode = _reactDom2['default'].findDOMNode(this.refs.focused);
        var menuNode = _reactDom2['default'].findDOMNode(this.refs.menu);
        menuNode.scrollTop = focusedOptionNode.offsetTop;
        this.hasScrolledToOption = true;
      } else if (!this.state.isOpen) {
        this.hasScrolledToOption = false;
      }
      if (this._scrollToFocusedOptionOnUpdate && this.refs.focused && this.refs.menu) {
        this._scrollToFocusedOptionOnUpdate = false;
        var focusedDOM = _reactDom2['default'].findDOMNode(this.refs.focused);
        var menuDOM = _reactDom2['default'].findDOMNode(this.refs.menu);
        var focusedRect = focusedDOM.getBoundingClientRect();
        var menuRect = menuDOM.getBoundingClientRect();
        if (focusedRect.bottom > menuRect.bottom || focusedRect.top < menuRect.top) {
          menuDOM.scrollTop = focusedDOM.offsetTop + focusedDOM.clientHeight - menuDOM.offsetHeight;
        }
      }
      if (this.props.scrollMenuIntoView && this.refs.menuContainer) {
        var menuContainerRect = this.refs.menuContainer.getBoundingClientRect();
        if (window.innerHeight < menuContainerRect.bottom + this.props.menuBuffer) {
          window.scrollBy(0, menuContainerRect.bottom + this.props.menuBuffer - window.innerHeight);
        }
      }
      if (prevProps.disabled !== this.props.disabled) {
        this.setState({isFocused: false});
      }
    },
    focus: function focus() {
      if (!this.refs.input)
        return;
      this.refs.input.focus();
      if (this.props.openAfterFocus) {
        this.setState({isOpen: true});
      }
    },
    blurInput: function blurInput() {
      if (!this.refs.input)
        return;
      this.refs.input.blur();
    },
    handleTouchMove: function handleTouchMove(event) {
      this.dragging = true;
    },
    handleTouchStart: function handleTouchStart(event) {
      this.dragging = false;
    },
    handleTouchEnd: function handleTouchEnd(event) {
      if (this.dragging)
        return;
      this.handleMouseDown(event);
    },
    handleTouchEndClearValue: function handleTouchEndClearValue(event) {
      if (this.dragging)
        return;
      this.clearValue(event);
    },
    handleMouseDown: function handleMouseDown(event) {
      if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      if (!this.props.searchable) {
        this.focus();
        return this.setState({isOpen: !this.state.isOpen});
      }
      if (this.state.isFocused) {
        this.setState({
          isOpen: true,
          isPseudoFocused: false
        });
      } else {
        this._openAfterFocus = true;
        this.focus();
      }
    },
    handleMouseDownOnArrow: function handleMouseDownOnArrow(event) {
      if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
        return;
      }
      if (!this.state.isOpen) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      this.closeMenu();
    },
    handleMouseDownOnMenu: function handleMouseDownOnMenu(event) {
      if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      this._openAfterFocus = true;
      this.focus();
    },
    closeMenu: function closeMenu() {
      this.setState({
        isOpen: false,
        isPseudoFocused: this.state.isFocused && !this.props.multi,
        inputValue: ''
      });
      this.hasScrolledToOption = false;
    },
    handleInputFocus: function handleInputFocus(event) {
      var isOpen = this.state.isOpen || this._openAfterFocus || this.props.openOnFocus;
      if (this.props.onFocus) {
        this.props.onFocus(event);
      }
      this.setState({
        isFocused: true,
        isOpen: isOpen
      });
      this._openAfterFocus = false;
    },
    handleInputBlur: function handleInputBlur(event) {
      if (this.refs.menu && document.activeElement === this.refs.menu) {
        this.focus();
        return;
      }
      if (this.props.onBlur) {
        this.props.onBlur(event);
      }
      var onBlurredState = {
        isFocused: false,
        isOpen: false,
        isPseudoFocused: false
      };
      if (this.props.onBlurResetsInput) {
        onBlurredState.inputValue = '';
      }
      this.setState(onBlurredState);
    },
    handleInputChange: function handleInputChange(event) {
      var newInputValue = event.target.value;
      if (this.state.inputValue !== event.target.value && this.props.onInputChange) {
        var nextState = this.props.onInputChange(newInputValue);
        if (nextState != null) {
          newInputValue = '' + nextState;
        }
      }
      this.setState({
        isOpen: true,
        isPseudoFocused: false,
        inputValue: newInputValue
      });
    },
    handleKeyDown: function handleKeyDown(event) {
      if (this.props.disabled)
        return;
      switch (event.keyCode) {
        case 8:
          if (!this.state.inputValue && this.props.backspaceRemoves) {
            event.preventDefault();
            this.popValue();
          }
          return;
        case 9:
          if (event.shiftKey || !this.state.isOpen || !this.props.tabSelectsValue) {
            return;
          }
          this.selectFocusedOption();
          return;
        case 13:
          if (!this.state.isOpen)
            return;
          event.stopPropagation();
          this.selectFocusedOption();
          break;
        case 27:
          if (this.state.isOpen) {
            this.closeMenu();
          } else if (this.props.clearable && this.props.escapeClearsValue) {
            this.clearValue(event);
          }
          break;
        case 38:
          this.focusPreviousOption();
          break;
        case 40:
          this.focusNextOption();
          break;
        default:
          return;
      }
      event.preventDefault();
    },
    handleValueClick: function handleValueClick(option, event) {
      if (!this.props.onValueClick)
        return;
      this.props.onValueClick(option, event);
    },
    handleMenuScroll: function handleMenuScroll(event) {
      if (!this.props.onMenuScrollToBottom)
        return;
      var target = event.target;
      if (target.scrollHeight > target.offsetHeight && !(target.scrollHeight - target.offsetHeight - target.scrollTop)) {
        this.props.onMenuScrollToBottom();
      }
    },
    handleRequired: function handleRequired(value, multi) {
      if (!value)
        return true;
      return multi ? value.length === 0 : Object.keys(value).length === 0;
    },
    getOptionLabel: function getOptionLabel(op) {
      return op[this.props.labelKey];
    },
    getValueArray: function getValueArray(value) {
      if (this.props.multi) {
        if (typeof value === 'string')
          value = value.split(this.props.delimiter);
        if (!Array.isArray(value)) {
          if (value === null || value === undefined)
            return [];
          value = [value];
        }
        return value.map(this.expandValue).filter(function(i) {
          return i;
        });
      }
      var expandedValue = this.expandValue(value);
      return expandedValue ? [expandedValue] : [];
    },
    expandValue: function expandValue(value) {
      if (typeof value !== 'string' && typeof value !== 'number')
        return value;
      var _props = this.props;
      var options = _props.options;
      var valueKey = _props.valueKey;
      if (!options)
        return;
      for (var i = 0; i < options.length; i++) {
        if (options[i][valueKey] === value)
          return options[i];
      }
    },
    setValue: function setValue(value) {
      var _this = this;
      if (this.props.autoBlur) {
        this.blurInput();
      }
      if (!this.props.onChange)
        return;
      if (this.props.required) {
        var required = this.handleRequired(value, this.props.multi);
        this.setState({required: required});
      }
      if (this.props.simpleValue && value) {
        value = this.props.multi ? value.map(function(i) {
          return i[_this.props.valueKey];
        }).join(this.props.delimiter) : value[this.props.valueKey];
      }
      this.props.onChange(value);
    },
    selectValue: function selectValue(value) {
      this.hasScrolledToOption = false;
      if (this.props.multi) {
        this.addValue(value);
        this.setState({inputValue: ''});
      } else {
        this.setValue(value);
        this.setState({
          isOpen: false,
          inputValue: '',
          isPseudoFocused: this.state.isFocused
        });
      }
    },
    addValue: function addValue(value) {
      var valueArray = this.getValueArray(this.props.value);
      this.setValue(valueArray.concat(value));
    },
    popValue: function popValue() {
      var valueArray = this.getValueArray(this.props.value);
      if (!valueArray.length)
        return;
      if (valueArray[valueArray.length - 1].clearableValue === false)
        return;
      this.setValue(valueArray.slice(0, valueArray.length - 1));
    },
    removeValue: function removeValue(value) {
      var valueArray = this.getValueArray(this.props.value);
      this.setValue(valueArray.filter(function(i) {
        return i !== value;
      }));
      this.focus();
    },
    clearValue: function clearValue(event) {
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      this.setValue(this.props.resetValue);
      this.setState({
        isOpen: false,
        inputValue: ''
      }, this.focus);
    },
    focusOption: function focusOption(option) {
      this.setState({focusedOption: option});
    },
    focusNextOption: function focusNextOption() {
      this.focusAdjacentOption('next');
    },
    focusPreviousOption: function focusPreviousOption() {
      this.focusAdjacentOption('previous');
    },
    focusAdjacentOption: function focusAdjacentOption(dir) {
      var options = this._visibleOptions.filter(function(i) {
        return !i.disabled;
      });
      this._scrollToFocusedOptionOnUpdate = true;
      if (!this.state.isOpen) {
        this.setState({
          isOpen: true,
          inputValue: '',
          focusedOption: this._focusedOption || options[dir === 'next' ? 0 : options.length - 1]
        });
        return;
      }
      if (!options.length)
        return;
      var focusedIndex = -1;
      for (var i = 0; i < options.length; i++) {
        if (this._focusedOption === options[i]) {
          focusedIndex = i;
          break;
        }
      }
      var focusedOption = options[0];
      if (dir === 'next' && focusedIndex > -1 && focusedIndex < options.length - 1) {
        focusedOption = options[focusedIndex + 1];
      } else if (dir === 'previous') {
        if (focusedIndex > 0) {
          focusedOption = options[focusedIndex - 1];
        } else {
          focusedOption = options[options.length - 1];
        }
      }
      this.setState({focusedOption: focusedOption});
    },
    selectFocusedOption: function selectFocusedOption() {
      if (this._focusedOption) {
        return this.selectValue(this._focusedOption);
      }
    },
    renderLoading: function renderLoading() {
      if (!this.props.isLoading)
        return;
      return _react2['default'].createElement('span', {
        className: 'Select-loading-zone',
        'aria-hidden': 'true'
      }, _react2['default'].createElement('span', {className: 'Select-loading'}));
    },
    renderValue: function renderValue(valueArray, isOpen) {
      var _this2 = this;
      var renderLabel = this.props.valueRenderer || this.getOptionLabel;
      var ValueComponent = this.props.valueComponent;
      if (!valueArray.length) {
        return !this.state.inputValue ? _react2['default'].createElement('div', {className: 'Select-placeholder'}, this.props.placeholder) : null;
      }
      var onClick = this.props.onValueClick ? this.handleValueClick : null;
      if (this.props.multi) {
        return valueArray.map(function(value, i) {
          return _react2['default'].createElement(ValueComponent, {
            disabled: _this2.props.disabled || value.clearableValue === false,
            key: 'value-' + i + '-' + value[_this2.props.valueKey],
            onClick: onClick,
            onRemove: _this2.removeValue,
            value: value
          }, renderLabel(value));
        });
      } else if (!this.state.inputValue) {
        if (isOpen)
          onClick = null;
        return _react2['default'].createElement(ValueComponent, {
          disabled: this.props.disabled,
          onClick: onClick,
          value: valueArray[0]
        }, renderLabel(valueArray[0]));
      }
    },
    renderInput: function renderInput(valueArray) {
      if (this.props.inputRenderer) {
        return this.props.inputRenderer();
      } else {
        var className = (0, _classnames2['default'])('Select-input', this.props.inputProps.className);
        if (this.props.disabled || !this.props.searchable) {
          return _react2['default'].createElement('div', _extends({}, this.props.inputProps, {
            className: className,
            tabIndex: this.props.tabIndex || 0,
            onBlur: this.handleInputBlur,
            onFocus: this.handleInputFocus,
            ref: 'input',
            style: {
              border: 0,
              width: 1,
              display: 'inline-block'
            }
          }));
        }
        if (this.props.autosize) {
          return _react2['default'].createElement(_reactInputAutosize2['default'], _extends({}, this.props.inputProps, {
            className: className,
            tabIndex: this.props.tabIndex,
            onBlur: this.handleInputBlur,
            onChange: this.handleInputChange,
            onFocus: this.handleInputFocus,
            minWidth: '5',
            ref: 'input',
            required: this.state.required,
            value: this.state.inputValue
          }));
        }
        return _react2['default'].createElement('div', {className: className}, _react2['default'].createElement('input', _extends({}, this.props.inputProps, {
          tabIndex: this.props.tabIndex,
          onBlur: this.handleInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.handleInputFocus,
          ref: 'input',
          required: this.state.required,
          value: this.state.inputValue
        })));
      }
    },
    renderClear: function renderClear() {
      if (!this.props.clearable || !this.props.value || this.props.multi && !this.props.value.length || this.props.disabled || this.props.isLoading)
        return;
      return _react2['default'].createElement('span', {
        className: 'Select-clear-zone',
        title: this.props.multi ? this.props.clearAllText : this.props.clearValueText,
        'aria-label': this.props.multi ? this.props.clearAllText : this.props.clearValueText,
        onMouseDown: this.clearValue,
        onTouchStart: this.handleTouchStart,
        onTouchMove: this.handleTouchMove,
        onTouchEnd: this.handleTouchEndClearValue
      }, _react2['default'].createElement('span', {
        className: 'Select-clear',
        dangerouslySetInnerHTML: {__html: '&times;'}
      }));
    },
    renderArrow: function renderArrow() {
      return _react2['default'].createElement('span', {
        className: 'Select-arrow-zone',
        onMouseDown: this.handleMouseDownOnArrow
      }, _react2['default'].createElement('span', {
        className: 'Select-arrow',
        onMouseDown: this.handleMouseDownOnArrow
      }));
    },
    filterOptions: function filterOptions(excludeOptions) {
      var _this3 = this;
      var filterValue = this.state.inputValue;
      var options = this.props.options || [];
      if (typeof this.props.filterOptions === 'function') {
        return this.props.filterOptions.call(this, options, filterValue, excludeOptions);
      } else if (this.props.filterOptions) {
        if (this.props.ignoreAccents) {
          filterValue = (0, _utilsStripDiacritics2['default'])(filterValue);
        }
        if (this.props.ignoreCase) {
          filterValue = filterValue.toLowerCase();
        }
        if (excludeOptions)
          excludeOptions = excludeOptions.map(function(i) {
            return i[_this3.props.valueKey];
          });
        return options.filter(function(option) {
          if (excludeOptions && excludeOptions.indexOf(option[_this3.props.valueKey]) > -1)
            return false;
          if (_this3.props.filterOption)
            return _this3.props.filterOption.call(_this3, option, filterValue);
          if (!filterValue)
            return true;
          var valueTest = String(option[_this3.props.valueKey]);
          var labelTest = String(option[_this3.props.labelKey]);
          if (_this3.props.ignoreAccents) {
            if (_this3.props.matchProp !== 'label')
              valueTest = (0, _utilsStripDiacritics2['default'])(valueTest);
            if (_this3.props.matchProp !== 'value')
              labelTest = (0, _utilsStripDiacritics2['default'])(labelTest);
          }
          if (_this3.props.ignoreCase) {
            if (_this3.props.matchProp !== 'label')
              valueTest = valueTest.toLowerCase();
            if (_this3.props.matchProp !== 'value')
              labelTest = labelTest.toLowerCase();
          }
          return _this3.props.matchPos === 'start' ? _this3.props.matchProp !== 'label' && valueTest.substr(0, filterValue.length) === filterValue || _this3.props.matchProp !== 'value' && labelTest.substr(0, filterValue.length) === filterValue : _this3.props.matchProp !== 'label' && valueTest.indexOf(filterValue) >= 0 || _this3.props.matchProp !== 'value' && labelTest.indexOf(filterValue) >= 0;
        });
      } else {
        return options;
      }
    },
    renderMenu: function renderMenu(options, valueArray, focusedOption) {
      var _this4 = this;
      if (options && options.length) {
        if (this.props.menuRenderer) {
          return this.props.menuRenderer({
            focusedOption: focusedOption,
            focusOption: this.focusOption,
            labelKey: this.props.labelKey,
            options: options,
            selectValue: this.selectValue,
            valueArray: valueArray
          });
        } else {
          var _ret = (function() {
            var Option = _this4.props.optionComponent;
            var renderLabel = _this4.props.optionRenderer || _this4.getOptionLabel;
            return {v: options.map(function(option, i) {
                var isSelected = valueArray && valueArray.indexOf(option) > -1;
                var isFocused = option === focusedOption;
                var optionRef = isFocused ? 'focused' : null;
                var optionClass = (0, _classnames2['default'])(_this4.props.optionClassName, {
                  'Select-option': true,
                  'is-selected': isSelected,
                  'is-focused': isFocused,
                  'is-disabled': option.disabled
                });
                return _react2['default'].createElement(Option, {
                  className: optionClass,
                  isDisabled: option.disabled,
                  isFocused: isFocused,
                  key: 'option-' + i + '-' + option[_this4.props.valueKey],
                  onSelect: _this4.selectValue,
                  onFocus: _this4.focusOption,
                  option: option,
                  isSelected: isSelected,
                  ref: optionRef
                }, renderLabel(option));
              })};
          })();
          if (typeof _ret === 'object')
            return _ret.v;
        }
      } else if (this.props.noResultsText) {
        return _react2['default'].createElement('div', {className: 'Select-noresults'}, this.props.noResultsText);
      } else {
        return null;
      }
    },
    renderHiddenField: function renderHiddenField(valueArray) {
      var _this5 = this;
      if (!this.props.name)
        return;
      if (this.props.joinValues) {
        var value = valueArray.map(function(i) {
          return stringifyValue(i[_this5.props.valueKey]);
        }).join(this.props.delimiter);
        return _react2['default'].createElement('input', {
          type: 'hidden',
          ref: 'value',
          name: this.props.name,
          value: value,
          disabled: this.props.disabled
        });
      }
      return valueArray.map(function(item, index) {
        return _react2['default'].createElement('input', {
          key: 'hidden.' + index,
          type: 'hidden',
          ref: 'value' + index,
          name: _this5.props.name,
          value: stringifyValue(item[_this5.props.valueKey]),
          disabled: _this5.props.disabled
        });
      });
    },
    getFocusableOption: function getFocusableOption(selectedOption) {
      var options = this._visibleOptions;
      if (!options.length)
        return;
      var focusedOption = this.state.focusedOption || selectedOption;
      if (focusedOption && options.indexOf(focusedOption) > -1)
        return focusedOption;
      for (var i = 0; i < options.length; i++) {
        if (!options[i].disabled)
          return options[i];
      }
    },
    renderOuter: function renderOuter(options, valueArray, focusedOption) {
      var menu = this.renderMenu(options, valueArray, focusedOption);
      if (!menu) {
        return null;
      }
      return _react2['default'].createElement('div', {
        ref: 'menuContainer',
        className: 'Select-menu-outer',
        style: this.props.menuContainerStyle
      }, _react2['default'].createElement('div', {
        ref: 'menu',
        className: 'Select-menu',
        style: this.props.menuStyle,
        onScroll: this.handleMenuScroll,
        onMouseDown: this.handleMouseDownOnMenu
      }, menu));
    },
    render: function render() {
      var valueArray = this.getValueArray(this.props.value);
      var options = this._visibleOptions = this.filterOptions(this.props.multi ? valueArray : null);
      var isOpen = this.state.isOpen;
      if (this.props.multi && !options.length && valueArray.length && !this.state.inputValue)
        isOpen = false;
      var focusedOption = this._focusedOption = this.getFocusableOption(valueArray[0]);
      var className = (0, _classnames2['default'])('Select', this.props.className, {
        'Select--multi': this.props.multi,
        'Select--single': !this.props.multi,
        'is-disabled': this.props.disabled,
        'is-focused': this.state.isFocused,
        'is-loading': this.props.isLoading,
        'is-open': isOpen,
        'is-pseudo-focused': this.state.isPseudoFocused,
        'is-searchable': this.props.searchable,
        'has-value': valueArray.length
      });
      return _react2['default'].createElement('div', {
        ref: 'wrapper',
        className: className,
        style: this.props.wrapperStyle
      }, this.renderHiddenField(valueArray), _react2['default'].createElement('div', {
        ref: 'control',
        className: 'Select-control',
        style: this.props.style,
        onKeyDown: this.handleKeyDown,
        onMouseDown: this.handleMouseDown,
        onTouchEnd: this.handleTouchEnd,
        onTouchStart: this.handleTouchStart,
        onTouchMove: this.handleTouchMove
      }, this.renderValue(valueArray, isOpen), this.renderInput(valueArray), this.renderLoading(), this.renderClear(), this.renderArrow()), isOpen ? this.renderOuter(options, !this.props.multi ? valueArray : null, focusedOption) : null);
    }
  });
  exports['default'] = Select;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:react-select@1.0.0-beta13/lib/utils/stripDiacritics.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var map = [{
    'base': 'A',
    'letters': /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g
  }, {
    'base': 'AA',
    'letters': /[\uA732]/g
  }, {
    'base': 'AE',
    'letters': /[\u00C6\u01FC\u01E2]/g
  }, {
    'base': 'AO',
    'letters': /[\uA734]/g
  }, {
    'base': 'AU',
    'letters': /[\uA736]/g
  }, {
    'base': 'AV',
    'letters': /[\uA738\uA73A]/g
  }, {
    'base': 'AY',
    'letters': /[\uA73C]/g
  }, {
    'base': 'B',
    'letters': /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g
  }, {
    'base': 'C',
    'letters': /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g
  }, {
    'base': 'D',
    'letters': /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g
  }, {
    'base': 'DZ',
    'letters': /[\u01F1\u01C4]/g
  }, {
    'base': 'Dz',
    'letters': /[\u01F2\u01C5]/g
  }, {
    'base': 'E',
    'letters': /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g
  }, {
    'base': 'F',
    'letters': /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g
  }, {
    'base': 'G',
    'letters': /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g
  }, {
    'base': 'H',
    'letters': /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g
  }, {
    'base': 'I',
    'letters': /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g
  }, {
    'base': 'J',
    'letters': /[\u004A\u24BF\uFF2A\u0134\u0248]/g
  }, {
    'base': 'K',
    'letters': /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g
  }, {
    'base': 'L',
    'letters': /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g
  }, {
    'base': 'LJ',
    'letters': /[\u01C7]/g
  }, {
    'base': 'Lj',
    'letters': /[\u01C8]/g
  }, {
    'base': 'M',
    'letters': /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g
  }, {
    'base': 'N',
    'letters': /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g
  }, {
    'base': 'NJ',
    'letters': /[\u01CA]/g
  }, {
    'base': 'Nj',
    'letters': /[\u01CB]/g
  }, {
    'base': 'O',
    'letters': /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g
  }, {
    'base': 'OI',
    'letters': /[\u01A2]/g
  }, {
    'base': 'OO',
    'letters': /[\uA74E]/g
  }, {
    'base': 'OU',
    'letters': /[\u0222]/g
  }, {
    'base': 'P',
    'letters': /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g
  }, {
    'base': 'Q',
    'letters': /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g
  }, {
    'base': 'R',
    'letters': /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g
  }, {
    'base': 'S',
    'letters': /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g
  }, {
    'base': 'T',
    'letters': /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g
  }, {
    'base': 'TZ',
    'letters': /[\uA728]/g
  }, {
    'base': 'U',
    'letters': /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g
  }, {
    'base': 'V',
    'letters': /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g
  }, {
    'base': 'VY',
    'letters': /[\uA760]/g
  }, {
    'base': 'W',
    'letters': /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g
  }, {
    'base': 'X',
    'letters': /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g
  }, {
    'base': 'Y',
    'letters': /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g
  }, {
    'base': 'Z',
    'letters': /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g
  }, {
    'base': 'a',
    'letters': /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g
  }, {
    'base': 'aa',
    'letters': /[\uA733]/g
  }, {
    'base': 'ae',
    'letters': /[\u00E6\u01FD\u01E3]/g
  }, {
    'base': 'ao',
    'letters': /[\uA735]/g
  }, {
    'base': 'au',
    'letters': /[\uA737]/g
  }, {
    'base': 'av',
    'letters': /[\uA739\uA73B]/g
  }, {
    'base': 'ay',
    'letters': /[\uA73D]/g
  }, {
    'base': 'b',
    'letters': /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g
  }, {
    'base': 'c',
    'letters': /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g
  }, {
    'base': 'd',
    'letters': /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g
  }, {
    'base': 'dz',
    'letters': /[\u01F3\u01C6]/g
  }, {
    'base': 'e',
    'letters': /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g
  }, {
    'base': 'f',
    'letters': /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g
  }, {
    'base': 'g',
    'letters': /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g
  }, {
    'base': 'h',
    'letters': /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g
  }, {
    'base': 'hv',
    'letters': /[\u0195]/g
  }, {
    'base': 'i',
    'letters': /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g
  }, {
    'base': 'j',
    'letters': /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g
  }, {
    'base': 'k',
    'letters': /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g
  }, {
    'base': 'l',
    'letters': /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g
  }, {
    'base': 'lj',
    'letters': /[\u01C9]/g
  }, {
    'base': 'm',
    'letters': /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g
  }, {
    'base': 'n',
    'letters': /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g
  }, {
    'base': 'nj',
    'letters': /[\u01CC]/g
  }, {
    'base': 'o',
    'letters': /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g
  }, {
    'base': 'oi',
    'letters': /[\u01A3]/g
  }, {
    'base': 'ou',
    'letters': /[\u0223]/g
  }, {
    'base': 'oo',
    'letters': /[\uA74F]/g
  }, {
    'base': 'p',
    'letters': /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g
  }, {
    'base': 'q',
    'letters': /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g
  }, {
    'base': 'r',
    'letters': /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g
  }, {
    'base': 's',
    'letters': /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g
  }, {
    'base': 't',
    'letters': /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g
  }, {
    'base': 'tz',
    'letters': /[\uA729]/g
  }, {
    'base': 'u',
    'letters': /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g
  }, {
    'base': 'v',
    'letters': /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g
  }, {
    'base': 'vy',
    'letters': /[\uA761]/g
  }, {
    'base': 'w',
    'letters': /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g
  }, {
    'base': 'x',
    'letters': /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g
  }, {
    'base': 'y',
    'letters': /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g
  }, {
    'base': 'z',
    'letters': /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g
  }];
  module.exports = function stripDiacritics(str) {
    for (var i = 0; i < map.length; i++) {
      str = str.replace(map[i].letters, map[i].base);
    }
    return str;
  };
  return module.exports;
});

System.registerDynamic("npm:react-select@1.0.0-beta13.json", [], false, function() {
  return {
    "main": "lib/Select.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      },
      ".publish/app.js": {
        "cjsRequireDetection": false
      },
      ".publish/bundle.js": {
        "cjsRequireDetection": false
      },
      ".publish/common.js": {
        "cjsRequireDetection": false
      },
      ".publish/standalone.js": {
        "cjsRequireDetection": false
      },
      "dist/react-select.js": {
        "cjsRequireDetection": false
      }
    }
  };
});

System.registerDynamic("npm:react-select@1.0.0-beta13/lib/Async.js", ["react", "./Select", "./utils/stripDiacritics"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _react = $__require('react');
  var _react2 = _interopRequireDefault(_react);
  var _Select = $__require('./Select');
  var _Select2 = _interopRequireDefault(_Select);
  var _utilsStripDiacritics = $__require('./utils/stripDiacritics');
  var _utilsStripDiacritics2 = _interopRequireDefault(_utilsStripDiacritics);
  var requestId = 0;
  function initCache(cache) {
    if (cache && typeof cache !== 'object') {
      cache = {};
    }
    return cache ? cache : null;
  }
  function updateCache(cache, input, data) {
    if (!cache)
      return;
    cache[input] = data;
  }
  function getFromCache(cache, input) {
    if (!cache)
      return;
    for (var i = input.length; i >= 0; --i) {
      var cacheKey = input.slice(0, i);
      if (cache[cacheKey] && (input === cacheKey || cache[cacheKey].complete)) {
        return cache[cacheKey];
      }
    }
  }
  function thenPromise(promise, callback) {
    if (!promise || typeof promise.then !== 'function')
      return;
    return promise.then(function(data) {
      callback(null, data);
    }, function(err) {
      callback(err);
    });
  }
  var stringOrNode = _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.string, _react2['default'].PropTypes.node]);
  var Async = _react2['default'].createClass({
    displayName: 'Async',
    propTypes: {
      cache: _react2['default'].PropTypes.any,
      ignoreAccents: _react2['default'].PropTypes.bool,
      ignoreCase: _react2['default'].PropTypes.bool,
      isLoading: _react2['default'].PropTypes.bool,
      loadOptions: _react2['default'].PropTypes.func.isRequired,
      loadingPlaceholder: _react2['default'].PropTypes.string,
      minimumInput: _react2['default'].PropTypes.number,
      noResultsText: stringOrNode,
      onInputChange: _react2['default'].PropTypes.func,
      placeholder: stringOrNode,
      searchPromptText: _react2['default'].PropTypes.string,
      searchingText: _react2['default'].PropTypes.string
    },
    getDefaultProps: function getDefaultProps() {
      return {
        cache: true,
        ignoreAccents: true,
        ignoreCase: true,
        loadingPlaceholder: 'Loading...',
        minimumInput: 0,
        searchingText: 'Searching...',
        searchPromptText: 'Type to search'
      };
    },
    getInitialState: function getInitialState() {
      return {
        cache: initCache(this.props.cache),
        isLoading: false,
        options: []
      };
    },
    componentWillMount: function componentWillMount() {
      this._lastInput = '';
    },
    componentDidMount: function componentDidMount() {
      this.loadOptions('');
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      if (nextProps.cache !== this.props.cache) {
        this.setState({cache: initCache(nextProps.cache)});
      }
    },
    focus: function focus() {
      this.refs.select.focus();
    },
    resetState: function resetState() {
      this._currentRequestId = -1;
      this.setState({
        isLoading: false,
        options: []
      });
    },
    getResponseHandler: function getResponseHandler(input) {
      var _this = this;
      var _requestId = this._currentRequestId = requestId++;
      return function(err, data) {
        if (err)
          throw err;
        if (!_this.isMounted())
          return;
        updateCache(_this.state.cache, input, data);
        if (_requestId !== _this._currentRequestId)
          return;
        _this.setState({
          isLoading: false,
          options: data && data.options || []
        });
      };
    },
    loadOptions: function loadOptions(input) {
      if (this.props.onInputChange) {
        var nextState = this.props.onInputChange(input);
        if (nextState != null) {
          input = '' + nextState;
        }
      }
      if (this.props.ignoreAccents)
        input = (0, _utilsStripDiacritics2['default'])(input);
      if (this.props.ignoreCase)
        input = input.toLowerCase();
      this._lastInput = input;
      if (input.length < this.props.minimumInput) {
        return this.resetState();
      }
      var cacheResult = getFromCache(this.state.cache, input);
      if (cacheResult) {
        return this.setState({options: cacheResult.options});
      }
      this.setState({isLoading: true});
      var responseHandler = this.getResponseHandler(input);
      return thenPromise(this.props.loadOptions(input, responseHandler), responseHandler);
    },
    render: function render() {
      var noResultsText = this.props.noResultsText;
      var _state = this.state;
      var isLoading = _state.isLoading;
      var options = _state.options;
      if (this.props.isLoading)
        isLoading = true;
      var placeholder = isLoading ? this.props.loadingPlaceholder : this.props.placeholder;
      if (!options.length) {
        if (this._lastInput.length < this.props.minimumInput)
          noResultsText = this.props.searchPromptText;
        if (isLoading)
          noResultsText = this.props.searchingText;
      }
      return _react2['default'].createElement(_Select2['default'], _extends({}, this.props, {
        ref: 'select',
        isLoading: isLoading,
        noResultsText: noResultsText,
        onInputChange: this.loadOptions,
        options: options,
        placeholder: placeholder
      }));
    }
  });
  module.exports = Async;
  return module.exports;
});

System.registerDynamic("npm:redux-logger@2.6.1.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./dist": "./dist/index.js",
      "./lib": "./lib/index.js",
      "./src": "./src/index.js"
    }
  };
});

System.registerDynamic("npm:redux-logger@2.6.1/lib/index.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0,
          arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function _typeof(obj) {
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
  }
  var repeat = function repeat(str, times) {
    return new Array(times + 1).join(str);
  };
  var pad = function pad(num, maxLength) {
    return repeat("0", maxLength - num.toString().length) + num;
  };
  var formatTime = function formatTime(time) {
    return "@ " + pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
  };
  var timer = typeof performance !== "undefined" && typeof performance.now === "function" ? performance : Date;
  function getLogLevel(level, action, payload, type) {
    switch (typeof level === "undefined" ? "undefined" : _typeof(level)) {
      case "object":
        return typeof level[type] === "function" ? level[type].apply(level, _toConsumableArray(payload)) : level[type];
      case "function":
        return level(action);
      default:
        return level;
    }
  }
  function createLogger() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var _options$level = options.level;
    var level = _options$level === undefined ? "log" : _options$level;
    var _options$logger = options.logger;
    var logger = _options$logger === undefined ? console : _options$logger;
    var _options$logErrors = options.logErrors;
    var logErrors = _options$logErrors === undefined ? true : _options$logErrors;
    var collapsed = options.collapsed;
    var predicate = options.predicate;
    var _options$duration = options.duration;
    var duration = _options$duration === undefined ? false : _options$duration;
    var _options$timestamp = options.timestamp;
    var timestamp = _options$timestamp === undefined ? true : _options$timestamp;
    var transformer = options.transformer;
    var _options$stateTransfo = options.stateTransformer;
    var stateTransformer = _options$stateTransfo === undefined ? function(state) {
      return state;
    } : _options$stateTransfo;
    var _options$actionTransf = options.actionTransformer;
    var actionTransformer = _options$actionTransf === undefined ? function(actn) {
      return actn;
    } : _options$actionTransf;
    var _options$errorTransfo = options.errorTransformer;
    var errorTransformer = _options$errorTransfo === undefined ? function(error) {
      return error;
    } : _options$errorTransfo;
    var _options$colors = options.colors;
    var colors = _options$colors === undefined ? {
      title: function title() {
        return "#000000";
      },
      prevState: function prevState() {
        return "#9E9E9E";
      },
      action: function action() {
        return "#03A9F4";
      },
      nextState: function nextState() {
        return "#4CAF50";
      },
      error: function error() {
        return "#F20404";
      }
    } : _options$colors;
    if (typeof logger === "undefined") {
      return function() {
        return function(next) {
          return function(action) {
            return next(action);
          };
        };
      };
    }
    if (transformer) {
      console.error("Option 'transformer' is deprecated, use stateTransformer instead");
    }
    var logBuffer = [];
    function printBuffer() {
      logBuffer.forEach(function(logEntry, key) {
        var started = logEntry.started;
        var startedTime = logEntry.startedTime;
        var action = logEntry.action;
        var prevState = logEntry.prevState;
        var error = logEntry.error;
        var took = logEntry.took;
        var nextState = logEntry.nextState;
        var nextEntry = logBuffer[key + 1];
        if (nextEntry) {
          nextState = nextEntry.prevState;
          took = nextEntry.started - started;
        }
        var formattedAction = actionTransformer(action);
        var isCollapsed = typeof collapsed === "function" ? collapsed(function() {
          return nextState;
        }, action) : collapsed;
        var formattedTime = formatTime(startedTime);
        var titleCSS = colors.title ? "color: " + colors.title(formattedAction) + ";" : null;
        var title = "action " + (timestamp ? formattedTime : "") + " " + formattedAction.type + " " + (duration ? "(in " + took.toFixed(2) + " ms)" : "");
        try {
          if (isCollapsed) {
            if (colors.title)
              logger.groupCollapsed("%c " + title, titleCSS);
            else
              logger.groupCollapsed(title);
          } else {
            if (colors.title)
              logger.group("%c " + title, titleCSS);
            else
              logger.group(title);
          }
        } catch (e) {
          logger.log(title);
        }
        var prevStateLevel = getLogLevel(level, formattedAction, [prevState], "prevState");
        var actionLevel = getLogLevel(level, formattedAction, [formattedAction], "action");
        var errorLevel = getLogLevel(level, formattedAction, [error, prevState], "error");
        var nextStateLevel = getLogLevel(level, formattedAction, [nextState], "nextState");
        if (prevStateLevel) {
          if (colors.prevState)
            logger[prevStateLevel]("%c prev state", "color: " + colors.prevState(prevState) + "; font-weight: bold", prevState);
          else
            logger[prevStateLevel]("prev state", prevState);
        }
        if (actionLevel) {
          if (colors.action)
            logger[actionLevel]("%c action", "color: " + colors.action(formattedAction) + "; font-weight: bold", formattedAction);
          else
            logger[actionLevel]("action", formattedAction);
        }
        if (error && errorLevel) {
          if (colors.error)
            logger[errorLevel]("%c error", "color: " + colors.error(error, prevState) + "; font-weight: bold", error);
          else
            logger[errorLevel]("error", error);
        }
        if (nextStateLevel) {
          if (colors.nextState)
            logger[nextStateLevel]("%c next state", "color: " + colors.nextState(nextState) + "; font-weight: bold", nextState);
          else
            logger[nextStateLevel]("next state", nextState);
        }
        try {
          logger.groupEnd();
        } catch (e) {
          logger.log(" log end ");
        }
      });
      logBuffer.length = 0;
    }
    return function(_ref) {
      var getState = _ref.getState;
      return function(next) {
        return function(action) {
          if (typeof predicate === "function" && !predicate(getState, action)) {
            return next(action);
          }
          var logEntry = {};
          logBuffer.push(logEntry);
          logEntry.started = timer.now();
          logEntry.startedTime = new Date();
          logEntry.prevState = stateTransformer(getState());
          logEntry.action = action;
          var returnedValue = undefined;
          if (logErrors) {
            try {
              returnedValue = next(action);
            } catch (e) {
              logEntry.error = errorTransformer(e);
            }
          } else {
            returnedValue = next(action);
          }
          logEntry.took = timer.now() - logEntry.started;
          logEntry.nextState = stateTransformer(getState());
          printBuffer();
          if (logEntry.error)
            throw logEntry.error;
          return returnedValue;
        };
      };
    };
  }
  module.exports = createLogger;
  return module.exports;
});

System.registerDynamic("npm:redux-thunk@2.1.0.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      },
      "es/*": {
        "format": "esm"
      },
      "src/*": {
        "format": "esm"
      }
    },
    "map": {
      "./lib": "./lib/index.js"
    }
  };
});

System.registerDynamic("npm:redux-thunk@2.1.0/lib/index.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  function createThunkMiddleware(extraArgument) {
    return function(_ref) {
      var dispatch = _ref.dispatch;
      var getState = _ref.getState;
      return function(next) {
        return function(action) {
          if (typeof action === 'function') {
            return action(dispatch, getState, extraArgument);
          }
          return next(action);
        };
      };
    };
  }
  var thunk = createThunkMiddleware();
  thunk.withExtraArgument = createThunkMiddleware;
  exports['default'] = thunk;
  return module.exports;
});

System.registerDynamic("npm:component-emitter@1.2.1.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:component-emitter@1.2.1/index.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  if (typeof module !== 'undefined') {
    module.exports = Emitter;
  }
  function Emitter(obj) {
    if (obj)
      return mixin(obj);
  }
  ;
  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }
  Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
    return this;
  };
  Emitter.prototype.once = function(event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }
    on.fn = fn;
    this.on(event, on);
    return this;
  };
  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }
    var callbacks = this._callbacks['$' + event];
    if (!callbacks)
      return this;
    if (1 == arguments.length) {
      delete this._callbacks['$' + event];
      return this;
    }
    var cb;
    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }
    return this;
  };
  Emitter.prototype.emit = function(event) {
    this._callbacks = this._callbacks || {};
    var args = [].slice.call(arguments, 1),
        callbacks = this._callbacks['$' + event];
    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0,
          len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }
    return this;
  };
  Emitter.prototype.listeners = function(event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks['$' + event] || [];
  };
  Emitter.prototype.hasListeners = function(event) {
    return !!this.listeners(event).length;
  };
  return module.exports;
});

System.registerDynamic("npm:reduce-component@1.0.1.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:reduce-component@1.0.1/index.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function(arr, fn, initial) {
    var idx = 0;
    var len = arr.length;
    var curr = arguments.length == 3 ? initial : arr[idx++];
    while (idx < len) {
      curr = fn.call(null, curr, arr[idx], ++idx, arr);
    }
    return curr;
  };
  return module.exports;
});

System.registerDynamic("npm:superagent@1.8.3/lib/request-base.js", ["./is-object"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var isObject = $__require('./is-object');
  exports.clearTimeout = function _clearTimeout() {
    this._timeout = 0;
    clearTimeout(this._timer);
    return this;
  };
  exports.parse = function parse(fn) {
    this._parser = fn;
    return this;
  };
  exports.timeout = function timeout(ms) {
    this._timeout = ms;
    return this;
  };
  exports.then = function then(fulfill, reject) {
    return this.end(function(err, res) {
      err ? reject(err) : fulfill(res);
    });
  };
  exports.use = function use(fn) {
    fn(this);
    return this;
  };
  exports.get = function(field) {
    return this._header[field.toLowerCase()];
  };
  exports.getHeader = exports.get;
  exports.set = function(field, val) {
    if (isObject(field)) {
      for (var key in field) {
        this.set(key, field[key]);
      }
      return this;
    }
    this._header[field.toLowerCase()] = val;
    this.header[field] = val;
    return this;
  };
  exports.unset = function(field) {
    delete this._header[field.toLowerCase()];
    delete this.header[field];
    return this;
  };
  exports.field = function(name, val) {
    this._getFormData().append(name, val);
    return this;
  };
  return module.exports;
});

System.registerDynamic("npm:superagent@1.8.3/lib/is-object.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function isObject(obj) {
    return null != obj && 'object' == typeof obj;
  }
  module.exports = isObject;
  return module.exports;
});

System.registerDynamic("npm:superagent@1.8.3/lib/request.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function request(RequestConstructor, method, url) {
    if ('function' == typeof url) {
      return new RequestConstructor('GET', method).end(url);
    }
    if (2 == arguments.length) {
      return new RequestConstructor('GET', method);
    }
    return new RequestConstructor(method, url);
  }
  module.exports = request;
  return module.exports;
});

System.registerDynamic("npm:superagent@1.8.3.json", [], false, function() {
  return {
    "main": "lib/client.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      },
      "docs/jquery-ui.min.js": {
        "format": "amd"
      },
      "docs/jquery.js": {
        "format": "amd"
      },
      "lib/node/index.js": {
        "globals": {
          "Buffer": "buffer/global"
        }
      },
      "lib/node/parsers/image.js": {
        "globals": {
          "Buffer": "buffer/global"
        }
      },
      "superagent.js": {
        "cjsRequireDetection": false
      }
    },
    "map": {
      "./lib/node": "./lib/node/index.js",
      "./lib/node/index.js": {
        "browser": "./lib/client.js"
      },
      "./lib/node/parsers": "./lib/node/parsers/index.js",
      "emitter": {
        "browser": "component-emitter"
      },
      "reduce": {
        "browser": "reduce-component"
      }
    }
  };
});

System.registerDynamic("npm:superagent@1.8.3/lib/client.js", ["emitter", "reduce", "./request-base", "./is-object", "./request"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Emitter = $__require('emitter');
  var reduce = $__require('reduce');
  var requestBase = $__require('./request-base');
  var isObject = $__require('./is-object');
  var root;
  if (typeof window !== 'undefined') {
    root = window;
  } else if (typeof self !== 'undefined') {
    root = self;
  } else {
    root = this;
  }
  function noop() {}
  ;
  function isHost(obj) {
    var str = {}.toString.call(obj);
    switch (str) {
      case '[object File]':
      case '[object Blob]':
      case '[object FormData]':
        return true;
      default:
        return false;
    }
  }
  var request = module.exports = $__require('./request').bind(null, Request);
  request.getXHR = function() {
    if (root.XMLHttpRequest && (!root.location || 'file:' != root.location.protocol || !root.ActiveXObject)) {
      return new XMLHttpRequest;
    } else {
      try {
        return new ActiveXObject('Microsoft.XMLHTTP');
      } catch (e) {}
      try {
        return new ActiveXObject('Msxml2.XMLHTTP.6.0');
      } catch (e) {}
      try {
        return new ActiveXObject('Msxml2.XMLHTTP.3.0');
      } catch (e) {}
      try {
        return new ActiveXObject('Msxml2.XMLHTTP');
      } catch (e) {}
    }
    return false;
  };
  var trim = ''.trim ? function(s) {
    return s.trim();
  } : function(s) {
    return s.replace(/(^\s*|\s*$)/g, '');
  };
  function serialize(obj) {
    if (!isObject(obj))
      return obj;
    var pairs = [];
    for (var key in obj) {
      if (null != obj[key]) {
        pushEncodedKeyValuePair(pairs, key, obj[key]);
      }
    }
    return pairs.join('&');
  }
  function pushEncodedKeyValuePair(pairs, key, val) {
    if (Array.isArray(val)) {
      return val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    }
    pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
  }
  request.serializeObject = serialize;
  function parseString(str) {
    var obj = {};
    var pairs = str.split('&');
    var parts;
    var pair;
    for (var i = 0,
        len = pairs.length; i < len; ++i) {
      pair = pairs[i];
      parts = pair.split('=');
      obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
    }
    return obj;
  }
  request.parseString = parseString;
  request.types = {
    html: 'text/html',
    json: 'application/json',
    xml: 'application/xml',
    urlencoded: 'application/x-www-form-urlencoded',
    'form': 'application/x-www-form-urlencoded',
    'form-data': 'application/x-www-form-urlencoded'
  };
  request.serialize = {
    'application/x-www-form-urlencoded': serialize,
    'application/json': JSON.stringify
  };
  request.parse = {
    'application/x-www-form-urlencoded': parseString,
    'application/json': JSON.parse
  };
  function parseHeader(str) {
    var lines = str.split(/\r?\n/);
    var fields = {};
    var index;
    var line;
    var field;
    var val;
    lines.pop();
    for (var i = 0,
        len = lines.length; i < len; ++i) {
      line = lines[i];
      index = line.indexOf(':');
      field = line.slice(0, index).toLowerCase();
      val = trim(line.slice(index + 1));
      fields[field] = val;
    }
    return fields;
  }
  function isJSON(mime) {
    return /[\/+]json\b/.test(mime);
  }
  function type(str) {
    return str.split(/ *; */).shift();
  }
  ;
  function params(str) {
    return reduce(str.split(/ *; */), function(obj, str) {
      var parts = str.split(/ *= */),
          key = parts.shift(),
          val = parts.shift();
      if (key && val)
        obj[key] = val;
      return obj;
    }, {});
  }
  ;
  function Response(req, options) {
    options = options || {};
    this.req = req;
    this.xhr = this.req.xhr;
    this.text = ((this.req.method != 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined') ? this.xhr.responseText : null;
    this.statusText = this.req.xhr.statusText;
    this.setStatusProperties(this.xhr.status);
    this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
    this.header['content-type'] = this.xhr.getResponseHeader('content-type');
    this.setHeaderProperties(this.header);
    this.body = this.req.method != 'HEAD' ? this.parseBody(this.text ? this.text : this.xhr.response) : null;
  }
  Response.prototype.get = function(field) {
    return this.header[field.toLowerCase()];
  };
  Response.prototype.setHeaderProperties = function(header) {
    var ct = this.header['content-type'] || '';
    this.type = type(ct);
    var obj = params(ct);
    for (var key in obj)
      this[key] = obj[key];
  };
  Response.prototype.parseBody = function(str) {
    var parse = request.parse[this.type];
    if (!parse && isJSON(this.type)) {
      parse = request.parse['application/json'];
    }
    return parse && str && (str.length || str instanceof Object) ? parse(str) : null;
  };
  Response.prototype.setStatusProperties = function(status) {
    if (status === 1223) {
      status = 204;
    }
    var type = status / 100 | 0;
    this.status = this.statusCode = status;
    this.statusType = type;
    this.info = 1 == type;
    this.ok = 2 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type) ? this.toError() : false;
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.notFound = 404 == status;
    this.forbidden = 403 == status;
  };
  Response.prototype.toError = function() {
    var req = this.req;
    var method = req.method;
    var url = req.url;
    var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
    var err = new Error(msg);
    err.status = this.status;
    err.method = method;
    err.url = url;
    return err;
  };
  request.Response = Response;
  function Request(method, url) {
    var self = this;
    this._query = this._query || [];
    this.method = method;
    this.url = url;
    this.header = {};
    this._header = {};
    this.on('end', function() {
      var err = null;
      var res = null;
      try {
        res = new Response(self);
      } catch (e) {
        err = new Error('Parser is unable to parse the response');
        err.parse = true;
        err.original = e;
        err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
        err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;
        return self.callback(err);
      }
      self.emit('response', res);
      if (err) {
        return self.callback(err, res);
      }
      if (res.status >= 200 && res.status < 300) {
        return self.callback(err, res);
      }
      var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    });
  }
  Emitter(Request.prototype);
  for (var key in requestBase) {
    Request.prototype[key] = requestBase[key];
  }
  Request.prototype.abort = function() {
    if (this.aborted)
      return;
    this.aborted = true;
    this.xhr.abort();
    this.clearTimeout();
    this.emit('abort');
    return this;
  };
  Request.prototype.type = function(type) {
    this.set('Content-Type', request.types[type] || type);
    return this;
  };
  Request.prototype.responseType = function(val) {
    this._responseType = val;
    return this;
  };
  Request.prototype.accept = function(type) {
    this.set('Accept', request.types[type] || type);
    return this;
  };
  Request.prototype.auth = function(user, pass, options) {
    if (!options) {
      options = {type: 'basic'};
    }
    switch (options.type) {
      case 'basic':
        var str = btoa(user + ':' + pass);
        this.set('Authorization', 'Basic ' + str);
        break;
      case 'auto':
        this.username = user;
        this.password = pass;
        break;
    }
    return this;
  };
  Request.prototype.query = function(val) {
    if ('string' != typeof val)
      val = serialize(val);
    if (val)
      this._query.push(val);
    return this;
  };
  Request.prototype.attach = function(field, file, filename) {
    this._getFormData().append(field, file, filename || file.name);
    return this;
  };
  Request.prototype._getFormData = function() {
    if (!this._formData) {
      this._formData = new root.FormData();
    }
    return this._formData;
  };
  Request.prototype.send = function(data) {
    var obj = isObject(data);
    var type = this._header['content-type'];
    if (obj && isObject(this._data)) {
      for (var key in data) {
        this._data[key] = data[key];
      }
    } else if ('string' == typeof data) {
      if (!type)
        this.type('form');
      type = this._header['content-type'];
      if ('application/x-www-form-urlencoded' == type) {
        this._data = this._data ? this._data + '&' + data : data;
      } else {
        this._data = (this._data || '') + data;
      }
    } else {
      this._data = data;
    }
    if (!obj || isHost(data))
      return this;
    if (!type)
      this.type('json');
    return this;
  };
  Response.prototype.parse = function serialize(fn) {
    if (root.console) {
      console.warn("Client-side parse() method has been renamed to serialize(). This method is not compatible with superagent v2.0");
    }
    this.serialize(fn);
    return this;
  };
  Response.prototype.serialize = function serialize(fn) {
    this._parser = fn;
    return this;
  };
  Request.prototype.callback = function(err, res) {
    var fn = this._callback;
    this.clearTimeout();
    fn(err, res);
  };
  Request.prototype.crossDomainError = function() {
    var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
    err.crossDomain = true;
    err.status = this.status;
    err.method = this.method;
    err.url = this.url;
    this.callback(err);
  };
  Request.prototype.timeoutError = function() {
    var timeout = this._timeout;
    var err = new Error('timeout of ' + timeout + 'ms exceeded');
    err.timeout = timeout;
    this.callback(err);
  };
  Request.prototype.withCredentials = function() {
    this._withCredentials = true;
    return this;
  };
  Request.prototype.end = function(fn) {
    var self = this;
    var xhr = this.xhr = request.getXHR();
    var query = this._query.join('&');
    var timeout = this._timeout;
    var data = this._formData || this._data;
    this._callback = fn || noop;
    xhr.onreadystatechange = function() {
      if (4 != xhr.readyState)
        return;
      var status;
      try {
        status = xhr.status;
      } catch (e) {
        status = 0;
      }
      if (0 == status) {
        if (self.timedout)
          return self.timeoutError();
        if (self.aborted)
          return;
        return self.crossDomainError();
      }
      self.emit('end');
    };
    var handleProgress = function(e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }
      e.direction = 'download';
      self.emit('progress', e);
    };
    if (this.hasListeners('progress')) {
      xhr.onprogress = handleProgress;
    }
    try {
      if (xhr.upload && this.hasListeners('progress')) {
        xhr.upload.onprogress = handleProgress;
      }
    } catch (e) {}
    if (timeout && !this._timer) {
      this._timer = setTimeout(function() {
        self.timedout = true;
        self.abort();
      }, timeout);
    }
    if (query) {
      query = request.serializeObject(query);
      this.url += ~this.url.indexOf('?') ? '&' + query : '?' + query;
    }
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
    if (this._withCredentials)
      xhr.withCredentials = true;
    if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
      var contentType = this._header['content-type'];
      var serialize = this._parser || request.serialize[contentType ? contentType.split(';')[0] : ''];
      if (!serialize && isJSON(contentType))
        serialize = request.serialize['application/json'];
      if (serialize)
        data = serialize(data);
    }
    for (var field in this.header) {
      if (null == this.header[field])
        continue;
      xhr.setRequestHeader(field, this.header[field]);
    }
    if (this._responseType) {
      xhr.responseType = this._responseType;
    }
    this.emit('request', this);
    xhr.send(typeof data !== 'undefined' ? data : null);
    return this;
  };
  request.Request = Request;
  request.get = function(url, data, fn) {
    var req = request('GET', url);
    if ('function' == typeof data)
      fn = data, data = null;
    if (data)
      req.query(data);
    if (fn)
      req.end(fn);
    return req;
  };
  request.head = function(url, data, fn) {
    var req = request('HEAD', url);
    if ('function' == typeof data)
      fn = data, data = null;
    if (data)
      req.send(data);
    if (fn)
      req.end(fn);
    return req;
  };
  function del(url, fn) {
    var req = request('DELETE', url);
    if (fn)
      req.end(fn);
    return req;
  }
  ;
  request['del'] = del;
  request['delete'] = del;
  request.patch = function(url, data, fn) {
    var req = request('PATCH', url);
    if ('function' == typeof data)
      fn = data, data = null;
    if (data)
      req.send(data);
    if (fn)
      req.end(fn);
    return req;
  };
  request.post = function(url, data, fn) {
    var req = request('POST', url);
    if ('function' == typeof data)
      fn = data, data = null;
    if (data)
      req.send(data);
    if (fn)
      req.end(fn);
    return req;
  };
  request.put = function(url, data, fn) {
    var req = request('PUT', url);
    if ('function' == typeof data)
      fn = data, data = null;
    if (data)
      req.send(data);
    if (fn)
      req.end(fn);
    return req;
  };
  return module.exports;
});

System.register("npm:systemjs-plugin-babel@0.0.13/babel-helpers/classCallCheck.js", [], function (_export, _context) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      _export("default", function (instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      });
    }
  };
});
System.register("npm:systemjs-plugin-babel@0.0.13/babel-helpers/createClass.js", [], function (_export, _context) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      _export("default", function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }());
    }
  };
});
System.register("npm:systemjs-plugin-babel@0.0.13/babel-helpers/inherits.js", [], function (_export, _context) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      _export("default", function (subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      });
    }
  };
});
System.registerDynamic("npm:systemjs-plugin-babel@0.0.13.json", [], false, function() {
  return {
    "main": "plugin-babel.js",
    "map": {
      "systemjs-babel-build": {
        "browser": "./systemjs-babel-browser.js",
        "default": "./systemjs-babel-browser.js"
      }
    },
    "meta": {
      "./plugin-babel.js": {
        "format": "cjs"
      }
    }
  };
});

System.register("npm:systemjs-plugin-babel@0.0.13/babel-helpers/possibleConstructorReturn.js", [], function (_export, _context) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      _export("default", function (self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      });
    }
  };
});
System.registerDynamic("npm:uuid@2.0.2/rng-browser.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var rng;
  if (global.crypto && crypto.getRandomValues) {
    var _rnds8 = new Uint8Array(16);
    rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }
  if (!rng) {
    var _rnds = new Array(16);
    rng = function() {
      for (var i = 0,
          r; i < 16; i++) {
        if ((i & 0x03) === 0)
          r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }
      return _rnds;
    };
  }
  module.exports = rng;
  return module.exports;
});

System.registerDynamic("npm:uuid@2.0.2.json", [], false, function() {
  return {
    "main": "uuid.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./rng.js": {
        "browser": "./rng-browser.js"
      },
      "uuid": "."
    }
  };
});

System.registerDynamic("npm:uuid@2.0.2/uuid.js", ["./rng"], true, function($__require, exports, module) {
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var _rng = $__require('./rng');
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0,
        ii = 0;
    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) {
        buf[i + ii++] = _hexToByte[oct];
      }
    });
    while (ii < 16) {
      buf[i + ii++] = 0;
    }
    return buf;
  }
  function unparse(buf, offset) {
    var i = offset || 0,
        bth = _byteToHex;
    return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
  }
  var _seedBytes = _rng();
  var _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
  var _lastMSecs = 0,
      _lastNSecs = 0;
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];
    options = options || {};
    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();
    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs) / 10000;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 0x3fff;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;
    b[i++] = tmh >>> 24 & 0xf | 0x10;
    b[i++] = tmh >>> 16 & 0xff;
    b[i++] = clockseq >>> 8 | 0x80;
    b[i++] = clockseq & 0xff;
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }
    return buf ? buf : unparse(b);
  }
  function v4(options, buf, offset) {
    var i = buf && offset || 0;
    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new Array(16) : null;
      options = null;
    }
    options = options || {};
    var rnds = options.random || (options.rng || _rng)();
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }
    return buf || unparse(rnds);
  }
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  module.exports = uuid;
  return module.exports;
});

//# sourceMappingURL=dev.js.map